"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const prettier_util_1 = require("../utility/prettier-util");
const dependencies_1 = require("../utility/dependencies");
const util_1 = require("../utility/util");
function default_1(options) {
    return (tree, context) => {
        const cliOptions = prettier_util_1.getDefaultOptions(context, options, new prettier_util_1.PrettierSettings());
        return schematics_1.chain([
            addDependencies(cliOptions),
            addPrettierFiles(cliOptions),
            installPackages(),
            modifyTsLint(),
            updateEditorConfig(cliOptions),
            addLintStagedConfig(cliOptions),
            addScripts(cliOptions),
        ])(tree, context);
    };
}
exports.default = default_1;
const prettierCommand = 'prettier --write';
const tslintConfigPackage = 'tslint-config-prettier';
function addDependencies(options) {
    return (tree) => {
        const lintStagedDep = ['lint-staged', 'husky'];
        return rxjs_1.of('prettier', 'lint-staged', 'husky', tslintConfigPackage).pipe(operators_1.filter((pkg) => {
            if (options.lintStaged === false) {
                // remove lint-staged deps
                return !lintStagedDep.some((p) => p === pkg);
            }
            return true;
        }), operators_1.concatMap((pkg) => util_1.getLatestNodeVersion(pkg)), operators_1.map((packageFromRegistry) => {
            const { name, version } = packageFromRegistry;
            dependencies_1.addPackageJsonDependency(tree, { type: dependencies_1.NodeDependencyType.Dev, name, version });
            return tree;
        }));
    };
}
function installPackages() {
    return (tree, context) => {
        return context.addTask(new tasks_1.NodePackageInstallTask()) && tree;
    };
}
function addPrettierFiles(prettierOptions) {
    return (tree, context) => {
        const templateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.template(Object.assign({}, prettierOptions)),
            schematics_1.move('./'),
        ]);
        return schematics_1.chain([schematics_1.mergeWith(templateSource)])(tree, context);
    };
}
function modifyTsLint() {
    return (tree, context) => {
        const tslintPath = 'tslint.json';
        if (tree.exists(tslintPath)) {
            const tslint = util_1.getFileAsJson(tree, tslintPath);
            if (!tslint)
                return tree;
            if (Array.isArray(tslint.extends)) {
                // should be added last https://github.com/prettier/tslint-config-prettier
                tslint.extends.push(tslintConfigPackage);
            }
            else if (typeof tslint.extends === 'string') {
                tslint.extends = [tslint.extends, tslintConfigPackage];
            }
            else {
                tslint.extends = tslintConfigPackage;
            }
            tree.overwrite(tslintPath, JSON.stringify(tslint, null, 2));
        }
        else {
            context.logger.info(`unable to locate tslint file at ${tslintPath}, conflicting styles may exists`);
        }
        return tree;
    };
}
function updateEditorConfig(options) {
    return (tree, context) => {
        const editorConfigPath = '.editorconfig';
        const rule = 'indent_size';
        if (tree.exists(editorConfigPath)) {
            // editorconfig exists on host
            const editorConfigBuffer = tree.read(editorConfigPath);
            if (editorConfigBuffer === null) {
                // unable to read editorconfig
                context.logger.info(`Could not modify .editorconfig at ${editorConfigPath}. Update ${rule} to match tabWidth: ${options.tabWidth}.`);
            }
            else {
                // editorconfig parsed, modify
                const ecBuffer = editorConfigBuffer.toString();
                if (ecBuffer.includes(rule)) {
                    const modifiedEditorConfig = ecBuffer
                        .split('\n')
                        .map((line) => {
                        if (line.includes(rule)) {
                            return `indent_size = ${options.tabWidth}`;
                        }
                        else {
                            return line;
                        }
                    })
                        .join('\n');
                    tree.overwrite(editorConfigPath, modifiedEditorConfig);
                }
            }
        }
        return tree;
    };
}
function addLintStagedConfig(options) {
    return (tree, context) => {
        if (options.lintStaged === true) {
            util_1.addPropertyToPackageJson(tree, context, 'husky', {
                hooks: { 'pre-commit': 'lint-staged' },
            });
            util_1.addPropertyToPackageJson(tree, context, 'lint-staged', {
                [`*.{${getFileTypes(options.formatAllAngularFiles)}}`]: [prettierCommand, 'git add'],
            });
        }
        return tree;
    };
}
function addScripts(options) {
    return (tree, context) => {
        util_1.addPropertyToPackageJson(tree, context, 'scripts', {
            // run against all typescript files
            // prettier-ignore
            prettier: `${prettierCommand} \"**/*.{${getFileTypes(options.formatAllAngularFiles)}}\"`
        });
        return tree;
    };
}
function getFileTypes(allAngularFiles) {
    // https://prettier.io/docs/en/options.html#parser
    // https://prettier.io/blog/2018/11/07/1.15.0.html#automatic-parser-inference
    return allAngularFiles ? 'js,json,css,scss,less,md,ts,html,component.html' : 'ts,tsx';
}
//# sourceMappingURL=index.js.map