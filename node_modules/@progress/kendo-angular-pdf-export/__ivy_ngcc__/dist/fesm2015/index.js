/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, TemplateRef, Optional, Component, Input, ElementRef, ContentChild, NgModule } from '@angular/core';
import { drawDOM, exportPDF } from '@progress/kendo-drawing';
import { saveAs } from '@progress/kendo-file-saver';

import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
class PDFTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PDFTemplateDirective.ɵfac = function PDFTemplateDirective_Factory(t) { return new (t || PDFTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PDFTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PDFTemplateDirective, selectors: [["", "kendoPDFTemplate", ""]] });
/** @nocollapse */
PDFTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPDFTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

const FIELDS = ['bottom', 'left', 'right', 'top'];
/**
 * Represents the Kendo UI PDFMargin component for Angular.
 */
class PDFMarginComponent {
    /**
     * @hidden
     */
    get options() {
        const options = {};
        for (let idx = 0; idx < FIELDS.length; idx++) {
            const field = FIELDS[idx];
            const value = this[field];
            if (typeof value !== 'undefined') {
                options[field] = value;
            }
        }
        return options;
    }
}
PDFMarginComponent.ɵfac = function PDFMarginComponent_Factory(t) { return new (t || PDFMarginComponent)(); };
PDFMarginComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PDFMarginComponent, selectors: [["kendo-pdf-export-margin"]], inputs: { left: "left", top: "top", right: "right", bottom: "bottom" }, decls: 0, vars: 0, template: function PDFMarginComponent_Template(rf, ctx) { }, encapsulation: 2 });
PDFMarginComponent.propDecorators = {
    left: [{ type: Input }],
    top: [{ type: Input }],
    right: [{ type: Input }],
    bottom: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFMarginComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-pdf-export-margin',
                template: ``
            }]
    }], null, { left: [{
            type: Input
        }], top: [{
            type: Input
        }], right: [{
            type: Input
        }], bottom: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
const compileTemplate = (templateRef) => {
    const context = {};
    let embeddedView = templateRef.createEmbeddedView(context);
    const result = (data) => {
        Object.assign(context, data);
        embeddedView.detectChanges();
        const templateWrap = document.createElement('span');
        embeddedView.rootNodes.forEach((rootNode) => {
            templateWrap.appendChild(rootNode.cloneNode(true));
        });
        return templateWrap;
    };
    result.destroy = () => {
        embeddedView.destroy();
        embeddedView = null;
    };
    return result;
};

/**
 * Represents the [Kendo UI PDF Export component for Angular]({% slug overview_pdfexport %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <div class="example-config">
 *       <button class="k-button" (click)="pdf.saveAs('document.pdf')">
 *         Save As PDF...
 *       </button>
 *     </div>
 *
 *     <kendo-pdf-export #pdf paperSize="A4" margin="2cm">
 *       Content goes here
 *     </kendo-pdf-export>
 *   `
 * })
 * export class AppComponent {
 * }
 * ```
 */
class PDFExportComponent {
    constructor(element) {
        this.element = element;
        /**
         * The creator of the PDF document.
         * @default "Kendo UI PDF Generator"
         */
        this.creator = 'Kendo UI PDF Generator';
        /**
         * Specifies the name of the exported PDF file.
         * @default "Export.pdf"
         */
        this.fileName = 'export.pdf';
    }
    get drawMargin() {
        const marginComponent = this.marginComponent;
        let margin = this.margin;
        if (marginComponent) {
            margin = Object.assign(margin || {}, marginComponent.options);
        }
        return margin;
    }
    /**
     * Saves the content as a PDF file with the specified name.
     * @param fileName - The name of the exported file.
     */
    saveAs(fileName = this.fileName) {
        this.save(this.element.nativeElement, fileName);
    }
    /**
     * Exports the content as a `Group` for further processing.
     *
     * @return - The root group of the exported scene.
     */
    export() {
        return this.exportElement(this.element.nativeElement);
    }
    save(element, fileName) {
        this.exportElement(element)
            .then(group => this.exportGroup(group, this.pdfOptions()))
            .then(dataUri => this.saveDataUri(dataUri, fileName, this.saveOptions()));
    }
    exportElement(element) {
        const promise = this.drawElement(element, this.drawOptions());
        const cleanup = this.cleanup.bind(this);
        promise.then(cleanup, cleanup);
        return promise;
    }
    cleanup() {
        if (this.pageTemplate) {
            this.pageTemplate.destroy();
            delete this.pageTemplate;
        }
    }
    drawOptions() {
        if (this.pageTemplateDirective) {
            this.pageTemplate = compileTemplate(this.pageTemplateDirective.templateRef);
        }
        return {
            avoidLinks: this.avoidLinks,
            forcePageBreak: this.forcePageBreak,
            keepTogether: this.keepTogether,
            margin: this.drawMargin,
            paperSize: this.paperSize,
            landscape: this.landscape,
            repeatHeaders: this.repeatHeaders,
            scale: this.scale,
            template: this.pageTemplate
        };
    }
    pdfOptions() {
        return {
            autoPrint: this.autoPrint,
            author: this.author,
            creator: this.creator,
            date: this.date,
            imgDPI: this.imageResolution,
            keywords: this.keywords,
            landscape: this.landscape,
            margin: this.drawMargin,
            multiPage: true,
            paperSize: this.paperSize,
            producer: this.producer,
            subject: this.subject,
            title: this.title
        };
    }
    saveOptions() {
        return {
            forceProxy: this.forceProxy,
            proxyData: this.proxyData,
            proxyTarget: this.proxyTarget,
            proxyURL: this.proxyURL
        };
    }
    drawElement(element, options) {
        return drawDOM(element, options);
    }
    exportGroup(group, options) {
        return exportPDF(group, options);
    }
    saveDataUri(dataUri, fileName, options) {
        saveAs(dataUri, fileName, options);
    }
}
PDFExportComponent.ɵfac = function PDFExportComponent_Factory(t) { return new (t || PDFExportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PDFExportComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PDFExportComponent, selectors: [["kendo-pdf-export"]], contentQueries: function PDFExportComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PDFTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PDFMarginComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
    } }, inputs: { creator: "creator", fileName: "fileName", autoPrint: "autoPrint", author: "author", avoidLinks: "avoidLinks", forcePageBreak: "forcePageBreak", keepTogether: "keepTogether", date: "date", imageResolution: "imageResolution", forceProxy: "forceProxy", keywords: "keywords", landscape: "landscape", margin: "margin", paperSize: "paperSize", repeatHeaders: "repeatHeaders", scale: "scale", proxyData: "proxyData", proxyURL: "proxyURL", proxyTarget: "proxyTarget", producer: "producer", subject: "subject", title: "title" }, ngContentSelectors: _c0, decls: 2, vars: 0, template: function PDFExportComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/** @nocollapse */
PDFExportComponent.ctorParameters = () => [
    { type: ElementRef }
];
PDFExportComponent.propDecorators = {
    autoPrint: [{ type: Input }],
    author: [{ type: Input }],
    avoidLinks: [{ type: Input }],
    forcePageBreak: [{ type: Input }],
    keepTogether: [{ type: Input }],
    creator: [{ type: Input }],
    date: [{ type: Input }],
    imageResolution: [{ type: Input }],
    fileName: [{ type: Input }],
    forceProxy: [{ type: Input }],
    keywords: [{ type: Input }],
    landscape: [{ type: Input }],
    margin: [{ type: Input }],
    paperSize: [{ type: Input }],
    repeatHeaders: [{ type: Input }],
    scale: [{ type: Input }],
    proxyData: [{ type: Input }],
    proxyURL: [{ type: Input }],
    proxyTarget: [{ type: Input }],
    producer: [{ type: Input }],
    subject: [{ type: Input }],
    title: [{ type: Input }],
    pageTemplateDirective: [{ type: ContentChild, args: [PDFTemplateDirective,] }],
    marginComponent: [{ type: ContentChild, args: [PDFMarginComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFExportComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-pdf-export',
                template: `<div><ng-content></ng-content></div>`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { creator: [{
            type: Input
        }], fileName: [{
            type: Input
        }], autoPrint: [{
            type: Input
        }], author: [{
            type: Input
        }], avoidLinks: [{
            type: Input
        }], forcePageBreak: [{
            type: Input
        }], keepTogether: [{
            type: Input
        }], date: [{
            type: Input
        }], imageResolution: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], keywords: [{
            type: Input
        }], landscape: [{
            type: Input
        }], margin: [{
            type: Input
        }], paperSize: [{
            type: Input
        }], repeatHeaders: [{
            type: Input
        }], scale: [{
            type: Input
        }], proxyData: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], proxyTarget: [{
            type: Input
        }], producer: [{
            type: Input
        }], subject: [{
            type: Input
        }], title: [{
            type: Input
        }], pageTemplateDirective: [{
            type: ContentChild,
            args: [PDFTemplateDirective]
        }], marginComponent: [{
            type: ContentChild,
            args: [PDFMarginComponent]
        }] }); })();

const COMPONENT_DIRECTIVES = [
    PDFExportComponent,
    PDFMarginComponent,
    PDFTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the PDF Export directive.
 */
class PDFExportModule {
}
PDFExportModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PDFExportModule });
PDFExportModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PDFExportModule_Factory(t) { return new (t || PDFExportModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PDFExportModule, { declarations: [PDFExportComponent,
        PDFMarginComponent,
        PDFTemplateDirective], exports: [PDFExportComponent,
        PDFMarginComponent,
        PDFTemplateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFExportModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { PDFExportComponent, PDFExportModule, PDFMarginComponent, PDFTemplateDirective, compileTemplate };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnSUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVNBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs2QkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmLCBPcHRpb25hbCwgQ29tcG9uZW50LCBJbnB1dCwgRWxlbWVudFJlZiwgQ29udGVudENoaWxkLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZHJhd0RPTSwgZXhwb3J0UERGIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRyYXdpbmcnO1xuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWZpbGUtc2F2ZXInO1xuXG5jbGFzcyBQREZUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cblBERlRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9QREZUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBERlRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbmNvbnN0IEZJRUxEUyA9IFsnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJ107XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEtlbmRvIFVJIFBERk1hcmdpbiBjb21wb25lbnQgZm9yIEFuZ3VsYXIuXG4gKi9cbmNsYXNzIFBERk1hcmdpbkNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IEZJRUxEUy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IEZJRUxEU1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2ZpZWxkXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG59XG5QREZNYXJnaW5Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXBkZi1leHBvcnQtbWFyZ2luJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblBERk1hcmdpbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBsZWZ0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0b3A6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBib3R0b206IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY29tcGlsZVRlbXBsYXRlID0gKHRlbXBsYXRlUmVmKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHt9O1xuICAgIGxldCBlbWJlZGRlZFZpZXcgPSB0ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dCk7XG4gICAgY29uc3QgcmVzdWx0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgZW1iZWRkZWRWaWV3LmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBlbWJlZGRlZFZpZXcucm9vdE5vZGVzLmZvckVhY2goKHJvb3ROb2RlKSA9PiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVdyYXAuYXBwZW5kQ2hpbGQocm9vdE5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZVdyYXA7XG4gICAgfTtcbiAgICByZXN1bHQuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgZW1iZWRkZWRWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgZW1iZWRkZWRWaWV3ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBQREYgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19wZGZleHBvcnQgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1jb25maWdcIj5cbiAqICAgICAgIDxidXR0b24gY2xhc3M9XCJrLWJ1dHRvblwiIChjbGljayk9XCJwZGYuc2F2ZUFzKCdkb2N1bWVudC5wZGYnKVwiPlxuICogICAgICAgICBTYXZlIEFzIFBERi4uLlxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKlxuICogICAgIDxrZW5kby1wZGYtZXhwb3J0ICNwZGYgcGFwZXJTaXplPVwiQTRcIiBtYXJnaW49XCIyY21cIj5cbiAqICAgICAgIENvbnRlbnQgZ29lcyBoZXJlXG4gKiAgICAgPC9rZW5kby1wZGYtZXhwb3J0PlxuICogICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgUERGRXhwb3J0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3JlYXRvciBvZiB0aGUgUERGIGRvY3VtZW50LlxuICAgICAgICAgKiBAZGVmYXVsdCBcIktlbmRvIFVJIFBERiBHZW5lcmF0b3JcIlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdG9yID0gJ0tlbmRvIFVJIFBERiBHZW5lcmF0b3InO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSBleHBvcnRlZCBQREYgZmlsZS5cbiAgICAgICAgICogQGRlZmF1bHQgXCJFeHBvcnQucGRmXCJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnZXhwb3J0LnBkZic7XG4gICAgfVxuICAgIGdldCBkcmF3TWFyZ2luKCkge1xuICAgICAgICBjb25zdCBtYXJnaW5Db21wb25lbnQgPSB0aGlzLm1hcmdpbkNvbXBvbmVudDtcbiAgICAgICAgbGV0IG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICAgICAgICBpZiAobWFyZ2luQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBtYXJnaW4gPSBPYmplY3QuYXNzaWduKG1hcmdpbiB8fCB7fSwgbWFyZ2luQ29tcG9uZW50Lm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBjb250ZW50IGFzIGEgUERGIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAgICogQHBhcmFtIGZpbGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV4cG9ydGVkIGZpbGUuXG4gICAgICovXG4gICAgc2F2ZUFzKGZpbGVOYW1lID0gdGhpcy5maWxlTmFtZSkge1xuICAgICAgICB0aGlzLnNhdmUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGZpbGVOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgY29udGVudCBhcyBhIGBHcm91cGAgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgcm9vdCBncm91cCBvZiB0aGUgZXhwb3J0ZWQgc2NlbmUuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRFbGVtZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgc2F2ZShlbGVtZW50LCBmaWxlTmFtZSkge1xuICAgICAgICB0aGlzLmV4cG9ydEVsZW1lbnQoZWxlbWVudClcbiAgICAgICAgICAgIC50aGVuKGdyb3VwID0+IHRoaXMuZXhwb3J0R3JvdXAoZ3JvdXAsIHRoaXMucGRmT3B0aW9ucygpKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGFVcmkgPT4gdGhpcy5zYXZlRGF0YVVyaShkYXRhVXJpLCBmaWxlTmFtZSwgdGhpcy5zYXZlT3B0aW9ucygpKSk7XG4gICAgfVxuICAgIGV4cG9ydEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5kcmF3RWxlbWVudChlbGVtZW50LCB0aGlzLmRyYXdPcHRpb25zKCkpO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gdGhpcy5jbGVhbnVwLmJpbmQodGhpcyk7XG4gICAgICAgIHByb21pc2UudGhlbihjbGVhbnVwLCBjbGVhbnVwKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFnZVRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXdPcHRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5wYWdlVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZVRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKHRoaXMucGFnZVRlbXBsYXRlRGlyZWN0aXZlLnRlbXBsYXRlUmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXZvaWRMaW5rczogdGhpcy5hdm9pZExpbmtzLFxuICAgICAgICAgICAgZm9yY2VQYWdlQnJlYWs6IHRoaXMuZm9yY2VQYWdlQnJlYWssXG4gICAgICAgICAgICBrZWVwVG9nZXRoZXI6IHRoaXMua2VlcFRvZ2V0aGVyLFxuICAgICAgICAgICAgbWFyZ2luOiB0aGlzLmRyYXdNYXJnaW4sXG4gICAgICAgICAgICBwYXBlclNpemU6IHRoaXMucGFwZXJTaXplLFxuICAgICAgICAgICAgbGFuZHNjYXBlOiB0aGlzLmxhbmRzY2FwZSxcbiAgICAgICAgICAgIHJlcGVhdEhlYWRlcnM6IHRoaXMucmVwZWF0SGVhZGVycyxcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMucGFnZVRlbXBsYXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBkZk9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRvUHJpbnQ6IHRoaXMuYXV0b1ByaW50LFxuICAgICAgICAgICAgYXV0aG9yOiB0aGlzLmF1dGhvcixcbiAgICAgICAgICAgIGNyZWF0b3I6IHRoaXMuY3JlYXRvcixcbiAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZSxcbiAgICAgICAgICAgIGltZ0RQSTogdGhpcy5pbWFnZVJlc29sdXRpb24sXG4gICAgICAgICAgICBrZXl3b3JkczogdGhpcy5rZXl3b3JkcyxcbiAgICAgICAgICAgIGxhbmRzY2FwZTogdGhpcy5sYW5kc2NhcGUsXG4gICAgICAgICAgICBtYXJnaW46IHRoaXMuZHJhd01hcmdpbixcbiAgICAgICAgICAgIG11bHRpUGFnZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhcGVyU2l6ZTogdGhpcy5wYXBlclNpemUsXG4gICAgICAgICAgICBwcm9kdWNlcjogdGhpcy5wcm9kdWNlcixcbiAgICAgICAgICAgIHN1YmplY3Q6IHRoaXMuc3ViamVjdCxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnRpdGxlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNhdmVPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9yY2VQcm94eTogdGhpcy5mb3JjZVByb3h5LFxuICAgICAgICAgICAgcHJveHlEYXRhOiB0aGlzLnByb3h5RGF0YSxcbiAgICAgICAgICAgIHByb3h5VGFyZ2V0OiB0aGlzLnByb3h5VGFyZ2V0LFxuICAgICAgICAgICAgcHJveHlVUkw6IHRoaXMucHJveHlVUkxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhd0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZHJhd0RPTShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZXhwb3J0R3JvdXAoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydFBERihncm91cCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHNhdmVEYXRhVXJpKGRhdGFVcmksIGZpbGVOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHNhdmVBcyhkYXRhVXJpLCBmaWxlTmFtZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuUERGRXhwb3J0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wZGYtZXhwb3J0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYDxkaXY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PmBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUERGRXhwb3J0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuUERGRXhwb3J0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGF1dG9QcmludDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYXV0aG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhdm9pZExpbmtzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JjZVBhZ2VCcmVhazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAga2VlcFRvZ2V0aGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjcmVhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbWFnZVJlc29sdXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbGVOYW1lOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JjZVByb3h5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBrZXl3b3JkczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGFuZHNjYXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXJnaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhcGVyU2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVwZWF0SGVhZGVyczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2NhbGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb3h5RGF0YTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHJveHlVUkw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb3h5VGFyZ2V0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwcm9kdWNlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3ViamVjdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZ2VUZW1wbGF0ZURpcmVjdGl2ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbUERGVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBtYXJnaW5Db21wb25lbnQ6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW1BERk1hcmdpbkNvbXBvbmVudCxdIH1dXG59O1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtcbiAgICBQREZFeHBvcnRDb21wb25lbnQsXG4gICAgUERGTWFyZ2luQ29tcG9uZW50LFxuICAgIFBERlRlbXBsYXRlRGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pIGRlZmluaXRpb24gZm9yIHRoZSBQREYgRXhwb3J0IGRpcmVjdGl2ZS5cbiAqL1xuY2xhc3MgUERGRXhwb3J0TW9kdWxlIHtcbn1cblBERkV4cG9ydE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBQREZFeHBvcnRDb21wb25lbnQsIFBERkV4cG9ydE1vZHVsZSwgUERGTWFyZ2luQ29tcG9uZW50LCBQREZUZW1wbGF0ZURpcmVjdGl2ZSwgY29tcGlsZVRlbXBsYXRlIH07XG4iXX0=