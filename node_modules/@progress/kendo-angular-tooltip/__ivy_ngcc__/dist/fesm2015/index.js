/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { InjectionToken, Injectable, EventEmitter, Component, ElementRef, HostBinding, Output, Input, isDevMode, Directive, NgZone, Renderer2, Optional, Inject, forwardRef, NgModule } from '@angular/core';
import { filter, debounceTime, take } from 'rxjs/operators';
import { fromEvent } from 'rxjs';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { CommonModule } from '@angular/common';

/**
 * Obsolete. Provide the TooltipSettings class instead.
 *
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-popup';

var I18N_0;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the close button
     * @meaning kendo.tooltip.closeTitle
     */ 
    const MSG_EXTERNAL_1245147641110884896$$DIST_FESM2015_INDEX_JS_1 = goog.getMsg("Close");
    I18N_0 = MSG_EXTERNAL_1245147641110884896$$DIST_FESM2015_INDEX_JS_1;
}
else {
    I18N_0 = $localize `:kendo.tooltip.closeTitle|The title of the close button␟de53b3f74f2d4a81b5c3f54c0ac1269cb017bd4f␟1245147641110884896:Close`;
}
const _c2 = ["closeTitle", I18N_0];
function TooltipContentComponent_div_3_ng_template_1_Template(rf, ctx) { }
const _c3 = function (a0, a1) { return { $implicit: a0, anchor: a1 }; };
function TooltipContentComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtemplate(1, TooltipContentComponent_div_3_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.titleTemplate)("ngTemplateOutlet", ctx_r0.titleTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c3, ctx_r0.anchor, ctx_r0.anchor));
} }
function TooltipContentComponent_ng_template_4_Template(rf, ctx) { }
function TooltipContentComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.templateString, " ");
} }
function TooltipContentComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵlistener("click", function TooltipContentComponent_div_6_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onCloseClick($event); });
    ɵngcc0.ɵɵelement(1, "a", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("title", ctx_r3.closeButtonTitle);
} }
function TooltipContentComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 10);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r4.calloutPositionClass());
} }
const TOOLTIP_SETTINGS = new InjectionToken('kendo-ui-tooltip-settings');
/**
 * Provides a global configuration for the Kendo UI Tooltip. Once injected through
 * the `AppComponent` constructor, the configuration properties can be overridden.
 *
 * @example
 * ```ts-no-run
 * import { TooltipSettings } from '@progress/kendo-angular-tooltip';
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *      <div kendoTooltip>
 *          <button title="Saves the current document">Save</button>
 *      </div>`,
 *    providers: [{
 *        provide: TooltipSettings,
 *        useFactory: (): TooltipSettings => ({
 *          // Override default values of tooltips if wanted
 *          position: 'right'
 *        })
 *    }]
 * })
 * export class AppComponent { }
 * ```
 */
class TooltipSettings {
}
TooltipSettings.ɵfac = function TooltipSettings_Factory(t) { return new (t || TooltipSettings)(); };
TooltipSettings.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipSettings, factory: TooltipSettings.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipSettings, [{
        type: Injectable
    }], null, null); })();

/**
 * @hidden
 */
function align(position, offset) {
    let anchorAlign = {};
    let popupAlign = {};
    let popupMargin = {};
    switch (position) {
        case 'top':
            anchorAlign = { horizontal: 'center', vertical: 'top' };
            popupAlign = { horizontal: 'center', vertical: 'bottom' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'bottom':
            anchorAlign = { horizontal: 'center', vertical: 'bottom' };
            popupAlign = { horizontal: 'center', vertical: 'top' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'right':
            anchorAlign = { horizontal: 'right', vertical: 'center' };
            popupAlign = { horizontal: 'left', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        case 'left':
            anchorAlign = { horizontal: 'left', vertical: 'center' };
            popupAlign = { horizontal: 'right', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        default: break;
    }
    return {
        anchorAlign,
        popupAlign,
        popupMargin
    };
}
/**
 * @hidden
 */
function collision(inputcollision, position) {
    if (inputcollision) {
        return inputcollision;
    }
    if (position === 'top' || position === 'bottom') {
        return { horizontal: 'fit', vertical: 'flip' };
    }
    return { horizontal: 'flip', vertical: 'fit' };
}
function isDocumentNode(container) {
    return container.nodeType === 9;
}
/**
 * @hidden
 */
function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    const matches = Element.prototype.matches ?
        (el, sel) => el.matches(sel)
        : (el, sel) => el.msMatchesSelector(sel);
    let node = element;
    while (node && !isDocumentNode(node)) {
        if (matches(node, selector)) {
            return node;
        }
        node = node.parentNode;
    }
}
/**
 * @hidden
 */
function contains(container, child) {
    if (!container) {
        return false;
    }
    if (isDocumentNode(container)) {
        return false;
    }
    if (container.contains) {
        return container.contains(child);
    }
    if (container.compareDocumentPosition) {
        // tslint:disable-next-line
        return !!(container.compareDocumentPosition(child) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    }
}
/**
 * @hidden
 */
const hasParent = (node, parent) => {
    while (node && node !== parent) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
function getCenterOffset(item, dir, size) {
    const rect = item.getBoundingClientRect();
    return rect[dir] + (rect[size] / 2);
}
/**
 * @hidden
 */
function containsItem(collection, item) {
    return collection.indexOf(item) !== -1;
}

/**
 * @hidden
 */
class TooltipContentComponent {
    constructor(content, localizationService) {
        this.content = content;
        this.localizationService = localizationService;
        this.close = new EventEmitter();
        this.tooltipWidth = null;
        this.tooltipHeight = null;
        this.callout = true;
        this.calloutStyles = (position, calloutSize, isFlip) => {
            const styles = {};
            const isVertical = position === 'top' || position === 'bottom';
            const flipDeg = '180deg';
            const zeroDeg = '0deg';
            if (!isFlip) {
                styles.transform = isVertical ? `rotateX(${zeroDeg})` : `rotateY(${zeroDeg})`;
                return styles;
            }
            if (position === 'top') {
                styles.bottom = 'unset';
            }
            else if (position === 'bottom') {
                styles.top = 'unset';
            }
            else if (position === 'left') {
                styles.right = 'unset';
            }
            else if (position === 'right') {
                styles.left = 'unset';
            }
            styles[position] = `${-calloutSize}px`;
            styles.transform = isVertical ? `rotateX(${flipDeg})` : `rotateY(${flipDeg})`;
            return styles;
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get cssClasses() {
        return 'k-widget k-tooltip';
    }
    get className() {
        return this.closable;
    }
    get cssPosition() {
        return 'relative';
    }
    ngOnInit() {
        this.dynamicRTLSubscription = this.localizationService.changes
            .subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    get closeButtonTitle() {
        return this.closeTitle || this.localizationService.get('closeTitle');
    }
    calloutPositionClass() {
        return {
            'top': 'k-callout-s',
            'left': 'k-callout-e',
            'bottom': 'k-callout-n',
            'right': 'k-callout-w'
        }[this.position];
    }
    onCloseClick(event) {
        event.preventDefault();
        this.close.emit();
    }
    updateCalloutPosition(position, isFlip) {
        if (!this.callout) {
            return;
        }
        const callout = this.content.nativeElement.querySelector('.k-callout');
        const isVertical = position === 'top' || position === 'bottom';
        const size = isVertical ? 'width' : 'height';
        const dir = isVertical ? 'left' : 'top';
        const offsetProperty = isVertical ? 'marginLeft' : 'marginTop';
        const calloutSize = callout.getBoundingClientRect()[size];
        const anchorCenter = getCenterOffset(this.anchor.nativeElement, dir, size);
        const contentCenter = getCenterOffset(this.content.nativeElement, dir, size);
        const diff = Math.abs(contentCenter - anchorCenter);
        if (diff > 1 || diff === 0 || Math.round(diff) === 0) {
            const newMargin = contentCenter - anchorCenter + (calloutSize / 2);
            callout.style[offsetProperty] = `${-newMargin}px`;
        }
        const calloutStyles = this.calloutStyles(position, calloutSize, isFlip);
        Object.keys(calloutStyles).forEach((style) => {
            callout.style[style] = calloutStyles[style];
        });
    }
}
TooltipContentComponent.ɵfac = function TooltipContentComponent_Factory(t) { return new (t || TooltipContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
TooltipContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipContentComponent, selectors: [["kendo-tooltip"]], hostVars: 11, hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
        ɵngcc0.ɵɵstyleProp("width", ctx.tooltipWidth, "px")("height", ctx.tooltipHeight, "px")("position", ctx.cssPosition);
        ɵngcc0.ɵɵclassProp("k-tooltip-closable", ctx.className);
    } }, inputs: { tooltipWidth: "tooltipWidth", tooltipHeight: "tooltipHeight", titleTemplate: "titleTemplate", anchor: "anchor", closable: "closable", templateRef: "templateRef", templateString: "templateString" }, outputs: { close: "close" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tooltip'
            }
        ])], decls: 8, vars: 10, consts: [["kendoTooltipLocalizedMessages", "", 6, "closeTitle"], [1, "k-tooltip-content"], ["class", "k-tooltip-title", 4, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngIf"], ["class", "k-tooltip-button", 3, "click", 4, "ngIf"], ["class", "k-callout", 3, "ngClass", 4, "ngIf"], [1, "k-tooltip-title"], [1, "k-tooltip-button", 3, "click"], ["href", "#", 1, "k-icon", "k-i-close"], [1, "k-callout", 3, "ngClass"]], template: function TooltipContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c2);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵtemplate(3, TooltipContentComponent_div_3_Template, 2, 6, "div", 2);
        ɵngcc0.ɵɵtemplate(4, TooltipContentComponent_ng_template_4_Template, 0, 0, "ng-template", 3);
        ɵngcc0.ɵɵtemplate(5, TooltipContentComponent_ng_template_5_Template, 1, 1, "ng-template", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, TooltipContentComponent_div_6_Template, 2, 1, "div", 5);
        ɵngcc0.ɵɵtemplate(7, TooltipContentComponent_div_7_Template, 1, 1, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.templateRef)("ngTemplateOutlet", ctx.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(7, _c3, ctx.anchor, ctx.anchor));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.templateString);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.closable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.callout);
    } }, directives: function () { return [LocalizedMessagesDirective, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgClass]; }, encapsulation: 2 });
/** @nocollapse */
TooltipContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: LocalizationService }
];
TooltipContentComponent.propDecorators = {
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    close: [{ type: Output }],
    cssClasses: [{ type: HostBinding, args: ['class',] }],
    className: [{ type: HostBinding, args: ['class.k-tooltip-closable',] }],
    cssPosition: [{ type: HostBinding, args: ['style.position',] }],
    tooltipWidth: [{ type: HostBinding, args: ['style.width.px',] }, { type: Input }],
    tooltipHeight: [{ type: HostBinding, args: ['style.height.px',] }, { type: Input }],
    titleTemplate: [{ type: Input }],
    anchor: [{ type: Input }],
    closable: [{ type: Input }],
    templateRef: [{ type: Input }],
    templateString: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipContentComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-tooltip',
                template: `
        <ng-container kendoTooltipLocalizedMessages
            i18n-closeTitle="kendo.tooltip.closeTitle|The title of the close button"
            closeTitle="Close"
        >
        </ng-container>

        <div class="k-tooltip-content">
            <div class="k-tooltip-title" *ngIf="titleTemplate">
                <ng-template
                    [ngIf]="titleTemplate"
                    [ngTemplateOutlet]="titleTemplate"
                    [ngTemplateOutletContext]="{ $implicit: anchor, anchor: anchor }">
                </ng-template>
            </div>

            <ng-template
                [ngIf]="templateRef"
                [ngTemplateOutlet]="templateRef"
                [ngTemplateOutletContext]="{ $implicit: anchor, anchor: anchor }">
            </ng-template>
            <ng-template
                [ngIf]="templateString">
                {{ templateString }}
            </ng-template>
        </div>

        <div *ngIf="closable" class="k-tooltip-button" (click)="onCloseClick($event)">
            <a href="#" class="k-icon k-i-close" [attr.title]="closeButtonTitle"></a>
        </div>

        <div class="k-callout" *ngIf="callout" [ngClass]="calloutPositionClass()"></div>
    `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tooltip'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.LocalizationService }]; }, { close: [{
            type: Output
        }], tooltipWidth: [{
            type: HostBinding,
            args: ['style.width.px']
        }, {
            type: Input
        }], tooltipHeight: [{
            type: HostBinding,
            args: ['style.height.px']
        }, {
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], className: [{
            type: HostBinding,
            args: ['class.k-tooltip-closable']
        }], cssPosition: [{
            type: HostBinding,
            args: ['style.position']
        }], titleTemplate: [{
            type: Input
        }], anchor: [{
            type: Input
        }], closable: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], templateString: [{
            type: Input
        }] }); })();

/**
 * Represents the [Kendo UI Tooltip directive for Angular]({% slug overview_tooltip %}).
 * Used to display additional information that is related to an element.
 *
 * @example
 * ```ts-no-run
 * <div kendoTooltip>
 *    <a title="Tooltip title" href="foo">foo</a>
 * </div>
 * ```
 */
class TooltipDirective {
    constructor(tooltipWrapper, ngZone, renderer, popupService, settings, legacySettings) {
        this.tooltipWrapper = tooltipWrapper;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.popupService = popupService;
        /**
         * Specifies a selector for elements within a container which will display a tooltip
         * ([see example]({% slug anchorelements_tooltip %})). The possible values include any
         * DOM `selector`. The default value is `[title]`.
         */
        this.filter = '[title]';
        /**
         * Specifies the position of the Tooltip that is relative to the
         * anchor element ([see example]({% slug positioning_tooltip %})).
         *
         * The possible values are:
         * * `top` (default)
         * * `bottom`
         * * `left`
         * * `right`
         */
        this.position = 'top';
        /**
         * Specifies the delay in milliseconds before the Tooltip is shown.
         * * `100` (default) milliseconds.
         */
        this.showAfter = 100;
        /**
         * Specifies if the Тooltip will display a callout arrow.
         *
         * The possible values are:
         * * `true` (default)
         * * `false`
         */
        this.callout = true;
        /**
         * Specifies if the Тooltip will display a **Close** button
         * ([see example]({% slug closable_tooltip %})).
         *
         * The possible values are:
         * * `true`
         * * `false`
         */
        this.closable = false;
        /**
         * Specifies the offset in pixels between the Tooltip and the anchor. Defaults to `6` pixels.
         * If the `callout` property is set to `true`, the offset is rendered from the callout arrow.
         * If the `callout` property is set to `false`, the offset is rendered from the content of the Tooltip.
         */
        this.offset = 6;
        this.anchor = null;
        this.validPositions = ['top', 'bottom', 'right', 'left'];
        this.validShowOptions = ['hover', 'click', 'none'];
        Object.assign(this, settings, legacySettings);
        this.ngZone.runOutsideAngular(() => {
            const wrapper = this.tooltipWrapper.nativeElement;
            this.anchorTitleSubscription = fromEvent(wrapper, 'mouseover')
                .pipe(filter(() => this.filter !== ''))
                .subscribe((e) => {
                const filterElement = closest(e.target, this.filter);
                if (filterElement) {
                    this.hideElementTitle({ nativeElement: filterElement });
                }
            });
            this.mouseOverSubscription = fromEvent(wrapper, 'mouseover')
                .pipe(debounceTime(100), filter(() => this.filter !== ''))
                .subscribe(e => this.onMouseOver(e));
            this.mouseOutSubscription = fromEvent(wrapper, 'mouseout')
                .pipe(debounceTime(100))
                .subscribe(e => this.onMouseOut(e));
        });
    }
    /**
     * Sets the content of the Tooltip as a template reference
     * ([see example]({% slug templates_tooltip %})).
     */
    set tooltipTemplate(value) {
        this.template = value;
    }
    get tooltipTemplate() { return this.template; }
    /**
     * Shows the Tooltip.
     * @param anchor&mdash; ElementRef|Element.
     * Specifies the element that will be used as an anchor. The Tooltip opens relative to that element.
     */
    show(anchor) {
        if (this.popupRef) {
            return;
        }
        if (anchor instanceof Element) {
            anchor = { nativeElement: anchor };
        }
        this.anchor = anchor;
        if (this.showOn === 'hover') {
            if (this.popupRef) {
                return;
            }
            clearTimeout(this.showTimeout);
            this.showTimeout = window.setTimeout(() => this.showContent(this.anchor), this.showAfter);
        }
        else {
            this.hideElementTitle(this.anchor);
            this.showContent(this.anchor);
        }
    }
    /**
     * Hides the Tooltip.
     */
    hide() {
        clearTimeout(this.showTimeout);
        const anchor = this.anchor && this.anchor.nativeElement;
        if (anchor && anchor.getAttribute('data-title')) {
            if (!anchor.getAttribute('title')) {
                anchor.setAttribute('title', anchor.getAttribute('data-title'));
            }
            anchor.setAttribute('data-title', '');
        }
        if (this.popupMouseOutSubscription) {
            this.popupMouseOutSubscription.unsubscribe();
        }
        if (this.closeClickSubscription) {
            this.closeClickSubscription.unsubscribe();
        }
        this.closePopup();
    }
    /**
     * Toggle visibility of the Tooltip.
     *
     * @param anchor&mdash; ElementRef|Element. Specifies the element that will be used as an anchor.
     * @param show&mdash; Optional. Boolean. Specifies if the Tooltip will be rendered.
     */
    toggle(anchor, show) {
        const previousAnchor = this.anchor && this.anchor.nativeElement;
        if (anchor instanceof Element) {
            anchor = { nativeElement: anchor };
        }
        if (previousAnchor !== anchor.nativeElement) {
            this.hide();
        }
        if (previousAnchor === anchor.nativeElement && this.showOn === 'click') {
            this.hide();
        }
        if (typeof show === 'undefined') {
            show = !this.popupRef;
        }
        if (show) {
            this.show(anchor);
        }
        else {
            this.hide();
        }
    }
    ngOnInit() {
        if (this.showOn === undefined) {
            this.showOn = 'hover';
        }
        this.verifyProperties();
    }
    ngOnChanges(changes) {
        if (changes.showOn) {
            this.subscribeClick();
        }
    }
    ngAfterViewChecked() {
        if (!this.popupRef) {
            return;
        }
        if (this.anchor &&
            !hasParent(this.anchor.nativeElement || this.anchor, this.tooltipWrapper.nativeElement)) {
            this.anchor = null;
            this.hide();
        }
    }
    ngOnDestroy() {
        this.hide();
        this.template = null;
        this.anchorTitleSubscription.unsubscribe();
        this.mouseOverSubscription.unsubscribe();
        this.mouseOutSubscription.unsubscribe();
        if (this.mouseClickSubscription) {
            this.mouseClickSubscription.unsubscribe();
        }
        if (this.popupPositionChangeSubscription) {
            this.popupPositionChangeSubscription.unsubscribe();
        }
        if (this.popupMouseOutSubscription) {
            this.popupMouseOutSubscription.unsubscribe();
        }
    }
    showContent(anchorRef) {
        if (!anchorRef.nativeElement.getAttribute('data-title') && !this.template) {
            return;
        }
        this.ngZone.run(() => {
            this.openPopup(anchorRef);
            this.bindContent(this.popupRef.content, anchorRef);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take(1))
            .subscribe(() => this.hide());
    }
    bindContent(contentComponent, anchorRef) {
        const content = contentComponent.instance;
        this.closeClickSubscription = content.close
            .subscribe(() => { this.hide(); });
        if (!this.template) {
            content.templateString = this.anchor.nativeElement.getAttribute('data-title');
        }
        else {
            content.templateRef = this.template;
        }
        if (this.titleTemplate) {
            content.titleTemplate = this.titleTemplate;
        }
        content.closeTitle = this.closeTitle;
        content.anchor = anchorRef;
        content.callout = this.callout;
        content.closable = this.closable;
        content.position = this.position;
        content.tooltipWidth = this.tooltipWidth;
        content.tooltipHeight = this.tooltipHeight;
        this.popupRef.content.changeDetectorRef.detectChanges();
    }
    hideElementTitle(elementRef) {
        const element = elementRef.nativeElement;
        if (element.getAttribute('title')) {
            element.setAttribute('data-title', element.getAttribute('title'));
            element.setAttribute('title', '');
        }
    }
    openPopup(anchorRef) {
        const alignSettings = align(this.position, this.offset);
        const anchorAlign = alignSettings.anchorAlign;
        const popupAlign = alignSettings.popupAlign;
        const popupMargin = alignSettings.popupMargin;
        this.popupRef = this.popupService.open({
            anchor: anchorRef,
            anchorAlign,
            animate: false,
            content: TooltipContentComponent,
            collision: collision(this.collision, this.position),
            margin: popupMargin,
            popupAlign,
            popupClass: 'k-popup-transparent'
        });
        this.renderer.addClass(this.popupRef.popupElement, 'k-tooltip-wrapper');
        if (this.tooltipClass) {
            this.renderer.addClass(this.popupRef.popupElement, this.tooltipClass);
        }
        const popupInstance = this.popupRef.content.instance;
        if (popupInstance.callout) {
            this.popupPositionChangeSubscription = this.popupRef.popupPositionChange
                .subscribe(({ flip }) => {
                const isFlip = flip.horizontal === true || flip.vertical === true;
                popupInstance.updateCalloutPosition(this.position, isFlip);
            });
        }
        if (this.showOn === 'hover') {
            this.ngZone.runOutsideAngular(() => {
                const popup = this.popupRef.popupElement;
                this.popupMouseOutSubscription = fromEvent(popup, 'mouseout')
                    .subscribe((e) => this.onMouseOut(e));
            });
        }
    }
    closePopup() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupPositionChangeSubscription) {
            this.popupPositionChangeSubscription.unsubscribe();
        }
    }
    subscribeClick() {
        if (this.mouseClickSubscription) {
            this.mouseClickSubscription.unsubscribe();
        }
        if (this.showOn === 'click') {
            this.mouseClickSubscription = fromEvent(document, 'click')
                .pipe(filter(() => this.filter !== ''))
                .subscribe(e => this.onMouseClick(e, this.tooltipWrapper.nativeElement));
        }
    }
    onMouseClick(e, wrapper) {
        const target = e.target;
        const filterElement = closest(target, this.filter);
        const popup = this.popupRef && this.popupRef.popupElement;
        if (popup) {
            if (popup.contains(target)) {
                return;
            }
            if (this.closable) {
                return;
            }
        }
        if (wrapper.contains(target) && filterElement) {
            this.toggle(filterElement, true);
        }
        else if (popup) {
            this.hide();
        }
    }
    onMouseOver(e) {
        const filterElement = closest(e.target, this.filter);
        if (this.showOn !== 'hover') {
            return;
        }
        if (filterElement) {
            this.toggle(filterElement, true);
        }
    }
    onMouseOut(e) {
        if (this.showOn !== 'hover') {
            return;
        }
        if (this.closable) {
            return;
        }
        const popup = this.popupRef && this.popupRef.popupElement;
        const relatedTarget = e.relatedTarget;
        if (relatedTarget && this.anchor && contains(this.anchor.nativeElement, relatedTarget)) {
            return;
        }
        if (relatedTarget && contains(popup, relatedTarget)) {
            return;
        }
        this.hide();
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        if (!containsItem(this.validPositions, this.position)) {
            throw new Error(`Invalid value provided for position property.The available options are 'top', 'bottom', 'left', or 'right'.`);
        }
        if (!containsItem(this.validShowOptions, this.showOn)) {
            throw new Error(`Invalid value provided for showOn property.The available options are 'hover' or 'none'.`);
        }
    }
}
TooltipDirective.ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(TooltipSettings, 8), ɵngcc0.ɵɵdirectiveInject(TOOLTIP_SETTINGS, 8)); };
TooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "kendoTooltip", ""]], inputs: { filter: "filter", position: "position", showAfter: "showAfter", callout: "callout", closable: "closable", offset: "offset", tooltipTemplate: "tooltipTemplate", showOn: "showOn", titleTemplate: "titleTemplate", tooltipWidth: "tooltipWidth", tooltipHeight: "tooltipHeight", tooltipClass: "tooltipClass", collision: "collision", closeTitle: "closeTitle" }, exportAs: ["kendoTooltip"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
TooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: PopupService },
    { type: TooltipSettings, decorators: [{ type: Optional }] },
    { type: TooltipSettings, decorators: [{ type: Optional }, { type: Inject, args: [TOOLTIP_SETTINGS,] }] }
];
TooltipDirective.propDecorators = {
    filter: [{ type: Input }],
    position: [{ type: Input }],
    titleTemplate: [{ type: Input }],
    showOn: [{ type: Input }],
    showAfter: [{ type: Input }],
    callout: [{ type: Input }],
    closable: [{ type: Input }],
    offset: [{ type: Input }],
    tooltipWidth: [{ type: Input }],
    tooltipHeight: [{ type: Input }],
    tooltipClass: [{ type: Input }],
    collision: [{ type: Input }],
    closeTitle: [{ type: Input }],
    tooltipTemplate: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTooltip]',
                exportAs: 'kendoTooltip'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc3.PopupService }, { type: TooltipSettings, decorators: [{
                type: Optional
            }] }, { type: TooltipSettings, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TOOLTIP_SETTINGS]
            }] }]; }, { filter: [{
            type: Input
        }], position: [{
            type: Input
        }], showAfter: [{
            type: Input
        }], callout: [{
            type: Input
        }], closable: [{
            type: Input
        }], offset: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], showOn: [{
            type: Input
        }], titleTemplate: [{
            type: Input
        }], tooltipWidth: [{
            type: Input
        }], tooltipHeight: [{
            type: Input
        }], tooltipClass: [{
            type: Input
        }], collision: [{
            type: Input
        }], closeTitle: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class LocalizedMessagesDirective extends ComponentMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoTooltipLocalizedMessages", ""]], inputs: { closeTitle: "closeTitle" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ComponentMessages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
LocalizedMessagesDirective.propDecorators = {
    closeTitle: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: ComponentMessages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective)
                    }
                ],
                selector: `[kendoTooltipLocalizedMessages]`
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { closeTitle: [{
            type: Input
        }] }); })();

const COMPONENT_DIRECTIVES = [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective];
const COMPONENT_MODULES = [PopupModule];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Tooltip component.
 *
 * The package exports:
 * - `KendoTooltipDirective`&mdash;The Tooltip directive class.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Tooltip module
 * import { TooltipModule } from '@progress/kendo-angular-tooltip';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * _@NgModule{{
 *    declarations: [AppComponent], // declare app component
 *    imports:      [BrowserModule, TooltipModule], // import TooltipModule module
 *    bootstrap:    [AppComponent]
 * }}
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 * ```
 */
class TooltipModule {
}
TooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TooltipModule });
TooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TooltipModule_Factory(t) { return new (t || TooltipModule)(); }, imports: [[CommonModule, ...COMPONENT_MODULES]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TooltipModule, { declarations: function () { return [TooltipDirective,
        TooltipContentComponent,
        LocalizedMessagesDirective]; }, imports: function () { return [CommonModule,
        PopupModule]; }, exports: function () { return [TooltipDirective,
        TooltipContentComponent,
        LocalizedMessagesDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                entryComponents: [TooltipContentComponent],
                imports: [CommonModule, ...COMPONENT_MODULES],
                exports: [COMPONENT_DIRECTIVES]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { LocalizedMessagesDirective, TooltipContentComponent, TooltipDirective, TooltipModule, TooltipSettings, TOOLTIP_SETTINGS };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7MEJBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUpBNkNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxaUJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBV0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFRRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEluamVjdGlvblRva2VuLCBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIE91dHB1dCwgSW5wdXQsIGlzRGV2TW9kZSwgRGlyZWN0aXZlLCBOZ1pvbmUsIFJlbmRlcmVyMiwgT3B0aW9uYWwsIEluamVjdCwgZm9yd2FyZFJlZiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciwgZGVib3VuY2VUaW1lLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQb3B1cFNlcnZpY2UsIFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVgsIENvbXBvbmVudE1lc3NhZ2VzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIE9ic29sZXRlLiBQcm92aWRlIHRoZSBUb29sdGlwU2V0dGluZ3MgY2xhc3MgaW5zdGVhZC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFRPT0xUSVBfU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2tlbmRvLXVpLXRvb2x0aXAtc2V0dGluZ3MnKTtcbi8qKlxuICogUHJvdmlkZXMgYSBnbG9iYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIEtlbmRvIFVJIFRvb2x0aXAuIE9uY2UgaW5qZWN0ZWQgdGhyb3VnaFxuICogdGhlIGBBcHBDb21wb25lbnRgIGNvbnN0cnVjdG9yLCB0aGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGNhbiBiZSBvdmVycmlkZGVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIGltcG9ydCB7IFRvb2x0aXBTZXR0aW5ncyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXRvb2x0aXAnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxkaXYga2VuZG9Ub29sdGlwPlxuICogICAgICAgICAgPGJ1dHRvbiB0aXRsZT1cIlNhdmVzIHRoZSBjdXJyZW50IGRvY3VtZW50XCI+U2F2ZTwvYnV0dG9uPlxuICogICAgICA8L2Rpdj5gLFxuICogICAgcHJvdmlkZXJzOiBbe1xuICogICAgICAgIHByb3ZpZGU6IFRvb2x0aXBTZXR0aW5ncyxcbiAqICAgICAgICB1c2VGYWN0b3J5OiAoKTogVG9vbHRpcFNldHRpbmdzID0+ICh7XG4gKiAgICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IHZhbHVlcyBvZiB0b29sdGlwcyBpZiB3YW50ZWRcbiAqICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gKiAgICAgICAgfSlcbiAqICAgIH1dXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAqIGBgYFxuICovXG5jbGFzcyBUb29sdGlwU2V0dGluZ3Mge1xufVxuVG9vbHRpcFNldHRpbmdzLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWxpZ24ocG9zaXRpb24sIG9mZnNldCkge1xuICAgIGxldCBhbmNob3JBbGlnbiA9IHt9O1xuICAgIGxldCBwb3B1cEFsaWduID0ge307XG4gICAgbGV0IHBvcHVwTWFyZ2luID0ge307XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgYW5jaG9yQWxpZ24gPSB7IGhvcml6b250YWw6ICdjZW50ZXInLCB2ZXJ0aWNhbDogJ3RvcCcgfTtcbiAgICAgICAgICAgIHBvcHVwQWxpZ24gPSB7IGhvcml6b250YWw6ICdjZW50ZXInLCB2ZXJ0aWNhbDogJ2JvdHRvbScgfTtcbiAgICAgICAgICAgIHBvcHVwTWFyZ2luID0geyBob3Jpem9udGFsOiAwLCB2ZXJ0aWNhbDogb2Zmc2V0IH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGFuY2hvckFsaWduID0geyBob3Jpem9udGFsOiAnY2VudGVyJywgdmVydGljYWw6ICdib3R0b20nIH07XG4gICAgICAgICAgICBwb3B1cEFsaWduID0geyBob3Jpem9udGFsOiAnY2VudGVyJywgdmVydGljYWw6ICd0b3AnIH07XG4gICAgICAgICAgICBwb3B1cE1hcmdpbiA9IHsgaG9yaXpvbnRhbDogMCwgdmVydGljYWw6IG9mZnNldCB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGFuY2hvckFsaWduID0geyBob3Jpem9udGFsOiAncmlnaHQnLCB2ZXJ0aWNhbDogJ2NlbnRlcicgfTtcbiAgICAgICAgICAgIHBvcHVwQWxpZ24gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICdjZW50ZXInIH07XG4gICAgICAgICAgICBwb3B1cE1hcmdpbiA9IHsgaG9yaXpvbnRhbDogb2Zmc2V0LCB2ZXJ0aWNhbDogMCB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgYW5jaG9yQWxpZ24gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICdjZW50ZXInIH07XG4gICAgICAgICAgICBwb3B1cEFsaWduID0geyBob3Jpem9udGFsOiAncmlnaHQnLCB2ZXJ0aWNhbDogJ2NlbnRlcicgfTtcbiAgICAgICAgICAgIHBvcHVwTWFyZ2luID0geyBob3Jpem9udGFsOiBvZmZzZXQsIHZlcnRpY2FsOiAwIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFuY2hvckFsaWduLFxuICAgICAgICBwb3B1cEFsaWduLFxuICAgICAgICBwb3B1cE1hcmdpblxuICAgIH07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29sbGlzaW9uKGlucHV0Y29sbGlzaW9uLCBwb3NpdGlvbikge1xuICAgIGlmIChpbnB1dGNvbGxpc2lvbikge1xuICAgICAgICByZXR1cm4gaW5wdXRjb2xsaXNpb247XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiB7IGhvcml6b250YWw6ICdmaXQnLCB2ZXJ0aWNhbDogJ2ZsaXAnIH07XG4gICAgfVxuICAgIHJldHVybiB7IGhvcml6b250YWw6ICdmbGlwJywgdmVydGljYWw6ICdmaXQnIH07XG59XG5mdW5jdGlvbiBpc0RvY3VtZW50Tm9kZShjb250YWluZXIpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLm5vZGVUeXBlID09PSA5O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoZWxlbWVudC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA/XG4gICAgICAgIChlbCwgc2VsKSA9PiBlbC5tYXRjaGVzKHNlbClcbiAgICAgICAgOiAoZWwsIHNlbCkgPT4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsKTtcbiAgICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKG5vZGUgJiYgIWlzRG9jdW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgIGlmIChtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnMoY29udGFpbmVyLCBjaGlsZCkge1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnROb2RlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnMoY2hpbGQpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICByZXR1cm4gISEoY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGNoaWxkKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzUGFyZW50ID0gKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHBhcmVudCkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyT2Zmc2V0KGl0ZW0sIGRpciwgc2l6ZSkge1xuICAgIGNvbnN0IHJlY3QgPSBpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiByZWN0W2Rpcl0gKyAocmVjdFtzaXplXSAvIDIpO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zSXRlbShjb2xsZWN0aW9uLCBpdGVtKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUb29sdGlwQ29udGVudENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCwgbG9jYWxpemF0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRvb2x0aXBXaWR0aCA9IG51bGw7XG4gICAgICAgIHRoaXMudG9vbHRpcEhlaWdodCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbG91dCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbG91dFN0eWxlcyA9IChwb3NpdGlvbiwgY2FsbG91dFNpemUsIGlzRmxpcCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0ge307XG4gICAgICAgICAgICBjb25zdCBpc1ZlcnRpY2FsID0gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgICAgICAgICAgIGNvbnN0IGZsaXBEZWcgPSAnMTgwZGVnJztcbiAgICAgICAgICAgIGNvbnN0IHplcm9EZWcgPSAnMGRlZyc7XG4gICAgICAgICAgICBpZiAoIWlzRmxpcCkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSBpc1ZlcnRpY2FsID8gYHJvdGF0ZVgoJHt6ZXJvRGVnfSlgIDogYHJvdGF0ZVkoJHt6ZXJvRGVnfSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLmJvdHRvbSA9ICd1bnNldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudG9wID0gJ3Vuc2V0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMucmlnaHQgPSAndW5zZXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMubGVmdCA9ICd1bnNldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNbcG9zaXRpb25dID0gYCR7LWNhbGxvdXRTaXplfXB4YDtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSBpc1ZlcnRpY2FsID8gYHJvdGF0ZVgoJHtmbGlwRGVnfSlgIDogYHJvdGF0ZVkoJHtmbGlwRGVnfSlgO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIGdldCBjc3NDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gJ2std2lkZ2V0IGstdG9vbHRpcCc7XG4gICAgfVxuICAgIGdldCBjbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NhYmxlO1xuICAgIH1cbiAgICBnZXQgY3NzUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJyk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2xvc2VCdXR0b25UaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VUaXRsZSB8fCB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdjbG9zZVRpdGxlJyk7XG4gICAgfVxuICAgIGNhbGxvdXRQb3NpdGlvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RvcCc6ICdrLWNhbGxvdXQtcycsXG4gICAgICAgICAgICAnbGVmdCc6ICdrLWNhbGxvdXQtZScsXG4gICAgICAgICAgICAnYm90dG9tJzogJ2stY2FsbG91dC1uJyxcbiAgICAgICAgICAgICdyaWdodCc6ICdrLWNhbGxvdXQtdydcbiAgICAgICAgfVt0aGlzLnBvc2l0aW9uXTtcbiAgICB9XG4gICAgb25DbG9zZUNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgIH1cbiAgICB1cGRhdGVDYWxsb3V0UG9zaXRpb24ocG9zaXRpb24sIGlzRmxpcCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbG91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxvdXQgPSB0aGlzLmNvbnRlbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuay1jYWxsb3V0Jyk7XG4gICAgICAgIGNvbnN0IGlzVmVydGljYWwgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgICAgICBjb25zdCBzaXplID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgZGlyID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgICBjb25zdCBvZmZzZXRQcm9wZXJ0eSA9IGlzVmVydGljYWwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luVG9wJztcbiAgICAgICAgY29uc3QgY2FsbG91dFNpemUgPSBjYWxsb3V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3NpemVdO1xuICAgICAgICBjb25zdCBhbmNob3JDZW50ZXIgPSBnZXRDZW50ZXJPZmZzZXQodGhpcy5hbmNob3IubmF0aXZlRWxlbWVudCwgZGlyLCBzaXplKTtcbiAgICAgICAgY29uc3QgY29udGVudENlbnRlciA9IGdldENlbnRlck9mZnNldCh0aGlzLmNvbnRlbnQubmF0aXZlRWxlbWVudCwgZGlyLCBzaXplKTtcbiAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKGNvbnRlbnRDZW50ZXIgLSBhbmNob3JDZW50ZXIpO1xuICAgICAgICBpZiAoZGlmZiA+IDEgfHwgZGlmZiA9PT0gMCB8fCBNYXRoLnJvdW5kKGRpZmYpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXJnaW4gPSBjb250ZW50Q2VudGVyIC0gYW5jaG9yQ2VudGVyICsgKGNhbGxvdXRTaXplIC8gMik7XG4gICAgICAgICAgICBjYWxsb3V0LnN0eWxlW29mZnNldFByb3BlcnR5XSA9IGAkey1uZXdNYXJnaW59cHhgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxvdXRTdHlsZXMgPSB0aGlzLmNhbGxvdXRTdHlsZXMocG9zaXRpb24sIGNhbGxvdXRTaXplLCBpc0ZsaXApO1xuICAgICAgICBPYmplY3Qua2V5cyhjYWxsb3V0U3R5bGVzKS5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICAgICAgY2FsbG91dC5zdHlsZVtzdHlsZV0gPSBjYWxsb3V0U3R5bGVzW3N0eWxlXTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuVG9vbHRpcENvbnRlbnRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRvb2x0aXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIga2VuZG9Ub29sdGlwTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4tY2xvc2VUaXRsZT1cImtlbmRvLnRvb2x0aXAuY2xvc2VUaXRsZXxUaGUgdGl0bGUgb2YgdGhlIGNsb3NlIGJ1dHRvblwiXG4gICAgICAgICAgICBjbG9zZVRpdGxlPVwiQ2xvc2VcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXRvb2x0aXAtY29udGVudFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstdG9vbHRpcC10aXRsZVwiICpuZ0lmPVwidGl0bGVUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBbbmdJZl09XCJ0aXRsZVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGl0bGVUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogYW5jaG9yLCBhbmNob3I6IGFuY2hvciB9XCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICBbbmdJZl09XCJ0ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogYW5jaG9yLCBhbmNob3I6IGFuY2hvciB9XCI+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgW25nSWZdPVwidGVtcGxhdGVTdHJpbmdcIj5cbiAgICAgICAgICAgICAgICB7eyB0ZW1wbGF0ZVN0cmluZyB9fVxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiAqbmdJZj1cImNsb3NhYmxlXCIgY2xhc3M9XCJrLXRvb2x0aXAtYnV0dG9uXCIgKGNsaWNrKT1cIm9uQ2xvc2VDbGljaygkZXZlbnQpXCI+XG4gICAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwiay1pY29uIGstaS1jbG9zZVwiIFthdHRyLnRpdGxlXT1cImNsb3NlQnV0dG9uVGl0bGVcIj48L2E+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWNhbGxvdXRcIiAqbmdJZj1cImNhbGxvdXRcIiBbbmdDbGFzc109XCJjYWxsb3V0UG9zaXRpb25DbGFzcygpXCI+PC9kaXY+XG4gICAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnRvb2x0aXAnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRvb2x0aXBDb250ZW50Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNzc0NsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIGNsYXNzTmFtZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay10b29sdGlwLWNsb3NhYmxlJyxdIH1dLFxuICAgIGNzc1Bvc2l0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5wb3NpdGlvbicsXSB9XSxcbiAgICB0b29sdGlwV2lkdGg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLndpZHRoLnB4JyxdIH0sIHsgdHlwZTogSW5wdXQgfV0sXG4gICAgdG9vbHRpcEhlaWdodDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUuaGVpZ2h0LnB4JyxdIH0sIHsgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGVUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYW5jaG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbG9zYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGVtcGxhdGVSZWY6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRlbXBsYXRlU3RyaW5nOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgVG9vbHRpcCBkaXJlY3RpdmUgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfdG9vbHRpcCAlfSkuXG4gKiBVc2VkIHRvIGRpc3BsYXkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGlzIHJlbGF0ZWQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiA8ZGl2IGtlbmRvVG9vbHRpcD5cbiAqICAgIDxhIHRpdGxlPVwiVG9vbHRpcCB0aXRsZVwiIGhyZWY9XCJmb29cIj5mb288L2E+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICovXG5jbGFzcyBUb29sdGlwRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b29sdGlwV3JhcHBlciwgbmdab25lLCByZW5kZXJlciwgcG9wdXBTZXJ2aWNlLCBzZXR0aW5ncywgbGVnYWN5U2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy50b29sdGlwV3JhcHBlciA9IHRvb2x0aXBXcmFwcGVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBhIHNlbGVjdG9yIGZvciBlbGVtZW50cyB3aXRoaW4gYSBjb250YWluZXIgd2hpY2ggd2lsbCBkaXNwbGF5IGEgdG9vbHRpcFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFuY2hvcmVsZW1lbnRzX3Rvb2x0aXAgJX0pKS4gVGhlIHBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlIGFueVxuICAgICAgICAgKiBET00gYHNlbGVjdG9yYC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYFt0aXRsZV1gLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXIgPSAnW3RpdGxlXSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBUb29sdGlwIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIGFuY2hvciBlbGVtZW50IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcG9zaXRpb25pbmdfdG9vbHRpcCAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiBgdG9wYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgYm90dG9tYFxuICAgICAgICAgKiAqIGBsZWZ0YFxuICAgICAgICAgKiAqIGByaWdodGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAndG9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgVG9vbHRpcCBpcyBzaG93bi5cbiAgICAgICAgICogKiBgMTAwYCAoZGVmYXVsdCkgbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93QWZ0ZXIgPSAxMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlINCib29sdGlwIHdpbGwgZGlzcGxheSBhIGNhbGxvdXQgYXJyb3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIGB0cnVlYCAoZGVmYXVsdClcbiAgICAgICAgICogKiBgZmFsc2VgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxvdXQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSDQom9vbHRpcCB3aWxsIGRpc3BsYXkgYSAqKkNsb3NlKiogYnV0dG9uXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2xvc2FibGVfdG9vbHRpcCAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiBgdHJ1ZWBcbiAgICAgICAgICogKiBgZmFsc2VgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG9mZnNldCBpbiBwaXhlbHMgYmV0d2VlbiB0aGUgVG9vbHRpcCBhbmQgdGhlIGFuY2hvci4gRGVmYXVsdHMgdG8gYDZgIHBpeGVscy5cbiAgICAgICAgICogSWYgdGhlIGBjYWxsb3V0YCBwcm9wZXJ0eSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgb2Zmc2V0IGlzIHJlbmRlcmVkIGZyb20gdGhlIGNhbGxvdXQgYXJyb3cuXG4gICAgICAgICAqIElmIHRoZSBgY2FsbG91dGAgcHJvcGVydHkgaXMgc2V0IHRvIGBmYWxzZWAsIHRoZSBvZmZzZXQgaXMgcmVuZGVyZWQgZnJvbSB0aGUgY29udGVudCBvZiB0aGUgVG9vbHRpcC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gNjtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbGlkUG9zaXRpb25zID0gWyd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgICAgICAgdGhpcy52YWxpZFNob3dPcHRpb25zID0gWydob3ZlcicsICdjbGljaycsICdub25lJ107XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgc2V0dGluZ3MsIGxlZ2FjeVNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMudG9vbHRpcFdyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yVGl0bGVTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQod3JhcHBlciwgJ21vdXNlb3ZlcicpXG4gICAgICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuZmlsdGVyICE9PSAnJykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBjbG9zZXN0KGUudGFyZ2V0LCB0aGlzLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlRWxlbWVudFRpdGxlKHsgbmF0aXZlRWxlbWVudDogZmlsdGVyRWxlbWVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubW91c2VPdmVyU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdyYXBwZXIsICdtb3VzZW92ZXInKVxuICAgICAgICAgICAgICAgIC5waXBlKGRlYm91bmNlVGltZSgxMDApLCBmaWx0ZXIoKCkgPT4gdGhpcy5maWx0ZXIgIT09ICcnKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGUgPT4gdGhpcy5vbk1vdXNlT3ZlcihlKSk7XG4gICAgICAgICAgICB0aGlzLm1vdXNlT3V0U3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdyYXBwZXIsICdtb3VzZW91dCcpXG4gICAgICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKDEwMCkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShlID0+IHRoaXMub25Nb3VzZU91dChlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBUb29sdGlwIGFzIGEgdGVtcGxhdGUgcmVmZXJlbmNlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfdG9vbHRpcCAlfSkpLlxuICAgICAqL1xuICAgIHNldCB0b29sdGlwVGVtcGxhdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcFRlbXBsYXRlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZTsgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBUb29sdGlwLlxuICAgICAqIEBwYXJhbSBhbmNob3ImbWRhc2g7IEVsZW1lbnRSZWZ8RWxlbWVudC5cbiAgICAgKiBTcGVjaWZpZXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYW4gYW5jaG9yLiBUaGUgVG9vbHRpcCBvcGVucyByZWxhdGl2ZSB0byB0aGF0IGVsZW1lbnQuXG4gICAgICovXG4gICAgc2hvdyhhbmNob3IpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgYW5jaG9yID0geyBuYXRpdmVFbGVtZW50OiBhbmNob3IgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgaWYgKHRoaXMuc2hvd09uID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dDb250ZW50KHRoaXMuYW5jaG9yKSwgdGhpcy5zaG93QWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlRWxlbWVudFRpdGxlKHRoaXMuYW5jaG9yKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRlbnQodGhpcy5hbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBUb29sdGlwLlxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lb3V0KTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3IgJiYgdGhpcy5hbmNob3IubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKGFuY2hvciAmJiBhbmNob3IuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJykpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yLmdldEF0dHJpYnV0ZSgndGl0bGUnKSkge1xuICAgICAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgYW5jaG9yLmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9wdXBNb3VzZU91dFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1vdXNlT3V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNsaWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZVBvcHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIHRoZSBUb29sdGlwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFuY2hvciZtZGFzaDsgRWxlbWVudFJlZnxFbGVtZW50LiBTcGVjaWZpZXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYW4gYW5jaG9yLlxuICAgICAqIEBwYXJhbSBzaG93Jm1kYXNoOyBPcHRpb25hbC4gQm9vbGVhbi4gU3BlY2lmaWVzIGlmIHRoZSBUb29sdGlwIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKGFuY2hvciwgc2hvdykge1xuICAgICAgICBjb25zdCBwcmV2aW91c0FuY2hvciA9IHRoaXMuYW5jaG9yICYmIHRoaXMuYW5jaG9yLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChhbmNob3IgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBhbmNob3IgPSB7IG5hdGl2ZUVsZW1lbnQ6IGFuY2hvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c0FuY2hvciAhPT0gYW5jaG9yLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c0FuY2hvciA9PT0gYW5jaG9yLm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5zaG93T24gPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2hvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNob3cgPSAhdGhpcy5wb3B1cFJlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgdGhpcy5zaG93KGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvd09uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd09uID0gJ2hvdmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcmlmeVByb3BlcnRpZXMoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5zaG93T24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuY2hvciAmJlxuICAgICAgICAgICAgIWhhc1BhcmVudCh0aGlzLmFuY2hvci5uYXRpdmVFbGVtZW50IHx8IHRoaXMuYW5jaG9yLCB0aGlzLnRvb2x0aXBXcmFwcGVyLm5hdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvclRpdGxlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMubW91c2VPdmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMubW91c2VPdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKHRoaXMubW91c2VDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUNsaWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9wdXBQb3NpdGlvbkNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFBvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9wdXBNb3VzZU91dFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1vdXNlT3V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd0NvbnRlbnQoYW5jaG9yUmVmKSB7XG4gICAgICAgIGlmICghYW5jaG9yUmVmLm5hdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJykgJiYgIXRoaXMudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAoYW5jaG9yUmVmKTtcbiAgICAgICAgICAgIHRoaXMuYmluZENvbnRlbnQodGhpcy5wb3B1cFJlZi5jb250ZW50LCBhbmNob3JSZWYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEFuY2hvclZpZXdwb3J0TGVhdmVcbiAgICAgICAgICAgIC5waXBlKHRha2UoMSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuaGlkZSgpKTtcbiAgICB9XG4gICAgYmluZENvbnRlbnQoY29udGVudENvbXBvbmVudCwgYW5jaG9yUmVmKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50Q29tcG9uZW50Lmluc3RhbmNlO1xuICAgICAgICB0aGlzLmNsb3NlQ2xpY2tTdWJzY3JpcHRpb24gPSBjb250ZW50LmNsb3NlXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHsgdGhpcy5oaWRlKCk7IH0pO1xuICAgICAgICBpZiAoIXRoaXMudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQudGVtcGxhdGVTdHJpbmcgPSB0aGlzLmFuY2hvci5uYXRpdmVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGVudC50ZW1wbGF0ZVJlZiA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGl0bGVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgY29udGVudC50aXRsZVRlbXBsYXRlID0gdGhpcy50aXRsZVRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQuY2xvc2VUaXRsZSA9IHRoaXMuY2xvc2VUaXRsZTtcbiAgICAgICAgY29udGVudC5hbmNob3IgPSBhbmNob3JSZWY7XG4gICAgICAgIGNvbnRlbnQuY2FsbG91dCA9IHRoaXMuY2FsbG91dDtcbiAgICAgICAgY29udGVudC5jbG9zYWJsZSA9IHRoaXMuY2xvc2FibGU7XG4gICAgICAgIGNvbnRlbnQucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb250ZW50LnRvb2x0aXBXaWR0aCA9IHRoaXMudG9vbHRpcFdpZHRoO1xuICAgICAgICBjb250ZW50LnRvb2x0aXBIZWlnaHQgPSB0aGlzLnRvb2x0aXBIZWlnaHQ7XG4gICAgICAgIHRoaXMucG9wdXBSZWYuY29udGVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGhpZGVFbGVtZW50VGl0bGUoZWxlbWVudFJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Qb3B1cChhbmNob3JSZWYpIHtcbiAgICAgICAgY29uc3QgYWxpZ25TZXR0aW5ncyA9IGFsaWduKHRoaXMucG9zaXRpb24sIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgY29uc3QgYW5jaG9yQWxpZ24gPSBhbGlnblNldHRpbmdzLmFuY2hvckFsaWduO1xuICAgICAgICBjb25zdCBwb3B1cEFsaWduID0gYWxpZ25TZXR0aW5ncy5wb3B1cEFsaWduO1xuICAgICAgICBjb25zdCBwb3B1cE1hcmdpbiA9IGFsaWduU2V0dGluZ3MucG9wdXBNYXJnaW47XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgICAgICAgIGFuY2hvcjogYW5jaG9yUmVmLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ24sXG4gICAgICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFRvb2x0aXBDb250ZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgY29sbGlzaW9uOiBjb2xsaXNpb24odGhpcy5jb2xsaXNpb24sIHRoaXMucG9zaXRpb24pLFxuICAgICAgICAgICAgbWFyZ2luOiBwb3B1cE1hcmdpbixcbiAgICAgICAgICAgIHBvcHVwQWxpZ24sXG4gICAgICAgICAgICBwb3B1cENsYXNzOiAnay1wb3B1cC10cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQsICdrLXRvb2x0aXAtd3JhcHBlcicpO1xuICAgICAgICBpZiAodGhpcy50b29sdGlwQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQsIHRoaXMudG9vbHRpcENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3B1cEluc3RhbmNlID0gdGhpcy5wb3B1cFJlZi5jb250ZW50Lmluc3RhbmNlO1xuICAgICAgICBpZiAocG9wdXBJbnN0YW5jZS5jYWxsb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLnBvcHVwUmVmLnBvcHVwUG9zaXRpb25DaGFuZ2VcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGZsaXAgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRmxpcCA9IGZsaXAuaG9yaXpvbnRhbCA9PT0gdHJ1ZSB8fCBmbGlwLnZlcnRpY2FsID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcHVwSW5zdGFuY2UudXBkYXRlQ2FsbG91dFBvc2l0aW9uKHRoaXMucG9zaXRpb24sIGlzRmxpcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG93T24gPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNb3VzZU91dFN1YnNjcmlwdGlvbiA9IGZyb21FdmVudChwb3B1cCwgJ21vdXNlb3V0JylcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4gdGhpcy5vbk1vdXNlT3V0KGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlUG9wdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3B1cFBvc2l0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUG9zaXRpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmVDbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VDbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUNsaWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvd09uID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlQ2xpY2tTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpXG4gICAgICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuZmlsdGVyICE9PSAnJykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShlID0+IHRoaXMub25Nb3VzZUNsaWNrKGUsIHRoaXMudG9vbHRpcFdyYXBwZXIubmF0aXZlRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2VDbGljayhlLCB3cmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gY2xvc2VzdCh0YXJnZXQsIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwUmVmICYmIHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgIGlmIChwb3B1cC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2FibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBwZXIuY29udGFpbnModGFyZ2V0KSAmJiBmaWx0ZXJFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZShmaWx0ZXJFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3B1cCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Nb3VzZU92ZXIoZSkge1xuICAgICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gY2xvc2VzdChlLnRhcmdldCwgdGhpcy5maWx0ZXIpO1xuICAgICAgICBpZiAodGhpcy5zaG93T24gIT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoZmlsdGVyRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Nb3VzZU91dChlKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3dPbiAhPT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsb3NhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLnBvcHVwUmVmICYmIHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICBpZiAocmVsYXRlZFRhcmdldCAmJiB0aGlzLmFuY2hvciAmJiBjb250YWlucyh0aGlzLmFuY2hvci5uYXRpdmVFbGVtZW50LCByZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmIGNvbnRhaW5zKHBvcHVwLCByZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgICB2ZXJpZnlQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAoIWlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250YWluc0l0ZW0odGhpcy52YWxpZFBvc2l0aW9ucywgdGhpcy5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBwcm92aWRlZCBmb3IgcG9zaXRpb24gcHJvcGVydHkuVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZSAndG9wJywgJ2JvdHRvbScsICdsZWZ0Jywgb3IgJ3JpZ2h0Jy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5zSXRlbSh0aGlzLnZhbGlkU2hvd09wdGlvbnMsIHRoaXMuc2hvd09uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIHByb3ZpZGVkIGZvciBzaG93T24gcHJvcGVydHkuVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZSAnaG92ZXInIG9yICdub25lJy5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblRvb2x0aXBEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1Rvb2x0aXBdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvVG9vbHRpcCdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVG9vbHRpcERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBQb3B1cFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFRvb2x0aXBTZXR0aW5ncywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICB7IHR5cGU6IFRvb2x0aXBTZXR0aW5ncywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtUT09MVElQX1NFVFRJTkdTLF0gfV0gfVxuXTtcblRvb2x0aXBEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3NpdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGVUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd09uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93QWZ0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNhbGxvdXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNsb3NhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvZmZzZXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvb2x0aXBXaWR0aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdG9vbHRpcEhlaWdodDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdG9vbHRpcENsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2xsaXNpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNsb3NlVGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvb2x0aXBUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufVxuTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ29tcG9uZW50TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGBba2VuZG9Ub29sdGlwTG9jYWxpemVkTWVzc2FnZXNdYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Mb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcbkxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNsb3NlVGl0bGU6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtUb29sdGlwRGlyZWN0aXZlLCBUb29sdGlwQ29udGVudENvbXBvbmVudCwgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmVdO1xuY29uc3QgQ09NUE9ORU5UX01PRFVMRVMgPSBbUG9wdXBNb2R1bGVdO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgVG9vbHRpcCBjb21wb25lbnQuXG4gKlxuICogVGhlIHBhY2thZ2UgZXhwb3J0czpcbiAqIC0gYEtlbmRvVG9vbHRpcERpcmVjdGl2ZWAmbWRhc2g7VGhlIFRvb2x0aXAgZGlyZWN0aXZlIGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFRvb2x0aXAgbW9kdWxlXG4gKiBpbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdG9vbHRpcCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogX0BOZ01vZHVsZXt7XG4gKiAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFRvb2x0aXBNb2R1bGVdLCAvLyBpbXBvcnQgVG9vbHRpcE1vZHVsZSBtb2R1bGVcbiAqICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH19XG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqIGBgYFxuICovXG5jbGFzcyBUb29sdGlwTW9kdWxlIHtcbn1cblRvb2x0aXBNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtUb29sdGlwQ29udGVudENvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgLi4uQ09NUE9ORU5UX01PRFVMRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQsIFRvb2x0aXBEaXJlY3RpdmUsIFRvb2x0aXBNb2R1bGUsIFRvb2x0aXBTZXR0aW5ncywgVE9PTFRJUF9TRVRUSU5HUyB9O1xuIl19