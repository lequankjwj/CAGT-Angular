/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable, NgZone, EventEmitter, Directive, TemplateRef, Optional, Component, Input, ContentChildren, forwardRef, Renderer2, Output, HostBinding, ElementRef, ChangeDetectorRef, ViewChild, isDevMode, NgModule, ContentChild } from '@angular/core';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { hasObservers, isDocumentAvailable, Keys } from '@progress/kendo-angular-common';
import { PopupService, POPUP_CONTAINER, PopupModule } from '@progress/kendo-angular-popup';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-popup';

const _c0 = ["kendoMenuList", ""];
function ListComponent_ng_container_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 3);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const idx_r2 = ctx_r5.index;
    const item_r1 = ctx_r5.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-first", idx_r2 === 0)("k-last", idx_r2 === ctx_r3.items.length - 1)("k-state-disabled", item_r1.disabled);
    ɵngcc0.ɵɵproperty("item", item_r1)("level", ctx_r3.level)("vertical", ctx_r3.vertical)("animate", ctx_r3.animate)("rtl", ctx_r3.rtl)("itemTemplate", ctx_r3.itemTemplate)("itemLinkTemplate", ctx_r3.itemLinkTemplate)("openOnClick", ctx_r3.openOnClick)("index", ctx_r3.hierarchyIndex(idx_r2))("siblingIndex", idx_r2)("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-menu-index", ctx_r3.hierarchyIndex(idx_r2));
} }
function ListComponent_ng_container_0_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵtext(1, " \u00A0 ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
} }
function ListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ListComponent_ng_container_0_li_1_Template, 1, 19, "li", 1);
    ɵngcc0.ɵɵtemplate(2, ListComponent_ng_container_0_li_2_Template, 2, 2, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r1.separator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r1.separator);
} }
const _c1 = ["link"];
const _c2 = ["popupTemplate"];
const _c3 = ["kendoMenuItem", ""];
function ItemComponent_span_0_ng_template_2_Template(rf, ctx) { }
function ItemComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6, 7);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_span_0_ng_template_2_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r0.opened);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function ItemComponent_a_1_ng_template_2_Template(rf, ctx) { }
function ItemComponent_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 9, 7);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_a_1_ng_template_2_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r1.opened);
    ɵngcc0.ɵɵattribute("href", ctx_r1.item.url, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function ItemComponent_2_ng_template_0_Template(rf, ctx) { }
const _c4 = function (a0, a1) { return { item: a0, index: a1 }; };
function ItemComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_2_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.linkTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c4, ctx_r2.item, ctx_r2.index));
} }
function ItemComponent_div_3_ng_template_1_Template(rf, ctx) { }
function ItemComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, ItemComponent_div_3_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.item.content)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c4, ctx_r3.item.owner, ctx_r3.item.ownerIndex));
} }
function ItemComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 12);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("animate", ctx_r5.animate)("rtl", ctx_r5.rtl)("vertical", ctx_r5.vertical)("openOnClick", ctx_r5.openOnClick)("items", ctx_r5.children)("level", ctx_r5.level + 1)("index", ctx_r5.index)("itemTemplate", ctx_r5.itemTemplate)("itemLinkTemplate", ctx_r5.itemLinkTemplate);
    ɵngcc0.ɵɵattribute("id", ctx_r5.childId);
} }
function ItemComponent_ng_template_6_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 15);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r14.iconClass);
} }
function ItemComponent_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r15.item.text, " ");
} }
function ItemComponent_ng_template_6_2_ng_template_0_Template(rf, ctx) { }
function ItemComponent_ng_template_6_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_template_6_2_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r16.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c4, ctx_r16.item, ctx_r16.index));
} }
function ItemComponent_ng_template_6_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 16);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-60-down", !ctx_r17.horizontal)("k-i-arrow-60-right", ctx_r17.horizontal && !ctx_r17.rtl)("k-i-arrow-60-left", ctx_r17.horizontal && ctx_r17.rtl);
} }
function ItemComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ItemComponent_ng_template_6_span_0_Template, 1, 1, "span", 13);
    ɵngcc0.ɵɵtemplate(1, ItemComponent_ng_template_6_ng_container_1_Template, 2, 1, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, ItemComponent_ng_template_6_2_Template, 1, 5, undefined, 2);
    ɵngcc0.ɵɵtemplate(3, ItemComponent_ng_template_6_span_3_Template, 1, 6, "span", 14);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.item.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r7.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.hasContent);
} }
const _c5 = ["default"];
function ContextMenuComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-menu", 1);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("items", ctx_r1.rootItems)("vertical", ctx_r1.vertical)("openOnClick", ctx_r1.openOnClick)("hoverDelay", ctx_r1.hoverDelay)("animate", ctx_r1.animate)("menuItemTemplate", ctx_r1.itemTemplate.first == null ? null : ctx_r1.itemTemplate.first.templateRef)("menuItemLinkTemplate", ctx_r1.itemLinkTemplate.first == null ? null : ctx_r1.itemLinkTemplate.first.templateRef);
} }
const PARENT_REGEX = /_?\d+$/;
const SEPARATOR = '_';
let id = 0;
const itemIndexComparer = (a, b) => a.siblingIndex - b.siblingIndex;
const next = (idx, items, dir) => {
    let current = items[idx + dir];
    while (!current) {
        if (idx < 0) {
            idx = items.length - 1;
        }
        else if (idx >= items.length) {
            idx = 0;
        }
        else {
            idx += dir;
        }
        current = items[idx];
    }
    return current;
};
/**
 * @hidden
 */
class ItemsService {
    constructor() {
        this.items = {};
        this.lists = [];
        this.idPrefix = `k-menu${id++}`;
    }
    get hasItems() {
        return Object.keys(this.items).length > 0;
    }
    childId(index) {
        return `${this.idPrefix}-child${index}`;
    }
    itemIndex(parentIndex, index) {
        return (parentIndex ? parentIndex + SEPARATOR : '') + index;
    }
    get(index) {
        return this.items[index];
    }
    add(item) {
        this.items[item.index] = item;
    }
    remove(item) {
        if (this.items[item.index] === item) {
            delete this.items[item.index];
        }
    }
    addList(list) {
        this.lists.push(list);
    }
    removeList(list) {
        const index = this.lists.indexOf(list);
        if (index >= 0) {
            this.lists.splice(index, 1);
        }
    }
    containsList(element) {
        return Boolean(this.lists.find(list => list.element.nativeElement === element));
    }
    siblings(item) {
        const parentIndex = this.parentIndex(item.index);
        return this.filter((index) => this.parentIndex(index) === parentIndex);
    }
    otherSiblings(item) {
        const parentIndex = this.parentIndex(item.index);
        return this.filter((index) => this.parentIndex(index) === parentIndex && index !== item.index);
    }
    children(item) {
        return this.filter((index) => this.parentIndex(index) === item.index);
    }
    parent(item) {
        return this.items[this.parentIndex(item.index)];
    }
    root(item) {
        return this.items[this.indices(item.index)[0]];
    }
    indices(index) {
        return index.split(SEPARATOR);
    }
    filter(predicate) {
        const result = [];
        const items = this.items;
        for (let index in items) {
            if (predicate(index, items[index])) {
                result.push(items[index]);
            }
        }
        return result.sort(itemIndexComparer);
    }
    previous(item) {
        const siblings = this.siblings(item);
        const itemIndex = siblings.indexOf(item);
        return next(itemIndex, siblings, -1);
    }
    next(item) {
        const siblings = this.siblings(item);
        const itemIndex = siblings.indexOf(item);
        return next(itemIndex, siblings, 1);
    }
    hasParent(item, parent) {
        return item.index.startsWith(parent.index);
    }
    areSiblings(item1, item2) {
        return item1 !== item2 && this.parent(item1) === this.parent(item2);
    }
    forEach(callback) {
        const items = this.items;
        for (let index in items) {
            if (items.hasOwnProperty(index)) {
                callback(items[index]);
            }
        }
    }
    parentIndex(index) {
        return index.replace(PARENT_REGEX, '');
    }
}
ItemsService.ɵfac = function ItemsService_Factory(t) { return new (t || ItemsService)(); };
ItemsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ItemsService, factory: ItemsService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemsService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class PreventableEvent {
    /**
     * @hidden
     */
    constructor(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `open` and `close` events of the Menu.
 */
class MenuEvent extends PreventableEvent {
}

const canPerformAction = (item, action) => !((action === 'open' && item.opened) || (action === 'close' && !item.opened));
/**
 * @hidden
 */
class ActionsService {
    constructor(ngZone, items) {
        this.ngZone = ngZone;
        this.items = items;
        this.actions = [];
    }
    open(item, finished) {
        if (item.disabled) {
            return;
        }
        if (item.hasContent && !item.opened) {
            this.actions.push({
                name: 'open',
                requiresZone: item.hasContentTemplates(),
                item,
                finished
            });
        }
        else if (finished) {
            finished();
        }
    }
    close(item) {
        this.closeChildren(item);
        this.closeItem(item);
    }
    closeItem(item) {
        if (item.opened) {
            this.actions.push({
                name: 'close',
                item
            });
        }
    }
    closeToRoot(item) {
        this.closeChildren(item);
        let current = item;
        do {
            this.closeItem(current);
            current = this.items.parent(current);
        } while (current);
    }
    closeOthers(item) {
        this.closeChildren(item);
        let current = item;
        while (current) {
            const siblings = this.items.otherSiblings(current);
            this.closeItems(siblings);
            current = this.items.parent(current);
        }
    }
    closeAll() {
        this.items.forEach((item) => {
            if (item.opened && item.level === 0) {
                this.close(item);
            }
        });
    }
    select(item, domEvent, prevented, finished) {
        this.actions.push({
            name: 'select',
            item,
            prevented,
            finished,
            domEvent
        });
    }
    emit(name, item, domEvent) {
        const owner = this.owner;
        const eventArgs = new MenuEvent({
            sender: owner,
            item: item.item,
            index: item.index,
            originalEvent: domEvent,
            hasContent: item.hasContent
        });
        owner[name].emit(eventArgs);
        if (owner.contextService) {
            owner.contextService.emit(name, eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    get hasPending() {
        return this.actions.length > 0;
    }
    execute(toExecute) {
        if (!this.hasPending && !toExecute) {
            return;
        }
        const actions = toExecute || this.clear();
        if (!NgZone.isInAngularZone() && this.requiresZone(actions)) {
            this.ngZone.run(() => {
                this.executeActions(actions);
            });
        }
        else {
            this.executeActions(actions);
        }
    }
    clear() {
        const actions = this.actions;
        this.actions = [];
        return actions;
    }
    executeActions(actions) {
        for (let idx = 0; idx < actions.length; idx++) {
            const { item, name, prevented, finished, domEvent } = actions[idx];
            if (!canPerformAction(item, name)) {
                continue;
            }
            if (!this.emit(name, item, domEvent)) {
                if (item[name]) {
                    item[name]();
                }
                if (finished) {
                    finished();
                }
            }
            else if (prevented) {
                prevented();
            }
        }
    }
    requiresZone(toExecute) {
        const actions = toExecute || this.actions;
        const owner = this.owner;
        const contextService = owner.contextService;
        for (let idx = 0; idx < actions.length; idx++) {
            const action = actions[idx];
            const name = action.name;
            if (action.requiresZone || (name && (hasObservers(owner[name]) || (contextService && contextService.hasObservers(name))))) {
                return true;
            }
        }
        return false;
    }
    closeChildren(item) {
        if (!item.opened) {
            return;
        }
        const children = this.items.children(item);
        this.closeItems(children);
    }
    closeItems(items) {
        for (let idx = 0; idx < items.length; idx++) {
            this.close(items[idx]);
        }
    }
}
ActionsService.ɵfac = function ActionsService_Factory(t) { return new (t || ActionsService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ItemsService)); };
ActionsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ActionsService, factory: ActionsService.ɵfac });
/** @nocollapse */
ActionsService.ctorParameters = () => [
    { type: NgZone },
    { type: ItemsService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActionsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ItemsService }]; }, null); })();

const DEFAULT_ACTIVE = '0';
const NO_SPACE_REGEX = /\S/;
const handlers = {};
handlers['37'] = 'left';
handlers['39'] = 'right';
handlers['38'] = 'up';
handlers['40'] = 'down';
handlers['36'] = 'home';
handlers['35'] = 'end';
handlers['32'] = 'enter';
handlers['13'] = 'enter';
handlers['27'] = 'esc';
handlers['9'] = 'tab';
const handlersRTL = Object.assign({}, handlers, {
    '37': 'right',
    '39': 'left'
});
function isPrintableCharacter(key) {
    return key.length === 1 && NO_SPACE_REGEX.test(key);
}
const resolvedPromise = Promise.resolve(null);
/**
 * @hidden
 */
class NavigationService {
    constructor(items, actions, localization, ngZone) {
        this.items = items;
        this.actions = actions;
        this.localization = localization;
        this.ngZone = ngZone;
        this.vertical = false;
        this.activeIndex = DEFAULT_ACTIVE;
    }
    get focusedItem() {
        return this.items.get(this.focusedIdx);
    }
    get activeItem() {
        return this.items.get(this.activeIndex);
    }
    get handlers() {
        return this.localization.rtl ? handlersRTL : handlers;
    }
    focus(item) {
        if (item.index === this.focusedIdx) {
            return;
        }
        if (!this.activeItem || !this.items.hasParent(item, this.activeItem)) {
            this.setActive(item);
        }
        this.setFocus(item);
    }
    setFocus(item) {
        this.focusedIdx = item.index;
        item.focus();
    }
    focusLeave() {
        const focused = this.focusedItem;
        if (focused) {
            this.actions.closeToRoot(focused);
            this.actions.execute();
        }
        this.focusedIdx = null;
    }
    updateActive() {
        if (!this.activeItem && this.items.hasItems) {
            const firstItem = this.items.get(DEFAULT_ACTIVE);
            firstItem.toggleActive(true);
            this.ngZone.runOutsideAngular(() => {
                resolvedPromise.then(() => {
                    this.activeIndex = DEFAULT_ACTIVE;
                });
            });
        }
    }
    keydown(e) {
        const current = this.focusedItem || this.activeItem;
        const handler = this.handlers[e.keyCode];
        if (!current) {
            return;
        }
        if (handler) {
            if (handler !== 'tab') {
                e.preventDefault();
            }
            this[handler](current, e);
        }
        else if (isPrintableCharacter(e.key)) {
            this.search(current, e.key);
        }
        this.actions.execute();
    }
    focusIndex(index) {
        if (!index && this.activeItem) {
            this.setFocus(this.activeItem);
        }
        else if (index === 'first') {
            this.focusFirst();
        }
        else if (index === 'last') {
            this.focusLast();
        }
        else {
            const item = this.items.get(index);
            if (item) {
                this.focus(item);
            }
        }
    }
    focusFirst() {
        const items = this.items.siblings(this.items.get('0'));
        this.focus(items[0]);
    }
    focusLast() {
        const items = this.items.siblings(this.items.get('0'));
        this.focus(items[items.length - 1]);
    }
    search(current, key) {
        const siblings = this.items.siblings(current);
        const startIndex = siblings.indexOf(current);
        const items = siblings.slice(startIndex + 1).concat(siblings.slice(0, startIndex));
        for (let idx = 0; idx < items.length; idx++) {
            const sibling = items[idx];
            const text = sibling.item.text || "";
            if (text.toLowerCase().startsWith(key.toLowerCase())) {
                this.focus(sibling);
                break;
            }
        }
    }
    down(current) {
        if (current.level === 0 && !this.vertical) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, 0));
            }
        }
        else {
            this.focus(this.items.next(current));
        }
    }
    up(current) {
        if (current.level === 0 && !this.vertical) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, current.children.length - 1));
            }
        }
        else {
            this.focus(this.items.previous(current));
        }
    }
    left(current) {
        if (this.vertical && current.level === 0 && current.disabled) {
            return;
        }
        if (current.level > 1 || (this.vertical && current.level > 0)) {
            const parent = this.items.parent(current);
            this.focus(parent);
            this.actions.close(parent);
        }
        else if (this.vertical && current.level === 0 && !current.disabled) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, current.children.length - 1));
            }
        }
        else {
            this.focus(this.items.previous(this.activeItem));
        }
    }
    right(current) {
        if (this.vertical && current.level === 0 && current.disabled) {
            return;
        }
        if (current.horizontal && !current.disabled) {
            if (current.hasContent) {
                this.actions.open(current, this.focusChild(current, 0));
            }
            else if (!this.vertical || current.level > 0) {
                this.focus(this.items.next(this.activeItem));
            }
        }
        else {
            this.focus(this.items.next(this.activeItem));
        }
    }
    home(current) {
        const siblings = this.items.siblings(current);
        this.focus(siblings[0]);
    }
    end(current) {
        const siblings = this.items.siblings(current);
        this.focus(siblings[siblings.length - 1]);
    }
    enter(current, domEvent) {
        const actions = this.actions;
        if (current.disabled) {
            return;
        }
        if (current.hasContent) {
            actions.select(current, domEvent);
            actions.open(current, this.focusChild(current, 0));
        }
        else {
            actions.select(current, domEvent, null, () => {
                current.navigate();
            });
            this.focus(this.items.root(current));
            actions.closeToRoot(current);
        }
    }
    esc(current) {
        if (current.level > 0) {
            const parent = this.items.parent(current);
            this.actions.close(parent);
            this.focus(parent);
        }
    }
    tab(current) {
        if (current.level > 0) {
            this.activeItem.focus();
        }
    }
    focusChild(item, index) {
        return () => {
            const child = this.items.children(item)[index];
            this.setFocus(child);
        };
    }
    setActive(item) {
        const focused = this.focusedItem;
        const active = this.items.root(item);
        if (this.activeItem) {
            this.activeItem.toggleActive(false);
        }
        this.activeIndex = active.index;
        active.toggleActive(true);
        if (focused) {
            this.actions.closeToRoot(focused);
            if (focused.level > 0) {
                this.actions.open(active);
            }
        }
    }
}
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(ItemsService), ɵngcc0.ɵɵinject(ActionsService), ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
NavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: NavigationService.ɵfac });
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: ItemsService },
    { type: ActionsService },
    { type: LocalizationService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: ItemsService }, { type: ActionsService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, null); })();

const DISABLE_OPEN_ON_OVER_DELAY = 500;
/**
 * @hidden
 */
class HoverService {
    constructor(actions, items) {
        this.actions = actions;
        this.items = items;
        this.delay = 100;
        this._openOnOver = true;
        this.scheduled = [];
    }
    get openOnOver() {
        return this._openOnOver;
    }
    set openOnOver(value) {
        this.cancelActions();
        this._openOnOver = value;
    }
    get hovered() {
        return this.items.get(this.hoveredIdx);
    }
    set hovered(item) {
        this.hoveredIdx = item ? item.index : null;
    }
    ngOnDestroy() {
        this.cancelActions();
    }
    over(item) {
        this.cancelActions((action) => action.name === 'openOnOver');
        if (!this.hovered || this.hovered !== item) {
            this.actions.closeOthers(item);
            this.hovered = item;
            if ((item.level > 0 || this.openOnOver) && !item.disabled) {
                this.actions.open(item);
                this.cancelActions((action) => (action.name === 'close' && (item === action.item || this.items.hasParent(item, action.item))) ||
                    (action.name === 'open' && !this.items.hasParent(item, action.item)));
            }
            this.scheduleActions();
        }
    }
    leave(disableOpenOnOver) {
        const hovered = this.hovered;
        if (hovered) {
            this.actions.closeToRoot(hovered);
            this.cancelActions(action => action.name === 'open');
            this.scheduleActions();
        }
        if (disableOpenOnOver && this._openOnOver) {
            this.scheduleDisableOpenOnOver();
        }
        this.hovered = null;
    }
    closeCurrent() {
        const hovered = this.hovered;
        if (hovered) {
            this.actions.closeToRoot(hovered);
            this.hovered = null;
        }
    }
    scheduleActions() {
        if (this.actions.hasPending) {
            const item = {};
            item.actions = this.actions.clear();
            item.id = setTimeout(() => {
                this.actions.execute(item.actions);
                this.removeScheduled(item);
            }, this.delay);
            this.scheduled.push(item);
        }
    }
    scheduleDisableOpenOnOver() {
        const item = {
            actions: [{ name: 'openOnOver' }]
        };
        item.id = setTimeout(() => {
            this._openOnOver = false;
            this.removeScheduled(item);
        }, Math.max(this.delay, DISABLE_OPEN_ON_OVER_DELAY));
        this.scheduled.push(item);
    }
    removeScheduled(item) {
        const scheduled = this.scheduled;
        for (let idx = 0; idx < scheduled.length; idx++) {
            if (scheduled[idx] === item) {
                scheduled.splice(idx, 1);
                return;
            }
        }
    }
    cancelActions(predicate) {
        const scheduled = this.scheduled;
        for (let idx = scheduled.length - 1; idx >= 0; idx--) {
            const item = scheduled[idx];
            const actions = item.actions;
            if (predicate) {
                for (let actionIdx = actions.length - 1; actionIdx >= 0; actionIdx--) {
                    if (predicate(actions[actionIdx])) {
                        actions.splice(actionIdx, 1);
                    }
                }
            }
            if (!predicate || actions.length === 0) {
                clearTimeout(item.id);
                scheduled.splice(idx, 1);
            }
        }
    }
}
HoverService.ɵfac = function HoverService_Factory(t) { return new (t || HoverService)(ɵngcc0.ɵɵinject(ActionsService), ɵngcc0.ɵɵinject(ItemsService)); };
HoverService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HoverService, factory: HoverService.ɵfac });
/** @nocollapse */
HoverService.ctorParameters = () => [
    { type: ActionsService },
    { type: ItemsService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HoverService, [{
        type: Injectable
    }], function () { return [{ type: ActionsService }, { type: ItemsService }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * @hidden
 */
const normalize = (settings) => settings && Object.assign({
    toggle: 'select'
}, settings);

/**
 * @hidden
 */
const NODE_INDEX = 'data-kendo-menu-index';

const DEFAULT_ID = 'kendo-matches-container';
const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const matches = (element, selector) => (element.matches || element.msMatchesSelector).call(element, selector);
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClass = (element, name) => {
    return toClassList(element.className).indexOf(name) >= 0;
};
/**
 * @hidden
 */
const matchesClasses = (classes) => {
    const list = toClassList(classes);
    return (element) => {
        const classList = toClassList(element.className);
        return Boolean(list.find(name => classList.indexOf(name) >= 0));
    };
};
/**
 * @hidden
 */
const nodeIndex = (node) => node.getAttribute(NODE_INDEX);
/**
 * @hidden
 */
const closestItem = (node, scope) => closestInScope(node, nodeIndex, scope);
/**
 * @hidden
 */
const closestList = (node) => {
    let list = closest(node, matchesClasses('k-menu-popup k-menu k-menu-group'));
    if (list && hasClass(list, 'k-menu-popup')) {
        list = list.querySelector('.k-menu-group');
    }
    return list;
};
/**
 * @hidden
 */
const inMenu = (node, itemsService) => {
    if (node === itemsService.lists[0].element.nativeElement) {
        return false;
    }
    const list = closestList(node);
    return list && itemsService.containsList(list);
};
/**
 * @hidden
 */
const findInContainer = (element, selector, container) => {
    const id = container.getAttribute('id');
    if (!id) {
        container.setAttribute('id', DEFAULT_ID);
    }
    const contextSelector = `#${id || DEFAULT_ID} ${selector}`;
    const match = closestInScope(element, node => matches(node, contextSelector), container);
    if (!id) {
        container.removeAttribute('id');
    }
    return match;
};

/**
 * @hidden
 */
class ContextMenuService {
    constructor() {
        this.keydown = new EventEmitter();
    }
    emit(name, args) {
        this.owner.emitMenuEvent(name, args);
    }
    hasObservers(name) {
        return this.owner && hasObservers(this.owner[name]);
    }
    leaveMenu(e) {
        return this.items ? !inMenu(e.target, this.items) : true;
    }
}
ContextMenuService.ɵfac = function ContextMenuService_Factory(t) { return new (t || ContextMenuService)(); };
ContextMenuService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuService, factory: ContextMenuService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Represents a template for the Menu items ([see example]({% slug templates_menu %})). To define a template
 * for an item, nest an `<ng-template>` tag with the `kendoMenuItemTemplate` directive inside a `<kendo-menu-item>`
 * component. To define a template for all Menu items, nest the template inside the `<kendo-menu>` component.
 *
 * The available fields in the template context are:
 * - `item`&mdash;The item data.
 * - `index`&mdash;The item index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemTemplate let-item="item" let-index="index">
 *                  <div style="padding: 10px;">
 *                      My Template for: {{ item.text }} at index: {{ index }}
 *                  </div>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
class ItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ItemTemplateDirective.ɵfac = function ItemTemplateDirective_Factory(t) { return new (t || ItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ItemTemplateDirective, selectors: [["", "kendoMenuItemTemplate", ""]] });
/** @nocollapse */
ItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template for the links of the Menu items ([see example]({% slug templates_menu %})). To define a template
 * for an item, nest an `<ng-template>` tag with the `kendoMenuItemLinkTemplate` directive inside a `<kendo-menu-item>`
 * component. To define a template for all Menu items, nest the template inside the `<kendo-menu>` component.
 *
 * The available fields in the template context are:
 * - `item`&mdash;The item data.
 * - `index`&mdash;The item index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemLinkTemplate let-item="item" let-index="index">
 *                  <span [kendoMenuItemLink]="index">
 *                      {{ item.text }}
 *                      <span *ngIf="item.items && item.items.length" [kendoMenuExpandArrow]="index"></span>
 *                  </span>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
class ItemLinkTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ItemLinkTemplateDirective.ɵfac = function ItemLinkTemplateDirective_Factory(t) { return new (t || ItemLinkTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ItemLinkTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ItemLinkTemplateDirective, selectors: [["", "kendoMenuItemLinkTemplate", ""]] });
/** @nocollapse */
ItemLinkTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemLinkTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemLinkTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template for the content of the Menu items ([see example]({% slug templates_menu %})). To define the template,
 * nest an `<ng-template>` tag with the `kendoMenuItemContentTemplate` directive inside a `<kendo-menu-item>` component.
 *
 * The available fields in the template context are:
 * - `item`&mdash;The item data.
 * - `index`&mdash;The item index.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemContentTemplate let-item="item" let-index="index">
 *                  <div style="padding: 10px;">
 *                      My Content Template for: {{ item.text }} at index: {{ index }}
 *                  </div>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
class ItemContentTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ItemContentTemplateDirective.ɵfac = function ItemContentTemplateDirective_Factory(t) { return new (t || ItemContentTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ItemContentTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ItemContentTemplateDirective, selectors: [["", "kendoMenuItemContentTemplate", ""]] });
/** @nocollapse */
ItemContentTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemContentTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemContentTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * A component that can be used to specify the Menu items
 * ([more information and examples]({% slug items_menu %})).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu>
 *          <kendo-menu-item text="item1">
 *              <kendo-menu-item text="item1.1" url="https://example.com">
 *              </kendo-menu-item>
 *              <kendo-menu-item text="item1.2" [disabled]="true">
 *              </kendo-menu-item>
 *          </kendo-menu-item>
 *          <kendo-menu-item text="item2">
 *              <ng-template kendoMenuItemContentTemplate let-item="item">
 *                  <div style="padding: 10px;">
 *                      My Content Template: {{ item.text }}
 *                  </div>
 *              </ng-template>
 *              <ng-template kendoMenuItemTemplate let-item="item">
 *                  <div style="padding: 10px;">
 *                      My Template: {{ item.text }}
 *                  </div>
 *              </ng-template>
 *          </kendo-menu-item>
 *          <kendo-menu-item text="item3">
 *              <ng-template kendoMenuItemLinkTemplate let-item="item" let-index="index">
 *                  <span [kendoMenuItemLink]="index">
 *                      {{ item.text }}
 *                      <span *ngIf="item.items && item.items.length" [kendoMenuExpandArrow]="index"></span>
 *                  </span>
 *              </ng-template>
 *          </kendo-menu-item>
 *        </kendo-menu>
 *    `
 * })
 *
 * class AppComponent {
 * }
 * ```
 */
class MenuItemComponent {
    /**
     * @hidden
     */
    get template() {
        if (this.itemTemplate && this.itemTemplate.length) {
            return this.itemTemplate.first.templateRef;
        }
    }
    /**
     * @hidden
     */
    get linkTemplate() {
        if (this.itemLinkTemplate && this.itemLinkTemplate.length) {
            return this.itemLinkTemplate.first.templateRef;
        }
    }
    /**
     * @hidden
     */
    get contentTemplate() {
        if (this.itemContentTemplate && this.itemContentTemplate.length) {
            return this.itemContentTemplate.first.templateRef;
        }
    }
    /**
     * @hidden
     */
    get items() {
        if (this.children.length) {
            return this.children.toArray().filter(c => c !== this);
        }
    }
}
MenuItemComponent.ɵfac = function MenuItemComponent_Factory(t) { return new (t || MenuItemComponent)(); };
MenuItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MenuItemComponent, selectors: [["kendo-menu-item"]], contentQueries: function MenuItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemLinkTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemContentTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemContentTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { text: "text", url: "url", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle", icon: "icon", data: "data", separator: "separator" }, decls: 0, vars: 0, template: function MenuItemComponent_Template(rf, ctx) { }, encapsulation: 2 });
MenuItemComponent.propDecorators = {
    text: [{ type: Input }],
    url: [{ type: Input }],
    disabled: [{ type: Input }],
    cssClass: [{ type: Input }],
    cssStyle: [{ type: Input }],
    icon: [{ type: Input }],
    data: [{ type: Input }],
    separator: [{ type: Input }],
    itemTemplate: [{ type: ContentChildren, args: [ItemTemplateDirective,] }],
    itemLinkTemplate: [{ type: ContentChildren, args: [ItemLinkTemplateDirective,] }],
    itemContentTemplate: [{ type: ContentChildren, args: [ItemContentTemplateDirective,] }],
    children: [{ type: ContentChildren, args: [MenuItemComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MenuItemComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-menu-item',
                template: ``
            }]
    }], null, { text: [{
            type: Input
        }], url: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }], icon: [{
            type: Input
        }], data: [{
            type: Input
        }], separator: [{
            type: Input
        }], itemTemplate: [{
            type: ContentChildren,
            args: [ItemTemplateDirective]
        }], itemLinkTemplate: [{
            type: ContentChildren,
            args: [ItemLinkTemplateDirective]
        }], itemContentTemplate: [{
            type: ContentChildren,
            args: [ItemContentTemplateDirective]
        }], children: [{
            type: ContentChildren,
            args: [MenuItemComponent]
        }] }); })();

/**
 * @hidden
 */
class MenuBase {
    constructor() {
        /**
         * Specifies if the Menu will be vertical ([see example]({% slug vertical_menu %})).
         */
        this.vertical = false;
        /**
         * Specifies that the root items can be opened only on click
         * ([see example]({% slug openclose_menu %}#toc-opening-on-click)).
         */
        this.openOnClick = false;
        /**
         * Specifies the delay in milliseconds before the Menu items are opened or closed on item hover
         * or leave ([see example]({% slug openclose_menu %}#toc-delay-on-hover)). Used to avoid the accidental
         * opening or closing of the items.
         */
        this.hoverDelay = 100;
        /**
         * Sets the Menu animation.
         */
        this.animate = true;
    }
    /**
     * @hidden
     */
    get rootItems() {
        return this.items || (this.children ? this.children.toArray() : []);
    }
}
MenuBase.ɵfac = function MenuBase_Factory(t) { return new (t || MenuBase)(); };
MenuBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MenuBase, contentQueries: function MenuBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ItemLinkTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemLinkTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { vertical: "vertical", openOnClick: "openOnClick", hoverDelay: "hoverDelay", animate: "animate", items: "items" } });
MenuBase.propDecorators = {
    items: [{ type: Input }],
    vertical: [{ type: Input }],
    openOnClick: [{ type: Input }],
    hoverDelay: [{ type: Input }],
    animate: [{ type: Input }],
    itemTemplate: [{ type: ContentChildren, args: [ItemTemplateDirective,] }],
    itemLinkTemplate: [{ type: ContentChildren, args: [ItemLinkTemplateDirective,] }],
    children: [{ type: ContentChildren, args: [MenuItemComponent,] }]
};


/**
 * Represents the [Kendo UI Menu component for Angular]({% slug overview_menu %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-menu [items]="items">
 *        </kendo-menu>
 *    `
 * })
 * class AppComponent {
 *    public items: any[] = [{ text: 'item1', items: [{ text: 'item1.1' }] }, { text: 'item2', disabled: true }];
 * }
 * ```
 */
class MenuComponent extends MenuBase {
    constructor(itemsService, hover, actions, navigation, localization, ngZone, renderer, contextService) {
        super();
        this.itemsService = itemsService;
        this.hover = hover;
        this.actions = actions;
        this.navigation = navigation;
        this.localization = localization;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.contextService = contextService;
        /**
         * Fires when a Menu item is selected ([see example]({% slug routing_menu %})).
         */
        this.select = new EventEmitter();
        /**
         * Fires when a Menu item is opened.
         */
        this.open = new EventEmitter();
        /**
         * Fires when a Menu item is closed.
         */
        this.close = new EventEmitter();
        this.actions.owner = this;
        if (contextService) {
            contextService.items = this.itemsService;
            this.contextKeyDownSubscription = contextService.keydown.subscribe(this.contextKeyDown.bind(this));
        }
    }
    /**
     * @hidden
     */
    get ariaOrientation() {
        if (this.vertical) {
            return 'vertical';
        }
    }
    /**
     * @hidden
     */
    get contextMenuClass() {
        return Boolean(this.contextService);
    }
    get direction() {
        return this.rtl;
    }
    get rtl() {
        return this.localization.rtl;
    }
    /**
     * Opens or closes the specified Menu items.
     *
     * @param open - A Boolean value which indicates if the items will be opened or closed.
     * @param indices - One or more values which represent the hierarchical indices of the items that will be opened or closed.
     */
    toggle(open, ...indices) {
        for (let idx = 0; idx < indices.length; idx++) {
            const item = this.itemsService.get(indices[idx]);
            if (item && !item.disabled) {
                if (open) {
                    item.open();
                }
                else {
                    item.close();
                }
            }
        }
    }
    /**
     * @hidden
     */
    focus(index) {
        this.navigation.focusIndex(index);
    }
    ngOnChanges(changes) {
        this.navigation.vertical = this.vertical;
        this.hover.delay = this.hoverDelay;
        if (changes.openOnClick) {
            const openOnClick = this.openOnClick = normalize(this.openOnClick);
            this.hover.openOnOver = !openOnClick;
            if (openOnClick && openOnClick.toggle === 'click') {
                this.attachCloseClick();
            }
            else {
                this.unsubscribeClick();
            }
        }
    }
    ngAfterViewChecked() {
        this.navigation.updateActive();
    }
    ngOnDestroy() {
        this.unsubscribeClick();
        if (this.contextService) {
            this.contextService.items = null;
            this.contextKeyDownSubscription.unsubscribe();
        }
    }
    attachCloseClick() {
        if (!this.closeClickSubscription && isDocumentAvailable()) {
            this.ngZone.runOutsideAngular(() => {
                this.closeClickSubscription = this.renderer.listen('document', 'click', (e) => {
                    if (!inMenu(e.target, this.itemsService)) {
                        this.hover.openOnOver = false;
                        this.actions.closeAll();
                        this.actions.execute();
                    }
                });
            });
        }
    }
    unsubscribeClick() {
        if (this.closeClickSubscription) {
            this.closeClickSubscription();
        }
    }
    contextKeyDown(e) {
        if (!this.itemsService.hasItems) {
            return;
        }
        const keyCode = e.keyCode;
        const rtl = this.localization.rtl;
        const first = keyCode === Keys.ArrowDown || keyCode === Keys.ArrowRight;
        const last = keyCode === Keys.ArrowUp || keyCode === Keys.ArrowLeft;
        let index;
        if ((first && !rtl) || (last && rtl)) {
            index = 'first';
        }
        else if ((first && rtl) || (last && !rtl)) {
            index = 'last';
        }
        if (index) {
            e.preventDefault();
            this.focus(index);
        }
    }
}
MenuComponent.ɵfac = function MenuComponent_Factory(t) { return new (t || MenuComponent)(ɵngcc0.ɵɵdirectiveInject(ItemsService), ɵngcc0.ɵɵdirectiveInject(HoverService), ɵngcc0.ɵɵdirectiveInject(ActionsService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ContextMenuService, 8)); };
MenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MenuComponent, selectors: [["kendo-menu"]], hostVars: 2, hostBindings: function MenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-rtl", ctx.direction);
    } }, inputs: { menuItemTemplate: "menuItemTemplate", menuItemLinkTemplate: "menuItemLinkTemplate" }, outputs: { select: "select", open: "open", close: "close" }, exportAs: ["kendoMenu"], features: [ɵngcc0.ɵɵProvidersFeature([
            ItemsService,
            ActionsService,
            NavigationService,
            HoverService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.menu'
            },
            {
                provide: MenuBase,
                useExisting: forwardRef(() => MenuComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 15, consts: [["role", "menubar", "kendoMenuList", "", 1, "k-widget", "k-reset", "k-header", "k-menu", 3, "items", "level", "vertical", "rtl", "animate", "openOnClick", "itemTemplate", "itemLinkTemplate"]], template: function MenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "ul", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-menu-horizontal", !ctx.vertical)("k-menu-vertical", ctx.vertical)("k-context-menu", ctx.contextMenuClass);
        ɵngcc0.ɵɵproperty("items", ctx.rootItems)("level", 0)("vertical", ctx.vertical)("rtl", ctx.rtl)("animate", ctx.animate)("openOnClick", ctx.openOnClick)("itemTemplate", (ctx.itemTemplate.first == null ? null : ctx.itemTemplate.first.templateRef) || ctx.menuItemTemplate)("itemLinkTemplate", (ctx.itemLinkTemplate.first == null ? null : ctx.itemLinkTemplate.first.templateRef) || ctx.menuItemLinkTemplate);
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.ariaOrientation);
    } }, directives: function () { return [ListComponent]; }, encapsulation: 2 });
/** @nocollapse */
MenuComponent.ctorParameters = () => [
    { type: ItemsService },
    { type: HoverService },
    { type: ActionsService },
    { type: NavigationService },
    { type: LocalizationService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ContextMenuService, decorators: [{ type: Optional }] }
];
MenuComponent.propDecorators = {
    menuItemTemplate: [{ type: Input }],
    menuItemLinkTemplate: [{ type: Input }],
    select: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    direction: [{ type: HostBinding, args: ['class.k-rtl',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MenuComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoMenu',
                providers: [
                    ItemsService,
                    ActionsService,
                    NavigationService,
                    HoverService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.menu'
                    },
                    {
                        provide: MenuBase,
                        useExisting: forwardRef(() => MenuComponent)
                    }
                ],
                selector: 'kendo-menu',
                template: `
        <ul role="menubar"
            [attr.aria-orientation]="ariaOrientation"
            kendoMenuList [items]="rootItems" [level]="0" class="k-widget k-reset k-header k-menu"
            [vertical]="vertical" [rtl]="rtl" [animate]="animate" [openOnClick]="openOnClick"
            [itemTemplate]="itemTemplate.first?.templateRef || menuItemTemplate"
            [itemLinkTemplate]="itemLinkTemplate.first?.templateRef || menuItemLinkTemplate"
            [class.k-menu-horizontal]="!vertical"
            [class.k-menu-vertical]="vertical"
            [class.k-context-menu]="contextMenuClass">
        </ul>
    `
            }]
    }], function () { return [{ type: ItemsService }, { type: HoverService }, { type: ActionsService }, { type: NavigationService }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ContextMenuService, decorators: [{
                type: Optional
            }] }]; }, { select: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['class.k-rtl']
        }], menuItemTemplate: [{
            type: Input
        }], menuItemLinkTemplate: [{
            type: Input
        }] }); })();

/* tslint:disable:component-selector */
/**
 * @hidden
 */
class ListComponent {
    constructor(itemsService, hover, actions, navigation, renderer, ngZone, element) {
        this.itemsService = itemsService;
        this.hover = hover;
        this.actions = actions;
        this.navigation = navigation;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.element = element;
        this.animate = true;
    }
    hierarchyIndex(index) {
        return this.itemsService.itemIndex(this.index, index);
    }
    ngOnInit() {
        this.itemsService.addList(this);
        this.initDomEvents();
    }
    ngOnDestroy() {
        this.itemsService.removeList(this);
        if (this.domSubscriptions) {
            this.domSubscriptions();
        }
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const element = this.element.nativeElement;
            const container = this.level > 0 ? closest(element, (node) => hasClass(node, 'k-popup')) : element;
            const overSubscription = this.renderer.listen(element, 'mouseover', (e) => {
                if (e.target === element && this.level === 0) {
                    this.onLeave();
                }
                else {
                    const item = this.nodeItem(e.target) || this.itemsService.get(this.index);
                    if (item && !(this.openOnClick && this.openOnClick.toggle === 'click' && item.level === 0 && !item.hasContent)) {
                        this.hover.over(item);
                    }
                }
            });
            const leaveSubscription = this.renderer.listen(container, 'mouseleave', (e) => {
                if (this.leavesMenu(e)) {
                    this.onLeave();
                }
            });
            const keydownSubscription = this.renderer.listen(element, 'keydown', (e) => {
                if (hasClass(e.target, 'k-menu-item')) {
                    this.navigation.keydown(e);
                }
            });
            const blurSubscription = this.renderer.listen(element, 'focusout', (e) => {
                if (this.leavesMenu(e)) {
                    this.navigation.focusLeave();
                }
            });
            const clickSubscription = this.renderer.listen(element, 'click', this.clickHandler.bind(this));
            this.domSubscriptions = () => {
                overSubscription();
                leaveSubscription();
                keydownSubscription();
                blurSubscription();
                clickSubscription();
            };
        });
    }
    leavesMenu(e) {
        if (!e.relatedTarget) {
            return true;
        }
        return !inMenu(e.relatedTarget, this.itemsService);
    }
    onLeave() {
        const openOnClick = this.openOnClick;
        if (!openOnClick || openOnClick.toggle !== 'click') {
            this.hover.leave(openOnClick && openOnClick.toggle === 'leave');
        }
    }
    nodeItem(target) {
        const node = closestItem(target, this.element.nativeElement);
        if (node) {
            const index = nodeIndex(node);
            return this.itemsService.get(index);
        }
    }
    clickHandler(e) {
        if (isFocusable(e.target) && !hasClass(e.target, 'k-menu-item')) {
            return;
        }
        const item = this.nodeItem(e.target);
        if (!item || item.isContent || item.navigating) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        this.actions.select(item, e, () => {
            e.preventDefault();
        });
        this.navigation.focus(item);
        if (item.level > 0 && !item.hasContent) {
            this.actions.closeToRoot(item);
        }
        if (this.openOnClick) {
            const hover = this.hover;
            if (item.opened) {
                if (item.level === 0) {
                    hover.openOnOver = false;
                    this.actions.close(item);
                }
            }
            else if (item.hasContent) {
                hover.openOnOver = true;
                this.actions.closeOthers(item);
                this.actions.open(item);
            }
            else {
                hover.openOnOver = false;
                if (item.level === 0 && this.openOnClick.toggle === 'click') {
                    this.hover.closeCurrent();
                }
            }
        }
        this.actions.execute();
    }
}
ListComponent.ɵfac = function ListComponent_Factory(t) { return new (t || ListComponent)(ɵngcc0.ɵɵdirectiveInject(ItemsService), ɵngcc0.ɵɵdirectiveInject(HoverService), ɵngcc0.ɵɵdirectiveInject(ActionsService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ListComponent, selectors: [["", "kendoMenuList", ""]], inputs: { animate: "animate", items: "items", level: "level", index: "index", vertical: "vertical", rtl: "rtl", openOnClick: "openOnClick", itemTemplate: "itemTemplate", itemLinkTemplate: "itemLinkTemplate" }, attrs: _c0, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoMenuItem", "", "role", "menuitem", "class", "k-item k-menu-item", 3, "item", "level", "vertical", "animate", "rtl", "itemTemplate", "itemLinkTemplate", "openOnClick", "index", "siblingIndex", "ngClass", "ngStyle", "k-first", "k-last", "k-state-disabled", 4, "ngIf"], ["class", "k-separator k-item", "role", "separator", 3, "ngClass", "ngStyle", 4, "ngIf"], ["kendoMenuItem", "", "role", "menuitem", 1, "k-item", "k-menu-item", 3, "item", "level", "vertical", "animate", "rtl", "itemTemplate", "itemLinkTemplate", "openOnClick", "index", "siblingIndex", "ngClass", "ngStyle"], ["role", "separator", 1, "k-separator", "k-item", 3, "ngClass", "ngStyle"]], template: function ListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ListComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: function () { return [ɵngcc2.NgForOf, ɵngcc2.NgIf, ItemComponent, ɵngcc2.NgClass, ɵngcc2.NgStyle]; }, encapsulation: 2 });
/** @nocollapse */
ListComponent.ctorParameters = () => [
    { type: ItemsService },
    { type: HoverService },
    { type: ActionsService },
    { type: NavigationService },
    { type: Renderer2 },
    { type: NgZone },
    { type: ElementRef }
];
ListComponent.propDecorators = {
    items: [{ type: Input }],
    level: [{ type: Input }],
    index: [{ type: Input }],
    animate: [{ type: Input }],
    vertical: [{ type: Input }],
    rtl: [{ type: Input }],
    openOnClick: [{ type: Input }],
    itemTemplate: [{ type: Input }],
    itemLinkTemplate: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoMenuList]',
                template: `
        <ng-container *ngFor="let item of items; let idx = index">
            <li *ngIf="!item.separator" kendoMenuItem
                [item]="item" [level]="level" [vertical]="vertical" [animate]="animate" [rtl]="rtl"
                [itemTemplate]="itemTemplate" [itemLinkTemplate]="itemLinkTemplate" [openOnClick]="openOnClick"
                [index]="hierarchyIndex(idx)" [siblingIndex]="idx" [attr.${NODE_INDEX}]="hierarchyIndex(idx)"
                [ngClass]="item.cssClass" [ngStyle]="item.cssStyle"
                role="menuitem"
                class="k-item k-menu-item"
                [class.k-first]="idx === 0" [class.k-last]="idx === items.length - 1"
                [class.k-state-disabled]="item.disabled"></li>
            <li *ngIf="item.separator" class="k-separator k-item"
                role="separator" [ngClass]="item.cssClass" [ngStyle]="item.cssStyle">
                &nbsp;
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ItemsService }, { type: HoverService }, { type: ActionsService }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }]; }, { animate: [{
            type: Input
        }], items: [{
            type: Input
        }], level: [{
            type: Input
        }], index: [{
            type: Input
        }], vertical: [{
            type: Input
        }], rtl: [{
            type: Input
        }], openOnClick: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], itemLinkTemplate: [{
            type: Input
        }] }); })();

const POPUP_ALIGN = {
    vertical: 'top',
    horizontal: 'left'
};
const POPUP_ALIGN_RTL = {
    vertical: 'top',
    horizontal: 'right'
};
const VERTICAL_COLLISION = {
    vertical: 'flip',
    horizontal: 'fit'
};
const HORIZONTAL_COLLISION = {
    vertical: 'fit',
    horizontal: 'flip'
};
/**
 * @hidden
 */
const POPUP_SETTINGS_RTL = {
    vertical: {
        anchor: {
            vertical: 'bottom',
            horizontal: 'right'
        },
        popup: POPUP_ALIGN_RTL,
        collision: VERTICAL_COLLISION,
        animate: 'down'
    },
    horizontal: {
        anchor: {
            vertical: 'top',
            horizontal: 'left'
        },
        popup: POPUP_ALIGN_RTL,
        collision: HORIZONTAL_COLLISION,
        animate: 'left'
    }
};
/**
 * @hidden
 */
const POPUP_SETTINGS = {
    vertical: {
        anchor: {
            vertical: 'bottom',
            horizontal: 'left'
        },
        popup: POPUP_ALIGN,
        collision: VERTICAL_COLLISION,
        animate: 'down'
    },
    horizontal: {
        anchor: {
            vertical: 'top',
            horizontal: 'right'
        },
        popup: POPUP_ALIGN,
        collision: HORIZONTAL_COLLISION,
        animate: 'right'
    }
};

/**
 * @hidden
 */
const defined = (value) => typeof value !== 'undefined';
/**
 * @hidden
 */
const bodyFactory = () => {
    if (isDocumentAvailable()) {
        return new ElementRef(document.body);
    }
};

const ɵ0$3 = bodyFactory;
/* tslint:disable:component-selector */
/**
 * @hidden
 */
class ItemComponent {
    constructor(itemsService, navigation, changeDetector, renderer, popupService, element) {
        this.itemsService = itemsService;
        this.navigation = navigation;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.popupService = popupService;
        this.element = element;
        this.animate = true;
        this.openOnClick = false;
        this.opened = false;
        this.navigating = false;
        this.destroyed = false;
    }
    set index(index) {
        if (this._index && this._index !== index) {
            this.itemsService.remove(this);
            this._index = index;
            this.itemsService.add(this);
        }
        else {
            this._index = index;
        }
        this.childId = this.itemsService.childId(index);
    }
    get index() {
        return this._index;
    }
    get disabled() {
        return this.item.disabled;
    }
    get hasPopup() {
        return this.hasContent ? true : null;
    }
    get expanded() {
        return this.hasContent ? this.opened : null;
    }
    get label() {
        return this.item.text ? this.item.text : null;
    }
    get activeId() {
        return this.index === this.navigation.activeIndex ? '0' : '-1';
    }
    get popupSettings() {
        const settings = this.rtl ? POPUP_SETTINGS_RTL : POPUP_SETTINGS;
        return this.horizontal ? settings.horizontal : settings.vertical;
    }
    get horizontal() {
        return this.vertical || this.level > 0;
    }
    get hasLink() {
        return Boolean(this.item.url);
    }
    get linkTemplate() {
        return this.item.linkTemplate || this.itemLinkTemplate;
    }
    get hasContent() {
        const items = this.item.items;
        return items && items.length || this.item.contentTemplate;
    }
    get isContent() {
        return Boolean(this.item.content);
    }
    get iconClass() {
        return `k-i-${this.item.icon}`;
    }
    get children() {
        const item = this.item;
        if (item.contentTemplate) {
            if (!this.contentItems) {
                this.contentItems = [{
                        content: item.contentTemplate,
                        owner: item,
                        ownerIndex: this.index
                    }];
            }
            return this.contentItems;
        }
        return item.items;
    }
    get template() {
        return this.item.template || this.itemTemplate;
    }
    hasContentTemplates() {
        const item = this.item;
        return this.itemTemplate || item.contentTemplate || this.itemLinkTemplate ||
            (item.items && item.items.find(current => current.template || current.linkTemplate));
    }
    ngOnInit() {
        this.itemsService.add(this);
    }
    ngOnDestroy() {
        this.itemsService.remove(this);
        this.destroyed = true;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    focus() {
        this.element.nativeElement.focus();
    }
    toggleActive(isActive) {
        if (isActive) {
            this.setAttribute('tabindex', '0');
        }
        else {
            this.setAttribute('tabindex', '-1');
        }
    }
    open() {
        if (!this.destroyed && this.hasContent && !this.opened) {
            const popupSettings = this.popupSettings;
            const animate = this.animate ? Object.assign({}, this.animate, {
                direction: popupSettings.animate
            }) : false;
            this.opened = true;
            this.popupRef = this.popupService.open({
                popupAlign: popupSettings.popup,
                anchorAlign: popupSettings.anchor,
                collision: popupSettings.collision,
                anchor: this.element,
                positionMode: 'absolute',
                content: this.popupTemplate,
                popupClass: {
                    'k-rtl': this.rtl,
                    'k-menu-popup': true
                },
                animate: animate
            });
            this.setAttribute('aria-expanded', 'true');
            this.setAttribute('aria-owns', this.childId);
            this.changeDetector.detectChanges();
        }
    }
    close() {
        if (!this.destroyed && this.opened) {
            this.opened = false;
            if (this.popupRef) {
                this.popupRef.close();
                this.popupRef = null;
            }
            this.changeDetector.detectChanges();
            this.setAttribute('aria-expanded', 'false');
            this.renderer.removeAttribute(this.element.nativeElement, 'aria-owns');
        }
    }
    navigate() {
        let link;
        if (this.linkTemplate) {
            link = this.element.nativeElement.querySelector('a.k-menu-link');
        }
        else if (this.hasLink) {
            link = this.link.nativeElement;
        }
        if (link) {
            this.navigating = true;
            link.click();
            this.navigating = false;
        }
    }
    setAttribute(name, value) {
        this.renderer.setAttribute(this.element.nativeElement, name, value);
    }
}
ItemComponent.ɵfac = function ItemComponent_Factory(t) { return new (t || ItemComponent)(ɵngcc0.ɵɵdirectiveInject(ItemsService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ItemComponent, selectors: [["", "kendoMenuItem", ""]], viewQuery: function ItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.link = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
    } }, hostVars: 5, hostBindings: function ItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("aria-haspopup", ctx.hasPopup)("aria-expanded", ctx.expanded)("aria-label", ctx.label)("tabindex", ctx.activeId);
    } }, inputs: { animate: "animate", openOnClick: "openOnClick", index: "index", item: "item", level: "level", siblingIndex: "siblingIndex", vertical: "vertical", rtl: "rtl", itemTemplate: "itemTemplate", itemLinkTemplate: "itemLinkTemplate" }, features: [ɵngcc0.ɵɵProvidersFeature([PopupService, {
                provide: POPUP_CONTAINER,
                useFactory: ɵ0$3
            }])], attrs: _c3, decls: 8, vars: 4, consts: [["class", "k-link k-menu-link", "role", "presentation", 3, "k-state-active", 4, "ngIf"], ["class", "k-link k-menu-link", "tabindex", "-1", "role", "presentation", 3, "k-state-active", 4, "ngIf"], [4, "ngIf"], ["class", "k-content", "role", "presentation", 4, "ngIf"], ["popupTemplate", ""], ["itemcontent", ""], ["role", "presentation", 1, "k-link", "k-menu-link"], ["link", ""], [3, "ngTemplateOutlet"], ["tabindex", "-1", "role", "presentation", 1, "k-link", "k-menu-link"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "presentation", 1, "k-content"], ["kendoMenuList", "", "role", "menu", 1, "k-group", "k-menu-group", "k-reset", 3, "animate", "rtl", "vertical", "openOnClick", "items", "level", "index", "itemTemplate", "itemLinkTemplate"], ["class", "k-icon", "role", "presentation", 3, "ngClass", 4, "ngIf"], ["class", "k-icon k-menu-expand-arrow", "role", "presentation", 3, "k-i-arrow-60-down", "k-i-arrow-60-right", "k-i-arrow-60-left", 4, "ngIf"], ["role", "presentation", 1, "k-icon", 3, "ngClass"], ["role", "presentation", 1, "k-icon", "k-menu-expand-arrow"]], template: function ItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ItemComponent_span_0_Template, 3, 3, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ItemComponent_a_1_Template, 3, 4, "a", 1);
        ɵngcc0.ɵɵtemplate(2, ItemComponent_2_Template, 1, 5, undefined, 2);
        ɵngcc0.ɵɵtemplate(3, ItemComponent_div_3_Template, 2, 5, "div", 3);
        ɵngcc0.ɵɵtemplate(4, ItemComponent_ng_template_4_Template, 1, 10, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, ItemComponent_ng_template_6_Template, 4, 4, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasLink && !ctx.item.content && !ctx.linkTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.item.url && !ctx.linkTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.linkTemplate && !ctx.item.content);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.item.content);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ListComponent, ɵngcc2.NgClass], encapsulation: 2 });
/** @nocollapse */
ItemComponent.ctorParameters = () => [
    { type: ItemsService },
    { type: NavigationService },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: PopupService },
    { type: ElementRef }
];
ItemComponent.propDecorators = {
    item: [{ type: Input }],
    level: [{ type: Input }],
    index: [{ type: Input }],
    siblingIndex: [{ type: Input }],
    animate: [{ type: Input }],
    vertical: [{ type: Input }],
    rtl: [{ type: Input }],
    openOnClick: [{ type: Input }],
    itemTemplate: [{ type: Input }],
    itemLinkTemplate: [{ type: Input }],
    link: [{ type: ViewChild, args: ['link',] }],
    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
    disabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    hasPopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    label: [{ type: HostBinding, args: ['attr.aria-label',] }],
    activeId: [{ type: HostBinding, args: ['attr.tabindex',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemComponent, [{
        type: Component,
        args: [{
                providers: [PopupService, {
                        provide: POPUP_CONTAINER,
                        useFactory: ɵ0$3
                    }],
                selector: '[kendoMenuItem]',
                template: `
    <span *ngIf="!hasLink && !item.content && !linkTemplate" class="k-link k-menu-link" #link
        [class.k-state-active]="opened" role="presentation">
        <ng-template [ngTemplateOutlet]="itemcontent">
        </ng-template>
    </span>
    <a *ngIf="item.url && !linkTemplate" class="k-link k-menu-link" #link [attr.href]="item.url"
        [class.k-state-active]="opened" tabindex="-1" role="presentation">
        <ng-template [ngTemplateOutlet]="itemcontent">
        </ng-template>
    </a>
    <ng-template *ngIf="linkTemplate && !item.content" [ngTemplateOutlet]="linkTemplate"
        [ngTemplateOutletContext]="{ item: item, index: index }">
    </ng-template>

    <div class="k-content" *ngIf="item.content" role="presentation">
        <ng-template [ngTemplateOutlet]="item.content" [ngTemplateOutletContext]="{ item: item.owner, index: item.ownerIndex }">
        </ng-template>
    </div>

    <ng-template #popupTemplate>
        <ul kendoMenuList
            [attr.id]="childId"
            [animate]="animate"
            [rtl]="rtl"
            [vertical]="vertical"
            [openOnClick]="openOnClick"
            [items]="children"
            [level]="level + 1"
            [index]="index"
            [itemTemplate]="itemTemplate"
            [itemLinkTemplate]="itemLinkTemplate"
            role="menu"
            class="k-group k-menu-group k-reset">
        </ul>
    </ng-template>

    <ng-template #itemcontent>
        <span *ngIf="item.icon" class="k-icon" [ngClass]="iconClass" role="presentation"></span>
        <ng-container *ngIf="!template">
            {{ item.text }}
        </ng-container>
        <ng-template *ngIf="template" [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ item: item, index: index }">
        </ng-template>
        <span class="k-icon k-menu-expand-arrow" *ngIf="hasContent"
            role="presentation"
            [class.k-i-arrow-60-down]="!horizontal"
            [class.k-i-arrow-60-right]="horizontal && !rtl"
            [class.k-i-arrow-60-left]="horizontal && rtl">
        </span>
    </ng-template>
  `
            }]
    }], function () { return [{ type: ItemsService }, { type: NavigationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc3.PopupService }, { type: ɵngcc0.ElementRef }]; }, { animate: [{
            type: Input
        }], openOnClick: [{
            type: Input
        }], index: [{
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], hasPopup: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], expanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], label: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], activeId: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], item: [{
            type: Input
        }], level: [{
            type: Input
        }], siblingIndex: [{
            type: Input
        }], vertical: [{
            type: Input
        }], rtl: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], itemLinkTemplate: [{
            type: Input
        }], link: [{
            type: ViewChild,
            args: ['link']
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate']
        }] }); })();

/**
 * Represents a directive that can be used in the [`linkTemplate`]({% slug api_menu_itemlinktemplatedirective %})
 * of the items to apply the default styling and behavior.
 */
class LinkDirective {
    constructor(itemsService) {
        this.itemsService = itemsService;
        this.hostClasses = true;
        this.role = 'presentation';
        this.tabindex = '-1';
    }
    get activeClass() {
        return this.item.opened;
    }
    ngOnInit() {
        if (isDevMode() && !this.index) {
            throw new Error('The kendoMenuItemLink directive requires the item index to be set.');
        }
        this.item = this.itemsService.get(this.index) || {};
    }
}
LinkDirective.ɵfac = function LinkDirective_Factory(t) { return new (t || LinkDirective)(ɵngcc0.ɵɵdirectiveInject(ItemsService)); };
LinkDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LinkDirective, selectors: [["", "kendoMenuItemLink", ""]], hostVars: 8, hostBindings: function LinkDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("k-link", ctx.hostClasses)("k-menu-link", ctx.hostClasses)("k-state-active", ctx.activeClass);
    } }, inputs: { index: ["kendoMenuItemLink", "index"] } });
/** @nocollapse */
LinkDirective.ctorParameters = () => [
    { type: ItemsService }
];
LinkDirective.propDecorators = {
    index: [{ type: Input, args: ['kendoMenuItemLink',] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-link',] }, { type: HostBinding, args: ['class.k-menu-link',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    activeClass: [{ type: HostBinding, args: ['class.k-state-active',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinkDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuItemLink]'
            }]
    }], function () { return [{ type: ItemsService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-link']
        }, {
            type: HostBinding,
            args: ['class.k-menu-link']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], activeClass: [{
            type: HostBinding,
            args: ['class.k-state-active']
        }], index: [{
            type: Input,
            args: ['kendoMenuItemLink']
        }] }); })();

/**
 * Represents a directive that can be used in the [`linkTemplate`]({% slug api_menu_itemlinktemplatedirective %})
 * of the items to render the default expand arrow.
 */
class ExpandArrowDirective {
    constructor(itemsService) {
        this.itemsService = itemsService;
        this.hostClasses = true;
        this.role = 'presentation';
    }
    get arrowDown() {
        return !this.item.horizontal;
    }
    get arrowRight() {
        return this.item.horizontal && !this.item.rtl;
    }
    get arrowLeft() {
        return this.item.horizontal && this.item.rtl;
    }
    ngOnInit() {
        if (isDevMode() && !this.index) {
            throw new Error('The kendoMenuExpandArrow directive requires the item index to be set.');
        }
        this.item = this.itemsService.get(this.index) || {};
    }
}
ExpandArrowDirective.ɵfac = function ExpandArrowDirective_Factory(t) { return new (t || ExpandArrowDirective)(ɵngcc0.ɵɵdirectiveInject(ItemsService)); };
ExpandArrowDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ExpandArrowDirective, selectors: [["", "kendoMenuExpandArrow", ""]], hostVars: 11, hostBindings: function ExpandArrowDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("k-icon", ctx.hostClasses)("k-menu-expand-arrow", ctx.hostClasses)("k-i-arrow-60-down", ctx.arrowDown)("k-i-arrow-60-right", ctx.arrowRight)("k-i-arrow-60-left", ctx.arrowLeft);
    } }, inputs: { index: ["kendoMenuExpandArrow", "index"] } });
/** @nocollapse */
ExpandArrowDirective.ctorParameters = () => [
    { type: ItemsService }
];
ExpandArrowDirective.propDecorators = {
    index: [{ type: Input, args: ['kendoMenuExpandArrow',] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-icon',] }, { type: HostBinding, args: ['class.k-menu-expand-arrow',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    arrowDown: [{ type: HostBinding, args: ['class.k-i-arrow-60-down',] }],
    arrowRight: [{ type: HostBinding, args: ['class.k-i-arrow-60-right',] }],
    arrowLeft: [{ type: HostBinding, args: ['class.k-i-arrow-60-left',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandArrowDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoMenuExpandArrow]'
            }]
    }], function () { return [{ type: ItemsService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-icon']
        }, {
            type: HostBinding,
            args: ['class.k-menu-expand-arrow']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], arrowDown: [{
            type: HostBinding,
            args: ['class.k-i-arrow-60-down']
        }], arrowRight: [{
            type: HostBinding,
            args: ['class.k-i-arrow-60-right']
        }], arrowLeft: [{
            type: HostBinding,
            args: ['class.k-i-arrow-60-left']
        }], index: [{
            type: Input,
            args: ['kendoMenuExpandArrow']
        }] }); })();

/**
 * Arguments for the `select` event of the Menu.
 */
class MenuSelectEvent extends MenuEvent {
}

const ITEM_FIELDS = ['textField', 'urlField', 'iconField', 'disabledField', 'cssClassField', 'cssStyleField', 'separatorField'];
/**
 * @hidden
 */
class BindingDirectiveBase {
    constructor(menu) {
        this.menu = menu;
    }
    ngOnChanges() {
        this.rebind();
    }
    /**
     *  Rebinds the Menu items.
     */
    rebind() {
        const fields = this.fields = [];
        for (let idx = 0; idx < ITEM_FIELDS.length; idx++) {
            const inputName = ITEM_FIELDS[idx];
            const inputValue = this[inputName];
            if (inputValue) {
                fields.push({ target: inputName.replace('Field', ''), source: inputValue });
            }
        }
        this.menu.items = this.data ? this.mapItems(this.data) : [];
    }
}
BindingDirectiveBase.ɵfac = function BindingDirectiveBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BindingDirectiveBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BindingDirectiveBase, features: [ɵngcc0.ɵɵNgOnChangesFeature] });


const FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
const getterCache = {};
// tslint:disable-next-line:no-string-literal
getterCache['undefined'] = (obj) => obj;
/**
 * @hidden
 */
const getter = (field) => {
    if (getterCache[field]) {
        return getterCache[field];
    }
    const fields = [];
    field.replace(FIELD_REGEX, (_match, index, indexAccessor, name) => {
        fields.push(index !== undefined ? index : (indexAccessor || name));
    });
    getterCache[field] = (obj) => {
        let result = obj;
        for (let idx = 0; idx < fields.length && result; idx++) {
            result = result[fields[idx]];
        }
        return result;
    };
    return getterCache[field];
};
/**
 * @hidden
 */
const last = (arr) => arr[arr.length - 1];

const getField = (field, level) => Array.isArray(field) ? field[level] || last(field) : field;
/* tslint:disable:no-input-rename */
/**
 * A directive that converts the provided hierarchical data to [MenuItems]({% slug api_menu_menuitem %}) and binds them to the Menu.
 */
class HierarchyBindingDirective extends BindingDirectiveBase {
    constructor(menu) {
        super(menu);
    }
    mapItems(items, level = 0) {
        return items.map((item) => {
            const menuItem = this.createItem(item, level);
            const children = this.getChildren(item, level);
            if (children) {
                menuItem.items = this.mapItems(children, level + 1);
            }
            return menuItem;
        });
    }
    createItem(item, level) {
        const result = { data: item };
        const fields = this.fields;
        for (let idx = 0; idx < fields.length; idx++) {
            const { target, source } = fields[idx];
            result[target] = getter(getField(source, level))(item);
        }
        return result;
    }
    getChildren(item, level) {
        if (this.childrenField) {
            const field = getField(this.childrenField, level);
            return item[field];
        }
    }
}
HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) { return new (t || HierarchyBindingDirective)(ɵngcc0.ɵɵdirectiveInject(MenuBase)); };
HierarchyBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HierarchyBindingDirective, selectors: [["", "kendoMenuHierarchyBinding", ""]], inputs: { data: ["kendoMenuHierarchyBinding", "data"], textField: "textField", urlField: "urlField", iconField: "iconField", disabledField: "disabledField", cssClassField: "cssClassField", cssStyleField: "cssStyleField", separatorField: "separatorField", childrenField: "childrenField" }, exportAs: ["kendoMenuHierarchyBinding"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
HierarchyBindingDirective.ctorParameters = () => [
    { type: MenuBase }
];
HierarchyBindingDirective.propDecorators = {
    data: [{ type: Input, args: ["kendoMenuHierarchyBinding",] }],
    textField: [{ type: Input }],
    urlField: [{ type: Input }],
    iconField: [{ type: Input }],
    disabledField: [{ type: Input }],
    cssClassField: [{ type: Input }],
    cssStyleField: [{ type: Input }],
    separatorField: [{ type: Input }],
    childrenField: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HierarchyBindingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoMenuHierarchyBinding',
                selector: '[kendoMenuHierarchyBinding]'
            }]
    }], function () { return [{ type: MenuBase }]; }, { data: [{
            type: Input,
            args: ["kendoMenuHierarchyBinding"]
        }], textField: [{
            type: Input
        }], urlField: [{
            type: Input
        }], iconField: [{
            type: Input
        }], disabledField: [{
            type: Input
        }], cssClassField: [{
            type: Input
        }], cssStyleField: [{
            type: Input
        }], separatorField: [{
            type: Input
        }], childrenField: [{
            type: Input
        }] }); })();

/* tslint:disable:no-input-rename */
/**
 * A directive that converts the provided flat data to [MenuItems]({% slug api_menu_menuitem %}) and binds them to the Menu.
 */
class FlatBindingDirective extends BindingDirectiveBase {
    constructor(menu) {
        super(menu);
    }
    mapItems(items) {
        if (!this.idField || !this.parentIdField) {
            return items.map(item => this.createItem(item));
        }
        const result = [];
        const map = {};
        for (let idx = 0; idx < items.length; idx++) {
            const item = items[idx];
            const menuItem = this.createItem(item);
            const id = getter(this.idField)(item);
            const parentId = getter(this.parentIdField)(item);
            if (parentId === null || parentId === undefined) {
                result.push(menuItem);
            }
            else {
                const parent = map[parentId] = map[parentId] || {};
                parent.items = parent.items || [];
                parent.items.push(menuItem);
            }
            if (map[id]) {
                menuItem.items = map[id].items;
            }
            map[id] = menuItem;
        }
        return result;
    }
    createItem(dataItem) {
        const result = { data: dataItem };
        const fields = this.fields;
        for (let idx = 0; idx < fields.length; idx++) {
            const { source, target } = fields[idx];
            result[target] = getter(source)(dataItem);
        }
        return result;
    }
}
FlatBindingDirective.ɵfac = function FlatBindingDirective_Factory(t) { return new (t || FlatBindingDirective)(ɵngcc0.ɵɵdirectiveInject(MenuBase)); };
FlatBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FlatBindingDirective, selectors: [["", "kendoMenuFlatBinding", ""]], inputs: { data: ["kendoMenuFlatBinding", "data"], textField: "textField", urlField: "urlField", iconField: "iconField", disabledField: "disabledField", cssClassField: "cssClassField", cssStyleField: "cssStyleField", separatorField: "separatorField", idField: "idField", parentIdField: "parentIdField" }, exportAs: ["kendoMenuFlatBinding"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FlatBindingDirective.ctorParameters = () => [
    { type: MenuBase }
];
FlatBindingDirective.propDecorators = {
    data: [{ type: Input, args: ["kendoMenuFlatBinding",] }],
    textField: [{ type: Input }],
    urlField: [{ type: Input }],
    iconField: [{ type: Input }],
    disabledField: [{ type: Input }],
    cssClassField: [{ type: Input }],
    cssStyleField: [{ type: Input }],
    separatorField: [{ type: Input }],
    idField: [{ type: Input }],
    parentIdField: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FlatBindingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoMenuFlatBinding',
                selector: '[kendoMenuFlatBinding]'
            }]
    }], function () { return [{ type: MenuBase }]; }, { data: [{
            type: Input,
            args: ["kendoMenuFlatBinding"]
        }], textField: [{
            type: Input
        }], urlField: [{
            type: Input
        }], iconField: [{
            type: Input
        }], disabledField: [{
            type: Input
        }], cssClassField: [{
            type: Input
        }], cssStyleField: [{
            type: Input
        }], separatorField: [{
            type: Input
        }], idField: [{
            type: Input
        }], parentIdField: [{
            type: Input
        }] }); })();

const COMPONENT_EXPORTS = [
    MenuComponent,
    MenuItemComponent,
    ItemTemplateDirective,
    ItemLinkTemplateDirective,
    ItemContentTemplateDirective,
    HierarchyBindingDirective,
    FlatBindingDirective,
    LinkDirective,
    ExpandArrowDirective
];
const COMPONENT_DIRECTIVES = [
    ...COMPONENT_EXPORTS,
    ListComponent,
    ItemComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Menu component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Menu module
 * import { MenuModule } from '@progress/kendo-angular-menu';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, MenuModule], // import Menu module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class MenuModule {
}
MenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MenuModule });
MenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MenuModule_Factory(t) { return new (t || MenuModule)(); }, imports: [[PopupModule, CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MenuModule, { declarations: function () { return [MenuComponent,
        MenuItemComponent,
        ItemTemplateDirective,
        ItemLinkTemplateDirective,
        ItemContentTemplateDirective,
        HierarchyBindingDirective,
        FlatBindingDirective,
        LinkDirective,
        ExpandArrowDirective,
        ListComponent,
        ItemComponent]; }, imports: function () { return [PopupModule, CommonModule]; }, exports: function () { return [MenuComponent,
        MenuItemComponent,
        ItemTemplateDirective,
        ItemLinkTemplateDirective,
        ItemContentTemplateDirective,
        HierarchyBindingDirective,
        FlatBindingDirective,
        LinkDirective,
        ExpandArrowDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MenuModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_EXPORTS],
                imports: [PopupModule, CommonModule]
            }]
    }], null, null); })();

/**
 * Arguments for the `open` and `close` events of the ContextMenu.
 */
class ContextMenuEvent {
}

/**
 * Arguments for the `select` event of the ContextMenu.
 */
class ContextMenuSelectEvent extends ContextMenuEvent {
}

/**
 * Arguments for the `popupOpen` and `popupClose` events of the ContextMenu.
 */
class ContextMenuPopupEvent extends PreventableEvent {
}

/**
 * Represents a template for the content of the ContextMenu. To define a template, nest an `<ng-template>`
 * tag with the `kendoContextMenuTemplate` directive inside a `<kendo-contextmenu>` component
 * ([more information and examples]({% slug templates_contextmenu %})).
 *
 * {% meta height:200 %}
 * {% embed_file context-menu/template/app.component.ts preview %}
 * {% embed_file context-menu/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% endmeta %}
 */
class ContextMenuTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ContextMenuTemplateDirective.ɵfac = function ContextMenuTemplateDirective_Factory(t) { return new (t || ContextMenuTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ContextMenuTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ContextMenuTemplateDirective, selectors: [["", "kendoContextMenuTemplate", ""]] });
/** @nocollapse */
ContextMenuTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoContextMenuTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class ContextMenuItemsService {
    constructor(contextService) {
        this.contextService = contextService;
    }
    get(index) {
        if (this.contextService.items) {
            return this.contextService.items.get(index);
        }
    }
}
ContextMenuItemsService.ɵfac = function ContextMenuItemsService_Factory(t) { return new (t || ContextMenuItemsService)(ɵngcc0.ɵɵinject(ContextMenuService)); };
ContextMenuItemsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuItemsService, factory: ContextMenuItemsService.ɵfac });
/** @nocollapse */
ContextMenuItemsService.ctorParameters = () => [
    { type: ContextMenuService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuItemsService, [{
        type: Injectable
    }], function () { return [{ type: ContextMenuService }]; }, null); })();

/**
 * @hidden
 */
class ContextMenuTargetService {
    constructor() {
        this.targets = [];
    }
    add(target) {
        this.targets.push(target);
    }
    remove(target) {
        const index = this.targets.indexOf(target);
        this.targets.splice(index, 1);
    }
    find(targetElement) {
        return this.targets.find(target => target.element === targetElement);
    }
}
ContextMenuTargetService.ɵfac = function ContextMenuTargetService_Factory(t) { return new (t || ContextMenuTargetService)(); };
ContextMenuTargetService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuTargetService, factory: ContextMenuTargetService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuTargetService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Specifies a container for the [targets]({% slug api_menu_contextmenutargetdirective %}) of the ContextMenu.
 */
class ContextMenuTargetContainerDirective {
    /**
     * @hidden
     */
    constructor(elementRef, targetService) {
        this.targetService = targetService;
        if (elementRef) {
            this.element = elementRef.nativeElement;
        }
    }
}
ContextMenuTargetContainerDirective.ɵfac = function ContextMenuTargetContainerDirective_Factory(t) { return new (t || ContextMenuTargetContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ContextMenuTargetService)); };
ContextMenuTargetContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ContextMenuTargetContainerDirective, selectors: [["", "kendoContextMenuTargetContainer", ""]], exportAs: ["kendoContextMenuTargetContainer"], features: [ɵngcc0.ɵɵProvidersFeature([ContextMenuTargetService])] });
/** @nocollapse */
ContextMenuTargetContainerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ContextMenuTargetService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuTargetContainerDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoContextMenuTargetContainer]',
                exportAs: 'kendoContextMenuTargetContainer',
                providers: [ContextMenuTargetService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ContextMenuTargetService }]; }, null); })();

/**
 * @hidden
 */
const TARGET_CLASS = 'k-contextmenu-target';
/**
 * Specifies a [target]({% slug api_menu_contextmenutargetdirective %}) for the ContextMenu
 * ([see example]({% slug target_contextmenu %}#toc-directives)).
 */
class ContextMenuTargetDirective {
    constructor(elementRef, targetService) {
        this.targetService = targetService;
        /**
         * @hidden
         */
        this.hostClass = true;
        if (elementRef) {
            this.element = elementRef.nativeElement;
        }
        targetService.add(this);
    }
    ngOnDestroy() {
        this.targetService.remove(this);
    }
}
ContextMenuTargetDirective.ɵfac = function ContextMenuTargetDirective_Factory(t) { return new (t || ContextMenuTargetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ContextMenuTargetService)); };
ContextMenuTargetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ContextMenuTargetDirective, selectors: [["", "kendoContextMenuTarget", ""]], hostVars: 2, hostBindings: function ContextMenuTargetDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-contextmenu-target", ctx.hostClass);
    } }, inputs: { data: ["kendoContextMenuTarget", "data"] }, exportAs: ["kendoContextMenuTarget"] });
/** @nocollapse */
ContextMenuTargetDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ContextMenuTargetService }
];
ContextMenuTargetDirective.propDecorators = {
    data: [{ type: Input, args: ['kendoContextMenuTarget',] }],
    hostClass: [{ type: HostBinding, args: [`class.${TARGET_CLASS}`,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuTargetDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoContextMenuTarget]',
                exportAs: 'kendoContextMenuTarget'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ContextMenuTargetService }]; }, { hostClass: [{
            type: HostBinding,
            args: [`class.${TARGET_CLASS}`]
        }], data: [{
            type: Input,
            args: ['kendoContextMenuTarget']
        }] }); })();

const CONTEXT_MENU = 'contextmenu';
const DEFAULT_ANCHOR_ALIGN = { horizontal: 'left', vertical: 'bottom' };
const DEFAULT_POPUP_ALIGN = { horizontal: 'left', vertical: 'top' };
const DEFAULT_COLLISION = { horizontal: 'fit', vertical: 'flip' };
const preventDefault = e => e.preventDefault();
const ɵ1$2 = bodyFactory;
/**
 * Represents the [Kendo UI ContextMenu component for Angular]({% slug overview_contextmenu %}).
 *
 * {% meta height:200 %}
 * {% embed_file context-menu/basic/app.component.ts preview %}
 * {% embed_file shared/contextmenu-items.ts %}
 * {% embed_file context-menu/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% endmeta %}
 */
class ContextMenuComponent extends MenuBase {
    constructor(popupService, service, ngZone, renderer) {
        super();
        this.popupService = popupService;
        this.service = service;
        this.ngZone = ngZone;
        this.renderer = renderer;
        /**
         * Specifies the event on which the ContextMenu will open ([see example]({% slug showon_contextmenu %})).
         * Accepts the name of a native DOM event. Defaults to `contextmenu` which opens the ContextMenu for the target element.
         */
        this.showOn = CONTEXT_MENU;
        /**
         * Indicates that the ContextMenu will be aligned to the target or to the `filter` element (if specified).
         */
        this.alignToAnchor = false;
        /**
         * Specifies if the Menu will be vertically rendered ([see example]({% slug orientation_contextmenu %})).
         * @default true
         */
        this.vertical = true;
        /**
         * Fires when the Menu is opened ([see example]({% slug target_contextmenu %}#toc-changing-items-for-specified-targets)).
         */
        this.popupOpen = new EventEmitter();
        /**
         * Fires when the Menu is closed.
         */
        this.popupClose = new EventEmitter();
        /**
         * Fires when a Menu item is selected.
         */
        this.select = new EventEmitter();
        /**
         * Fires when a Menu item is opened.
         */
        this.open = new EventEmitter();
        /**
         * Fires when a Menu item is closed.
         */
        this.close = new EventEmitter();
        this.service.owner = this;
        this.popupKeyDownHandler = this.popupKeyDownHandler.bind(this);
    }
    /**
     * Hides the ContextMenu.
     */
    hide() {
        this.removePopup();
    }
    /**
     * Shows the ContextMenu for the specified target.
     * @param target - The offset or the target element for which the ContextMenu will open.
     */
    show(target) {
        if (!target) {
            return;
        }
        const showTarget = target;
        this.removePopup();
        if (defined(showTarget.left) && defined(showTarget.top)) {
            this.createPopup({ offset: showTarget });
        }
        else {
            this.currentTarget = showTarget.nativeElement || showTarget;
            this.createPopup({ anchor: this.currentTarget });
        }
    }
    ngOnChanges(changes) {
        if (changes.target || changes.showOn) {
            this.bindShowHandler();
        }
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            const closeClickSubscription = this.renderer.listen('document', 'mousedown', (e) => {
                if (this.popupRef && !closest(e.target, node => node === this.popupRef.popupElement) && this.service.leaveMenu(e)) {
                    this.closePopup(e);
                }
            });
            const closeBlurSubscription = this.renderer.listen('window', 'blur', (e) => {
                if (this.popupRef) {
                    this.closePopup(e);
                }
            });
            this.closeSubscription = () => {
                closeClickSubscription();
                closeBlurSubscription();
            };
        });
    }
    ngOnDestroy() {
        if (this.closeSubscription) {
            this.closeSubscription();
            this.closeSubscription = null;
        }
        this.unbindShowHandler();
        this.removePopup();
    }
    /**
     * @hidden
     */
    emitMenuEvent(name, args) {
        args.target = this.currentTarget;
        args.sender = this;
        this[name].emit(args);
        if (name === 'select' && !args.hasContent) {
            this.closeAndFocus(args.originalEvent);
        }
    }
    bindShowHandler() {
        this.unbindShowHandler();
        this.ngZone.runOutsideAngular(() => {
            const element = this.targetElement();
            if (!element) {
                return;
            }
            const eventName = this.showOn || CONTEXT_MENU;
            this.showSubscription = this.renderer.listen(element, this.showOn || CONTEXT_MENU, (e) => {
                this.showContextMenu(e, element);
            });
            if (eventName === CONTEXT_MENU) {
                this.keydownSubscription = this.renderer.listen(element, 'keydown', (e) => {
                    if (e.shiftKey && e.keyCode === Keys.F10) {
                        this.showContextMenu(e, element);
                    }
                });
            }
        });
    }
    showContextMenu(e, element) {
        const filter = this.targetFilter();
        let currentTarget = element;
        if (filter) {
            currentTarget = findInContainer(e.target, filter, element);
            if (currentTarget && currentTarget !== e.target && isFocusable(e.target)) {
                return;
            }
            if (currentTarget && this.directiveTarget) {
                currentTarget = this.target.targetService.find(currentTarget);
            }
        }
        if (!currentTarget) {
            this.closePopup(e);
            return;
        }
        this.ngZone.run(() => {
            if (!this.closePopup(e)) {
                this.currentTarget = currentTarget;
                this.openPopup(e);
            }
        });
    }
    unbindShowHandler() {
        if (this.showSubscription) {
            this.showSubscription();
            this.showSubscription = null;
        }
        if (this.keydownSubscription) {
            this.keydownSubscription();
            this.keydownSubscription = null;
        }
    }
    targetElement() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.directiveTarget = false;
        let target = this.target;
        if (typeof target === 'string') {
            target = document.querySelector(target); // maybe querySelectorAll?
        }
        else if (target && target.nativeElement) {
            target = target.nativeElement;
        }
        else if (target instanceof ContextMenuTargetContainerDirective) {
            target = target.element;
            this.directiveTarget = true;
        }
        return target;
    }
    targetFilter() {
        if (this.directiveTarget) {
            return `.${TARGET_CLASS}`;
        }
        return this.filter;
    }
    closePopup(e) {
        if (!this.popupRef) {
            return;
        }
        return this.popupAction('popupClose', e, () => {
            this.removePopup();
        });
    }
    removePopup() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.currentTarget = null;
        }
        if (this.popupSubscriptions) {
            this.popupSubscriptions();
            this.popupSubscriptions = null;
        }
    }
    openPopup(e) {
        this.popupAction('popupOpen', e, () => {
            e.preventDefault();
            let anchor, offset;
            if (this.alignToAnchor || e.type === 'keydown') {
                anchor = this.currentTargetElement;
            }
            else {
                offset = { left: e.pageX, top: e.pageY };
            }
            this.createPopup({ anchor, offset });
        });
    }
    createPopup(options) {
        this.popupRef = this.popupService.open(Object.assign({
            animate: defined(this.popupAnimate) ? this.popupAnimate : true,
            appendTo: this.appendTo,
            collision: this.collision || DEFAULT_COLLISION,
            popupAlign: this.popupAlign || DEFAULT_POPUP_ALIGN,
            anchorAlign: this.anchorAlign || DEFAULT_ANCHOR_ALIGN,
            content: this.contentTemplate ? this.contentTemplate.templateRef : this.defaultContentTemplate,
            popupClass: 'k-menu-popup'
        }, options));
        const element = this.popupRef.popupElement;
        this.renderer.addClass(element, 'k-context-menu-popup');
        this.renderer.setAttribute(element, 'tabindex', '-1');
        this.renderer.setStyle(element, 'outline', '0'); //possibly move to styles
        if (this.ariaLabel) {
            this.renderer.setAttribute(element, 'aria-label', this.ariaLabel);
        }
        this.activeTarget = this.currentTargetElement === document.activeElement;
        this.ngZone.runOutsideAngular(() => {
            const unbindKeyDown = this.renderer.listen(element, 'keydown', this.popupKeyDownHandler);
            const unbindContextmenu = this.renderer.listen(element, 'contextmenu', preventDefault);
            this.popupSubscriptions = () => {
                unbindKeyDown();
                unbindContextmenu();
            };
        });
        element.focus();
    }
    closeAndFocus(e) {
        const currentTarget = this.currentTargetElement;
        if (!this.closePopup(e) && this.activeTarget) {
            currentTarget.focus();
        }
    }
    popupKeyDownHandler(e) {
        const element = this.popupRef.popupElement;
        if (e.keyCode === Keys.Escape && (hasClass(e.target, 'k-menu-item') || e.target === element)) {
            this.closeAndFocus(e);
        }
        else if (e.target === element) {
            this.service.keydown.emit(e);
        }
    }
    popupAction(name, originalEvent, callback) {
        const emitter = this[name];
        let prevented = false;
        if (hasObservers(emitter)) {
            this.ngZone.run(() => {
                const args = new ContextMenuPopupEvent({
                    originalEvent: originalEvent,
                    sender: this,
                    target: this.currentTarget
                });
                emitter.emit(args);
                if (!args.isDefaultPrevented()) {
                    callback();
                }
                prevented = args.isDefaultPrevented();
            });
        }
        else {
            callback();
        }
        return prevented;
    }
    get currentTargetElement() {
        return this.directiveTarget && this.currentTarget ? this.currentTarget.element : this.currentTarget;
    }
}
ContextMenuComponent.ɵfac = function ContextMenuComponent_Factory(t) { return new (t || ContextMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.PopupService), ɵngcc0.ɵɵdirectiveInject(ContextMenuService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ContextMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContextMenuComponent, selectors: [["kendo-contextmenu"]], contentQueries: function ContextMenuComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ContextMenuTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, viewQuery: function ContextMenuComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c5, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultContentTemplate = _t.first);
    } }, inputs: { showOn: "showOn", alignToAnchor: "alignToAnchor", vertical: "vertical", target: "target", filter: "filter", popupAnimate: "popupAnimate", popupAlign: "popupAlign", anchorAlign: "anchorAlign", collision: "collision", appendTo: "appendTo", ariaLabel: "ariaLabel" }, outputs: { popupOpen: "popupOpen", popupClose: "popupClose", select: "select", open: "open", close: "close" }, exportAs: ["kendoContextMenu"], features: [ɵngcc0.ɵɵProvidersFeature([
            ContextMenuService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.contextmenu'
            },
            {
                provide: ItemsService,
                useClass: ContextMenuItemsService
            },
            {
                provide: MenuBase,
                useExisting: forwardRef(() => ContextMenuComponent)
            },
            PopupService,
            {
                provide: POPUP_CONTAINER,
                useFactory: ɵ1$2
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 0, consts: [["default", ""], [3, "items", "vertical", "openOnClick", "hoverDelay", "animate", "menuItemTemplate", "menuItemLinkTemplate"]], template: function ContextMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ContextMenuComponent_ng_template_0_Template, 1, 7, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [MenuComponent], encapsulation: 2 });
/** @nocollapse */
ContextMenuComponent.ctorParameters = () => [
    { type: PopupService },
    { type: ContextMenuService },
    { type: NgZone },
    { type: Renderer2 }
];
ContextMenuComponent.propDecorators = {
    showOn: [{ type: Input }],
    target: [{ type: Input }],
    filter: [{ type: Input }],
    alignToAnchor: [{ type: Input }],
    vertical: [{ type: Input }],
    popupAnimate: [{ type: Input }],
    popupAlign: [{ type: Input }],
    anchorAlign: [{ type: Input }],
    collision: [{ type: Input }],
    appendTo: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    popupOpen: [{ type: Output }],
    popupClose: [{ type: Output }],
    select: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    contentTemplate: [{ type: ContentChild, args: [ContextMenuTemplateDirective,] }],
    defaultContentTemplate: [{ type: ViewChild, args: ['default',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoContextMenu',
                providers: [
                    ContextMenuService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.contextmenu'
                    },
                    {
                        provide: ItemsService,
                        useClass: ContextMenuItemsService
                    },
                    {
                        provide: MenuBase,
                        useExisting: forwardRef(() => ContextMenuComponent)
                    },
                    PopupService,
                    {
                        provide: POPUP_CONTAINER,
                        useFactory: ɵ1$2
                    }
                ],
                selector: 'kendo-contextmenu',
                template: `
        <ng-template #default>
            <kendo-menu [items]="rootItems"
                [vertical]="vertical"
                [openOnClick]="openOnClick"
                [hoverDelay]="hoverDelay"
                [animate]="animate"
                [menuItemTemplate]="itemTemplate.first?.templateRef"
                [menuItemLinkTemplate]="itemLinkTemplate.first?.templateRef"
                ></kendo-menu>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc3.PopupService }, { type: ContextMenuService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { showOn: [{
            type: Input
        }], alignToAnchor: [{
            type: Input
        }], vertical: [{
            type: Input
        }], popupOpen: [{
            type: Output
        }], popupClose: [{
            type: Output
        }], select: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], target: [{
            type: Input
        }], filter: [{
            type: Input
        }], popupAnimate: [{
            type: Input
        }], popupAlign: [{
            type: Input
        }], anchorAlign: [{
            type: Input
        }], collision: [{
            type: Input
        }], appendTo: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], contentTemplate: [{
            type: ContentChild,
            args: [ContextMenuTemplateDirective]
        }], defaultContentTemplate: [{
            type: ViewChild,
            args: ['default']
        }] }); })();

const COMPONENT_DIRECTIVES$1 = [
    ContextMenuComponent,
    ContextMenuTemplateDirective,
    ContextMenuTargetDirective,
    ContextMenuTargetContainerDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ContextMenu component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ContextMenu module
 * import { ContextMenuModule } from '@progress/kendo-angular-menu';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, ContextMenuModule], // import ContextMenuModule module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class ContextMenuModule {
}
ContextMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ContextMenuModule });
ContextMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ContextMenuModule_Factory(t) { return new (t || ContextMenuModule)(); }, imports: [[PopupModule, CommonModule, MenuModule],
        MenuModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContextMenuModule, { declarations: function () { return [ContextMenuComponent,
        ContextMenuTemplateDirective,
        ContextMenuTargetDirective,
        ContextMenuTargetContainerDirective]; }, imports: function () { return [PopupModule, CommonModule,
        MenuModule]; }, exports: function () { return [ContextMenuComponent,
        ContextMenuTemplateDirective,
        ContextMenuTargetDirective,
        ContextMenuTargetContainerDirective,
        MenuModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES$1],
                exports: [COMPONENT_DIRECTIVES$1, MenuModule],
                imports: [PopupModule, CommonModule, MenuModule]
            }]
    }], null, null); })();

/**
 * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Menu and ContextMenu components and directives.
 * Imports the MenusModule into your application [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity)
 * or any other sub-module that will use the Menu and ContextMenu components.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 * import { MenusModule } from '@progress/kendo-angular-menu';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, BrowserAnimationsModule, MenusModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
class MenusModule {
}
MenusModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MenusModule });
MenusModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MenusModule_Factory(t) { return new (t || MenusModule)(); }, imports: [MenuModule,
        ContextMenuModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MenusModule, { exports: [MenuModule,
        ContextMenuModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MenusModule, [{
        type: NgModule,
        args: [{
                exports: [MenuModule, ContextMenuModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NODE_INDEX, ContextMenuItemsService, ContextMenuTargetContainerDirective, ContextMenuTargetDirective, ContextMenuTargetService, BindingDirectiveBase, MenuBase, PreventableEvent, ActionsService, HoverService, ItemsService, NavigationService, bodyFactory, MenuComponent, ListComponent, ItemComponent, LinkDirective, ExpandArrowDirective, MenuItemComponent, MenuEvent, MenuSelectEvent, ItemContentTemplateDirective, ItemTemplateDirective, ItemLinkTemplateDirective, HierarchyBindingDirective, FlatBindingDirective, MenuModule, ContextMenuEvent, ContextMenuSelectEvent, ContextMenuPopupEvent, ContextMenuTemplateDirective, ContextMenuComponent, ContextMenuModule, ContextMenuService, MenusModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBHQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OytGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttSEFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7K0pBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvR0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztnR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUpBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRKQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozt3UUFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozt1SUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0ZBaUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OytJQXNCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0hBNkRFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OERBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2lFQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NGdCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dWdCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0pBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxSUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7NEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytSQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7K0dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozt1R0FNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MERBdUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzswQkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSwgRXZlbnRFbWl0dGVyLCBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmLCBPcHRpb25hbCwgQ29tcG9uZW50LCBJbnB1dCwgQ29udGVudENoaWxkcmVuLCBmb3J3YXJkUmVmLCBSZW5kZXJlcjIsIE91dHB1dCwgSG9zdEJpbmRpbmcsIEVsZW1lbnRSZWYsIENoYW5nZURldGVjdG9yUmVmLCBWaWV3Q2hpbGQsIGlzRGV2TW9kZSwgTmdNb2R1bGUsIENvbnRlbnRDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVggfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IGhhc09ic2VydmVycywgaXNEb2N1bWVudEF2YWlsYWJsZSwgS2V5cyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyBQb3B1cFNlcnZpY2UsIFBPUFVQX0NPTlRBSU5FUiwgUG9wdXBNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5jb25zdCBQQVJFTlRfUkVHRVggPSAvXz9cXGQrJC87XG5jb25zdCBTRVBBUkFUT1IgPSAnXyc7XG5sZXQgaWQgPSAwO1xuY29uc3QgaXRlbUluZGV4Q29tcGFyZXIgPSAoYSwgYikgPT4gYS5zaWJsaW5nSW5kZXggLSBiLnNpYmxpbmdJbmRleDtcbmNvbnN0IG5leHQgPSAoaWR4LCBpdGVtcywgZGlyKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSBpdGVtc1tpZHggKyBkaXJdO1xuICAgIHdoaWxlICghY3VycmVudCkge1xuICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgaWR4ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZHggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gaXRlbXNbaWR4XTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEl0ZW1zU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICAgICAgdGhpcy5saXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmlkUHJlZml4ID0gYGstbWVudSR7aWQrK31gO1xuICAgIH1cbiAgICBnZXQgaGFzSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLml0ZW1zKS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBjaGlsZElkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkUHJlZml4fS1jaGlsZCR7aW5kZXh9YDtcbiAgICB9XG4gICAgaXRlbUluZGV4KHBhcmVudEluZGV4LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKHBhcmVudEluZGV4ID8gcGFyZW50SW5kZXggKyBTRVBBUkFUT1IgOiAnJykgKyBpbmRleDtcbiAgICB9XG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICB9XG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pdGVtc1tpdGVtLmluZGV4XSA9IGl0ZW07XG4gICAgfVxuICAgIHJlbW92ZShpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zW2l0ZW0uaW5kZXhdID09PSBpdGVtKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRMaXN0KGxpc3QpIHtcbiAgICAgICAgdGhpcy5saXN0cy5wdXNoKGxpc3QpO1xuICAgIH1cbiAgICByZW1vdmVMaXN0KGxpc3QpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmxpc3RzLmluZGV4T2YobGlzdCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGFpbnNMaXN0KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5saXN0cy5maW5kKGxpc3QgPT4gbGlzdC5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQpKTtcbiAgICB9XG4gICAgc2libGluZ3MoaXRlbSkge1xuICAgICAgICBjb25zdCBwYXJlbnRJbmRleCA9IHRoaXMucGFyZW50SW5kZXgoaXRlbS5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcigoaW5kZXgpID0+IHRoaXMucGFyZW50SW5kZXgoaW5kZXgpID09PSBwYXJlbnRJbmRleCk7XG4gICAgfVxuICAgIG90aGVyU2libGluZ3MoaXRlbSkge1xuICAgICAgICBjb25zdCBwYXJlbnRJbmRleCA9IHRoaXMucGFyZW50SW5kZXgoaXRlbS5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcigoaW5kZXgpID0+IHRoaXMucGFyZW50SW5kZXgoaW5kZXgpID09PSBwYXJlbnRJbmRleCAmJiBpbmRleCAhPT0gaXRlbS5pbmRleCk7XG4gICAgfVxuICAgIGNoaWxkcmVuKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKChpbmRleCkgPT4gdGhpcy5wYXJlbnRJbmRleChpbmRleCkgPT09IGl0ZW0uaW5kZXgpO1xuICAgIH1cbiAgICBwYXJlbnQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLnBhcmVudEluZGV4KGl0ZW0uaW5kZXgpXTtcbiAgICB9XG4gICAgcm9vdChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMuaW5kaWNlcyhpdGVtLmluZGV4KVswXV07XG4gICAgfVxuICAgIGluZGljZXMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4LnNwbGl0KFNFUEFSQVRPUik7XG4gICAgfVxuICAgIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoaW5kZXgsIGl0ZW1zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydChpdGVtSW5kZXhDb21wYXJlcik7XG4gICAgfVxuICAgIHByZXZpb3VzKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLnNpYmxpbmdzKGl0ZW0pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICByZXR1cm4gbmV4dChpdGVtSW5kZXgsIHNpYmxpbmdzLCAtMSk7XG4gICAgfVxuICAgIG5leHQoaXRlbSkge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMuc2libGluZ3MoaXRlbSk7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHNpYmxpbmdzLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIHJldHVybiBuZXh0KGl0ZW1JbmRleCwgc2libGluZ3MsIDEpO1xuICAgIH1cbiAgICBoYXNQYXJlbnQoaXRlbSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBpdGVtLmluZGV4LnN0YXJ0c1dpdGgocGFyZW50LmluZGV4KTtcbiAgICB9XG4gICAgYXJlU2libGluZ3MoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIHJldHVybiBpdGVtMSAhPT0gaXRlbTIgJiYgdGhpcy5wYXJlbnQoaXRlbTEpID09PSB0aGlzLnBhcmVudChpdGVtMik7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGl0ZW1zW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyZW50SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4LnJlcGxhY2UoUEFSRU5UX1JFR0VYLCAnJyk7XG4gICAgfVxufVxuSXRlbXNTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyBvZiB0aGUgTWVudS5cbiAqL1xuY2xhc3MgTWVudUV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG59XG5cbmNvbnN0IGNhblBlcmZvcm1BY3Rpb24gPSAoaXRlbSwgYWN0aW9uKSA9PiAhKChhY3Rpb24gPT09ICdvcGVuJyAmJiBpdGVtLm9wZW5lZCkgfHwgKGFjdGlvbiA9PT0gJ2Nsb3NlJyAmJiAhaXRlbS5vcGVuZWQpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBBY3Rpb25zU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lLCBpdGVtcykge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgb3BlbihpdGVtLCBmaW5pc2hlZCkge1xuICAgICAgICBpZiAoaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmhhc0NvbnRlbnQgJiYgIWl0ZW0ub3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVzWm9uZTogaXRlbS5oYXNDb250ZW50VGVtcGxhdGVzKCksXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoaXRlbSkge1xuICAgICAgICB0aGlzLmNsb3NlQ2hpbGRyZW4oaXRlbSk7XG4gICAgICAgIHRoaXMuY2xvc2VJdGVtKGl0ZW0pO1xuICAgIH1cbiAgICBjbG9zZUl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5vcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xvc2UnLFxuICAgICAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlVG9Sb290KGl0ZW0pIHtcbiAgICAgICAgdGhpcy5jbG9zZUNoaWxkcmVuKGl0ZW0pO1xuICAgICAgICBsZXQgY3VycmVudCA9IGl0ZW07XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VJdGVtKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuaXRlbXMucGFyZW50KGN1cnJlbnQpO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcbiAgICB9XG4gICAgY2xvc2VPdGhlcnMoaXRlbSkge1xuICAgICAgICB0aGlzLmNsb3NlQ2hpbGRyZW4oaXRlbSk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXRlbTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5pdGVtcy5vdGhlclNpYmxpbmdzKGN1cnJlbnQpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUl0ZW1zKHNpYmxpbmdzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLml0ZW1zLnBhcmVudChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZUFsbCgpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5vcGVuZWQgJiYgaXRlbS5sZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxlY3QoaXRlbSwgZG9tRXZlbnQsIHByZXZlbnRlZCwgZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgcHJldmVudGVkLFxuICAgICAgICAgICAgZmluaXNoZWQsXG4gICAgICAgICAgICBkb21FdmVudFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1pdChuYW1lLCBpdGVtLCBkb21FdmVudCkge1xuICAgICAgICBjb25zdCBvd25lciA9IHRoaXMub3duZXI7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBNZW51RXZlbnQoe1xuICAgICAgICAgICAgc2VuZGVyOiBvd25lcixcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgIGluZGV4OiBpdGVtLmluZGV4LFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZG9tRXZlbnQsXG4gICAgICAgICAgICBoYXNDb250ZW50OiBpdGVtLmhhc0NvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIG93bmVyW25hbWVdLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKG93bmVyLmNvbnRleHRTZXJ2aWNlKSB7XG4gICAgICAgICAgICBvd25lci5jb250ZXh0U2VydmljZS5lbWl0KG5hbWUsIGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgZ2V0IGhhc1BlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZXhlY3V0ZSh0b0V4ZWN1dGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1BlbmRpbmcgJiYgIXRvRXhlY3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0b0V4ZWN1dGUgfHwgdGhpcy5jbGVhcigpO1xuICAgICAgICBpZiAoIU5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSAmJiB0aGlzLnJlcXVpcmVzWm9uZShhY3Rpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGFjdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb25zKGFjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfVxuICAgIGV4ZWN1dGVBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYWN0aW9ucy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGl0ZW0sIG5hbWUsIHByZXZlbnRlZCwgZmluaXNoZWQsIGRvbUV2ZW50IH0gPSBhY3Rpb25zW2lkeF07XG4gICAgICAgICAgICBpZiAoIWNhblBlcmZvcm1BY3Rpb24oaXRlbSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5lbWl0KG5hbWUsIGl0ZW0sIGRvbUV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bbmFtZV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWlyZXNab25lKHRvRXhlY3V0ZSkge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gdG9FeGVjdXRlIHx8IHRoaXMuYWN0aW9ucztcbiAgICAgICAgY29uc3Qgb3duZXIgPSB0aGlzLm93bmVyO1xuICAgICAgICBjb25zdCBjb250ZXh0U2VydmljZSA9IG93bmVyLmNvbnRleHRTZXJ2aWNlO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhY3Rpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24ucmVxdWlyZXNab25lIHx8IChuYW1lICYmIChoYXNPYnNlcnZlcnMob3duZXJbbmFtZV0pIHx8IChjb250ZXh0U2VydmljZSAmJiBjb250ZXh0U2VydmljZS5oYXNPYnNlcnZlcnMobmFtZSkpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsb3NlQ2hpbGRyZW4oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0ub3BlbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zLmNoaWxkcmVuKGl0ZW0pO1xuICAgICAgICB0aGlzLmNsb3NlSXRlbXMoY2hpbGRyZW4pO1xuICAgIH1cbiAgICBjbG9zZUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGl0ZW1zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoaXRlbXNbaWR4XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5BY3Rpb25zU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQWN0aW9uc1NlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IEl0ZW1zU2VydmljZSB9XG5dO1xuXG5jb25zdCBERUZBVUxUX0FDVElWRSA9ICcwJztcbmNvbnN0IE5PX1NQQUNFX1JFR0VYID0gL1xcUy87XG5jb25zdCBoYW5kbGVycyA9IHt9O1xuaGFuZGxlcnNbJzM3J10gPSAnbGVmdCc7XG5oYW5kbGVyc1snMzknXSA9ICdyaWdodCc7XG5oYW5kbGVyc1snMzgnXSA9ICd1cCc7XG5oYW5kbGVyc1snNDAnXSA9ICdkb3duJztcbmhhbmRsZXJzWyczNiddID0gJ2hvbWUnO1xuaGFuZGxlcnNbJzM1J10gPSAnZW5kJztcbmhhbmRsZXJzWyczMiddID0gJ2VudGVyJztcbmhhbmRsZXJzWycxMyddID0gJ2VudGVyJztcbmhhbmRsZXJzWycyNyddID0gJ2VzYyc7XG5oYW5kbGVyc1snOSddID0gJ3RhYic7XG5jb25zdCBoYW5kbGVyc1JUTCA9IE9iamVjdC5hc3NpZ24oe30sIGhhbmRsZXJzLCB7XG4gICAgJzM3JzogJ3JpZ2h0JyxcbiAgICAnMzknOiAnbGVmdCdcbn0pO1xuZnVuY3Rpb24gaXNQcmludGFibGVDaGFyYWN0ZXIoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5sZW5ndGggPT09IDEgJiYgTk9fU1BBQ0VfUkVHRVgudGVzdChrZXkpO1xufVxuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgYWN0aW9ucywgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBhY3Rpb25zO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IERFRkFVTFRfQUNUSVZFO1xuICAgIH1cbiAgICBnZXQgZm9jdXNlZEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmdldCh0aGlzLmZvY3VzZWRJZHgpO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZ2V0KHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgIH1cbiAgICBnZXQgaGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyBoYW5kbGVyc1JUTCA6IGhhbmRsZXJzO1xuICAgIH1cbiAgICBmb2N1cyhpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmluZGV4ID09PSB0aGlzLmZvY3VzZWRJZHgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlSXRlbSB8fCAhdGhpcy5pdGVtcy5oYXNQYXJlbnQoaXRlbSwgdGhpcy5hY3RpdmVJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRGb2N1cyhpdGVtKTtcbiAgICB9XG4gICAgc2V0Rm9jdXMoaXRlbSkge1xuICAgICAgICB0aGlzLmZvY3VzZWRJZHggPSBpdGVtLmluZGV4O1xuICAgICAgICBpdGVtLmZvY3VzKCk7XG4gICAgfVxuICAgIGZvY3VzTGVhdmUoKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLmZvY3VzZWRJdGVtO1xuICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlVG9Sb290KGZvY3VzZWQpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzZWRJZHggPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVBY3RpdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVJdGVtICYmIHRoaXMuaXRlbXMuaGFzSXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SXRlbSA9IHRoaXMuaXRlbXMuZ2V0KERFRkFVTFRfQUNUSVZFKTtcbiAgICAgICAgICAgIGZpcnN0SXRlbS50b2dnbGVBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gREVGQVVMVF9BQ1RJVkU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZm9jdXNlZEl0ZW0gfHwgdGhpcy5hY3RpdmVJdGVtO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tlLmtleUNvZGVdO1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09ICd0YWInKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1toYW5kbGVyXShjdXJyZW50LCBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByaW50YWJsZUNoYXJhY3RlcihlLmtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoKGN1cnJlbnQsIGUua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMuZXhlY3V0ZSgpO1xuICAgIH1cbiAgICBmb2N1c0luZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICghaW5kZXggJiYgdGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZvY3VzKHRoaXMuYWN0aXZlSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09ICdmaXJzdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNGaXJzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSAnbGFzdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNMYXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzRmlyc3QoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcy5zaWJsaW5ncyh0aGlzLml0ZW1zLmdldCgnMCcpKTtcbiAgICAgICAgdGhpcy5mb2N1cyhpdGVtc1swXSk7XG4gICAgfVxuICAgIGZvY3VzTGFzdCgpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zLnNpYmxpbmdzKHRoaXMuaXRlbXMuZ2V0KCcwJykpO1xuICAgICAgICB0aGlzLmZvY3VzKGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgc2VhcmNoKGN1cnJlbnQsIGtleSkge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMuaXRlbXMuc2libGluZ3MoY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNpYmxpbmdzLnNsaWNlKHN0YXJ0SW5kZXggKyAxKS5jb25jYXQoc2libGluZ3Muc2xpY2UoMCwgc3RhcnRJbmRleCkpO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBpdGVtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gaXRlbXNbaWR4XTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBzaWJsaW5nLml0ZW0udGV4dCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRleHQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoc2libGluZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG93bihjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50LmxldmVsID09PSAwICYmICF0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLm9wZW4oY3VycmVudCwgdGhpcy5mb2N1c0NoaWxkKGN1cnJlbnQsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXModGhpcy5pdGVtcy5uZXh0KGN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cChjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50LmxldmVsID09PSAwICYmICF0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLm9wZW4oY3VycmVudCwgdGhpcy5mb2N1c0NoaWxkKGN1cnJlbnQsIGN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb2N1cyh0aGlzLml0ZW1zLnByZXZpb3VzKGN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZWZ0KGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwgJiYgY3VycmVudC5sZXZlbCA9PT0gMCAmJiBjdXJyZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQubGV2ZWwgPiAxIHx8ICh0aGlzLnZlcnRpY2FsICYmIGN1cnJlbnQubGV2ZWwgPiAwKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5pdGVtcy5wYXJlbnQoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2UocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnZlcnRpY2FsICYmIGN1cnJlbnQubGV2ZWwgPT09IDAgJiYgIWN1cnJlbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lmhhc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMub3BlbihjdXJyZW50LCB0aGlzLmZvY3VzQ2hpbGQoY3VycmVudCwgY3VycmVudC5jaGlsZHJlbi5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKHRoaXMuaXRlbXMucHJldmlvdXModGhpcy5hY3RpdmVJdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmlnaHQoY3VycmVudCkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCAmJiBjdXJyZW50LmxldmVsID09PSAwICYmIGN1cnJlbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudC5ob3Jpem9udGFsICYmICFjdXJyZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLm9wZW4oY3VycmVudCwgdGhpcy5mb2N1c0NoaWxkKGN1cnJlbnQsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnZlcnRpY2FsIHx8IGN1cnJlbnQubGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cyh0aGlzLml0ZW1zLm5leHQodGhpcy5hY3RpdmVJdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKHRoaXMuaXRlbXMubmV4dCh0aGlzLmFjdGl2ZUl0ZW0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBob21lKGN1cnJlbnQpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLml0ZW1zLnNpYmxpbmdzKGN1cnJlbnQpO1xuICAgICAgICB0aGlzLmZvY3VzKHNpYmxpbmdzWzBdKTtcbiAgICB9XG4gICAgZW5kKGN1cnJlbnQpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLml0ZW1zLnNpYmxpbmdzKGN1cnJlbnQpO1xuICAgICAgICB0aGlzLmZvY3VzKHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgZW50ZXIoY3VycmVudCwgZG9tRXZlbnQpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgaWYgKGN1cnJlbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudC5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNlbGVjdChjdXJyZW50LCBkb21FdmVudCk7XG4gICAgICAgICAgICBhY3Rpb25zLm9wZW4oY3VycmVudCwgdGhpcy5mb2N1c0NoaWxkKGN1cnJlbnQsIDApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbnMuc2VsZWN0KGN1cnJlbnQsIGRvbUV2ZW50LCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5uYXZpZ2F0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKHRoaXMuaXRlbXMucm9vdChjdXJyZW50KSk7XG4gICAgICAgICAgICBhY3Rpb25zLmNsb3NlVG9Sb290KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVzYyhjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50LmxldmVsID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5pdGVtcy5wYXJlbnQoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2UocGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMocGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWIoY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5sZXZlbCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzQ2hpbGQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5pdGVtcy5jaGlsZHJlbihpdGVtKVtpbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldEZvY3VzKGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0QWN0aXZlKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuZm9jdXNlZEl0ZW07XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuaXRlbXMucm9vdChpdGVtKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtLnRvZ2dsZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGFjdGl2ZS5pbmRleDtcbiAgICAgICAgYWN0aXZlLnRvZ2dsZUFjdGl2ZSh0cnVlKTtcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5jbG9zZVRvUm9vdChmb2N1c2VkKTtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkLmxldmVsID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5vcGVuKGFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5OYXZpZ2F0aW9uU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTmF2aWdhdGlvblNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJdGVtc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEFjdGlvbnNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblxuY29uc3QgRElTQUJMRV9PUEVOX09OX09WRVJfREVMQVkgPSA1MDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSG92ZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25zLCBpdGVtcykge1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBhY3Rpb25zO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAxMDA7XG4gICAgICAgIHRoaXMuX29wZW5Pbk92ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgIH1cbiAgICBnZXQgb3Blbk9uT3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5Pbk92ZXI7XG4gICAgfVxuICAgIHNldCBvcGVuT25PdmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9ucygpO1xuICAgICAgICB0aGlzLl9vcGVuT25PdmVyID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBob3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5nZXQodGhpcy5ob3ZlcmVkSWR4KTtcbiAgICB9XG4gICAgc2V0IGhvdmVyZWQoaXRlbSkge1xuICAgICAgICB0aGlzLmhvdmVyZWRJZHggPSBpdGVtID8gaXRlbS5pbmRleCA6IG51bGw7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbnMoKTtcbiAgICB9XG4gICAgb3ZlcihpdGVtKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9ucygoYWN0aW9uKSA9PiBhY3Rpb24ubmFtZSA9PT0gJ29wZW5Pbk92ZXInKTtcbiAgICAgICAgaWYgKCF0aGlzLmhvdmVyZWQgfHwgdGhpcy5ob3ZlcmVkICE9PSBpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VPdGhlcnMoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmhvdmVyZWQgPSBpdGVtO1xuICAgICAgICAgICAgaWYgKChpdGVtLmxldmVsID4gMCB8fCB0aGlzLm9wZW5Pbk92ZXIpICYmICFpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLm9wZW4oaXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb25zKChhY3Rpb24pID0+IChhY3Rpb24ubmFtZSA9PT0gJ2Nsb3NlJyAmJiAoaXRlbSA9PT0gYWN0aW9uLml0ZW0gfHwgdGhpcy5pdGVtcy5oYXNQYXJlbnQoaXRlbSwgYWN0aW9uLml0ZW0pKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGFjdGlvbi5uYW1lID09PSAnb3BlbicgJiYgIXRoaXMuaXRlbXMuaGFzUGFyZW50KGl0ZW0sIGFjdGlvbi5pdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZWF2ZShkaXNhYmxlT3Blbk9uT3Zlcikge1xuICAgICAgICBjb25zdCBob3ZlcmVkID0gdGhpcy5ob3ZlcmVkO1xuICAgICAgICBpZiAoaG92ZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlVG9Sb290KGhvdmVyZWQpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb25zKGFjdGlvbiA9PiBhY3Rpb24ubmFtZSA9PT0gJ29wZW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVPcGVuT25PdmVyICYmIHRoaXMuX29wZW5Pbk92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVEaXNhYmxlT3Blbk9uT3ZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG92ZXJlZCA9IG51bGw7XG4gICAgfVxuICAgIGNsb3NlQ3VycmVudCgpIHtcbiAgICAgICAgY29uc3QgaG92ZXJlZCA9IHRoaXMuaG92ZXJlZDtcbiAgICAgICAgaWYgKGhvdmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5jbG9zZVRvUm9vdChob3ZlcmVkKTtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NoZWR1bGVBY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zLmhhc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgIGl0ZW0uYWN0aW9ucyA9IHRoaXMuYWN0aW9ucy5jbGVhcigpO1xuICAgICAgICAgICAgaXRlbS5pZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5leGVjdXRlKGl0ZW0uYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2hlZHVsZWQoaXRlbSk7XG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVkLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NoZWR1bGVEaXNhYmxlT3Blbk9uT3ZlcigpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIGFjdGlvbnM6IFt7IG5hbWU6ICdvcGVuT25PdmVyJyB9XVxuICAgICAgICB9O1xuICAgICAgICBpdGVtLmlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuT25PdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNjaGVkdWxlZChpdGVtKTtcbiAgICAgICAgfSwgTWF0aC5tYXgodGhpcy5kZWxheSwgRElTQUJMRV9PUEVOX09OX09WRVJfREVMQVkpKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmVtb3ZlU2NoZWR1bGVkKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkID0gdGhpcy5zY2hlZHVsZWQ7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNjaGVkdWxlZC5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVkW2lkeF0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbEFjdGlvbnMocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBmb3IgKGxldCBpZHggPSBzY2hlZHVsZWQubGVuZ3RoIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZWR1bGVkW2lkeF07XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gaXRlbS5hY3Rpb25zO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbklkeCA9IGFjdGlvbnMubGVuZ3RoIC0gMTsgYWN0aW9uSWR4ID49IDA7IGFjdGlvbklkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoYWN0aW9uc1thY3Rpb25JZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2UoYWN0aW9uSWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlIHx8IGFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbkhvdmVyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuSG92ZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQWN0aW9uc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEl0ZW1zU2VydmljZSB9XG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemUgPSAoc2V0dGluZ3MpID0+IHNldHRpbmdzICYmIE9iamVjdC5hc3NpZ24oe1xuICAgIHRvZ2dsZTogJ3NlbGVjdCdcbn0sIHNldHRpbmdzKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE5PREVfSU5ERVggPSAnZGF0YS1rZW5kby1tZW51LWluZGV4JztcblxuY29uc3QgREVGQVVMVF9JRCA9ICdrZW5kby1tYXRjaGVzLWNvbnRhaW5lcic7XG5jb25zdCBmb2N1c2FibGVSZWdleCA9IC9eKD86YXxpbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pO1xuY29uc3QgbWF0Y2hlcyA9IChlbGVtZW50LCBzZWxlY3RvcikgPT4gKGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0ID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzRm9jdXNhYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICAgICAgY29uc3Qgc2tpcFRhYiA9IHRhYkluZGV4ID09PSAnLTEnO1xuICAgICAgICBsZXQgZm9jdXNhYmxlID0gdGFiSW5kZXggIT09IG51bGwgJiYgIXNraXBUYWI7XG4gICAgICAgIGlmIChmb2N1c2FibGVSZWdleC50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICBmb2N1c2FibGUgPSAhZWxlbWVudC5kaXNhYmxlZCAmJiAhc2tpcFRhYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgdG9DbGFzc0xpc3QgPSAoY2xhc3NOYW1lcykgPT4gU3RyaW5nKGNsYXNzTmFtZXMpLnRyaW0oKS5zcGxpdCgnICcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0NsYXNzID0gKGVsZW1lbnQsIG5hbWUpID0+IHtcbiAgICByZXR1cm4gdG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpLmluZGV4T2YobmFtZSkgPj0gMDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hlc0NsYXNzZXMgPSAoY2xhc3NlcykgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSB0b0NsYXNzTGlzdChjbGFzc2VzKTtcbiAgICByZXR1cm4gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gdG9DbGFzc0xpc3QoZWxlbWVudC5jbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihsaXN0LmZpbmQobmFtZSA9PiBjbGFzc0xpc3QuaW5kZXhPZihuYW1lKSA+PSAwKSk7XG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9kZUluZGV4ID0gKG5vZGUpID0+IG5vZGUuZ2V0QXR0cmlidXRlKE5PREVfSU5ERVgpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJdGVtID0gKG5vZGUsIHNjb3BlKSA9PiBjbG9zZXN0SW5TY29wZShub2RlLCBub2RlSW5kZXgsIHNjb3BlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0TGlzdCA9IChub2RlKSA9PiB7XG4gICAgbGV0IGxpc3QgPSBjbG9zZXN0KG5vZGUsIG1hdGNoZXNDbGFzc2VzKCdrLW1lbnUtcG9wdXAgay1tZW51IGstbWVudS1ncm91cCcpKTtcbiAgICBpZiAobGlzdCAmJiBoYXNDbGFzcyhsaXN0LCAnay1tZW51LXBvcHVwJykpIHtcbiAgICAgICAgbGlzdCA9IGxpc3QucXVlcnlTZWxlY3RvcignLmstbWVudS1ncm91cCcpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaW5NZW51ID0gKG5vZGUsIGl0ZW1zU2VydmljZSkgPT4ge1xuICAgIGlmIChub2RlID09PSBpdGVtc1NlcnZpY2UubGlzdHNbMF0uZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdCA9IGNsb3Nlc3RMaXN0KG5vZGUpO1xuICAgIHJldHVybiBsaXN0ICYmIGl0ZW1zU2VydmljZS5jb250YWluc0xpc3QobGlzdCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbmRJbkNvbnRhaW5lciA9IChlbGVtZW50LCBzZWxlY3RvciwgY29udGFpbmVyKSA9PiB7XG4gICAgY29uc3QgaWQgPSBjb250YWluZXIuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmICghaWQpIHtcbiAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCBERUZBVUxUX0lEKTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dFNlbGVjdG9yID0gYCMke2lkIHx8IERFRkFVTFRfSUR9ICR7c2VsZWN0b3J9YDtcbiAgICBjb25zdCBtYXRjaCA9IGNsb3Nlc3RJblNjb3BlKGVsZW1lbnQsIG5vZGUgPT4gbWF0Y2hlcyhub2RlLCBjb250ZXh0U2VsZWN0b3IpLCBjb250YWluZXIpO1xuICAgIGlmICghaWQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbnRleHRNZW51U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2V5ZG93biA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZW1pdChuYW1lLCBhcmdzKSB7XG4gICAgICAgIHRoaXMub3duZXIuZW1pdE1lbnVFdmVudChuYW1lLCBhcmdzKTtcbiAgICB9XG4gICAgaGFzT2JzZXJ2ZXJzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3duZXIgJiYgaGFzT2JzZXJ2ZXJzKHRoaXMub3duZXJbbmFtZV0pO1xuICAgIH1cbiAgICBsZWF2ZU1lbnUoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcyA/ICFpbk1lbnUoZS50YXJnZXQsIHRoaXMuaXRlbXMpIDogdHJ1ZTtcbiAgICB9XG59XG5Db250ZXh0TWVudVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIGZvciB0aGUgTWVudSBpdGVtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19tZW51ICV9KSkuIFRvIGRlZmluZSBhIHRlbXBsYXRlXG4gKiBmb3IgYW4gaXRlbSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb01lbnVJdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLW1lbnUtaXRlbT5gXG4gKiBjb21wb25lbnQuIFRvIGRlZmluZSBhIHRlbXBsYXRlIGZvciBhbGwgTWVudSBpdGVtcywgbmVzdCB0aGUgdGVtcGxhdGUgaW5zaWRlIHRoZSBgPGtlbmRvLW1lbnU+YCBjb21wb25lbnQuXG4gKlxuICogVGhlIGF2YWlsYWJsZSBmaWVsZHMgaW4gdGhlIHRlbXBsYXRlIGNvbnRleHQgYXJlOlxuICogLSBgaXRlbWAmbWRhc2g7VGhlIGl0ZW0gZGF0YS5cbiAqIC0gYGluZGV4YCZtZGFzaDtUaGUgaXRlbSBpbmRleC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLW1lbnU+XG4gKiAgICAgICAgICA8a2VuZG8tbWVudS1pdGVtIHRleHQ9XCJpdGVtMlwiPlxuICogICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb01lbnVJdGVtVGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICBNeSBUZW1wbGF0ZSBmb3I6IHt7IGl0ZW0udGV4dCB9fSBhdCBpbmRleDoge3sgaW5kZXggfX1cbiAqICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tbWVudS1pdGVtPlxuICogICAgICAgIDwva2VuZG8tbWVudT5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBJdGVtVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5JdGVtVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb01lbnVJdGVtVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5JdGVtVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdGVtcGxhdGUgZm9yIHRoZSBsaW5rcyBvZiB0aGUgTWVudSBpdGVtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19tZW51ICV9KSkuIFRvIGRlZmluZSBhIHRlbXBsYXRlXG4gKiBmb3IgYW4gaXRlbSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb01lbnVJdGVtTGlua1RlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby1tZW51LWl0ZW0+YFxuICogY29tcG9uZW50LiBUbyBkZWZpbmUgYSB0ZW1wbGF0ZSBmb3IgYWxsIE1lbnUgaXRlbXMsIG5lc3QgdGhlIHRlbXBsYXRlIGluc2lkZSB0aGUgYDxrZW5kby1tZW51PmAgY29tcG9uZW50LlxuICpcbiAqIFRoZSBhdmFpbGFibGUgZmllbGRzIGluIHRoZSB0ZW1wbGF0ZSBjb250ZXh0IGFyZTpcbiAqIC0gYGl0ZW1gJm1kYXNoO1RoZSBpdGVtIGRhdGEuXG4gKiAtIGBpbmRleGAmbWRhc2g7VGhlIGl0ZW0gaW5kZXguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1tZW51PlxuICogICAgICAgICAgPGtlbmRvLW1lbnUtaXRlbSB0ZXh0PVwiaXRlbTJcIj5cbiAqICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9NZW51SXRlbUxpbmtUZW1wbGF0ZSBsZXQtaXRlbT1cIml0ZW1cIiBsZXQtaW5kZXg9XCJpbmRleFwiPlxuICogICAgICAgICAgICAgICAgICA8c3BhbiBba2VuZG9NZW51SXRlbUxpbmtdPVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIHt7IGl0ZW0udGV4dCB9fVxuICogICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJpdGVtLml0ZW1zICYmIGl0ZW0uaXRlbXMubGVuZ3RoXCIgW2tlbmRvTWVudUV4cGFuZEFycm93XT1cImluZGV4XCI+PC9zcGFuPlxuICogICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tbWVudS1pdGVtPlxuICogICAgICAgIDwva2VuZG8tbWVudT5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBJdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuSXRlbUxpbmtUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvTWVudUl0ZW1MaW5rVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5JdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIGZvciB0aGUgY29udGVudCBvZiB0aGUgTWVudSBpdGVtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19tZW51ICV9KSkuIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsXG4gKiBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvTWVudUl0ZW1Db250ZW50VGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLW1lbnUtaXRlbT5gIGNvbXBvbmVudC5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIGZpZWxkcyBpbiB0aGUgdGVtcGxhdGUgY29udGV4dCBhcmU6XG4gKiAtIGBpdGVtYCZtZGFzaDtUaGUgaXRlbSBkYXRhLlxuICogLSBgaW5kZXhgJm1kYXNoO1RoZSBpdGVtIGluZGV4LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tbWVudT5cbiAqICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0yXCI+XG4gKiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvTWVudUl0ZW1Db250ZW50VGVtcGxhdGUgbGV0LWl0ZW09XCJpdGVtXCIgbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICBNeSBDb250ZW50IFRlbXBsYXRlIGZvcjoge3sgaXRlbS50ZXh0IH19IGF0IGluZGV4OiB7eyBpbmRleCB9fVxuICogICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgPC9rZW5kby1tZW51LWl0ZW0+XG4gKiAgICAgICAgPC9rZW5kby1tZW51PlxuICogICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIEl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5JdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIE1lbnUgaXRlbXNcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXNdKHslIHNsdWcgaXRlbXNfbWVudSAlfSkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tbWVudT5cbiAqICAgICAgICAgIDxrZW5kby1tZW51LWl0ZW0gdGV4dD1cIml0ZW0xXCI+XG4gKiAgICAgICAgICAgICAgPGtlbmRvLW1lbnUtaXRlbSB0ZXh0PVwiaXRlbTEuMVwiIHVybD1cImh0dHBzOi8vZXhhbXBsZS5jb21cIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLW1lbnUtaXRlbT5cbiAqICAgICAgICAgICAgICA8a2VuZG8tbWVudS1pdGVtIHRleHQ9XCJpdGVtMS4yXCIgW2Rpc2FibGVkXT1cInRydWVcIj5cbiAqICAgICAgICAgICAgICA8L2tlbmRvLW1lbnUtaXRlbT5cbiAqICAgICAgICAgIDwva2VuZG8tbWVudS1pdGVtPlxuICogICAgICAgICAgPGtlbmRvLW1lbnUtaXRlbSB0ZXh0PVwiaXRlbTJcIj5cbiAqICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZSBsZXQtaXRlbT1cIml0ZW1cIj5cbiAqICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICBNeSBDb250ZW50IFRlbXBsYXRlOiB7eyBpdGVtLnRleHQgfX1cbiAqICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9NZW51SXRlbVRlbXBsYXRlIGxldC1pdGVtPVwiaXRlbVwiPlxuICogICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwicGFkZGluZzogMTBweDtcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIE15IFRlbXBsYXRlOiB7eyBpdGVtLnRleHQgfX1cbiAqICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tbWVudS1pdGVtPlxuICogICAgICAgICAgPGtlbmRvLW1lbnUtaXRlbSB0ZXh0PVwiaXRlbTNcIj5cbiAqICAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9NZW51SXRlbUxpbmtUZW1wbGF0ZSBsZXQtaXRlbT1cIml0ZW1cIiBsZXQtaW5kZXg9XCJpbmRleFwiPlxuICogICAgICAgICAgICAgICAgICA8c3BhbiBba2VuZG9NZW51SXRlbUxpbmtdPVwiaW5kZXhcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIHt7IGl0ZW0udGV4dCB9fVxuICogICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJpdGVtLml0ZW1zICYmIGl0ZW0uaXRlbXMubGVuZ3RoXCIgW2tlbmRvTWVudUV4cGFuZEFycm93XT1cImluZGV4XCI+PC9zcGFuPlxuICogICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgIDwva2VuZG8tbWVudS1pdGVtPlxuICogICAgICAgIDwva2VuZG8tbWVudT5cbiAqICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBNZW51SXRlbUNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbVRlbXBsYXRlICYmIHRoaXMuaXRlbVRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbVRlbXBsYXRlLmZpcnN0LnRlbXBsYXRlUmVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbGlua1RlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtTGlua1RlbXBsYXRlICYmIHRoaXMuaXRlbUxpbmtUZW1wbGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1MaW5rVGVtcGxhdGUuZmlyc3QudGVtcGxhdGVSZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb250ZW50VGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1Db250ZW50VGVtcGxhdGUgJiYgdGhpcy5pdGVtQ29udGVudFRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbUNvbnRlbnRUZW1wbGF0ZS5maXJzdC50ZW1wbGF0ZVJlZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnRvQXJyYXkoKS5maWx0ZXIoYyA9PiBjICE9PSB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk1lbnVJdGVtQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1tZW51LWl0ZW0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuTWVudUl0ZW1Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdXJsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3NzQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNzc1N0eWxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZXBhcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1UZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbSXRlbVRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgaXRlbUxpbmtUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbSXRlbUxpbmtUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGl0ZW1Db250ZW50VGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0l0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWVudUl0ZW1Db21wb25lbnQsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1lbnVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgTWVudSB3aWxsIGJlIHZlcnRpY2FsIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmVydGljYWxfbWVudSAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgdGhlIHJvb3QgaXRlbXMgY2FuIGJlIG9wZW5lZCBvbmx5IG9uIGNsaWNrXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3BlbmNsb3NlX21lbnUgJX0jdG9jLW9wZW5pbmctb24tY2xpY2spKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3Blbk9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgTWVudSBpdGVtcyBhcmUgb3BlbmVkIG9yIGNsb3NlZCBvbiBpdGVtIGhvdmVyXG4gICAgICAgICAqIG9yIGxlYXZlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3BlbmNsb3NlX21lbnUgJX0jdG9jLWRlbGF5LW9uLWhvdmVyKSkuIFVzZWQgdG8gYXZvaWQgdGhlIGFjY2lkZW50YWxcbiAgICAgICAgICogb3BlbmluZyBvciBjbG9zaW5nIG9mIHRoZSBpdGVtcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG92ZXJEZWxheSA9IDEwMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIE1lbnUgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCByb290SXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zIHx8ICh0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlbi50b0FycmF5KCkgOiBbXSk7XG4gICAgfVxufVxuTWVudUJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaXRlbXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZlcnRpY2FsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcGVuT25DbGljazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaG92ZXJEZWxheTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYW5pbWF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXRlbVRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBpdGVtTGlua1RlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtJdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgY2hpbGRyZW46IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01lbnVJdGVtQ29tcG9uZW50LF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIE1lbnUgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X21lbnUgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1tZW51IFtpdGVtc109XCJpdGVtc1wiPlxuICogICAgICAgIDwva2VuZG8tbWVudT5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIGl0ZW1zOiBhbnlbXSA9IFt7IHRleHQ6ICdpdGVtMScsIGl0ZW1zOiBbeyB0ZXh0OiAnaXRlbTEuMScgfV0gfSwgeyB0ZXh0OiAnaXRlbTInLCBkaXNhYmxlZDogdHJ1ZSB9XTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBNZW51Q29tcG9uZW50IGV4dGVuZHMgTWVudUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zU2VydmljZSwgaG92ZXIsIGFjdGlvbnMsIG5hdmlnYXRpb24sIGxvY2FsaXphdGlvbiwgbmdab25lLCByZW5kZXJlciwgY29udGV4dFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UgPSBpdGVtc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuaG92ZXIgPSBob3ZlcjtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucztcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmF2aWdhdGlvbjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY29udGV4dFNlcnZpY2UgPSBjb250ZXh0U2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBNZW51IGl0ZW0gaXMgc2VsZWN0ZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByb3V0aW5nX21lbnUgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIE1lbnUgaXRlbSBpcyBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgTWVudSBpdGVtIGlzIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5vd25lciA9IHRoaXM7XG4gICAgICAgIGlmIChjb250ZXh0U2VydmljZSkge1xuICAgICAgICAgICAgY29udGV4dFNlcnZpY2UuaXRlbXMgPSB0aGlzLml0ZW1zU2VydmljZTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dEtleURvd25TdWJzY3JpcHRpb24gPSBjb250ZXh0U2VydmljZS5rZXlkb3duLnN1YnNjcmliZSh0aGlzLmNvbnRleHRLZXlEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYXJpYU9yaWVudGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb250ZXh0TWVudUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmNvbnRleHRTZXJ2aWNlKTtcbiAgICB9XG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnRsO1xuICAgIH1cbiAgICBnZXQgcnRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBvciBjbG9zZXMgdGhlIHNwZWNpZmllZCBNZW51IGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW4gLSBBIEJvb2xlYW4gdmFsdWUgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBpdGVtcyB3aWxsIGJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICogQHBhcmFtIGluZGljZXMgLSBPbmUgb3IgbW9yZSB2YWx1ZXMgd2hpY2ggcmVwcmVzZW50IHRoZSBoaWVyYXJjaGljYWwgaW5kaWNlcyBvZiB0aGUgaXRlbXMgdGhhdCB3aWxsIGJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKG9wZW4sIC4uLmluZGljZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgaW5kaWNlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc1NlcnZpY2UuZ2V0KGluZGljZXNbaWR4XSk7XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZm9jdXMoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmZvY3VzSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi52ZXJ0aWNhbCA9IHRoaXMudmVydGljYWw7XG4gICAgICAgIHRoaXMuaG92ZXIuZGVsYXkgPSB0aGlzLmhvdmVyRGVsYXk7XG4gICAgICAgIGlmIChjaGFuZ2VzLm9wZW5PbkNsaWNrKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuT25DbGljayA9IHRoaXMub3Blbk9uQ2xpY2sgPSBub3JtYWxpemUodGhpcy5vcGVuT25DbGljayk7XG4gICAgICAgICAgICB0aGlzLmhvdmVyLm9wZW5Pbk92ZXIgPSAhb3Blbk9uQ2xpY2s7XG4gICAgICAgICAgICBpZiAob3Blbk9uQ2xpY2sgJiYgb3Blbk9uQ2xpY2sudG9nZ2xlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi51cGRhdGVBY3RpdmUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbGljaygpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0U2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0U2VydmljZS5pdGVtcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRLZXlEb3duU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoQ2xvc2VDbGljaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlQ2xpY2tTdWJzY3JpcHRpb24gJiYgaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbk1lbnUoZS50YXJnZXQsIHRoaXMuaXRlbXNTZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3Zlci5vcGVuT25PdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlQ2xpY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRleHRLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW1zU2VydmljZS5oYXNJdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgIGNvbnN0IHJ0bCA9IHRoaXMubG9jYWxpemF0aW9uLnJ0bDtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBrZXlDb2RlID09PSBLZXlzLkFycm93RG93biB8fCBrZXlDb2RlID09PSBLZXlzLkFycm93UmlnaHQ7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBrZXlDb2RlID09PSBLZXlzLkFycm93VXAgfHwga2V5Q29kZSA9PT0gS2V5cy5BcnJvd0xlZnQ7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgaWYgKChmaXJzdCAmJiAhcnRsKSB8fCAobGFzdCAmJiBydGwpKSB7XG4gICAgICAgICAgICBpbmRleCA9ICdmaXJzdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGZpcnN0ICYmIHJ0bCkgfHwgKGxhc3QgJiYgIXJ0bCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gJ2xhc3QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyhpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5NZW51Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb01lbnUnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBJdGVtc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIEFjdGlvbnNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgSG92ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8ubWVudSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTWVudUJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNZW51Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDx1bCByb2xlPVwibWVudWJhclwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLW9yaWVudGF0aW9uXT1cImFyaWFPcmllbnRhdGlvblwiXG4gICAgICAgICAgICBrZW5kb01lbnVMaXN0IFtpdGVtc109XCJyb290SXRlbXNcIiBbbGV2ZWxdPVwiMFwiIGNsYXNzPVwiay13aWRnZXQgay1yZXNldCBrLWhlYWRlciBrLW1lbnVcIlxuICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInZlcnRpY2FsXCIgW3J0bF09XCJydGxcIiBbYW5pbWF0ZV09XCJhbmltYXRlXCIgW29wZW5PbkNsaWNrXT1cIm9wZW5PbkNsaWNrXCJcbiAgICAgICAgICAgIFtpdGVtVGVtcGxhdGVdPVwiaXRlbVRlbXBsYXRlLmZpcnN0Py50ZW1wbGF0ZVJlZiB8fCBtZW51SXRlbVRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtpdGVtTGlua1RlbXBsYXRlXT1cIml0ZW1MaW5rVGVtcGxhdGUuZmlyc3Q/LnRlbXBsYXRlUmVmIHx8IG1lbnVJdGVtTGlua1RlbXBsYXRlXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLW1lbnUtaG9yaXpvbnRhbF09XCIhdmVydGljYWxcIlxuICAgICAgICAgICAgW2NsYXNzLmstbWVudS12ZXJ0aWNhbF09XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICBbY2xhc3Muay1jb250ZXh0LW1lbnVdPVwiY29udGV4dE1lbnVDbGFzc1wiPlxuICAgICAgICA8L3VsPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWVudUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEl0ZW1zU2VydmljZSB9LFxuICAgIHsgdHlwZTogSG92ZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBBY3Rpb25zU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBDb250ZXh0TWVudVNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5NZW51Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG1lbnVJdGVtVGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1lbnVJdGVtTGlua1RlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBvcGVuOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY2xvc2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBkaXJlY3Rpb246IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstcnRsJyxdIH1dXG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpjb21wb25lbnQtc2VsZWN0b3IgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtc1NlcnZpY2UsIGhvdmVyLCBhY3Rpb25zLCBuYXZpZ2F0aW9uLCByZW5kZXJlciwgbmdab25lLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaXRlbXNTZXJ2aWNlID0gaXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhvdmVyID0gaG92ZXI7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5hdmlnYXRpb247XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGhpZXJhcmNoeUluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zU2VydmljZS5pdGVtSW5kZXgodGhpcy5pbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UuYWRkTGlzdCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0RG9tRXZlbnRzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5yZW1vdmVMaXN0KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5kb21TdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0RG9tRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMubGV2ZWwgPiAwID8gY2xvc2VzdChlbGVtZW50LCAobm9kZSkgPT4gaGFzQ2xhc3Mobm9kZSwgJ2stcG9wdXAnKSkgOiBlbGVtZW50O1xuICAgICAgICAgICAgY29uc3Qgb3ZlclN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdtb3VzZW92ZXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWxlbWVudCAmJiB0aGlzLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMubm9kZUl0ZW0oZS50YXJnZXQpIHx8IHRoaXMuaXRlbXNTZXJ2aWNlLmdldCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgISh0aGlzLm9wZW5PbkNsaWNrICYmIHRoaXMub3Blbk9uQ2xpY2sudG9nZ2xlID09PSAnY2xpY2snICYmIGl0ZW0ubGV2ZWwgPT09IDAgJiYgIWl0ZW0uaGFzQ29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG92ZXIub3ZlcihpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbGVhdmVTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihjb250YWluZXIsICdtb3VzZWxlYXZlJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWF2ZXNNZW51KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ZG93blN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsICdrLW1lbnUtaXRlbScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5rZXlkb3duKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYmx1clN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdmb2N1c291dCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzTWVudShlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24uZm9jdXNMZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBvdmVyU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgbGVhdmVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBrZXlkb3duU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgYmx1clN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGNsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmVzTWVudShlKSB7XG4gICAgICAgIGlmICghZS5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWluTWVudShlLnJlbGF0ZWRUYXJnZXQsIHRoaXMuaXRlbXNTZXJ2aWNlKTtcbiAgICB9XG4gICAgb25MZWF2ZSgpIHtcbiAgICAgICAgY29uc3Qgb3Blbk9uQ2xpY2sgPSB0aGlzLm9wZW5PbkNsaWNrO1xuICAgICAgICBpZiAoIW9wZW5PbkNsaWNrIHx8IG9wZW5PbkNsaWNrLnRvZ2dsZSAhPT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdGhpcy5ob3Zlci5sZWF2ZShvcGVuT25DbGljayAmJiBvcGVuT25DbGljay50b2dnbGUgPT09ICdsZWF2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVJdGVtKHRhcmdldCkge1xuICAgICAgICBjb25zdCBub2RlID0gY2xvc2VzdEl0ZW0odGFyZ2V0LCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG5vZGVJbmRleChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zU2VydmljZS5nZXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGlmIChpc0ZvY3VzYWJsZShlLnRhcmdldCkgJiYgIWhhc0NsYXNzKGUudGFyZ2V0LCAnay1tZW51LWl0ZW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm5vZGVJdGVtKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0uaXNDb250ZW50IHx8IGl0ZW0ubmF2aWdhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zLnNlbGVjdChpdGVtLCBlLCAoKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24uZm9jdXMoaXRlbSk7XG4gICAgICAgIGlmIChpdGVtLmxldmVsID4gMCAmJiAhaXRlbS5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuY2xvc2VUb1Jvb3QoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3Blbk9uQ2xpY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyID0gdGhpcy5ob3ZlcjtcbiAgICAgICAgICAgIGlmIChpdGVtLm9wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyLm9wZW5Pbk92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmNsb3NlKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGhvdmVyLm9wZW5Pbk92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5jbG9zZU90aGVycyhpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMub3BlbihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvdmVyLm9wZW5Pbk92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5sZXZlbCA9PT0gMCAmJiB0aGlzLm9wZW5PbkNsaWNrLnRvZ2dsZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyLmNsb3NlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMuZXhlY3V0ZSgpO1xuICAgIH1cbn1cbkxpc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb01lbnVMaXN0XScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtczsgbGV0IGlkeCA9IGluZGV4XCI+XG4gICAgICAgICAgICA8bGkgKm5nSWY9XCIhaXRlbS5zZXBhcmF0b3JcIiBrZW5kb01lbnVJdGVtXG4gICAgICAgICAgICAgICAgW2l0ZW1dPVwiaXRlbVwiIFtsZXZlbF09XCJsZXZlbFwiIFt2ZXJ0aWNhbF09XCJ2ZXJ0aWNhbFwiIFthbmltYXRlXT1cImFuaW1hdGVcIiBbcnRsXT1cInJ0bFwiXG4gICAgICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGVcIiBbaXRlbUxpbmtUZW1wbGF0ZV09XCJpdGVtTGlua1RlbXBsYXRlXCIgW29wZW5PbkNsaWNrXT1cIm9wZW5PbkNsaWNrXCJcbiAgICAgICAgICAgICAgICBbaW5kZXhdPVwiaGllcmFyY2h5SW5kZXgoaWR4KVwiIFtzaWJsaW5nSW5kZXhdPVwiaWR4XCIgW2F0dHIuJHtOT0RFX0lOREVYfV09XCJoaWVyYXJjaHlJbmRleChpZHgpXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJpdGVtLmNzc0NsYXNzXCIgW25nU3R5bGVdPVwiaXRlbS5jc3NTdHlsZVwiXG4gICAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstaXRlbSBrLW1lbnUtaXRlbVwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstZmlyc3RdPVwiaWR4ID09PSAwXCIgW2NsYXNzLmstbGFzdF09XCJpZHggPT09IGl0ZW1zLmxlbmd0aCAtIDFcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRpc2FibGVkXT1cIml0ZW0uZGlzYWJsZWRcIj48L2xpPlxuICAgICAgICAgICAgPGxpICpuZ0lmPVwiaXRlbS5zZXBhcmF0b3JcIiBjbGFzcz1cImstc2VwYXJhdG9yIGstaXRlbVwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInNlcGFyYXRvclwiIFtuZ0NsYXNzXT1cIml0ZW0uY3NzQ2xhc3NcIiBbbmdTdHlsZV09XCJpdGVtLmNzc1N0eWxlXCI+XG4gICAgICAgICAgICAgICAgJm5ic3A7XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxpc3RDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJdGVtc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEhvdmVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogQWN0aW9uc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5hdmlnYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuTGlzdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBpdGVtczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGV2ZWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmltYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2ZXJ0aWNhbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcnRsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcGVuT25DbGljazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXRlbVRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpdGVtTGlua1RlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuY29uc3QgUE9QVVBfQUxJR04gPSB7XG4gICAgdmVydGljYWw6ICd0b3AnLFxuICAgIGhvcml6b250YWw6ICdsZWZ0J1xufTtcbmNvbnN0IFBPUFVQX0FMSUdOX1JUTCA9IHtcbiAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgaG9yaXpvbnRhbDogJ3JpZ2h0J1xufTtcbmNvbnN0IFZFUlRJQ0FMX0NPTExJU0lPTiA9IHtcbiAgICB2ZXJ0aWNhbDogJ2ZsaXAnLFxuICAgIGhvcml6b250YWw6ICdmaXQnXG59O1xuY29uc3QgSE9SSVpPTlRBTF9DT0xMSVNJT04gPSB7XG4gICAgdmVydGljYWw6ICdmaXQnLFxuICAgIGhvcml6b250YWw6ICdmbGlwJ1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBQT1BVUF9TRVRUSU5HU19SVEwgPSB7XG4gICAgdmVydGljYWw6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogJ2JvdHRvbScsXG4gICAgICAgICAgICBob3Jpem9udGFsOiAncmlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgIHBvcHVwOiBQT1BVUF9BTElHTl9SVEwsXG4gICAgICAgIGNvbGxpc2lvbjogVkVSVElDQUxfQ09MTElTSU9OLFxuICAgICAgICBhbmltYXRlOiAnZG93bidcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgICAgICAgICBob3Jpem9udGFsOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXA6IFBPUFVQX0FMSUdOX1JUTCxcbiAgICAgICAgY29sbGlzaW9uOiBIT1JJWk9OVEFMX0NPTExJU0lPTixcbiAgICAgICAgYW5pbWF0ZTogJ2xlZnQnXG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBQT1BVUF9TRVRUSU5HUyA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgIHZlcnRpY2FsOiAnYm90dG9tJyxcbiAgICAgICAgICAgIGhvcml6b250YWw6ICdsZWZ0J1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cDogUE9QVVBfQUxJR04sXG4gICAgICAgIGNvbGxpc2lvbjogVkVSVElDQUxfQ09MTElTSU9OLFxuICAgICAgICBhbmltYXRlOiAnZG93bidcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgICAgICAgICBob3Jpem9udGFsOiAncmlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgIHBvcHVwOiBQT1BVUF9BTElHTixcbiAgICAgICAgY29sbGlzaW9uOiBIT1JJWk9OVEFMX0NPTExJU0lPTixcbiAgICAgICAgYW5pbWF0ZTogJ3JpZ2h0J1xuICAgIH1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZWZpbmVkID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGJvZHlGYWN0b3J5ID0gKCkgPT4ge1xuICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50UmVmKGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbn07XG5cbmNvbnN0IMm1MCQzID0gYm9keUZhY3Rvcnk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpjb21wb25lbnQtc2VsZWN0b3IgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtc1NlcnZpY2UsIG5hdmlnYXRpb24sIGNoYW5nZURldGVjdG9yLCByZW5kZXJlciwgcG9wdXBTZXJ2aWNlLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaXRlbXNTZXJ2aWNlID0gaXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3Blbk9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNldCBpbmRleChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggJiYgdGhpcy5faW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UuYWRkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkSWQgPSB0aGlzLml0ZW1zU2VydmljZS5jaGlsZElkKGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGhhc1BvcHVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDb250ZW50ID8gdHJ1ZSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBleHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29udGVudCA/IHRoaXMub3BlbmVkIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLnRleHQgPyB0aGlzLml0ZW0udGV4dCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBhY3RpdmVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPT09IHRoaXMubmF2aWdhdGlvbi5hY3RpdmVJbmRleCA/ICcwJyA6ICctMSc7XG4gICAgfVxuICAgIGdldCBwb3B1cFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucnRsID8gUE9QVVBfU0VUVElOR1NfUlRMIDogUE9QVVBfU0VUVElOR1M7XG4gICAgICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyBzZXR0aW5ncy5ob3Jpem9udGFsIDogc2V0dGluZ3MudmVydGljYWw7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCB8fCB0aGlzLmxldmVsID4gMDtcbiAgICB9XG4gICAgZ2V0IGhhc0xpbmsoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaXRlbS51cmwpO1xuICAgIH1cbiAgICBnZXQgbGlua1RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLmxpbmtUZW1wbGF0ZSB8fCB0aGlzLml0ZW1MaW5rVGVtcGxhdGU7XG4gICAgfVxuICAgIGdldCBoYXNDb250ZW50KCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbS5pdGVtcztcbiAgICAgICAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCB8fCB0aGlzLml0ZW0uY29udGVudFRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgaXNDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLml0ZW0uY29udGVudCk7XG4gICAgfVxuICAgIGdldCBpY29uQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBgay1pLSR7dGhpcy5pdGVtLmljb259YDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtO1xuICAgICAgICBpZiAoaXRlbS5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50SXRlbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRJdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBpdGVtLmNvbnRlbnRUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJbmRleDogdGhpcy5pbmRleFxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRJdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS5pdGVtcztcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLnRlbXBsYXRlIHx8IHRoaXMuaXRlbVRlbXBsYXRlO1xuICAgIH1cbiAgICBoYXNDb250ZW50VGVtcGxhdGVzKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtVGVtcGxhdGUgfHwgaXRlbS5jb250ZW50VGVtcGxhdGUgfHwgdGhpcy5pdGVtTGlua1RlbXBsYXRlIHx8XG4gICAgICAgICAgICAoaXRlbS5pdGVtcyAmJiBpdGVtLml0ZW1zLmZpbmQoY3VycmVudCA9PiBjdXJyZW50LnRlbXBsYXRlIHx8IGN1cnJlbnQubGlua1RlbXBsYXRlKSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5hZGQodGhpcyk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLml0ZW1zU2VydmljZS5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICB0b2dnbGVBY3RpdmUoaXNBY3RpdmUpIHtcbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLmhhc0NvbnRlbnQgJiYgIXRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwb3B1cFNldHRpbmdzID0gdGhpcy5wb3B1cFNldHRpbmdzO1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0ZSA9IHRoaXMuYW5pbWF0ZSA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYW5pbWF0ZSwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogcG9wdXBTZXR0aW5ncy5hbmltYXRlXG4gICAgICAgICAgICB9KSA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IHRoaXMucG9wdXBTZXJ2aWNlLm9wZW4oe1xuICAgICAgICAgICAgICAgIHBvcHVwQWxpZ246IHBvcHVwU2V0dGluZ3MucG9wdXAsXG4gICAgICAgICAgICAgICAgYW5jaG9yQWxpZ246IHBvcHVwU2V0dGluZ3MuYW5jaG9yLFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogcG9wdXBTZXR0aW5ncy5jb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgYW5jaG9yOiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucG9wdXBUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBwb3B1cENsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICdrLXJ0bCc6IHRoaXMucnRsLFxuICAgICAgICAgICAgICAgICAgICAnay1tZW51LXBvcHVwJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1vd25zJywgdGhpcy5jaGlsZElkKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2FyaWEtb3ducycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5hdmlnYXRlKCkge1xuICAgICAgICBsZXQgbGluaztcbiAgICAgICAgaWYgKHRoaXMubGlua1RlbXBsYXRlKSB7XG4gICAgICAgICAgICBsaW5rID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignYS5rLW1lbnUtbGluaycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzTGluaykge1xuICAgICAgICAgICAgbGluayA9IHRoaXMubGluay5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGluay5jbGljaygpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuSXRlbUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1BvcHVwU2VydmljZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUE9QVVBfQ09OVEFJTkVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogybUwJDNcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51SXRlbV0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gKm5nSWY9XCIhaGFzTGluayAmJiAhaXRlbS5jb250ZW50ICYmICFsaW5rVGVtcGxhdGVcIiBjbGFzcz1cImstbGluayBrLW1lbnUtbGlua1wiICNsaW5rXG4gICAgICAgIFtjbGFzcy5rLXN0YXRlLWFjdGl2ZV09XCJvcGVuZWRcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJpdGVtY29udGVudFwiPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvc3Bhbj5cbiAgICA8YSAqbmdJZj1cIml0ZW0udXJsICYmICFsaW5rVGVtcGxhdGVcIiBjbGFzcz1cImstbGluayBrLW1lbnUtbGlua1wiICNsaW5rIFthdHRyLmhyZWZdPVwiaXRlbS51cmxcIlxuICAgICAgICBbY2xhc3Muay1zdGF0ZS1hY3RpdmVdPVwib3BlbmVkXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIml0ZW1jb250ZW50XCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9hPlxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImxpbmtUZW1wbGF0ZSAmJiAhaXRlbS5jb250ZW50XCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGlua1RlbXBsYXRlXCJcbiAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgaXRlbTogaXRlbSwgaW5kZXg6IGluZGV4IH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImstY29udGVudFwiICpuZ0lmPVwiaXRlbS5jb250ZW50XCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiaXRlbS5jb250ZW50XCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgaXRlbTogaXRlbS5vd25lciwgaW5kZXg6IGl0ZW0ub3duZXJJbmRleCB9XCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG5cbiAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgIDx1bCBrZW5kb01lbnVMaXN0XG4gICAgICAgICAgICBbYXR0ci5pZF09XCJjaGlsZElkXCJcbiAgICAgICAgICAgIFthbmltYXRlXT1cImFuaW1hdGVcIlxuICAgICAgICAgICAgW3J0bF09XCJydGxcIlxuICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIFtvcGVuT25DbGlja109XCJvcGVuT25DbGlja1wiXG4gICAgICAgICAgICBbaXRlbXNdPVwiY2hpbGRyZW5cIlxuICAgICAgICAgICAgW2xldmVsXT1cImxldmVsICsgMVwiXG4gICAgICAgICAgICBbaW5kZXhdPVwiaW5kZXhcIlxuICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGVcIlxuICAgICAgICAgICAgW2l0ZW1MaW5rVGVtcGxhdGVdPVwiaXRlbUxpbmtUZW1wbGF0ZVwiXG4gICAgICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZ3JvdXAgay1tZW51LWdyb3VwIGstcmVzZXRcIj5cbiAgICAgICAgPC91bD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICNpdGVtY29udGVudD5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJpdGVtLmljb25cIiBjbGFzcz1cImstaWNvblwiIFtuZ0NsYXNzXT1cImljb25DbGFzc1wiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L3NwYW4+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhdGVtcGxhdGVcIj5cbiAgICAgICAgICAgIHt7IGl0ZW0udGV4dCB9fVxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwidGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVwiIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7IGl0ZW06IGl0ZW0sIGluZGV4OiBpbmRleCB9XCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstbWVudS1leHBhbmQtYXJyb3dcIiAqbmdJZj1cImhhc0NvbnRlbnRcIlxuICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LTYwLWRvd25dPVwiIWhvcml6b250YWxcIlxuICAgICAgICAgICAgW2NsYXNzLmstaS1hcnJvdy02MC1yaWdodF09XCJob3Jpem9udGFsICYmICFydGxcIlxuICAgICAgICAgICAgW2NsYXNzLmstaS1hcnJvdy02MC1sZWZ0XT1cImhvcml6b250YWwgJiYgcnRsXCI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkl0ZW1Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJdGVtc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5hdmlnYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBQb3B1cFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcbkl0ZW1Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaXRlbTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGV2ZWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaWJsaW5nSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFuaW1hdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZlcnRpY2FsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBydGw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wZW5PbkNsaWNrOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpdGVtVGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1MaW5rVGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxpbms6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydsaW5rJyxdIH1dLFxuICAgIHBvcHVwVGVtcGxhdGU6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydwb3B1cFRlbXBsYXRlJyxdIH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmFyaWEtZGlzYWJsZWQnLF0gfV0sXG4gICAgaGFzUG9wdXA6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1oYXNwb3B1cCcsXSB9XSxcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWV4cGFuZGVkJyxdIH1dLFxuICAgIGxhYmVsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmFyaWEtbGFiZWwnLF0gfV0sXG4gICAgYWN0aXZlSWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGFiaW5kZXgnLF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGRpcmVjdGl2ZSB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBbYGxpbmtUZW1wbGF0ZWBdKHslIHNsdWcgYXBpX21lbnVfaXRlbWxpbmt0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSlcbiAqIG9mIHRoZSBpdGVtcyB0byBhcHBseSB0aGUgZGVmYXVsdCBzdHlsaW5nIGFuZCBiZWhhdmlvci5cbiAqL1xuY2xhc3MgTGlua0RpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaXRlbXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaXRlbXNTZXJ2aWNlID0gaXRlbXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb2xlID0gJ3ByZXNlbnRhdGlvbic7XG4gICAgICAgIHRoaXMudGFiaW5kZXggPSAnLTEnO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0ub3BlbmVkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmICF0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBrZW5kb01lbnVJdGVtTGluayBkaXJlY3RpdmUgcmVxdWlyZXMgdGhlIGl0ZW0gaW5kZXggdG8gYmUgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbSA9IHRoaXMuaXRlbXNTZXJ2aWNlLmdldCh0aGlzLmluZGV4KSB8fCB7fTtcbiAgICB9XG59XG5MaW5rRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51SXRlbUxpbmtdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5MaW5rRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogSXRlbXNTZXJ2aWNlIH1cbl07XG5MaW5rRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb01lbnVJdGVtTGluaycsXSB9XSxcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1saW5rJyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1tZW51LWxpbmsnLF0gfV0sXG4gICAgcm9sZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5yb2xlJyxdIH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLnRhYmluZGV4JyxdIH1dLFxuICAgIGFjdGl2ZUNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWFjdGl2ZScsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlyZWN0aXZlIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIFtgbGlua1RlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfbWVudV9pdGVtbGlua3RlbXBsYXRlZGlyZWN0aXZlICV9KVxuICogb2YgdGhlIGl0ZW1zIHRvIHJlbmRlciB0aGUgZGVmYXVsdCBleHBhbmQgYXJyb3cuXG4gKi9cbmNsYXNzIEV4cGFuZEFycm93RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pdGVtc1NlcnZpY2UgPSBpdGVtc1NlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnJvbGUgPSAncHJlc2VudGF0aW9uJztcbiAgICB9XG4gICAgZ2V0IGFycm93RG93bigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLml0ZW0uaG9yaXpvbnRhbDtcbiAgICB9XG4gICAgZ2V0IGFycm93UmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0uaG9yaXpvbnRhbCAmJiAhdGhpcy5pdGVtLnJ0bDtcbiAgICB9XG4gICAgZ2V0IGFycm93TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5ob3Jpem9udGFsICYmIHRoaXMuaXRlbS5ydGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgIXRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGtlbmRvTWVudUV4cGFuZEFycm93IGRpcmVjdGl2ZSByZXF1aXJlcyB0aGUgaXRlbSBpbmRleCB0byBiZSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtID0gdGhpcy5pdGVtc1NlcnZpY2UuZ2V0KHRoaXMuaW5kZXgpIHx8IHt9O1xuICAgIH1cbn1cbkV4cGFuZEFycm93RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51RXhwYW5kQXJyb3ddJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5FeHBhbmRBcnJvd0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEl0ZW1zU2VydmljZSB9XG5dO1xuRXhwYW5kQXJyb3dEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaW5kZXg6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvTWVudUV4cGFuZEFycm93JyxdIH1dLFxuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWljb24nLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLW1lbnUtZXhwYW5kLWFycm93JyxdIH1dLFxuICAgIHJvbGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XSxcbiAgICBhcnJvd0Rvd246IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstaS1hcnJvdy02MC1kb3duJyxdIH1dLFxuICAgIGFycm93UmlnaHQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstaS1hcnJvdy02MC1yaWdodCcsXSB9XSxcbiAgICBhcnJvd0xlZnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstaS1hcnJvdy02MC1sZWZ0JyxdIH1dXG59O1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZWxlY3RgIGV2ZW50IG9mIHRoZSBNZW51LlxuICovXG5jbGFzcyBNZW51U2VsZWN0RXZlbnQgZXh0ZW5kcyBNZW51RXZlbnQge1xufVxuXG5jb25zdCBJVEVNX0ZJRUxEUyA9IFsndGV4dEZpZWxkJywgJ3VybEZpZWxkJywgJ2ljb25GaWVsZCcsICdkaXNhYmxlZEZpZWxkJywgJ2Nzc0NsYXNzRmllbGQnLCAnY3NzU3R5bGVGaWVsZCcsICdzZXBhcmF0b3JGaWVsZCddO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEJpbmRpbmdEaXJlY3RpdmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihtZW51KSB7XG4gICAgICAgIHRoaXMubWVudSA9IG1lbnU7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnJlYmluZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmViaW5kcyB0aGUgTWVudSBpdGVtcy5cbiAgICAgKi9cbiAgICByZWJpbmQoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IElURU1fRklFTERTLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0TmFtZSA9IElURU1fRklFTERTW2lkeF07XG4gICAgICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gdGhpc1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCh7IHRhcmdldDogaW5wdXROYW1lLnJlcGxhY2UoJ0ZpZWxkJywgJycpLCBzb3VyY2U6IGlucHV0VmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW51Lml0ZW1zID0gdGhpcy5kYXRhID8gdGhpcy5tYXBJdGVtcyh0aGlzLmRhdGEpIDogW107XG4gICAgfVxufVxuXG5jb25zdCBGSUVMRF9SRUdFWCA9IC9cXFsoPzooXFxkKyl8WydcIl0oLio/KVsnXCJdKVxcXXwoKD86KD8hXFxbLio/XFxdfFxcLikuKSspL2c7XG5jb25zdCBnZXR0ZXJDYWNoZSA9IHt9O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN0cmluZy1saXRlcmFsXG5nZXR0ZXJDYWNoZVsndW5kZWZpbmVkJ10gPSAob2JqKSA9PiBvYmo7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0dGVyID0gKGZpZWxkKSA9PiB7XG4gICAgaWYgKGdldHRlckNhY2hlW2ZpZWxkXSkge1xuICAgICAgICByZXR1cm4gZ2V0dGVyQ2FjaGVbZmllbGRdO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBmaWVsZC5yZXBsYWNlKEZJRUxEX1JFR0VYLCAoX21hdGNoLCBpbmRleCwgaW5kZXhBY2Nlc3NvciwgbmFtZSkgPT4ge1xuICAgICAgICBmaWVsZHMucHVzaChpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggOiAoaW5kZXhBY2Nlc3NvciB8fCBuYW1lKSk7XG4gICAgfSk7XG4gICAgZ2V0dGVyQ2FjaGVbZmllbGRdID0gKG9iaikgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gb2JqO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBmaWVsZHMubGVuZ3RoICYmIHJlc3VsdDsgaWR4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtmaWVsZHNbaWR4XV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBnZXR0ZXJDYWNoZVtmaWVsZF07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxhc3QgPSAoYXJyKSA9PiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuXG5jb25zdCBnZXRGaWVsZCA9IChmaWVsZCwgbGV2ZWwpID0+IEFycmF5LmlzQXJyYXkoZmllbGQpID8gZmllbGRbbGV2ZWxdIHx8IGxhc3QoZmllbGQpIDogZmllbGQ7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbnB1dC1yZW5hbWUgKi9cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBjb252ZXJ0cyB0aGUgcHJvdmlkZWQgaGllcmFyY2hpY2FsIGRhdGEgdG8gW01lbnVJdGVtc10oeyUgc2x1ZyBhcGlfbWVudV9tZW51aXRlbSAlfSkgYW5kIGJpbmRzIHRoZW0gdG8gdGhlIE1lbnUuXG4gKi9cbmNsYXNzIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUgZXh0ZW5kcyBCaW5kaW5nRGlyZWN0aXZlQmFzZSB7XG4gICAgY29uc3RydWN0b3IobWVudSkge1xuICAgICAgICBzdXBlcihtZW51KTtcbiAgICB9XG4gICAgbWFwSXRlbXMoaXRlbXMsIGxldmVsID0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlSXRlbShpdGVtLCBsZXZlbCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oaXRlbSwgbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbWVudUl0ZW0uaXRlbXMgPSB0aGlzLm1hcEl0ZW1zKGNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbnVJdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlSXRlbShpdGVtLCBsZXZlbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IGl0ZW0gfTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGZpZWxkcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldCwgc291cmNlIH0gPSBmaWVsZHNbaWR4XTtcbiAgICAgICAgICAgIHJlc3VsdFt0YXJnZXRdID0gZ2V0dGVyKGdldEZpZWxkKHNvdXJjZSwgbGV2ZWwpKShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbihpdGVtLCBsZXZlbCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbkZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKHRoaXMuY2hpbGRyZW5GaWVsZCwgbGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bZmllbGRdO1xuICAgICAgICB9XG4gICAgfVxufVxuSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9NZW51SGllcmFyY2h5QmluZGluZycsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51SGllcmFyY2h5QmluZGluZ10nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBNZW51QmFzZSB9XG5dO1xuSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogW1wia2VuZG9NZW51SGllcmFyY2h5QmluZGluZ1wiLF0gfV0sXG4gICAgdGV4dEZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB1cmxGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaWNvbkZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZEZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjc3NDbGFzc0ZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjc3NTdHlsZUZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZXBhcmF0b3JGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hpbGRyZW5GaWVsZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAqL1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnZlcnRzIHRoZSBwcm92aWRlZCBmbGF0IGRhdGEgdG8gW01lbnVJdGVtc10oeyUgc2x1ZyBhcGlfbWVudV9tZW51aXRlbSAlfSkgYW5kIGJpbmRzIHRoZW0gdG8gdGhlIE1lbnUuXG4gKi9cbmNsYXNzIEZsYXRCaW5kaW5nRGlyZWN0aXZlIGV4dGVuZHMgQmluZGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG1lbnUpIHtcbiAgICAgICAgc3VwZXIobWVudSk7XG4gICAgfVxuICAgIG1hcEl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5pZEZpZWxkIHx8ICF0aGlzLnBhcmVudElkRmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNyZWF0ZUl0ZW0oaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgaXRlbXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2lkeF07XG4gICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlSXRlbShpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ2V0dGVyKHRoaXMuaWRGaWVsZCkoaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGdldHRlcih0aGlzLnBhcmVudElkRmllbGQpKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSBudWxsIHx8IHBhcmVudElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZW51SXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBtYXBbcGFyZW50SWRdID0gbWFwW3BhcmVudElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaXRlbXMgPSBwYXJlbnQuaXRlbXMgfHwgW107XG4gICAgICAgICAgICAgICAgcGFyZW50Lml0ZW1zLnB1c2gobWVudUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcFtpZF0pIHtcbiAgICAgICAgICAgICAgICBtZW51SXRlbS5pdGVtcyA9IG1hcFtpZF0uaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBbaWRdID0gbWVudUl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY3JlYXRlSXRlbShkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IGRhdGFJdGVtIH07XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBmaWVsZHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCB9ID0gZmllbGRzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbdGFyZ2V0XSA9IGdldHRlcihzb3VyY2UpKGRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbkZsYXRCaW5kaW5nRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb01lbnVGbGF0QmluZGluZycsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9NZW51RmxhdEJpbmRpbmddJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GbGF0QmluZGluZ0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE1lbnVCYXNlIH1cbl07XG5GbGF0QmluZGluZ0RpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogW1wia2VuZG9NZW51RmxhdEJpbmRpbmdcIixdIH1dLFxuICAgIHRleHRGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdXJsRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb25GaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWRGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3NzQ2xhc3NGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3NzU3R5bGVGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VwYXJhdG9yRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlkRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhcmVudElkRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBDT01QT05FTlRfRVhQT1JUUyA9IFtcbiAgICBNZW51Q29tcG9uZW50LFxuICAgIE1lbnVJdGVtQ29tcG9uZW50LFxuICAgIEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJdGVtTGlua1RlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSxcbiAgICBGbGF0QmluZGluZ0RpcmVjdGl2ZSxcbiAgICBMaW5rRGlyZWN0aXZlLFxuICAgIEV4cGFuZEFycm93RGlyZWN0aXZlXG5dO1xuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMgPSBbXG4gICAgLi4uQ09NUE9ORU5UX0VYUE9SVFMsXG4gICAgTGlzdENvbXBvbmVudCxcbiAgICBJdGVtQ29tcG9uZW50XG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgTWVudSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgTWVudSBtb2R1bGVcbiAqIGltcG9ydCB7IE1lbnVNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1tZW51JztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICogaW1wb3J0IHsgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUsIE1lbnVNb2R1bGVdLCAvLyBpbXBvcnQgTWVudSBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIE1lbnVNb2R1bGUge1xufVxuTWVudU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRVhQT1JUU10sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1BvcHVwTW9kdWxlLCBDb21tb25Nb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyBvZiB0aGUgQ29udGV4dE1lbnUuXG4gKi9cbmNsYXNzIENvbnRleHRNZW51RXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZWxlY3RgIGV2ZW50IG9mIHRoZSBDb250ZXh0TWVudS5cbiAqL1xuY2xhc3MgQ29udGV4dE1lbnVTZWxlY3RFdmVudCBleHRlbmRzIENvbnRleHRNZW51RXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBwb3B1cE9wZW5gIGFuZCBgcG9wdXBDbG9zZWAgZXZlbnRzIG9mIHRoZSBDb250ZXh0TWVudS5cbiAqL1xuY2xhc3MgQ29udGV4dE1lbnVQb3B1cEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIGZvciB0aGUgY29udGVudCBvZiB0aGUgQ29udGV4dE1lbnUuIFRvIGRlZmluZSBhIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YFxuICogdGFnIHdpdGggdGhlIGBrZW5kb0NvbnRleHRNZW51VGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLWNvbnRleHRtZW51PmAgY29tcG9uZW50XG4gKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzXSh7JSBzbHVnIHRlbXBsYXRlc19jb250ZXh0bWVudSAlfSkpLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjIwMCAlfVxuICogeyUgZW1iZWRfZmlsZSBjb250ZXh0LW1lbnUvdGVtcGxhdGUvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbnRleHQtbWVudS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIENvbnRleHRNZW51VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Db250ZXh0TWVudVRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Db250ZXh0TWVudVRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29udGV4dE1lbnVUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29udGV4dE1lbnVJdGVtc1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFNlcnZpY2UgPSBjb250ZXh0U2VydmljZTtcbiAgICB9XG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRTZXJ2aWNlLml0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0U2VydmljZS5pdGVtcy5nZXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufVxuQ29udGV4dE1lbnVJdGVtc1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbnRleHRNZW51SXRlbXNTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ29udGV4dE1lbnVTZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb250ZXh0TWVudVRhcmdldFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICB9XG4gICAgYWRkKHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZW1vdmUodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcbiAgICAgICAgdGhpcy50YXJnZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGZpbmQodGFyZ2V0RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzLmZpbmQodGFyZ2V0ID0+IHRhcmdldC5lbGVtZW50ID09PSB0YXJnZXRFbGVtZW50KTtcbiAgICB9XG59XG5Db250ZXh0TWVudVRhcmdldFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgY29udGFpbmVyIGZvciB0aGUgW3RhcmdldHNdKHslIHNsdWcgYXBpX21lbnVfY29udGV4dG1lbnV0YXJnZXRkaXJlY3RpdmUgJX0pIG9mIHRoZSBDb250ZXh0TWVudS5cbiAqL1xuY2xhc3MgQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCB0YXJnZXRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0U2VydmljZSA9IHRhcmdldFNlcnZpY2U7XG4gICAgICAgIGlmIChlbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5Db250ZXh0TWVudVRhcmdldENvbnRhaW5lckRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXInLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NvbnRleHRNZW51VGFyZ2V0U2VydmljZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBDb250ZXh0TWVudVRhcmdldFNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFRBUkdFVF9DTEFTUyA9ICdrLWNvbnRleHRtZW51LXRhcmdldCc7XG4vKipcbiAqIFNwZWNpZmllcyBhIFt0YXJnZXRdKHslIHNsdWcgYXBpX21lbnVfY29udGV4dG1lbnV0YXJnZXRkaXJlY3RpdmUgJX0pIGZvciB0aGUgQ29udGV4dE1lbnVcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGFyZ2V0X2NvbnRleHRtZW51ICV9I3RvYy1kaXJlY3RpdmVzKSkuXG4gKi9cbmNsYXNzIENvbnRleHRNZW51VGFyZ2V0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCB0YXJnZXRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0U2VydmljZSA9IHRhcmdldFNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIGlmIChlbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0U2VydmljZS5hZGQodGhpcyk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRhcmdldFNlcnZpY2UucmVtb3ZlKHRoaXMpO1xuICAgIH1cbn1cbkNvbnRleHRNZW51VGFyZ2V0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Db250ZXh0TWVudVRhcmdldF0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9Db250ZXh0TWVudVRhcmdldCdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29udGV4dE1lbnVUYXJnZXREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBDb250ZXh0TWVudVRhcmdldFNlcnZpY2UgfVxuXTtcbkNvbnRleHRNZW51VGFyZ2V0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvQ29udGV4dE1lbnVUYXJnZXQnLF0gfV0sXG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogW2BjbGFzcy4ke1RBUkdFVF9DTEFTU31gLF0gfV1cbn07XG5cbmNvbnN0IENPTlRFWFRfTUVOVSA9ICdjb250ZXh0bWVudSc7XG5jb25zdCBERUZBVUxUX0FOQ0hPUl9BTElHTiA9IHsgaG9yaXpvbnRhbDogJ2xlZnQnLCB2ZXJ0aWNhbDogJ2JvdHRvbScgfTtcbmNvbnN0IERFRkFVTFRfUE9QVVBfQUxJR04gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICd0b3AnIH07XG5jb25zdCBERUZBVUxUX0NPTExJU0lPTiA9IHsgaG9yaXpvbnRhbDogJ2ZpdCcsIHZlcnRpY2FsOiAnZmxpcCcgfTtcbmNvbnN0IHByZXZlbnREZWZhdWx0ID0gZSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5jb25zdCDJtTEkMiA9IGJvZHlGYWN0b3J5O1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgQ29udGV4dE1lbnUgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2NvbnRleHRtZW51ICV9KS5cbiAqXG4gKiB7JSBtZXRhIGhlaWdodDoyMDAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29udGV4dC1tZW51L2Jhc2ljL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvY29udGV4dG1lbnUtaXRlbXMudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29udGV4dC1tZW51L2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgQ29udGV4dE1lbnVDb21wb25lbnQgZXh0ZW5kcyBNZW51QmFzZSB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCBzZXJ2aWNlLCBuZ1pvbmUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBldmVudCBvbiB3aGljaCB0aGUgQ29udGV4dE1lbnUgd2lsbCBvcGVuIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2hvd29uX2NvbnRleHRtZW51ICV9KSkuXG4gICAgICAgICAqIEFjY2VwdHMgdGhlIG5hbWUgb2YgYSBuYXRpdmUgRE9NIGV2ZW50LiBEZWZhdWx0cyB0byBgY29udGV4dG1lbnVgIHdoaWNoIG9wZW5zIHRoZSBDb250ZXh0TWVudSBmb3IgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93T24gPSBDT05URVhUX01FTlU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgQ29udGV4dE1lbnUgd2lsbCBiZSBhbGlnbmVkIHRvIHRoZSB0YXJnZXQgb3IgdG8gdGhlIGBmaWx0ZXJgIGVsZW1lbnQgKGlmIHNwZWNpZmllZCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsaWduVG9BbmNob3IgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgTWVudSB3aWxsIGJlIHZlcnRpY2FsbHkgcmVuZGVyZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvcmllbnRhdGlvbl9jb250ZXh0bWVudSAlfSkpLlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIE1lbnUgaXMgb3BlbmVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGFyZ2V0X2NvbnRleHRtZW51ICV9I3RvYy1jaGFuZ2luZy1pdGVtcy1mb3Itc3BlY2lmaWVkLXRhcmdldHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9wdXBPcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgTWVudSBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcHVwQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgTWVudSBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGEgTWVudSBpdGVtIGlzIG9wZW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBNZW51IGl0ZW0gaXMgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm93bmVyID0gdGhpcztcbiAgICAgICAgdGhpcy5wb3B1cEtleURvd25IYW5kbGVyID0gdGhpcy5wb3B1cEtleURvd25IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBDb250ZXh0TWVudS5cbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBDb250ZXh0TWVudSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBvZmZzZXQgb3IgdGhlIHRhcmdldCBlbGVtZW50IGZvciB3aGljaCB0aGUgQ29udGV4dE1lbnUgd2lsbCBvcGVuLlxuICAgICAqL1xuICAgIHNob3codGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvd1RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICAgICAgICBpZiAoZGVmaW5lZChzaG93VGFyZ2V0LmxlZnQpICYmIGRlZmluZWQoc2hvd1RhcmdldC50b3ApKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcHVwKHsgb2Zmc2V0OiBzaG93VGFyZ2V0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gc2hvd1RhcmdldC5uYXRpdmVFbGVtZW50IHx8IHNob3dUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcHVwKHsgYW5jaG9yOiB0aGlzLmN1cnJlbnRUYXJnZXQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy50YXJnZXQgfHwgY2hhbmdlcy5zaG93T24pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFNob3dIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlQ2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnbW91c2Vkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3B1cFJlZiAmJiAhY2xvc2VzdChlLnRhcmdldCwgbm9kZSA9PiBub2RlID09PSB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudCkgJiYgdGhpcy5zZXJ2aWNlLmxlYXZlTWVudShlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUG9wdXAoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZUJsdXJTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbignd2luZG93JywgJ2JsdXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvc2VDbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGNsb3NlQmx1clN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmJpbmRTaG93SGFuZGxlcigpO1xuICAgICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBlbWl0TWVudUV2ZW50KG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgYXJncy50YXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGFyZ3Muc2VuZGVyID0gdGhpcztcbiAgICAgICAgdGhpc1tuYW1lXS5lbWl0KGFyZ3MpO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3NlbGVjdCcgJiYgIWFyZ3MuaGFzQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFuZEZvY3VzKGFyZ3Mub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZFNob3dIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnVuYmluZFNob3dIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IHRoaXMuc2hvd09uIHx8IENPTlRFWFRfTUVOVTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1N1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsIHRoaXMuc2hvd09uIHx8IENPTlRFWFRfTUVOVSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dDb250ZXh0TWVudShlLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gQ09OVEVYVF9NRU5VKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlkb3duU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IEtleXMuRjEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dDb250ZXh0TWVudShlLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2hvd0NvbnRleHRNZW51KGUsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy50YXJnZXRGaWx0ZXIoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBlbGVtZW50O1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gZmluZEluQ29udGFpbmVyKGUudGFyZ2V0LCBmaWx0ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgY3VycmVudFRhcmdldCAhPT0gZS50YXJnZXQgJiYgaXNGb2N1c2FibGUoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgdGhpcy5kaXJlY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gdGhpcy50YXJnZXQudGFyZ2V0U2VydmljZS5maW5kKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcHVwKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2VQb3B1cChlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bmJpbmRTaG93SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvd1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zaG93U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmtleWRvd25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMua2V5ZG93blN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5rZXlkb3duU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXRFbGVtZW50KCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIG1heWJlIHF1ZXJ5U2VsZWN0b3JBbGw/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ICYmIHRhcmdldC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb250ZXh0TWVudVRhcmdldENvbnRhaW5lckRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZVRhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgdGFyZ2V0RmlsdGVyKCkge1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBgLiR7VEFSR0VUX0NMQVNTfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgIH1cbiAgICBjbG9zZVBvcHVwKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXBBY3Rpb24oJ3BvcHVwQ2xvc2UnLCBlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVQb3B1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3B1cFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlblBvcHVwKGUpIHtcbiAgICAgICAgdGhpcy5wb3B1cEFjdGlvbigncG9wdXBPcGVuJywgZSwgKCkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciwgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ25Ub0FuY2hvciB8fCBlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRoaXMuY3VycmVudFRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB7IGxlZnQ6IGUucGFnZVgsIHRvcDogZS5wYWdlWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVQb3B1cCh7IGFuY2hvciwgb2Zmc2V0IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUG9wdXAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3BlbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGFuaW1hdGU6IGRlZmluZWQodGhpcy5wb3B1cEFuaW1hdGUpID8gdGhpcy5wb3B1cEFuaW1hdGUgOiB0cnVlLFxuICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMuYXBwZW5kVG8sXG4gICAgICAgICAgICBjb2xsaXNpb246IHRoaXMuY29sbGlzaW9uIHx8IERFRkFVTFRfQ09MTElTSU9OLFxuICAgICAgICAgICAgcG9wdXBBbGlnbjogdGhpcy5wb3B1cEFsaWduIHx8IERFRkFVTFRfUE9QVVBfQUxJR04sXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogdGhpcy5hbmNob3JBbGlnbiB8fCBERUZBVUxUX0FOQ0hPUl9BTElHTixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFRlbXBsYXRlID8gdGhpcy5jb250ZW50VGVtcGxhdGUudGVtcGxhdGVSZWYgOiB0aGlzLmRlZmF1bHRDb250ZW50VGVtcGxhdGUsXG4gICAgICAgICAgICBwb3B1cENsYXNzOiAnay1tZW51LXBvcHVwJ1xuICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCAnay1jb250ZXh0LW1lbnUtcG9wdXAnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ291dGxpbmUnLCAnMCcpOyAvL3Bvc3NpYmx5IG1vdmUgdG8gc3R5bGVzXG4gICAgICAgIGlmICh0aGlzLmFyaWFMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2FyaWEtbGFiZWwnLCB0aGlzLmFyaWFMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXRFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmJpbmRLZXlEb3duID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLnBvcHVwS2V5RG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgY29uc3QgdW5iaW5kQ29udGV4dG1lbnUgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwU3Vic2NyaXB0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bmJpbmRLZXlEb3duKCk7XG4gICAgICAgICAgICAgICAgdW5iaW5kQ29udGV4dG1lbnUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIGNsb3NlQW5kRm9jdXMoZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0RWxlbWVudDtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlUG9wdXAoZSkgJiYgdGhpcy5hY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3B1cEtleURvd25IYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50O1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLZXlzLkVzY2FwZSAmJiAoaGFzQ2xhc3MoZS50YXJnZXQsICdrLW1lbnUtaXRlbScpIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFuZEZvY3VzKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUudGFyZ2V0ID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2Uua2V5ZG93bi5lbWl0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvcHVwQWN0aW9uKG5hbWUsIG9yaWdpbmFsRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzW25hbWVdO1xuICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnMoZW1pdHRlcikpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IG5ldyBDb250ZXh0TWVudVBvcHVwRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghYXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ZW50ZWQgPSBhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2ZW50ZWQ7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGFyZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aXZlVGFyZ2V0ICYmIHRoaXMuY3VycmVudFRhcmdldCA/IHRoaXMuY3VycmVudFRhcmdldC5lbGVtZW50IDogdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgIH1cbn1cbkNvbnRleHRNZW51Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0NvbnRleHRNZW51JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1lbnVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY29udGV4dG1lbnUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEl0ZW1zU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBDb250ZXh0TWVudUl0ZW1zU2VydmljZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBNZW51QmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbnRleHRNZW51Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBQb3B1cFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFBPUFVQX0NPTlRBSU5FUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IMm1MSQyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY29udGV4dG1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdD5cbiAgICAgICAgICAgIDxrZW5kby1tZW51IFtpdGVtc109XCJyb290SXRlbXNcIlxuICAgICAgICAgICAgICAgIFt2ZXJ0aWNhbF09XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICAgICAgW29wZW5PbkNsaWNrXT1cIm9wZW5PbkNsaWNrXCJcbiAgICAgICAgICAgICAgICBbaG92ZXJEZWxheV09XCJob3ZlckRlbGF5XCJcbiAgICAgICAgICAgICAgICBbYW5pbWF0ZV09XCJhbmltYXRlXCJcbiAgICAgICAgICAgICAgICBbbWVudUl0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGUuZmlyc3Q/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICBbbWVudUl0ZW1MaW5rVGVtcGxhdGVdPVwiaXRlbUxpbmtUZW1wbGF0ZS5maXJzdD8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgID48L2tlbmRvLW1lbnU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db250ZXh0TWVudUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFBvcHVwU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29udGV4dE1lbnVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuQ29udGV4dE1lbnVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc2hvd09uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YXJnZXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWxpZ25Ub0FuY2hvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmVydGljYWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvcHVwQW5pbWF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcG9wdXBBbGlnbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYW5jaG9yQWxpZ246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbGxpc2lvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYXBwZW5kVG86IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFyaWFMYWJlbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcG9wdXBPcGVuOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcG9wdXBDbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlbGVjdDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9wZW46IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRlbnRUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbQ29udGV4dE1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGRlZmF1bHRDb250ZW50VGVtcGxhdGU6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydkZWZhdWx0JyxdIH1dXG59O1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyQxID0gW1xuICAgIENvbnRleHRNZW51Q29tcG9uZW50LFxuICAgIENvbnRleHRNZW51VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQ29udGV4dE1lbnVUYXJnZXREaXJlY3RpdmUsXG4gICAgQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJEaXJlY3RpdmVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBDb250ZXh0TWVudSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgQ29udGV4dE1lbnUgbW9kdWxlXG4gKiBpbXBvcnQgeyBDb250ZXh0TWVudU1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLW1lbnUnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgQ29udGV4dE1lbnVNb2R1bGVdLCAvLyBpbXBvcnQgQ29udGV4dE1lbnVNb2R1bGUgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBDb250ZXh0TWVudU1vZHVsZSB7XG59XG5Db250ZXh0TWVudU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVMkMV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTJDEsIE1lbnVNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtQb3B1cE1vZHVsZSwgQ29tbW9uTW9kdWxlLCBNZW51TW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEEgW21vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgdGhhdCBpbmNsdWRlcyB0aGUgTWVudSBhbmQgQ29udGV4dE1lbnUgY29tcG9uZW50cyBhbmQgZGlyZWN0aXZlcy5cbiAqIEltcG9ydHMgdGhlIE1lbnVzTW9kdWxlIGludG8geW91ciBhcHBsaWNhdGlvbiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19I2FuZ3VsYXItbW9kdWxhcml0eSlcbiAqIG9yIGFueSBvdGhlciBzdWItbW9kdWxlIHRoYXQgd2lsbCB1c2UgdGhlIE1lbnUgYW5kIENvbnRleHRNZW51IGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqIGltcG9ydCB7IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJztcbiAqIGltcG9ydCB7IE1lbnVzTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbWVudSc7XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF0sXG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgTWVudXNNb2R1bGVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgTWVudXNNb2R1bGUge1xufVxuTWVudXNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZW51TW9kdWxlLCBDb250ZXh0TWVudU1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBOT0RFX0lOREVYLCBDb250ZXh0TWVudUl0ZW1zU2VydmljZSwgQ29udGV4dE1lbnVUYXJnZXRDb250YWluZXJEaXJlY3RpdmUsIENvbnRleHRNZW51VGFyZ2V0RGlyZWN0aXZlLCBDb250ZXh0TWVudVRhcmdldFNlcnZpY2UsIEJpbmRpbmdEaXJlY3RpdmVCYXNlLCBNZW51QmFzZSwgUHJldmVudGFibGVFdmVudCwgQWN0aW9uc1NlcnZpY2UsIEhvdmVyU2VydmljZSwgSXRlbXNTZXJ2aWNlLCBOYXZpZ2F0aW9uU2VydmljZSwgYm9keUZhY3RvcnksIE1lbnVDb21wb25lbnQsIExpc3RDb21wb25lbnQsIEl0ZW1Db21wb25lbnQsIExpbmtEaXJlY3RpdmUsIEV4cGFuZEFycm93RGlyZWN0aXZlLCBNZW51SXRlbUNvbXBvbmVudCwgTWVudUV2ZW50LCBNZW51U2VsZWN0RXZlbnQsIEl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUsIEl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSwgSXRlbUxpbmtUZW1wbGF0ZURpcmVjdGl2ZSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSwgRmxhdEJpbmRpbmdEaXJlY3RpdmUsIE1lbnVNb2R1bGUsIENvbnRleHRNZW51RXZlbnQsIENvbnRleHRNZW51U2VsZWN0RXZlbnQsIENvbnRleHRNZW51UG9wdXBFdmVudCwgQ29udGV4dE1lbnVUZW1wbGF0ZURpcmVjdGl2ZSwgQ29udGV4dE1lbnVDb21wb25lbnQsIENvbnRleHRNZW51TW9kdWxlLCBDb250ZXh0TWVudVNlcnZpY2UsIE1lbnVzTW9kdWxlIH07XG4iXX0=