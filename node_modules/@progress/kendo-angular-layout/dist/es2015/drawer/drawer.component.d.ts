/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, EventEmitter, OnDestroy } from '@angular/core';
import { DrawerMode, DrawerPosition, DrawerAnimation } from './types';
import { DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective } from './template-directives';
import { DrawerSelectEvent } from './events/select-event';
import { AnimationBuilder } from '@angular/animations';
import { DrawerService } from './drawer.service';
import { LocalizationService } from '@progress/kendo-angular-l10n';
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-drawer-container>
 *             <kendo-drawer #drawer
 *                  [items]="items"
 *                  [mode]="'overlay'"
 *                  [(expanded)]="expanded">
 *              </kendo-drawer>
 *              <kendo-drawer-content>
 *                  <button class="k-button" (click)="drawer.toggle()">Open the Drawer</button>
 *              </kendo-drawer-content>
 *        </kendo-drawer-container>
 *    `
 * })
 * class AppComponent {
 *    public expanded = false;
 *
 *    public items: any[] = [
 *      { text: 'Inbox', icon: 'k-i-inbox' },
 *      { text: 'Notifications', icon: 'k-i-bell' },
 *      { text: 'Date', icon: 'k-i-calendar' }
 *    ];
 * }
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class DrawerComponent implements OnDestroy {
    private element;
    private builder;
    private localizationService;
    private drawerService;
    hostClasses: boolean;
    readonly startPositionClass: boolean;
    readonly endPositionClass: boolean;
    readonly overlayTransofrmStyles: string;
    readonly flexStyles: number;
    /**
     * Specifies the mode in which the Drawer will be displayed.
     *
     * The possible values are:
     * * (Default) `overlay`
     * * `push`
     */
    mode: DrawerMode;
    /**
     * Specifies the position of the Drawer
     * ([see example]({% slug positioning_drawer %})).
     *
     * The possible values are:
     * * (Default) `start`
     * * `end`
     */
    position: DrawerPosition;
    /**
     * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed
     * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
     */
    mini: boolean;
    /**
     * Specifies the state of the Drawer.
     */
    expanded: boolean;
    /**
     * Defines the width of the Drawer when it is expanded.
     * Defaults to `240`.
     */
    width: number;
    /**
     * Defines the width of the Drawer when the mini view is enabled
     * and the component is collapsed. Defaults to `60`.
     */
    miniWidth: number;
    /**
     * Specifies if the Drawer will be automatically collapsed when an item
     * or the overlay is clicked. Defaults to `true`.
     */
    autoCollapse: boolean;
    /**
     * The collection of items that will be rendered in the Drawer.
     */
    items: any[];
    /**
     * @hidden
     */
    direction: string;
    /**
     * Specifies the animation settings of the Drawer.
     * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
     *
     * The possible values are:
     * * Boolean
     *    * (Default) `true`
     *    * `false`
     * * `DrawerAnimation`
     *    * (Default) `type?: 'slide'`
     *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.
     */
    animation?: boolean | DrawerAnimation;
    /**
     * Fires when the Drawer is expanded and its animation is complete.
     */
    expand: EventEmitter<any>;
    /**
     * Fires when the Drawer is collapsed and its animation is complete.
     */
    collapse: EventEmitter<any>;
    /**
     * Fires when a Drawer item is selected. This event is preventable.
     */
    select: EventEmitter<DrawerSelectEvent>;
    /**
     * Fires when the `expanded` property of the component was updated.
     * Used to provide a two-way binding for the `expanded` property.
     */
    expandedChange: EventEmitter<boolean>;
    /**
     * @hidden
     */
    drawerTemplate: DrawerTemplateDirective;
    /**
     * @hidden
     */
    footerTemplate: DrawerFooterTemplateDirective;
    /**
     * @hidden
     */
    headerTemplate: DrawerHeaderTemplateDirective;
    /**
     * @hidden
     */
    itemTemplate: DrawerItemTemplateDirective;
    private animationEnd;
    private dynamicRTLSubscription;
    private rtl;
    private _items;
    constructor(element: ElementRef, builder: AnimationBuilder, localizationService: LocalizationService, drawerService: DrawerService);
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    readonly minimized: boolean;
    /**
     * @hidden
     */
    readonly drawerWidth: number;
    /**
     * Toggles the visibility of the Drawer.
     *
     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.
     */
    toggle(expanded?: boolean): void;
    private onAnimationEnd;
    private setExpanded;
    private animate;
    private createPlayer;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DrawerComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DrawerComponent, "kendo-drawer", ["kendoDrawer"], { "mode": "mode"; "position": "position"; "mini": "mini"; "expanded": "expanded"; "width": "width"; "miniWidth": "miniWidth"; "autoCollapse": "autoCollapse"; "animation": "animation"; "items": "items"; }, { "expand": "expand"; "collapse": "collapse"; "select": "select"; "expandedChange": "expandedChange"; }, ["drawerTemplate", "footerTemplate", "headerTemplate", "itemTemplate"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJkcmF3ZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRHJhd2VyTW9kZSwgRHJhd2VyUG9zaXRpb24sIERyYXdlckFuaW1hdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgRHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUsIERyYXdlckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSwgRHJhd2VySGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIERyYXdlckZvb3RlclRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi90ZW1wbGF0ZS1kaXJlY3RpdmVzJztcbmltcG9ydCB7IERyYXdlclNlbGVjdEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvc2VsZWN0LWV2ZW50JztcbmltcG9ydCB7IEFuaW1hdGlvbkJ1aWxkZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IERyYXdlclNlcnZpY2UgfSBmcm9tICcuL2RyYXdlci5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERyYXdlciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfZHJhd2VyICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tZHJhd2VyLWNvbnRhaW5lcj5cbiAqICAgICAgICAgICAgIDxrZW5kby1kcmF3ZXIgI2RyYXdlclxuICogICAgICAgICAgICAgICAgICBbaXRlbXNdPVwiaXRlbXNcIlxuICogICAgICAgICAgICAgICAgICBbbW9kZV09XCInb3ZlcmxheSdcIlxuICogICAgICAgICAgICAgICAgICBbKGV4cGFuZGVkKV09XCJleHBhbmRlZFwiPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZHJhd2VyPlxuICogICAgICAgICAgICAgIDxrZW5kby1kcmF3ZXItY29udGVudD5cbiAqICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cImRyYXdlci50b2dnbGUoKVwiPk9wZW4gdGhlIERyYXdlcjwvYnV0dG9uPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZHJhd2VyLWNvbnRlbnQ+XG4gKiAgICAgICAgPC9rZW5kby1kcmF3ZXItY29udGFpbmVyPlxuICogICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICBwdWJsaWMgZXhwYW5kZWQgPSBmYWxzZTtcbiAqXG4gKiAgICBwdWJsaWMgaXRlbXM6IGFueVtdID0gW1xuICogICAgICB7IHRleHQ6ICdJbmJveCcsIGljb246ICdrLWktaW5ib3gnIH0sXG4gKiAgICAgIHsgdGV4dDogJ05vdGlmaWNhdGlvbnMnLCBpY29uOiAnay1pLWJlbGwnIH0sXG4gKiAgICAgIHsgdGV4dDogJ0RhdGUnLCBpY29uOiAnay1pLWNhbGVuZGFyJyB9XG4gKiAgICBdO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERyYXdlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbGVtZW50O1xuICAgIHByaXZhdGUgYnVpbGRlcjtcbiAgICBwcml2YXRlIGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgcHJpdmF0ZSBkcmF3ZXJTZXJ2aWNlO1xuICAgIGhvc3RDbGFzc2VzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHN0YXJ0UG9zaXRpb25DbGFzczogYm9vbGVhbjtcbiAgICByZWFkb25seSBlbmRQb3NpdGlvbkNsYXNzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IG92ZXJsYXlUcmFuc29mcm1TdHlsZXM6IHN0cmluZztcbiAgICByZWFkb25seSBmbGV4U3R5bGVzOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBtb2RlIGluIHdoaWNoIHRoZSBEcmF3ZXIgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIChEZWZhdWx0KSBgb3ZlcmxheWBcbiAgICAgKiAqIGBwdXNoYFxuICAgICAqL1xuICAgIG1vZGU6IERyYXdlck1vZGU7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgRHJhd2VyXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwb3NpdGlvbmluZ19kcmF3ZXIgJX0pKS5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogKERlZmF1bHQpIGBzdGFydGBcbiAgICAgKiAqIGBlbmRgXG4gICAgICovXG4gICAgcG9zaXRpb246IERyYXdlclBvc2l0aW9uO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIG1pbmkgKGNvbXBhY3QpIHZpZXcgb2YgdGhlIERyYXdlciB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNvbGxhcHNlZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhwYW5kbW9kZXNwb3NpdGlvbnNfZHJhd2VyICV9I3RvYy1taW5pLXZpZXcpKS5cbiAgICAgKi9cbiAgICBtaW5pOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgc3RhdGUgb2YgdGhlIERyYXdlci5cbiAgICAgKi9cbiAgICBleHBhbmRlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB3aWR0aCBvZiB0aGUgRHJhd2VyIHdoZW4gaXQgaXMgZXhwYW5kZWQuXG4gICAgICogRGVmYXVsdHMgdG8gYDI0MGAuXG4gICAgICovXG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB3aWR0aCBvZiB0aGUgRHJhd2VyIHdoZW4gdGhlIG1pbmkgdmlldyBpcyBlbmFibGVkXG4gICAgICogYW5kIHRoZSBjb21wb25lbnQgaXMgY29sbGFwc2VkLiBEZWZhdWx0cyB0byBgNjBgLlxuICAgICAqL1xuICAgIG1pbmlXaWR0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBpZiB0aGUgRHJhd2VyIHdpbGwgYmUgYXV0b21hdGljYWxseSBjb2xsYXBzZWQgd2hlbiBhbiBpdGVtXG4gICAgICogb3IgdGhlIG92ZXJsYXkgaXMgY2xpY2tlZC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAqL1xuICAgIGF1dG9Db2xsYXBzZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBpdGVtcyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIERyYXdlci5cbiAgICAgKi9cbiAgICBpdGVtczogYW55W107XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRpcmVjdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIHNldHRpbmdzIG9mIHRoZSBEcmF3ZXIuXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpbnRlcmFjdGlvbl9kcmF3ZXIgJX0jdG9jLXRvZ2dsaW5nLWJldHdlZW4tc3RhdGVzKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIEJvb2xlYW5cbiAgICAgKiAgICAqIChEZWZhdWx0KSBgdHJ1ZWBcbiAgICAgKiAgICAqIGBmYWxzZWBcbiAgICAgKiAqIGBEcmF3ZXJBbmltYXRpb25gXG4gICAgICogICAgKiAoRGVmYXVsdCkgYHR5cGU/OiAnc2xpZGUnYFxuICAgICAqICAgICogYGR1cmF0aW9uYCZtZGFzaDtBY2NlcHRzIGEgbnVtYmVyIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gYDMwMG1zYC5cbiAgICAgKi9cbiAgICBhbmltYXRpb24/OiBib29sZWFuIHwgRHJhd2VyQW5pbWF0aW9uO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIERyYXdlciBpcyBleHBhbmRlZCBhbmQgaXRzIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBleHBhbmQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIERyYXdlciBpcyBjb2xsYXBzZWQgYW5kIGl0cyBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgY29sbGFwc2U6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gYSBEcmF3ZXIgaXRlbSBpcyBzZWxlY3RlZC4gVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS5cbiAgICAgKi9cbiAgICBzZWxlY3Q6IEV2ZW50RW1pdHRlcjxEcmF3ZXJTZWxlY3RFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgYGV4cGFuZGVkYCBwcm9wZXJ0eSBvZiB0aGUgY29tcG9uZW50IHdhcyB1cGRhdGVkLlxuICAgICAqIFVzZWQgdG8gcHJvdmlkZSBhIHR3by13YXkgYmluZGluZyBmb3IgdGhlIGBleHBhbmRlZGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgZXhwYW5kZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZHJhd2VyVGVtcGxhdGU6IERyYXdlclRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb290ZXJUZW1wbGF0ZTogRHJhd2VyRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhlYWRlclRlbXBsYXRlOiBEcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXRlbVRlbXBsYXRlOiBEcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgcHJpdmF0ZSBhbmltYXRpb25FbmQ7XG4gICAgcHJpdmF0ZSBkeW5hbWljUlRMU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgcnRsO1xuICAgIHByaXZhdGUgX2l0ZW1zO1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsIGxvY2FsaXphdGlvblNlcnZpY2U6IExvY2FsaXphdGlvblNlcnZpY2UsIGRyYXdlclNlcnZpY2U6IERyYXdlclNlcnZpY2UpO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IG1pbmltaXplZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVhZG9ubHkgZHJhd2VyV2lkdGg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBEcmF3ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwYW5kZWQ/IC0gQm9vbGVhbi4gU3BlY2lmaWVzIGlmIHRoZSBEcmF3ZXIgd2lsbCBiZSBleHBhbmRlZCBvciBjb2xsYXBzZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKGV4cGFuZGVkPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHJpdmF0ZSBvbkFuaW1hdGlvbkVuZDtcbiAgICBwcml2YXRlIHNldEV4cGFuZGVkO1xuICAgIHByaXZhdGUgYW5pbWF0ZTtcbiAgICBwcml2YXRlIGNyZWF0ZVBsYXllcjtcbn1cbiJdfQ==