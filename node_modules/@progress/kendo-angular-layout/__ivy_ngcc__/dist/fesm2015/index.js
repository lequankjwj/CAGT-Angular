/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable, Directive, TemplateRef, Optional, isDevMode, Component, SkipSelf, Host, ElementRef, Input, ViewChild, HostBinding, ViewChildren, ContentChildren, EventEmitter, Output, ContentChild, HostListener, Renderer2, ChangeDetectorRef, NgZone, Inject, QueryList, ViewEncapsulation, NgModule, forwardRef } from '@angular/core';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { Keys, hasObservers, DraggableDirective, DraggableModule } from '@progress/kendo-angular-common';
import { trigger, state, style, transition, animate, AUTO_STYLE, AnimationBuilder } from '@angular/animations';
import { Subject, BehaviorSubject, Subscription, of } from 'rxjs';
import { take, tap, filter, switchMap, delay, takeUntil, map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { ProgressBarModule } from '@progress/kendo-angular-progressbar';

/**
 * Represents the expand modes of the PanelBar.
 * By default, the expand mode is set to `multiple`.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@progress/kendo-angular-common';
import * as ɵngcc4 from '@angular/animations';
import * as ɵngcc5 from '@progress/kendo-angular-progressbar';

const _c0 = ["header"];
const _c1 = ["contentWrapper"];
function PanelBarItemComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.iconClasses);
} }
function PanelBarItemComponent_img_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "img", 8);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("src", ctx_r2.imageUrl, ɵngcc0.ɵɵsanitizeUrl);
} }
function PanelBarItemComponent_ng_template_5_Template(rf, ctx) { }
function PanelBarItemComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span");
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-icon", true)("k-i-arrow-n", ctx_r4.expanded)("k-panelbar-collapse", ctx_r4.expanded)("k-i-arrow-s", !ctx_r4.expanded)("k-panelbar-expand", !ctx_r4.expanded);
} }
function PanelBarItemComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r7.contentOverflow)("height", ctx_r7.contentHeight);
} }
function PanelBarItemComponent_div_7_div_3_ng_template_1_Template(rf, ctx) { }
const _c2 = function (a0, a1, a2, a3, a4, a5) { return { title: a0, id: a1, icon: a2, imageUrl: a3, disabled: a4, content: a5 }; };
const _c3 = function (a0) { return { $implicit: a0 }; };
function PanelBarItemComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_3_ng_template_1_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r8.contentOverflow)("height", ctx_r8.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r8.contentTemplate.first.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(13, _c3, ɵngcc0.ɵɵpureFunction6(6, _c2, ctx_r8.title, ctx_r8.id, ctx_r8.icon, ctx_r8.imageUrl, ctx_r8.disabled, ctx_r8.content)));
} }
function PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-panelbar-item", 17);
} if (rf & 2) {
    const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r14 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("title", item_r13.title)("id", item_r13.id)("icon", item_r13.icon)("iconClass", item_r13.iconClass)("imageUrl", item_r13.imageUrl)("selected", !!item_r13.selected)("expanded", !!item_r13.expanded)("disabled", !!item_r13.disabled)("template", ctx_r14.template)("items", item_r13.children)("content", item_r13.content);
} }
function PanelBarItemComponent_div_7_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_kendo_panelbar_item_1_Template, 1, 11, "kendo-panelbar-item", 16);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r13 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r13.hidden);
} }
function PanelBarItemComponent_div_7_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_4_ng_container_1_Template, 2, 1, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r9.contentOverflow)("height", ctx_r9.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r9.items);
} }
function PanelBarItemComponent_div_7_div_5_ng_template_1_Template(rf, ctx) { }
function PanelBarItemComponent_div_7_div_5_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r17.content);
} }
function PanelBarItemComponent_div_7_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, PanelBarItemComponent_div_7_div_5_ng_template_1_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_5_ng_template_2_Template, 1, 1, "ng-template", 18);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("overflow", ctx_r10.contentOverflow)("height", ctx_r10.contentHeight);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r10.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(14, _c3, ɵngcc0.ɵɵpureFunction6(7, _c2, ctx_r10.title, ctx_r10.id, ctx_r10.icon, ctx_r10.imageUrl, ctx_r10.disabled, ctx_r10.content)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r10.template);
} }
function PanelBarItemComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", null, 9);
    ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_div_7_div_2_Template, 2, 4, "div", 10);
    ɵngcc0.ɵɵtemplate(3, PanelBarItemComponent_div_7_div_3_Template, 2, 15, "div", 11);
    ɵngcc0.ɵɵtemplate(4, PanelBarItemComponent_div_7_div_4_Template, 2, 5, "div", 10);
    ɵngcc0.ɵɵtemplate(5, PanelBarItemComponent_div_7_div_5_Template, 3, 16, "div", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@toggle", ctx_r5.state);
    ɵngcc0.ɵɵattribute("role", "group")("aria-hidden", !ctx_r5.disabled && !ctx_r5.expanded);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.hasChildItems && !(ctx_r5.items == null ? null : ctx_r5.items.length));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.hasContent && !ctx_r5.content);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.hasItems);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.content);
} }
const _c4 = [[["kendo-panelbar-item"]]];
const _c5 = ["kendo-panelbar-item"];
function PanelBarComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "contentChildItems && !items"]);
} }
function PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-panelbar-item", 4);
} if (rf & 2) {
    const item_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("title", item_r3.title)("id", item_r3.id)("icon", item_r3.icon)("iconClass", item_r3.iconClass)("imageUrl", item_r3.imageUrl)("selected", !!item_r3.selected)("expanded", !!item_r3.expanded)("disabled", !!item_r3.disabled)("template", ctx_r4.templateRef)("items", item_r3.children)("content", item_r3.content);
} }
function PanelBarComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_ng_container_0_kendo_panelbar_item_1_Template, 1, 11, "kendo-panelbar-item", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r3.hidden);
} }
function PanelBarComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, PanelBarComponent_ng_template_1_ng_container_0_Template, 2, 1, "ng-container", 2);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.items);
} }
function SplitterPaneComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SplitterPaneComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 2);
} }
const _c6 = ["*"];
function SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-splitter-bar", 2);
} if (rf & 2) {
    const index_r2 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("index", index_r2)("orientation", ctx_r4.orientation);
} }
function SplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, SplitterComponent_ng_container_1_kendo_splitter_bar_1_Template, 1, 2, "kendo-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r3 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r3);
} }
const _c7 = [[["kendo-splitter-pane"]]];
const _c8 = ["kendo-splitter-pane"];
const _c9 = ["tablist"];
const _c10 = ["tabHeadingContainer"];
function TabStripComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_0_ng_container_2_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    const _r4 = ɵngcc0.ɵɵreference(5);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
} }
function TabStripComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function TabStripComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r4 = ɵngcc0.ɵɵreference(5);
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function TabStripComponent_ng_template_2_li_2_ng_template_4_Template(rf, ctx) { }
function TabStripComponent_ng_template_2_li_2_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 7, 8);
    ɵngcc0.ɵɵlistener("click", function TabStripComponent_ng_template_2_li_2_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); const i_r13 = ctx.index; const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.onTabClick($event, i_r13); });
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵtemplate(4, TabStripComponent_ng_template_2_li_2_ng_template_4_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r12 = ctx.$implicit;
    const i_r13 = ctx.index;
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp("k-item", true)("k-state-default", true)("k-state-active", tab_r12.active)("k-state-disabled", tab_r12.disabled);
    ɵngcc0.ɵɵproperty("id", ctx_r11.tabId(i_r13))("tabIndex", tab_r12.active ? 0 : 0 - 1)("ngClass", tab_r12.cssClass);
    ɵngcc0.ɵɵattribute("aria-selected", tab_r12.active)("aria-controls", ctx_r11.tabPanelId(i_r13))("aria-disabled", tab_r12.disabled);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(tab_r12.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r12.tabTitle == null ? null : tab_r12.tabTitle.templateRef);
} }
function TabStripComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ul", 4, 5);
    ɵngcc0.ɵɵlistener("keydown", function TabStripComponent_ng_template_2_Template_ul_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.onKeyDown($event); });
    ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_template_2_li_2_Template, 5, 16, "li", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("justify-content", ctx_r3.tabsAlignment);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.tabs);
} }
function TabStripComponent_ng_template_4_ng_template_0_div_0_ng_template_1_Template(rf, ctx) { }
function TabStripComponent_ng_template_4_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_template_4_ng_template_0_div_0_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = ɵngcc0.ɵɵnextContext();
    const tab_r21 = ctx_r25.$implicit;
    const i_r22 = ctx_r25.index;
    const ctx_r23 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@state", tab_r21.active && ctx_r23._animate ? "active" : "inactive")("ngClass", ctx_r23.contentClass(tab_r21.active))("tabIndex", 0)("id", ctx_r23.tabPanelId(i_r22));
    ɵngcc0.ɵɵattribute("aria-hidden", !tab_r21.active)("aria-expanded", tab_r21.active)("aria-labelledby", ctx_r23.tabId(i_r22))("aria-disabled", tab_r21.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r21.tabContent == null ? null : tab_r21.tabContent.templateRef);
} }
function TabStripComponent_ng_template_4_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_template_4_ng_template_0_div_0_Template, 2, 9, "div", 12);
} if (rf & 2) {
    const tab_r21 = ctx.$implicit;
    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r21.active || ctx_r20.keepTabContent);
} }
function TabStripComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_template_4_ng_template_0_Template, 1, 1, "ng-template", 11);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.tabs);
} }
function DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_ng_container_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.headerTemplate == null ? null : ctx_r3.headerTemplate.templateRef);
} }
function DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_ng_container_1_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.footerTemplate == null ? null : ctx_r4.footerTemplate.templateRef);
} }
function DrawerComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_1_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelement(2, "ul", 3);
    ɵngcc0.ɵɵtemplate(3, DrawerComponent_div_0_ng_container_1_3_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("items", ctx_r1.items)("mini", ctx_r1.mini)("expanded", ctx_r1.expanded)("itemTemplate", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.footerTemplate);
} }
function DrawerComponent_div_0_2_ng_template_0_Template(rf, ctx) { }
function DrawerComponent_div_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.drawerTemplate == null ? null : ctx_r2.drawerTemplate.templateRef);
} }
function DrawerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtemplate(1, DrawerComponent_div_0_ng_container_1_Template, 4, 6, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, DrawerComponent_div_0_2_Template, 1, 1, undefined, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.drawerWidth, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.drawerTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.drawerTemplate);
} }
function DrawerContainerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("click", function DrawerContainerComponent_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.closeDrawer(); });
    ɵngcc0.ɵɵelementEnd();
} }
var I18N_11;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text for the optional segment of the step label
     * @meaning kendo.stepper.optional
     */ 
    const MSG_EXTERNAL_9222129954657106830$$DIST_FESM2015_INDEX_JS_12 = goog.getMsg("Optional");
    I18N_11 = MSG_EXTERNAL_9222129954657106830$$DIST_FESM2015_INDEX_JS_12;
}
else {
    I18N_11 = $localize `:kendo.stepper.optional|The text for the optional segment of the step label␟5662ca90a1b7d36b2f55d6e21c0f4f7e166291af␟9222129954657106830:Optional`;
}
const _c13 = ["optional", I18N_11];
function StepperComponent_kendo_progressbar_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-progressbar", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("animation", ctx_r0.progressAnimation)("max", ctx_r0.steps.length - 1)("label", false)("orientation", ctx_r0.orientation)("reverse", !ctx_r0.isHorizontal)("value", ctx_r0.currentStep)("ngStyle", ctx_r0.progressBarStyling);
    ɵngcc0.ɵɵattribute("aria-hidden", true);
} }
function AvatarComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "customAvatar"]);
} }
function AvatarComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r1.imageUrl, ɵngcc0.ɵɵdefaultStyleSanitizer);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r1.cssStyle);
} }
function AvatarComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r2.cssStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.initials.substring(0, 2));
} }
function AvatarComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r3.cssStyle)("ngClass", ctx_r3.iconClasses());
} }
function CardActionsComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!actions"]);
} }
function CardActionsComponent_ng_container_1_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function CardActionsComponent_ng_container_1_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const action_r4 = ctx.$implicit; const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onClick(action_r4); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r4 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("k-primary", action_r4.primary)("k-flat", action_r4.flat);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", action_r4.text, " ");
} }
function CardActionsComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_button_1_Template, 2, 5, "button", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.actions);
} }
function CardActionsComponent_2_ng_template_0_Template(rf, ctx) { }
function CardActionsComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, CardActionsComponent_2_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.actions);
} }
const _c14 = ["kendoDrawerItem", ""];
function DrawerItemComponent_0_ng_template_0_Template(rf, ctx) { }
function DrawerItemComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.itemTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx_r0.item));
} }
function DrawerItemComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementStart(2, "span", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r4.iconClasses(ctx_r4.item.icon));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.item.text);
} }
function DrawerItemComponent_ng_template_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r5.iconClasses(ctx_r5.item.icon));
} }
function DrawerItemComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_ng_template_1_ng_container_0_Template, 4, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_ng_container_1_Template, 2, 1, "ng-container", 3);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.expanded);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.mini && !ctx_r2.expanded);
} }
const _c15 = ["kendoDrawerList", ""];
function DrawerListComponent_ng_container_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 3);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const item_r1 = ctx_r5.$implicit;
    const idx_r2 = ctx_r5.index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("item", item_r1)("index", idx_r2)("mini", ctx_r3.mini)("expanded", ctx_r3.expanded)("itemTemplate", ctx_r3.itemTemplate)("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-drawer-index", idx_r2);
} }
function DrawerListComponent_ng_container_0_li_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵtext(1, " \u00A0 ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngClass", item_r1.cssClass)("ngStyle", item_r1.cssStyle);
} }
function DrawerListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, DrawerListComponent_ng_container_0_li_1_Template, 1, 8, "li", 1);
    ɵngcc0.ɵɵtemplate(2, DrawerListComponent_ng_container_0_li_2_Template, 2, 2, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r1.separator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r1.separator);
} }
const _c16 = ["stepLink"];
const _c17 = ["kendoStepperStep", ""];
function StepperStepComponent_2_ng_template_0_Template(rf, ctx) { }
const _c18 = function (a0, a1) { return { $implicit: a0, index: a1 }; };
function StepperStepComponent_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, StepperStepComponent_2_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.stepTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c18, ctx_r1.step, ctx_r1.index));
} }
function StepperStepComponent_ng_container_3_span_1_1_ng_template_0_Template(rf, ctx) { }
function StepperStepComponent_ng_container_3_span_1_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, StepperStepComponent_ng_container_3_span_1_1_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.indicatorTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c18, ctx_r6.step, ctx_r6.index));
} }
function StepperStepComponent_ng_container_3_span_1_ng_container_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r9.indicatorIconClasses);
} }
function StepperStepComponent_ng_container_3_span_1_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.indicatorText);
} }
function StepperStepComponent_ng_container_3_span_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_ng_container_2_span_1_Template, 1, 1, "span", 7);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_1_ng_container_2_span_2_Template, 2, 1, "span", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.showIndicatorIcon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r7.showIndicatorIcon);
} }
function StepperStepComponent_ng_container_3_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_1_Template, 1, 5, undefined, 2);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_1_ng_container_2_Template, 3, 2, "ng-container", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("transition-duration", ctx_r4.transitionDuration, "ms");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.indicatorTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.indicatorTemplate);
} }
function StepperStepComponent_ng_container_3_span_2_1_ng_template_0_Template(rf, ctx) { }
function StepperStepComponent_ng_container_3_span_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, StepperStepComponent_ng_container_3_span_2_1_ng_template_0_Template, 0, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r11.labelTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c18, ctx_r11.step, ctx_r11.index));
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 15);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.step.label);
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 16);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r15.validationIconClasses);
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("(", ctx_r16.optionalText, ")");
} }
function StepperStepComponent_ng_container_3_span_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_1_Template, 2, 1, "span", 12);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_2_Template, 1, 1, "span", 13);
    ɵngcc0.ɵɵtemplate(3, StepperStepComponent_ng_container_3_span_2_ng_container_2_span_3_Template, 2, 1, "span", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.showLabelText);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.showLabelIcon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r12.step.optional);
} }
function StepperStepComponent_ng_container_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_2_1_Template, 1, 5, undefined, 2);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_ng_container_2_Template, 4, 3, "ng-container", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.labelTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.labelTemplate);
} }
function StepperStepComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, StepperStepComponent_ng_container_3_span_1_Template, 3, 4, "span", 4);
    ɵngcc0.ɵɵtemplate(2, StepperStepComponent_ng_container_3_span_2_Template, 3, 2, "span", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showIndicator);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showLabel);
} }
const _c19 = ["kendoStepperList", ""];
function StepperListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "li", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const step_r1 = ctx.$implicit;
    const idx_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r0.maxStepWidth, "%")("max-height", ctx_r0.maxStepHeight, "%");
    ɵngcc0.ɵɵclassProp("k-step-first", idx_r2 === 0)("k-step-last", idx_r2 === ctx_r0.steps.length - 1)("k-step-done", idx_r2 < ctx_r0.currentStep)("k-step-current", idx_r2 === ctx_r0.currentStep)("k-step-optional", step_r1.optional)("k-step-disabled", step_r1.disabled);
    ɵngcc0.ɵɵproperty("type", ctx_r0.stepType)("step", step_r1)("index", idx_r2)("current", ctx_r0.currentStep)("successIcon", ctx_r0.successIcon)("errorIcon", ctx_r0.errorIcon)("indicatorTemplate", ctx_r0.indicatorTemplate)("labelTemplate", ctx_r0.labelTemplate)("stepTemplate", ctx_r0.stepTemplate)("ngClass", step_r1.cssClass)("ngStyle", step_r1.cssStyle);
    ɵngcc0.ɵɵattribute("data-kendo-stepper-index", idx_r2);
} }
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is coll.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * By default, the expand mode is set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
let nextPanelbarId = 0;
/**
 * @hidden
 */
class PanelBarService {
    constructor() {
        this.parentSource = new Subject();
        this.keepContentSource = new BehaviorSubject(false);
        this.childSource = new Subject();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    onKeepContent(keepContent) {
        this.keepContentSource.next(keepContent);
    }
    onSelect(event) {
        this.childSource.next(event);
    }
    onFocus() {
        this.parentSource.next(true);
    }
    onBlur() {
        this.parentSource.next(false);
    }
}
PanelBarService.ɵfac = function PanelBarService_Factory(t) { return new (t || PanelBarService)(); };
PanelBarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PanelBarService, factory: PanelBarService.ɵfac });
/** @nocollapse */
PanelBarService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Represents the content template of the declaratively initialized PanelBar items.
 * The content can be expanded or collapsed through the item.
 */
class PanelBarContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarContentDirective.ɵfac = function PanelBarContentDirective_Factory(t) { return new (t || PanelBarContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
PanelBarContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanelBarContentDirective, selectors: [["", "kendoPanelBarContent", ""]] });
/** @nocollapse */
PanelBarContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarContentDirective, [{
        type: Directive,
        args: [{
                selector: "[kendoPanelBarContent]"
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Represents the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *        <kendo-panelbar>
 *            <kendo-panelbar-item [title]="'Paris'" [expanded]="true">
 *                <ng-template kendoPanelBarItemTitle>
 *                    Additional Content
 *                </ng-template>
 *            </kendo-panelbar-item>
 *        </kendo-panelbar>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class PanelBarItemTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarItemTitleDirective.ɵfac = function PanelBarItemTitleDirective_Factory(t) { return new (t || PanelBarItemTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PanelBarItemTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanelBarItemTitleDirective, selectors: [["", "kendoPanelBarItemTitle", ""]] });
/** @nocollapse */
PanelBarItemTitleDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarItemTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPanelBarItemTitle]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

let nextId = 0;
const parsePanelBarItems = (data) => {
    return data.map((item) => {
        if (!item.id) {
            item.id = `default-${nextId++}`;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
var util = {
    parsePanelBarItems
};
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
const hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
const closestInScope = (target, targetAttr, predicate, scope) => {
    while (target && target !== scope && !predicate(target, targetAttr)) {
        target = target.parentNode;
    }
    if (target !== scope) {
        return target;
    }
};
/**
 * @hidden
 */
const itemIndex = (item, indexAttr) => +item.getAttribute(indexAttr);
const hasItemIndex = (item, indexAttr) => isPresent(item.getAttribute(indexAttr));
/**
 * @hidden
 */
const closestItem = (target, targetAttr, scope) => closestInScope(target, targetAttr, hasItemIndex, scope);

/**
 * @hidden
 */
let nextId$1 = 0;
/**
 * Represents the items of the PanelBar.
 */
class PanelBarItemComponent {
    constructor(parent, eventService, element) {
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        /**
         * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).
         */
        this.title = 'Untitled';
        /**
         * Allows the component to set the `"id"` property to each item.
         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
         */
        this.id = `default-${nextId$1++}`;
        /**
         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.icon = '';
        /**
         * Defines  the icon that will be rendered next to the title by using a custom CSS class
         * ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.iconClass = '';
        /**
         * Defines the location of the image that will be displayed next to the title
         * ([see example]({% slug items_panelbar %}#toc-title-images)).
         */
        this.imageUrl = '';
        /**
         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
         */
        this.disabled = false;
        /**
         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
         */
        this.selected = false;
        this.keepContent = false;
        this.hasChildItems = false;
        this.hasItems = false;
        this.hasContent = false;
        this.state = "inactive";
        this.role = "treeitem";
        this.titleAttribute = null; // tslint:disable-line
        this.focused = false;
        this.wrapperFocused = false;
        this.subscriptions = new Subscription(() => { });
        this._expanded = false;
        this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));
        this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));
        this.wrapperFocused = parent ? parent.focused : false;
    }
    /**
     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
     */
    set expanded(value) {
        const activeState = this.animate ? "active" : "activeWithoutAnimation";
        this.state = value ? activeState : "inactive";
        if (!this.keepContent) {
            this.toggleExpandedChildAnimations(value);
        }
        this._expanded = value;
    }
    get expanded() {
        return this._expanded;
    }
    get animate() {
        return this.eventService.animate;
    }
    get kItemClass() {
        return true;
    }
    get kStateDefaultClass() {
        return !this.disabled;
    }
    get kStateDisabledClass() {
        return this.disabled;
    }
    get kStateExpandedClass() {
        return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
    }
    get itemId() {
        return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
    }
    get ariaExpanded() {
        return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
    }
    get ariaSelected() {
        return !this.disabled && this.selected;
    }
    get ariaDisabled() {
        return this.disabled ? true : null;
    }
    /**
     * @hidden
     */
    get titleTemplate() {
        return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
    }
    /**
     * @hidden
     */
    headerHeight() {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    }
    /**
     * @hidden
     */
    ngAfterContentChecked() {
        this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;
        this.hasChildItems = this.contentItems.filter(item => item !== this).length > 0 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    }
    /**
     * @hidden
     */
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(item => item !== this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    onItemAction() {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    }
    /**
     * @hidden
     */
    onItemClick(e) {
        if (!isFocusable(e.target)) {
            this.onItemAction();
        }
    }
    /**
     * @hidden
     */
    get iconClasses() {
        let icon = this.icon ? 'k-i-' + this.icon : null;
        return {
            [icon || this.iconClass]: true
        };
    }
    /**
     * @hidden
     */
    serialize() {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title
        };
    }
    /**
     * @hidden
     */
    subTreeViewItems() {
        let subTree = [];
        this.viewChildItems.forEach(item => {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    }
    /**
     * @hidden
     */
    validateConfiguration() {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    }
    /**
     * @hidden
     */
    toggleAnimationState(value) {
        if (!this.animate) {
            return;
        }
        this.state = value && this.eventService.expandMode !== PanelBarExpandMode.Single ? 'active' : 'activeWithoutAnimation';
    }
    /**
     * @hidden
     */
    toggleExpandedChildAnimations(value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(child => {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    }
    onWrapperFocusChange(focused) {
        this.wrapperFocused = focused;
    }
}
PanelBarItemComponent.ɵfac = function PanelBarItemComponent_Factory(t) { return new (t || PanelBarItemComponent)(ɵngcc0.ɵɵdirectiveInject(PanelBarItemComponent, 13), ɵngcc0.ɵɵdirectiveInject(PanelBarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PanelBarItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PanelBarItemComponent, selectors: [["kendo-panelbar-item"]], contentQueries: function PanelBarItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarContentDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemTitleDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTemplates = _t);
    } }, viewQuery: function PanelBarItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(PanelBarItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);
    } }, hostVars: 14, hostBindings: function PanelBarItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.itemId);
        ɵngcc0.ɵɵattribute("role", ctx.role)("title", ctx.titleAttribute)("aria-expanded", ctx.ariaExpanded)("aria-selected", ctx.ariaSelected)("aria-disabled", ctx.ariaDisabled);
        ɵngcc0.ɵɵclassProp("k-item", ctx.kItemClass)("k-state-default", ctx.kStateDefaultClass)("k-state-disabled", ctx.kStateDisabledClass)("k-state-expanded", ctx.kStateExpandedClass);
    } }, inputs: { title: "title", id: "id", icon: "icon", iconClass: "iconClass", imageUrl: "imageUrl", disabled: "disabled", selected: "selected", expanded: "expanded", content: "content", items: "items", template: "template" }, exportAs: ["kendoPanelbarItem"], ngContentSelectors: _c5, decls: 8, vars: 14, consts: [[3, "click"], ["header", ""], ["class", "k-icon", 3, "ngClass", 4, "ngIf"], ["class", "k-image", "alt", "", 3, "src", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "k-icon", "k-i-arrow-n", "k-panelbar-collapse", "k-i-arrow-s", "k-panelbar-expand", 4, "ngIf"], [4, "ngIf"], [1, "k-icon", 3, "ngClass"], ["alt", "", 1, "k-image", 3, "src"], ["contentWrapper", ""], ["class", "k-panel k-group", 3, "overflow", "height", 4, "ngIf"], ["class", "k-content", 3, "overflow", "height", 4, "ngIf"], [1, "k-panel", "k-group"], [1, "k-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content", 4, "ngIf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"], [3, "ngIf"]], template: function PanelBarItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c4);
        ɵngcc0.ɵɵelementStart(0, "span", 0, 1);
        ɵngcc0.ɵɵlistener("click", function PanelBarItemComponent_Template_span_click_0_listener($event) { return ctx.onItemClick($event); });
        ɵngcc0.ɵɵtemplate(2, PanelBarItemComponent_span_2_Template, 1, 1, "span", 2);
        ɵngcc0.ɵɵtemplate(3, PanelBarItemComponent_img_3_Template, 1, 1, "img", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵtemplate(5, PanelBarItemComponent_ng_template_5_Template, 0, 0, "ng-template", 4);
        ɵngcc0.ɵɵtemplate(6, PanelBarItemComponent_span_6_Template, 1, 10, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, PanelBarItemComponent_div_7_Template, 6, 7, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-link", true)("k-header", !ctx.parent)("k-state-selected", !ctx.disabled && ctx.selected)("k-state-focused", !ctx.disabled && ctx.focused && ctx.wrapperFocused);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon || ctx.iconClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageUrl);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.title, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.titleTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasChildItems || ctx.hasContent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.keepContent || !ctx.disabled && ctx.expanded && (ctx.hasChildItems || ctx.hasContent));
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass, ɵngcc1.NgForOf, PanelBarItemComponent], encapsulation: 2, data: { animation: [
            trigger('toggle', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ overflow: 'hidden', display: 'block', height: 0 }),
                    animate(200, style({ height: AUTO_STYLE }))
                ]),
                transition('active => *', [
                    style({ overflow: 'hidden', height: AUTO_STYLE }),
                    animate(200, style({ height: 0, display: 'none' }))
                ])
            ])
        ] } });
/** @nocollapse */
PanelBarItemComponent.ctorParameters = () => [
    { type: PanelBarItemComponent, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
    { type: PanelBarService },
    { type: ElementRef }
];
PanelBarItemComponent.propDecorators = {
    title: [{ type: Input }],
    id: [{ type: Input }],
    icon: [{ type: Input }],
    iconClass: [{ type: Input }],
    imageUrl: [{ type: Input }],
    disabled: [{ type: Input }],
    expanded: [{ type: Input }],
    selected: [{ type: Input }],
    content: [{ type: Input }],
    items: [{ type: Input }],
    template: [{ type: Input }],
    header: [{ type: ViewChild, args: ['header', {},] }],
    contentWrapper: [{ type: ViewChild, args: ['contentWrapper', {},] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    titleAttribute: [{ type: HostBinding, args: ['attr.title',] }],
    kItemClass: [{ type: HostBinding, args: ['class.k-item',] }],
    kStateDefaultClass: [{ type: HostBinding, args: ['class.k-state-default',] }],
    kStateDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    kStateExpandedClass: [{ type: HostBinding, args: ['class.k-state-expanded',] }],
    itemId: [{ type: HostBinding, args: ['id',] }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],
    contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],
    contentTemplate: [{ type: ContentChildren, args: [PanelBarContentDirective, { descendants: false },] }],
    titleTemplates: [{ type: ContentChildren, args: [PanelBarItemTitleDirective, { descendants: false },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarItemComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('toggle', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ overflow: 'hidden', display: 'block', height: 0 }),
                            animate(200, style({ height: AUTO_STYLE }))
                        ]),
                        transition('active => *', [
                            style({ overflow: 'hidden', height: AUTO_STYLE }),
                            animate(200, style({ height: 0, display: 'none' }))
                        ])
                    ])
                ],
                exportAs: 'kendoPanelbarItem',
                selector: "kendo-panelbar-item",
                template: `<span
                #header
                [class.k-link]="true"
                [class.k-header]="!parent"
                [class.k-state-selected]="!disabled && selected"
                [class.k-state-focused]="!disabled && focused && wrapperFocused"
                (click)="onItemClick($event)">
            <span
                *ngIf="icon || iconClass"
                class="k-icon"
                [ngClass]="iconClasses">
            </span>
            <img
                *ngIf="imageUrl"
                class="k-image"
                [src]="imageUrl"
                alt="">
            {{title}}
            <ng-template [ngTemplateOutlet]="titleTemplate"></ng-template>
            <span *ngIf="hasChildItems || hasContent"
                [class.k-icon]="true"
                [class.k-i-arrow-n]="expanded"
                [class.k-panelbar-collapse]="expanded"
                [class.k-i-arrow-s]="!expanded"
                [class.k-panelbar-expand]="!expanded">
            </span>
        </span>
        <div #contentWrapper
            *ngIf="keepContent || (!disabled && expanded && (hasChildItems || hasContent))"
            [@toggle]="state"
            [attr.role]="'group'"
            [attr.aria-hidden]="!disabled && !expanded">
            <div
                *ngIf="hasChildItems && !items?.length"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-panel k-group">
                    <ng-content select="kendo-panelbar-item"></ng-content>
            </div>
            <div
                *ngIf="hasContent && !content"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-content">
                <ng-template
                    [ngTemplateOutlet]="contentTemplate.first.templateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: {
                            title: title,
                            id: id,
                            icon: icon,
                            imageUrl: imageUrl,
                            disabled: disabled,
                            content: content
                        }
                    }">
                </ng-template>
            </div>
            <div *ngIf="hasItems"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-panel k-group">
                <ng-container *ngFor="let item of items">
                    <kendo-panelbar-item *ngIf="!item.hidden"
                        [title]="item.title"
                        [id]="item.id"
                        [icon]="item.icon"
                        [iconClass]="item.iconClass"
                        [imageUrl]="item.imageUrl"
                        [selected]="!!item.selected"
                        [expanded]="!!item.expanded"
                        [disabled]="!!item.disabled"
                        [template]="template"
                        [items]="item.children"
                        [content]="item.content">
                    </kendo-panelbar-item>
                </ng-container>
            </div>
            <div
                *ngIf="content"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-content">
                <ng-template
                    [ngTemplateOutlet]="template"
                    [ngTemplateOutletContext]="{
                        $implicit: {
                            title: title,
                            id: id,
                            icon: icon,
                            imageUrl: imageUrl,
                            disabled: disabled,
                            content: content
                        }
                    }">
                </ng-template>
                <ng-template [ngIf]="!template">{{content}}</ng-template>
            </div>
        </div>`
            }]
    }], function () { return [{ type: PanelBarItemComponent, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: PanelBarService }, { type: ɵngcc0.ElementRef }]; }, { title: [{
            type: Input
        }], id: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], imageUrl: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selected: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], titleAttribute: [{
            type: HostBinding,
            args: ['attr.title']
        }], expanded: [{
            type: Input
        }], kItemClass: [{
            type: HostBinding,
            args: ['class.k-item']
        }], kStateDefaultClass: [{
            type: HostBinding,
            args: ['class.k-state-default']
        }], kStateDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], kStateExpandedClass: [{
            type: HostBinding,
            args: ['class.k-state-expanded']
        }], itemId: [{
            type: HostBinding,
            args: ['id']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], content: [{
            type: Input
        }], items: [{
            type: Input
        }], template: [{
            type: Input
        }], header: [{
            type: ViewChild,
            args: ['header', {}]
        }], contentWrapper: [{
            type: ViewChild,
            args: ['contentWrapper', {}]
        }], viewChildItems: [{
            type: ViewChildren,
            args: [PanelBarItemComponent]
        }], contentItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent]
        }], contentTemplate: [{
            type: ContentChildren,
            args: [PanelBarContentDirective, { descendants: false }]
        }], titleTemplates: [{
            type: ContentChildren,
            args: [PanelBarItemTitleDirective, { descendants: false }]
        }] }); })();

/**
 * Represents the template directive of the PanelBar which helps to customize the item content.
 */
class PanelBarItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarItemTemplateDirective.ɵfac = function PanelBarItemTemplateDirective_Factory(t) { return new (t || PanelBarItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PanelBarItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanelBarItemTemplateDirective, selectors: [["", "kendoPanelBarItemTemplate", ""]] });
/** @nocollapse */
PanelBarItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoPanelBarItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).
 */
// TODO: add styles as input prop
class PanelBarComponent {
    constructor(elementRef, eventService, localization) {
        this.localization = localization;
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
         *
         * The available modes are:
         * - `"single"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Expands more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Expands only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = "400px";
        /**
         * Fires each time the user interacts with a PanelBar item
         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).
         * The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        this.tabIndex = 0;
        this.role = "tree";
        this.activeDescendant = "";
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = () => {
            let childrenHeight = 0;
            const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
            const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            this.childrenItems.forEach(item => {
                childrenHeight += item.headerHeight();
            });
            this.childrenItems.forEach(item => {
                item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + "px" : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(event => this.onItemAction(event));
    }
    /**
     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM
     * ([see example]({% slug templates_panelbar %}#toc-collections)).
     * By default, this option is set to `false`.
     */
    get keepItemContent() {
        return this._keepItemContent;
    }
    set keepItemContent(keepItemContent) {
        this._keepItemContent = keepItemContent;
        this.eventService.onKeepContent(keepItemContent);
    }
    /**
     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
     * ([see example]({% slug items_panelbar %})).
     */
    set items(data) {
        if (data) {
            this._items = util.parsePanelBarItems(data);
        }
    }
    get items() {
        return this._items;
    }
    get hostHeight() {
        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
    }
    get overflow() {
        return this.expandMode === PanelBarExpandMode.Full ? "hidden" : "visible";
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    get computedKeys() {
        return {
            [Keys.Space]: () => this.selectFocusedItem(),
            [Keys.Enter]: () => this.selectFocusedItem(),
            [Keys.ArrowUp]: () => this.focusPreviousItem(),
            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: () => this.collapseItem(),
            [Keys.ArrowDown]: () => this.focusNextItem(),
            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: () => this.expandItem(),
            [Keys.End]: () => this.focusLastItem(),
            [Keys.Home]: () => this.focusFirstItem()
        };
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
        this.eventService.animate = this.animate;
        this.eventService.expandMode = this.expandMode;
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(() => this.updateChildrenHeight());
        }
        this.validateConfiguration();
    }
    ngOnChanges(changes) {
        if (changes['height'] || changes['expandMode'] || changes["items"]) { // tslint:disable-line
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes.animate) {
            this.eventService.animate = this.animate;
        }
        if (changes.expandMode) {
            this.eventService.expandMode = this.expandMode;
        }
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    onComponentClick(event) {
        const itemClicked = this.visibleItems().some((item) => {
            return item.header.nativeElement.contains(event.target);
        });
        if (!this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            const visibleItems = this.visibleItems();
            const focusedItems = visibleItems.filter(item => item.focused);
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = "";
    }
    /**
     * @hidden
     */
    onComponentKeyDown(event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown ||
                event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home ||
                event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
                event.preventDefault();
            }
            const handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    }
    get viewItems() {
        let treeItems = [];
        this.viewChildItems.toArray().forEach(item => {
            treeItems.push(item);
            treeItems = treeItems.concat(item.subTreeViewItems());
        });
        return treeItems;
    }
    validateConfiguration() {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and items property.");
            }
        }
    }
    onItemAction(item) {
        if (!item) {
            return;
        }
        let modifiedItems = new Array();
        this.allItems
            .forEach((currentItem) => {
            let selectedState = currentItem === item;
            let focusedState = selectedState;
            selectedState = this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                currentItem.selected = selectedState;
                currentItem.focused = focusedState;
                this.activeDescendant = focusedState ? currentItem.itemId : "";
                modifiedItems.push(currentItem);
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if (item.hasChildItems || item.hasContent) {
                item.expanded = !item.expanded;
            }
            if (modifiedItems.indexOf(item) < 0) {
                modifiedItems.push(item);
            }
        }
        else {
            let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            if (item.hasChildItems || item.hasContent) {
                siblings
                    .forEach((currentItem) => {
                    let expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        currentItem.expanded = expandedState;
                        if (modifiedItems.indexOf(currentItem) < 0) {
                            modifiedItems.push(currentItem);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(currentItem => currentItem.serialize()));
        }
    }
    get hostClasses() {
        return true;
    }
    isVisible(item) {
        const visibleItems = this.visibleItems();
        return visibleItems.some(i => i === item);
    }
    getVisibleParent(item) {
        const visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
    }
    focusItem(action) {
        const visibleItems = this.visibleItems();
        let currentIndex = visibleItems.findIndex(item => item.focused);
        let currentItem = visibleItems[currentIndex];
        let nextItem;
        if (currentIndex === -1) {
            let focusedItem = this.allItems.find(item => item.focused);
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(item => item === currentItem);
        }
        switch (action) {
            case "lastItem":
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case "firstItem":
                nextItem = visibleItems[0];
                break;
            case "nextItem":
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case "previousItem":
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    }
    moveFocus(from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        const modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    }
    focusLastItem() {
        this.focusItem("lastItem");
    }
    focusFirstItem() {
        this.focusItem("firstItem");
    }
    focusNextItem() {
        this.focusItem("nextItem");
    }
    focusPreviousItem() {
        this.focusItem("previousItem");
    }
    expandItem() {
        let currentItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    }
    collapseItem() {
        const currentItem = this.allItems.filter(item => item.focused)[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    }
    selectFocusedItem() {
        let focusedItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    }
    visibleItems() {
        return this.flatVisibleItems(this.childrenItems);
    }
    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
        listOfItems.forEach(item => {
            if (!item.disabled) {
                flattedItems.push(item);
                if (item.expanded && item.hasChildItems) {
                    this.flatVisibleItems(item.childrenItems, flattedItems);
                }
            }
        });
        return flattedItems;
    }
}
PanelBarComponent.ɵfac = function PanelBarComponent_Factory(t) { return new (t || PanelBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PanelBarService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
PanelBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PanelBarComponent, selectors: [["kendo-panelbar"]], contentQueries: function PanelBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PanelBarItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentItems = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentChildItems = _t);
    } }, viewQuery: function PanelBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(PanelBarItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewChildItems = _t);
    } }, hostVars: 12, hostBindings: function PanelBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PanelBarComponent_click_HostBindingHandler($event) { return ctx.onComponentClick($event); })("focus", function PanelBarComponent_focus_HostBindingHandler() { return ctx.onComponentFocus(); })("blur", function PanelBarComponent_blur_HostBindingHandler() { return ctx.onComponentBlur(); })("keydown", function PanelBarComponent_keydown_HostBindingHandler($event) { return ctx.onComponentKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabIndex", ctx.tabIndex)("role", ctx.role)("aria-activedescendant", ctx.activeDescendant)("dir", ctx.dir);
        ɵngcc0.ɵɵstyleProp("height", ctx.hostHeight)("overflow", ctx.overflow);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-panelbar", ctx.hostClasses);
    } }, inputs: { expandMode: "expandMode", selectable: "selectable", animate: "animate", height: "height", keepItemContent: "keepItemContent", items: "items" }, outputs: { stateChange: "stateChange" }, exportAs: ["kendoPanelbar"], features: [ɵngcc0.ɵɵProvidersFeature([
            PanelBarService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.panelbar'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c5, decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "ngIf"], [4, "ngFor", "ngForOf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content", 4, "ngIf"], [3, "title", "id", "icon", "iconClass", "imageUrl", "selected", "expanded", "disabled", "template", "items", "content"]], template: function PanelBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c4);
        ɵngcc0.ɵɵtemplate(0, PanelBarComponent_0_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, PanelBarComponent_ng_template_1_Template, 1, 1, "ng-template", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentChildItems && !ctx.items);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.items == null ? null : ctx.items.length);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, PanelBarItemComponent], encapsulation: 2 });
/** @nocollapse */
PanelBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PanelBarService },
    { type: LocalizationService }
];
PanelBarComponent.propDecorators = {
    expandMode: [{ type: Input }],
    selectable: [{ type: Input }],
    animate: [{ type: Input }],
    height: [{ type: Input }],
    keepItemContent: [{ type: Input }],
    items: [{ type: Input }],
    stateChange: [{ type: Output }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    activeDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
    hostHeight: [{ type: HostBinding, args: ['style.height',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    template: [{ type: ContentChild, args: [PanelBarItemTemplateDirective,] }],
    contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent, { descendants: true },] }],
    contentChildItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],
    viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],
    onComponentClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onComponentFocus: [{ type: HostListener, args: ['focus',] }],
    onComponentBlur: [{ type: HostListener, args: ['blur',] }],
    onComponentKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-panelbar',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoPanelbar',
                providers: [
                    PanelBarService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.panelbar'
                    }
                ],
                selector: 'kendo-panelbar',
                template: `
        <ng-content *ngIf="contentChildItems && !items" select="kendo-panelbar-item"></ng-content>
        <ng-template [ngIf]="items?.length">
            <ng-container *ngFor="let item of items">
                <kendo-panelbar-item *ngIf="!item.hidden"
                     [title]="item.title"
                     [id]="item.id"
                     [icon]="item.icon"
                     [iconClass]="item.iconClass"
                     [imageUrl]="item.imageUrl"
                     [selected]="!!item.selected"
                     [expanded]="!!item.expanded"
                     [disabled]="!!item.disabled"
                     [template]="templateRef"
                     [items]="item.children"
                     [content]="item.content"
                >
                </kendo-panelbar-item>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: PanelBarService }, { type: ɵngcc2.LocalizationService }]; }, { expandMode: [{
            type: Input
        }], selectable: [{
            type: Input
        }], animate: [{
            type: Input
        }], height: [{
            type: Input
        }], stateChange: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabIndex']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], activeDescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], keepItemContent: [{
            type: Input
        }], items: [{
            type: Input
        }], hostHeight: [{
            type: HostBinding,
            args: ['style.height']
        }], overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], onComponentClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onComponentFocus: [{
            type: HostListener,
            args: ['focus']
        }], onComponentBlur: [{
            type: HostListener,
            args: ['blur']
        }], onComponentKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-panelbar']
        }], template: [{
            type: ContentChild,
            args: [PanelBarItemTemplateDirective]
        }], contentItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent, { descendants: true }]
        }], contentChildItems: [{
            type: ContentChildren,
            args: [PanelBarItemComponent]
        }], viewChildItems: [{
            type: ViewChildren,
            args: [PanelBarItemComponent]
        }] }); })();

/**
 * Represents the pane component of the Splitter.
 */
class SplitterPaneComponent {
    constructor(element, renderer, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        /**
         * Specifies if the user is allowed to resize the pane and provide space for other panes.
         */
        this.resizable = true;
        /**
         * Specifies if the user is allowed to hide the pane and provide space for other panes.
         */
        this.collapsible = false;
        /**
         * Specifies if overflowing content is scrollable or hidden.
         */
        this.scrollable = true;
        /**
         * Specifies if the pane is initially collapsed.
         */
        this.collapsed = false;
        /**
         * @hidden
         */
        this.orientation = 'horizontal';
        /**
         * @hidden
         */
        this.containsSplitter = false;
        /**
         * @hidden
         */
        this.overlayContent = false;
        /**
         * Fires each time the user resizes the Splitter pane.
         * The event data contains the new pane size.
         * Allows a two-way binding of the pane `size` property.
         */
        this.sizeChange = new EventEmitter();
        /**
         * Fires each time the `collapsed` property changes.
         * The event data contains the new property state.
         * Allows a two-way binding of the `collapsed` pane property.
         */
        this.collapsedChange = new EventEmitter();
        this.hostClass = true;
        /**
         * @hidden
         */
        this.forceExpand = false;
    }
    /**
     * @hidden
     */
    set order(paneOrder) {
        this._order = paneOrder;
        this.setOrderStyles();
    }
    get order() {
        return this._order;
    }
    /**
     * Sets the initial size of the pane.
     * Has to be between the `min` and `max` properties.
     */
    set size(newSize) {
        this._size = newSize;
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);
        this.renderer.setStyle(element, 'flex-basis', newSize);
        if (this.staticPaneClass) {
            this.renderer.addClass(element, 'k-pane-static');
        }
        else {
            this.renderer.removeClass(element, 'k-pane-static');
        }
    }
    get size() {
        return this._size;
    }
    get isHidden() {
        return this.collapsed;
    }
    get styleDisplayFlex() {
        return this.containsSplitter;
    }
    get staticPaneClass() {
        if (this.forceExpand) {
            return false;
        }
        return !this.resizable && !this.collapsible || this.fixedSize;
    }
    get scrollablePaneClass() {
        return this.scrollable;
    }
    get fixedSize() {
        return this.size && this.size.length > 0;
    }
    ngAfterViewChecked() {
        const element = this.element.nativeElement;
        if (this.isHidden) {
            this.renderer.addClass(element, 'k-state-hidden');
            this.renderer.addClass(element, 'hidden');
        }
        else {
            this.renderer.removeClass(element, 'k-state-hidden');
            this.renderer.removeClass(element, 'hidden');
        }
    }
    /**
     * @hidden
     */
    get computedSize() {
        if (this.orientation === 'vertical') {
            return this.element.nativeElement.offsetHeight;
        }
        else {
            return this.element.nativeElement.offsetWidth;
        }
    }
    /**
     * @hidden
     */
    toggleOverlay(show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    setOrderStyles() {
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-order', this.order);
        this.renderer.setStyle(element, 'order', this.order);
    }
}
SplitterPaneComponent.ɵfac = function SplitterPaneComponent_Factory(t) { return new (t || SplitterPaneComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
SplitterPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SplitterPaneComponent, selectors: [["kendo-splitter-pane"]], hostVars: 8, hostBindings: function SplitterPaneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pane", ctx.hostClass)("k-pane-flex", ctx.styleDisplayFlex)("k-pane-static", ctx.staticPaneClass)("k-scrollable", ctx.scrollablePaneClass);
    } }, inputs: { resizable: "resizable", collapsible: "collapsible", scrollable: "scrollable", collapsed: "collapsed", orientation: "orientation", containsSplitter: "containsSplitter", overlayContent: "overlayContent", order: "order", size: "size", min: "min", max: "max" }, outputs: { sizeChange: "sizeChange", collapsedChange: "collapsedChange" }, exportAs: ["kendoSplitterPane"], ngContentSelectors: _c6, decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "k-splitter-overlay k-overlay", 4, "ngIf"], [1, "k-splitter-overlay", "k-overlay"]], template: function SplitterPaneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, SplitterPaneComponent_ng_container_0_Template, 2, 0, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, SplitterPaneComponent_div_1_Template, 1, 0, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.overlayContent);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
SplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
SplitterPaneComponent.propDecorators = {
    order: [{ type: Input }],
    size: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    resizable: [{ type: Input }],
    collapsible: [{ type: Input }],
    scrollable: [{ type: Input }],
    collapsed: [{ type: Input }],
    orientation: [{ type: Input }],
    containsSplitter: [{ type: Input }],
    overlayContent: [{ type: Input }],
    sizeChange: [{ type: Output }],
    collapsedChange: [{ type: Output }],
    styleDisplayFlex: [{ type: HostBinding, args: ['class.k-pane-flex',] }],
    hostClass: [{ type: HostBinding, args: ['class.k-pane',] }],
    staticPaneClass: [{ type: HostBinding, args: ['class.k-pane-static',] }],
    scrollablePaneClass: [{ type: HostBinding, args: ['class.k-scrollable',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterPaneComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSplitterPane',
                selector: 'kendo-splitter-pane',
                template: `
        <ng-container *ngIf="!collapsed"><ng-content></ng-content></ng-container>
        <div *ngIf="overlayContent" class="k-splitter-overlay k-overlay"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { resizable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], collapsed: [{
            type: Input
        }], orientation: [{
            type: Input
        }], containsSplitter: [{
            type: Input
        }], overlayContent: [{
            type: Input
        }], sizeChange: [{
            type: Output
        }], collapsedChange: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-pane']
        }], order: [{
            type: Input
        }], size: [{
            type: Input
        }], styleDisplayFlex: [{
            type: HostBinding,
            args: ['class.k-pane-flex']
        }], staticPaneClass: [{
            type: HostBinding,
            args: ['class.k-pane-static']
        }], scrollablePaneClass: [{
            type: HostBinding,
            args: ['class.k-scrollable']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();

const SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
class SplitterService {
    constructor(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = () => { };
    }
    tryToggle(paneIndex) {
        const pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        const notCollapsed = this.panes.filter(p => !p.collapsed);
        const allHaveFixedSize = notCollapsed.every(p => p.fixedSize);
        notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;
        return pane.collapsible;
    }
    toggleContentOverlay(index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    }
    dragState(splitbarIndex) {
        let prev = this.pane(splitbarIndex);
        let next = this.pane(splitbarIndex + 1);
        const total = prev.computedSize + next.computedSize;
        const px = s => this.toPixels(s);
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    }
    setSize(state$$1, delta) {
        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));
        const resize = (paneState, change) => {
            const pane = this.pane(paneState.index);
            const splitterSize = this.containerSize();
            const newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);
            let size = "";
            if (this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            this.emit(pane.sizeChange, size);
        };
        const prev = this.pane(state$$1.prev.index);
        const next = this.pane(state$$1.next.index);
        // determine which pane to resize
        if (prev.fixedSize && next.fixedSize) {
            // resizing both panes
            resize(state$$1.prev, delta);
            resize(state$$1.next, -delta);
        }
        else if (next.collapsible || next.fixedSize) {
            // resizing next
            resize(state$$1.next, -delta);
        }
        else {
            // resizing prev
            resize(state$$1.prev, delta);
        }
        this.emit(this.layoutChange, {});
    }
    isDraggable(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    }
    isStatic(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    }
    pane(index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    }
    configure({ panes, orientation, containerSize }) {
        this.panes = panes;
        this.panes.forEach((pane, index) => {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            const allFixed = panes.length && !panes.some(pane => !pane.fixedSize);
            if (allFixed) {
                throw new Error(`
                    The Splitter should have at least one pane without a set size.
                    See ${SIZING_DOC_LINK} for more information.
                `);
            }
        }
        this.containerSize = containerSize;
    }
    isPercent(size) {
        return /%$/.test(size);
    }
    toPixels(size) {
        let result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    }
    emit(emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(() => emitter.emit(args));
        }
    }
}
SplitterService.ɵfac = function SplitterService_Factory(t) { return new (t || SplitterService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
SplitterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SplitterService, factory: SplitterService.ɵfac });
/** @nocollapse */
SplitterService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * ```ts-preview
 *
 *  @Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-splitter style="height: 280px;">
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / left pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane>
 *            <h3>Inner splitter / center pane</h3>
 *            <p>Resizable only.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / right pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *        </kendo-splitter>
 *      `,
 *    styles: [ `
 *        h3 { font-size: 1.2em; }
 *        h3, p { margin: 10px; padding: 0; }
 *    ` ]
 *  })
 *  class AppComponent {}
 * ```
 */
class SplitterComponent {
    constructor(element, splitterService, localization, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        /**
         * Specifies the orientation of the panes within the Splitter.
         * Panes in a horizontal Splitter are placed horizontally.
         * Panes in a vertical Splitter are placed vertically.
         */
        this.orientation = 'horizontal';
        this.ariaRole = 'splitter';
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    get hostClasses() {
        return true;
    }
    get horizontalHostClasses() {
        return this.orientation === 'horizontal';
    }
    get verticalHostClasses() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    ngAfterContentInit() {
        this.reconfigure();
    }
    ngOnChanges(changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
    }
    reconfigure() {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    }
    unsubscribeChanges() {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    }
    configure() {
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: () => {
                if (this.orientation === 'vertical') {
                    return this.element.nativeElement.clientHeight;
                }
                else {
                    return this.element.nativeElement.clientWidth;
                }
            }
        });
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
}
SplitterComponent.ɵfac = function SplitterComponent_Factory(t) { return new (t || SplitterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SplitterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(SplitterPaneComponent, 9)); };
SplitterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SplitterComponent, selectors: [["kendo-splitter"]], contentQueries: function SplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SplitterPaneComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 12, hostBindings: function SplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.ariaRole)("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-splitter", ctx.hostClasses)("k-splitter-flex", ctx.hostClasses)("k-splitter-horizontal", ctx.horizontalHostClasses)("k-splitter-vertical", ctx.verticalHostClasses);
    } }, inputs: { orientation: "orientation" }, outputs: { layoutChange: "layoutChange" }, exportAs: ["kendoSplitter"], features: [ɵngcc0.ɵɵProvidersFeature([
            SplitterService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.spliter'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c8, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoDraggable", "", 3, "index", "orientation", 4, "ngIf"], ["kendoDraggable", "", 3, "index", "orientation"]], template: function SplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, SplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, SplitterBarComponent, ɵngcc3.DraggableDirective]; }, encapsulation: 2 });
/** @nocollapse */
SplitterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SplitterService },
    { type: LocalizationService },
    { type: SplitterPaneComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [SplitterPaneComponent,] }] }
];
SplitterComponent.propDecorators = {
    orientation: [{ type: Input }],
    layoutChange: [{ type: Output }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-splitter',] }, { type: HostBinding, args: ['class.k-splitter-flex',] }],
    horizontalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-horizontal',] }],
    verticalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-vertical',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
    panes: [{ type: ContentChildren, args: [SplitterPaneComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSplitter',
                selector: 'kendo-splitter',
                providers: [
                    SplitterService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.spliter'
                    }
                ],
                template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      <ng-container *ngFor="
        let pane of panes;
        let index = index;
        let last = last;
      ">
        <kendo-splitter-bar
          kendoDraggable
          *ngIf="!last"
          [index]="index"
          [orientation]="orientation">
        </kendo-splitter-bar>
      </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SplitterService }, { type: ɵngcc2.LocalizationService }, { type: SplitterPaneComponent, decorators: [{
                type: Optional
            }, {
                type: Host
            }, {
                type: Inject,
                args: [SplitterPaneComponent]
            }] }]; }, { orientation: [{
            type: Input
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], layoutChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-splitter']
        }, {
            type: HostBinding,
            args: ['class.k-splitter-flex']
        }], horizontalHostClasses: [{
            type: HostBinding,
            args: ['class.k-splitter-horizontal']
        }], verticalHostClasses: [{
            type: HostBinding,
            args: ['class.k-splitter-vertical']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], panes: [{
            type: ContentChildren,
            args: [SplitterPaneComponent]
        }] }); })();

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class TabContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TabContentDirective.ɵfac = function TabContentDirective_Factory(t) { return new (t || TabContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TabContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabContentDirective, selectors: [["", "kendoTabContent", ""]] });
/** @nocollapse */
TabContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabContentDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTabContent]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabTitle>
 *               Title
 *             </ng-template>
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class TabTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TabTitleDirective.ɵfac = function TabTitleDirective_Factory(t) { return new (t || TabTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
TabTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabTitleDirective, selectors: [["", "kendoTabTitle", ""]] });
/** @nocollapse */
TabTitleDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTabTitle]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();

/**
 * Represents the tab component of the TabStrip.
 */
class TabStripTabComponent {
    constructor() {
        this.active = false;
        this._tabContent = new QueryList();
    }
    get tabContent() {
        return this._tabContent.first;
    }
    ngAfterContentInit() {
        this.active = this.selected;
    }
    ngOnChanges(changes) {
        if (changes['selected'] && !changes['selected'].isFirstChange()) { // tslint:disable-line
            this.active = this.selected;
        }
    }
}
TabStripTabComponent.ɵfac = function TabStripTabComponent_Factory(t) { return new (t || TabStripTabComponent)(); };
TabStripTabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabStripTabComponent, selectors: [["kendo-tabstrip-tab"]], contentQueries: function TabStripTabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabTitleDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabContentDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabTitle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabContent = _t);
    } }, inputs: { title: "title", disabled: "disabled", cssClass: "cssClass", selected: "selected" }, exportAs: ["kendoTabStripTab"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function TabStripTabComponent_Template(rf, ctx) { }, encapsulation: 2 });
TabStripTabComponent.propDecorators = {
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    cssClass: [{ type: Input }],
    selected: [{ type: Input }],
    _tabContent: [{ type: ContentChildren, args: [TabContentDirective,] }],
    tabTitle: [{ type: ContentChild, args: [TabTitleDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabStripTabComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTabStripTab',
                selector: 'kendo-tabstrip-tab',
                template: ``
            }]
    }], function () { return []; }, { _tabContent: [{
            type: ContentChildren,
            args: [TabContentDirective]
        }], title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], selected: [{
            type: Input
        }], tabTitle: [{
            type: ContentChild,
            args: [TabTitleDirective]
        }] }); })();

/**
 * @hidden
 */
class PreventableEvent {
    /**
     * @hidden
     */
    constructor(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when a tab is selected (clicked).
 */
class SelectEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     */
    constructor(index, title) {
        super();
        this.index = index;
        this.title = title;
    }
}

/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 */
class TabStripComponent {
    constructor(localization, renderer, wrapper) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        /**
         * Enables the tab animation.
         */
        this.animate = true;
        /**
         * Sets the position of the tabs. Defaults to `top`.
         */
        this.tabPosition = 'top';
        /**
         * When set to `true`, the component renders all tabs and they are persisted in the DOM.
         * By default, `keepTabContent` is `false`.
         */
        this.keepTabContent = false;
        /**
         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).
         * The event data contains the index of the selected tab and its title.
         */
        this.tabSelect = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this._animate = false;
        this.keyBindings = this.computedKeys;
    }
    /**
     * Sets the height of the TabStrip.
     */
    set height(value) {
        this._height = value;
        this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
    }
    get height() {
        return this._height;
    }
    get tabsAtTop() {
        return this.tabPosition === 'top';
    }
    get tabsAtRight() {
        return this.tabPosition === 'right';
    }
    get tabsAtBottom() {
        return this.tabPosition === 'bottom';
    }
    get tabsAtLeft() {
        return this.tabPosition === 'left';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    contentClass(active) {
        const visible = !this.keepTabContent || active;
        return visible ? 'k-content k-state-active' : 'k-content';
    }
    get computedKeys() {
        return {
            [this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.ArrowDown, Keys.ArrowUp)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.ArrowUp, Keys.ArrowDown)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),
            [Keys.Home]: () => this.firstNavigatableIndex(),
            [Keys.End]: () => this.lastNavigatableIndex()
        };
    }
    /**
     * @hidden
     */
    get tabsAlignment() {
        return {
            start: 'flex-start',
            end: 'flex-end',
            center: 'center',
            justify: 'space-between'
        }[this.tabAlignment];
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    /**
     * @hidden
     */
    onKeyDown(event) {
        if (event.currentTarget !== this.tablist.nativeElement) {
            return;
        }
        const isHorizontal = this.tabPosition === 'top' || this.tabPosition === 'bottom';
        const isArrowUp = event.keyCode === Keys.ArrowUp;
        const isArrowDown = event.keyCode === Keys.ArrowDown;
        const isArrowLeft = event.keyCode === Keys.ArrowLeft;
        const isArrowRight = event.keyCode === Keys.ArrowRight;
        if (isHorizontal && (isArrowUp || isArrowDown)) {
            return;
        }
        if (!isHorizontal && (isArrowLeft || isArrowRight)) {
            return;
        }
        if (event.keyCode === Keys.Space || isArrowUp || isArrowDown || isArrowLeft || isArrowRight || event.keyCode === Keys.Home ||
            event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
            event.preventDefault();
        }
        const selectedIndex = this.tabs.toArray().findIndex(tab => tab.active && !tab.disabled);
        if (selectedIndex === -1) {
            this.selectTab(this.firstNavigatableIndex());
        }
        else {
            const getTabIndex = this.keyBindings[event.keyCode];
            if (getTabIndex) {
                const nextIndex = getTabIndex(selectedIndex);
                if (selectedIndex !== nextIndex) {
                    this.selectTab(getTabIndex(selectedIndex));
                }
            }
        }
    }
    /**
     * @hidden
     */
    tabPanelId(id) {
        return 'k-tabstrip-tabpanel-' + id;
    }
    /**
     * @hidden
     */
    tabId(id) {
        return 'k-tabstrip-tab-' + id;
    }
    /**
     * Allows the user to select a tab programmatically.
     * @param {number} index - The index of the tab that will be selected.
     */
    selectTab(index) {
        const tab = this.tabs.toArray()[index];
        if (!tab || Boolean(tab.disabled)) {
            return;
        }
        this.tabHeadingContainers.toArray()[index].nativeElement.focus();
        this.emitEvent(tab, index);
    }
    /**
     * @hidden
     */
    onTabClick(originalEvent, tabIndex) {
        if (isFocusable(originalEvent.target)) {
            return;
        }
        this.selectTab(tabIndex);
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    firstNavigatableIndex() {
        const tabs = this.tabs.toArray();
        for (let i = 0; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    }
    lastNavigatableIndex() {
        const tabs = this.tabs.toArray();
        for (let i = tabs.length - 1; i > 0; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    }
    prevNavigatableIndex(selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        const tabs = this.tabs.toArray();
        for (let i = selectedIndex - 1; i > -1; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i === 0) {
                return this.lastNavigatableIndex();
            }
        }
        return selectedIndex;
    }
    nextNavigatableIndex(selectedIndex) {
        if (selectedIndex + 1 >= this.tabs.length) {
            return this.firstNavigatableIndex();
        }
        const tabs = this.tabs.toArray();
        for (let i = selectedIndex + 1; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i + 1 === tabs.length) {
                return this.firstNavigatableIndex();
            }
        }
    }
    emitEvent(tab, selectedIndex) {
        const selectArgs = new SelectEvent(selectedIndex, tab.title);
        this.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented() && !tab.active) {
            this._animate = this.animate;
            this.deactivateAll();
            tab.active = true;
        }
    }
    deactivateAll() {
        this.tabs.forEach((tab) => {
            tab.active = false;
        });
    }
}
TabStripComponent.ɵfac = function TabStripComponent_Factory(t) { return new (t || TabStripComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TabStripComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabStripComponent, selectors: [["kendo-tabstrip"]], contentQueries: function TabStripComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabStripTabComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, viewQuery: function TabStripComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true);
        ɵngcc0.ɵɵviewQuery(_c10, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tablist = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeadingContainers = _t);
    } }, hostVars: 17, hostBindings: function TabStripComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-tabstrip", ctx.hostClasses)("k-floatwrap", ctx.hostClasses)("k-header", ctx.hostClasses)("k-tabstrip-top", ctx.tabsAtTop)("k-tabstrip-right", ctx.tabsAtRight)("k-tabstrip-bottom", ctx.tabsAtBottom)("k-tabstrip-left", ctx.tabsAtLeft);
    } }, inputs: { animate: "animate", tabPosition: "tabPosition", keepTabContent: "keepTabContent", height: "height", tabAlignment: "tabAlignment" }, outputs: { tabSelect: "tabSelect" }, exportAs: ["kendoTabStrip"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.tabstrip'
            }
        ])], decls: 6, vars: 2, consts: [[4, "ngIf"], ["heading", ""], ["content", ""], [4, "ngTemplateOutlet"], ["role", "tablist", 1, "k-reset", "k-tabstrip-items", 3, "keydown"], ["tablist", ""], ["role", "tab", 3, "id", "tabIndex", "ngClass", "k-item", "k-state-default", "k-state-active", "k-state-disabled", "click", 4, "ngFor", "ngForOf"], ["role", "tab", 3, "id", "tabIndex", "ngClass", "click"], ["tabHeadingContainer", ""], [1, "k-link"], [3, "ngTemplateOutlet"], ["ngFor", "", 3, "ngForOf"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id", 4, "ngIf"], ["role", "tabpanel", 3, "ngClass", "tabIndex", "id"]], template: function TabStripComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TabStripComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, TabStripComponent_ng_container_1_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, TabStripComponent_ng_template_2_Template, 3, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, TabStripComponent_ng_template_4_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tabsAtBottom);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tabsAtBottom);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgForOf, ɵngcc1.NgClass], encapsulation: 2, data: { animation: [
            trigger('state', [
                state('active', style({ opacity: 1 })),
                transition('* => active', [
                    style({ opacity: 0 }),
                    animate('400ms ease-in')
                ])
            ])
        ] } });
/** @nocollapse */
TabStripComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: Renderer2 },
    { type: ElementRef }
];
TabStripComponent.propDecorators = {
    height: [{ type: Input }],
    animate: [{ type: Input }],
    tabAlignment: [{ type: Input }],
    tabPosition: [{ type: Input }],
    keepTabContent: [{ type: Input }],
    tablist: [{ type: ViewChild, args: ['tablist',] }],
    tabSelect: [{ type: Output }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-tabstrip',] }, { type: HostBinding, args: ['class.k-floatwrap',] }, { type: HostBinding, args: ['class.k-header',] }],
    tabsAtTop: [{ type: HostBinding, args: ['class.k-tabstrip-top',] }],
    tabsAtRight: [{ type: HostBinding, args: ['class.k-tabstrip-right',] }],
    tabsAtBottom: [{ type: HostBinding, args: ['class.k-tabstrip-bottom',] }],
    tabsAtLeft: [{ type: HostBinding, args: ['class.k-tabstrip-left',] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    tabs: [{ type: ContentChildren, args: [TabStripTabComponent,] }],
    tabHeadingContainers: [{ type: ViewChildren, args: ['tabHeadingContainer',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabStripComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('state', [
                        state('active', style({ opacity: 1 })),
                        transition('* => active', [
                            style({ opacity: 0 }),
                            animate('400ms ease-in')
                        ])
                    ])
                ],
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tabstrip'
                    }
                ],
                exportAs: 'kendoTabStrip',
                selector: 'kendo-tabstrip',
                template: `
        <ng-container *ngIf="!tabsAtBottom">
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
        </ng-container>

        <ng-container *ngIf="tabsAtBottom">
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
        </ng-container>

        <ng-template #heading>
            <ul
                class="k-reset k-tabstrip-items"
                [style.justifyContent]="tabsAlignment"
                role="tablist"
                (keydown)="onKeyDown($event)"
                #tablist
            >
                <li *ngFor="let tab of tabs; let i = index;" (click)="onTabClick($event, i)"
                    #tabHeadingContainer
                    role="tab"
                    [id]="tabId(i)"
                    [tabIndex]="tab.active ? 0 : -1"
                    [ngClass]="tab.cssClass"
                    [class.k-item]="true"
                    [class.k-state-default]="true"
                    [class.k-state-active]="tab.active"
                    [class.k-state-disabled]="tab.disabled"
                    [attr.aria-selected]="tab.active"
                    [attr.aria-controls]="tabPanelId(i)"
                    [attr.aria-disabled]="tab.disabled"
                ><span class="k-link">{{ tab.title }}<ng-template [ngTemplateOutlet]="tab.tabTitle?.templateRef"></ng-template></span></li>
            </ul>
        </ng-template>
        <ng-template #content>
            <ng-template ngFor let-tab [ngForOf]="tabs" let-i="index">
                <div
                    [@state]="tab.active && _animate ? 'active' : 'inactive'"
                    *ngIf="tab.active || keepTabContent"
                    [ngClass]="contentClass(tab.active)"
                    [tabIndex]="0"
                    role="tabpanel"
                    [id]="tabPanelId(i)"
                    [attr.aria-hidden]="!tab.active"
                    [attr.aria-expanded]="tab.active"
                    [attr.aria-labelledby]="tabId(i)"
                    [attr.aria-disabled]="tab.disabled"
                >
                    <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef"></ng-template>
                </div>
            </ng-template>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { animate: [{
            type: Input
        }], tabPosition: [{
            type: Input
        }], keepTabContent: [{
            type: Input
        }], tabSelect: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-tabstrip']
        }, {
            type: HostBinding,
            args: ['class.k-floatwrap']
        }, {
            type: HostBinding,
            args: ['class.k-header']
        }], height: [{
            type: Input
        }], tabsAtTop: [{
            type: HostBinding,
            args: ['class.k-tabstrip-top']
        }], tabsAtRight: [{
            type: HostBinding,
            args: ['class.k-tabstrip-right']
        }], tabsAtBottom: [{
            type: HostBinding,
            args: ['class.k-tabstrip-bottom']
        }], tabsAtLeft: [{
            type: HostBinding,
            args: ['class.k-tabstrip-left']
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabAlignment: [{
            type: Input
        }], tablist: [{
            type: ViewChild,
            args: ['tablist']
        }], tabs: [{
            type: ContentChildren,
            args: [TabStripTabComponent]
        }], tabHeadingContainers: [{
            type: ViewChildren,
            args: ['tabHeadingContainer']
        }] }); })();

/**
 * Represents a template that defines the content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.
 * Using this template directive will override all other templates,
 * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.
 */
class DrawerTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerTemplateDirective.ɵfac = function DrawerTemplateDirective_Factory(t) { return new (t || DrawerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerTemplateDirective, selectors: [["", "kendoDrawerTemplate", ""]] });
/** @nocollapse */
DrawerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the item content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.
 */
class DrawerItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerItemTemplateDirective.ɵfac = function DrawerItemTemplateDirective_Factory(t) { return new (t || DrawerItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerItemTemplateDirective, selectors: [["", "kendoDrawerItemTemplate", ""]] });
/** @nocollapse */
DrawerItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerItemTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the header content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.
 */
class DrawerHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerHeaderTemplateDirective.ɵfac = function DrawerHeaderTemplateDirective_Factory(t) { return new (t || DrawerHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerHeaderTemplateDirective, selectors: [["", "kendoDrawerHeaderTemplate", ""]] });
/** @nocollapse */
DrawerHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the footer content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.
 */
class DrawerFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DrawerFooterTemplateDirective.ɵfac = function DrawerFooterTemplateDirective_Factory(t) { return new (t || DrawerFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DrawerFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DrawerFooterTemplateDirective, selectors: [["", "kendoDrawerFooterTemplate", ""]] });
/** @nocollapse */
DrawerFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDrawerFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
function miniExpandPush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function miniCollapsePush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 *
 */
function miniExpandOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${miniWidth}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function expandPush(duration, width) {
    return [
        style({ overflow: 'hidden', flexBasis: '0px' }),
        animate(`${duration}ms ease-in`, style({ flexBasis: `${width}px` }))
    ];
}
/**
 * @hidden
 */
function collapsePush(duration, width) {
    return [
        style({ flexBasis: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', flexBasis: `0px` }))
    ];
}
/**
 * @hidden
 */
function expandRTLOverlay(duration) {
    return [
        style({ transform: `translateX(100%)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function expandOverlay(duration, position) {
    const translateDir = position !== 'end' ? `-100%` : `100%`;
    return [
        style({ transform: `translateX(${translateDir})` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(0)` }))
    ];
}
/**
 * @hidden
 */
function miniCollapseOverlay(duration, width, miniWidth) {
    return [
        style({ width: `${width}px` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', width: `${miniWidth}px` }))
    ];
}
/**
 * @hidden
 */
function collapseOverlay(duration, position) {
    const translateDir = position !== 'end' ? '-100%' : '100%';
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(${translateDir})` }))
    ];
}
/**
 * @hidden
 */
function collapseRTLOverlay(duration) {
    return [
        style({ transform: `translateX(0)` }),
        animate(`${duration}ms ease-in`, style({ overflow: 'hidden', transform: `translateX(100%)` }))
    ];
}
/**
 * @hidden
 */
function expandAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniExpandPush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return expandPush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniExpandOverlay(duration, width, miniWidth);
    }
}
/**
 * @hidden
 */
function collapseAnimation(settings) {
    const duration = settings.animation.duration;
    const width = settings.width;
    const miniWidth = settings.miniWidth;
    const mode = settings.mode;
    const mini = settings.mini;
    const rtl = settings.rtl;
    const position = settings.position;
    if (mini && mode === 'push') {
        return miniCollapsePush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return collapsePush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniCollapseOverlay(duration, width, miniWidth);
    }
}

/**
 * Arguments for the `select` event of the Drawer.
 */
class DrawerSelectEvent extends PreventableEvent {
}

/**
 * @hidden
 */
class DrawerService {
    constructor() {
        this.selectedIndices = [];
    }
    emit(event, args) {
        const drawer = this.owner;
        const eventArgs = new DrawerSelectEvent(Object.assign({}, args, { sender: drawer }));
        if (hasObservers(drawer[event])) {
            drawer[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    onSelect(selectedIdx) {
        this.selectedIndices = [selectedIdx];
        const drawer = this.owner;
        if (drawer.autoCollapse && !drawer.minimized) {
            drawer.toggle(false);
        }
    }
    initSelection() {
        const items = this.owner.items;
        this.selectedIndices = [];
        for (let i = 0; i < items.length; i++) {
            if (items[i].selected) {
                this.selectedIndices.push(i);
            }
        }
    }
}
DrawerService.ɵfac = function DrawerService_Factory(t) { return new (t || DrawerService)(); };
DrawerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DrawerService, factory: DrawerService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const DEFAULT_ANIMATION = { type: 'slide', duration: 200 };
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-drawer-container>
 *             <kendo-drawer #drawer
 *                  [items]="items"
 *                  [mode]="'overlay'"
 *                  [(expanded)]="expanded">
 *              </kendo-drawer>
 *              <kendo-drawer-content>
 *                  <button class="k-button" (click)="drawer.toggle()">Open the Drawer</button>
 *              </kendo-drawer-content>
 *        </kendo-drawer-container>
 *    `
 * })
 * class AppComponent {
 *    public expanded = false;
 *
 *    public items: any[] = [
 *      { text: 'Inbox', icon: 'k-i-inbox' },
 *      { text: 'Notifications', icon: 'k-i-bell' },
 *      { text: 'Date', icon: 'k-i-calendar' }
 *    ];
 * }
 * ```
 */
class DrawerComponent {
    constructor(element, builder, localizationService, drawerService) {
        this.element = element;
        this.builder = builder;
        this.localizationService = localizationService;
        this.drawerService = drawerService;
        this.hostClasses = true;
        /**
         * Specifies the mode in which the Drawer will be displayed.
         *
         * The possible values are:
         * * (Default) `overlay`
         * * `push`
         */
        this.mode = 'overlay';
        /**
         * Specifies the position of the Drawer
         * ([see example]({% slug positioning_drawer %})).
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.position = 'start';
        /**
         * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed
         * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
         */
        this.mini = false;
        /**
         * Specifies the state of the Drawer.
         */
        this.expanded = false;
        /**
         * Defines the width of the Drawer when it is expanded.
         * Defaults to `240`.
         */
        this.width = 240;
        /**
         * Defines the width of the Drawer when the mini view is enabled
         * and the component is collapsed. Defaults to `60`.
         */
        this.miniWidth = 50;
        /**
         * Specifies if the Drawer will be automatically collapsed when an item
         * or the overlay is clicked. Defaults to `true`.
         */
        this.autoCollapse = true;
        /**
         * Specifies the animation settings of the Drawer.
         * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true`
         *    * `false`
         * * `DrawerAnimation`
         *    * (Default) `type?: 'slide'`
         *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.
         */
        this.animation = DEFAULT_ANIMATION;
        /**
         * Fires when the Drawer is expanded and its animation is complete.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the Drawer is collapsed and its animation is complete.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires when a Drawer item is selected. This event is preventable.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the `expanded` property of the component was updated.
         * Used to provide a two-way binding for the `expanded` property.
         */
        this.expandedChange = new EventEmitter();
        this.animationEnd = new EventEmitter();
        this.rtl = false;
        this._items = [];
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.drawerService.owner = this;
    }
    get startPositionClass() {
        return this.position === 'start';
    }
    get endPositionClass() {
        return this.position === 'end';
    }
    get overlayTransofrmStyles() {
        if (this.mode === 'push') {
            return;
        }
        if (this.expanded || this.minimized) {
            return `translateX(0px)`;
        }
        return `translateX(-100%)`;
    }
    get flexStyles() {
        if (this.mode === 'overlay') {
            return;
        }
        if (!this.expanded && !this.minimized) {
            return 0;
        }
        return this.drawerWidth;
    }
    /**
     * The collection of items that will be rendered in the Drawer.
     */
    set items(items) {
        if (isPresent(items)) {
            this._items = items;
            this.drawerService.initSelection();
        }
    }
    get items() {
        return this._items;
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get minimized() {
        return this.mini && !this.expanded;
    }
    /**
     * @hidden
     */
    get drawerWidth() {
        return this.minimized ? this.miniWidth : this.width;
    }
    /**
     * Toggles the visibility of the Drawer.
     *
     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.
     */
    toggle(expanded) {
        const previous = this.expanded;
        const current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        if (current === true) {
            this.setExpanded(true);
        }
        else if (current === false && !this.animation) {
            this.setExpanded(false);
        }
        if (this.animation) {
            this.animationEnd.pipe(take(1))
                .subscribe(() => { this.onAnimationEnd(current); });
            this.animate(current);
        }
        else {
            this[current ? 'expand' : 'collapse'].emit();
        }
    }
    onAnimationEnd(currentExpanded) {
        if (currentExpanded) {
            this.expand.emit();
        }
        else {
            this.setExpanded(false);
            this.collapse.emit();
        }
    }
    setExpanded(value) {
        this.expanded = value;
        this.expandedChange.emit(value);
    }
    animate(expanded) {
        const settings = {
            mode: this.mode,
            mini: this.mini,
            miniWidth: this.miniWidth,
            width: this.width,
            rtl: this.rtl,
            position: this.position,
            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION
        };
        const animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
        const player = this.createPlayer(animation, this.element.nativeElement);
        player.play();
    }
    createPlayer(animation, animatedElement) {
        const factory = this.builder.build(animation);
        let player = factory.create(animatedElement);
        player.onDone(() => {
            if (player) {
                this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    }
}
DrawerComponent.ɵfac = function DrawerComponent_Factory(t) { return new (t || DrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(DrawerService)); };
DrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerComponent, selectors: [["kendo-drawer"]], contentQueries: function DrawerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerFooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerHeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerItemTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
    } }, hostVars: 13, hostBindings: function DrawerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("transform", ctx.overlayTransofrmStyles)("flex-basis", ctx.flexStyles, "px");
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-drawer", ctx.hostClasses)("k-drawer-start", ctx.startPositionClass)("k-drawer-end", ctx.endPositionClass);
    } }, inputs: { mode: "mode", position: "position", mini: "mini", expanded: "expanded", width: "width", miniWidth: "miniWidth", autoCollapse: "autoCollapse", animation: "animation", items: "items" }, outputs: { expand: "expand", collapse: "collapse", select: "select", expandedChange: "expandedChange" }, exportAs: ["kendoDrawer"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            DrawerService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer'
            }
        ])], decls: 1, vars: 1, consts: [["class", "k-drawer-wrapper", 3, "width", 4, "ngIf"], [1, "k-drawer-wrapper"], [4, "ngIf"], ["kendoDrawerList", "", 1, "k-drawer-items", 3, "items", "mini", "expanded", "itemTemplate"], [3, "ngTemplateOutlet"]], template: function DrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerComponent_div_0_Template, 3, 4, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.expanded || ctx.mini);
    } }, directives: function () { return [ɵngcc1.NgIf, DrawerListComponent, ɵngcc1.NgTemplateOutlet]; }, encapsulation: 2 });
/** @nocollapse */
DrawerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder },
    { type: LocalizationService },
    { type: DrawerService }
];
DrawerComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-drawer',] }],
    startPositionClass: [{ type: HostBinding, args: ['class.k-drawer-start',] }],
    endPositionClass: [{ type: HostBinding, args: ['class.k-drawer-end',] }],
    overlayTransofrmStyles: [{ type: HostBinding, args: ['style.transform',] }],
    flexStyles: [{ type: HostBinding, args: ['style.flexBasis.px',] }],
    mode: [{ type: Input }],
    position: [{ type: Input }],
    mini: [{ type: Input }],
    expanded: [{ type: Input }],
    width: [{ type: Input }],
    miniWidth: [{ type: Input }],
    autoCollapse: [{ type: Input }],
    items: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    animation: [{ type: Input }],
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    select: [{ type: Output }],
    expandedChange: [{ type: Output }],
    drawerTemplate: [{ type: ContentChild, args: [DrawerTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [DrawerFooterTemplateDirective,] }],
    headerTemplate: [{ type: ContentChild, args: [DrawerHeaderTemplateDirective,] }],
    itemTemplate: [{ type: ContentChild, args: [DrawerItemTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoDrawer',
                providers: [
                    LocalizationService,
                    DrawerService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.drawer'
                    }
                ],
                selector: 'kendo-drawer',
                template: `
        <div class="k-drawer-wrapper" *ngIf="expanded || mini" [style.width.px]="drawerWidth">
            <ng-container *ngIf="!drawerTemplate">
                <ng-template *ngIf="headerTemplate"
                    [ngTemplateOutlet]="headerTemplate?.templateRef">
                </ng-template>

                <ul kendoDrawerList
                    [items]="items" [mini]="mini" [expanded]="expanded"
                    [itemTemplate]="itemTemplate?.templateRef"
                    class="k-drawer-items">
                </ul>

                <ng-template *ngIf="footerTemplate"
                    [ngTemplateOutlet]="footerTemplate?.templateRef">
                </ng-template>
            </ng-container>

            <ng-template *ngIf="drawerTemplate"
                [ngTemplateOutlet]="drawerTemplate?.templateRef">
            </ng-template>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.AnimationBuilder }, { type: ɵngcc2.LocalizationService }, { type: DrawerService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-drawer']
        }], mode: [{
            type: Input
        }], position: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }], width: [{
            type: Input
        }], miniWidth: [{
            type: Input
        }], autoCollapse: [{
            type: Input
        }], animation: [{
            type: Input
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], select: [{
            type: Output
        }], expandedChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], startPositionClass: [{
            type: HostBinding,
            args: ['class.k-drawer-start']
        }], endPositionClass: [{
            type: HostBinding,
            args: ['class.k-drawer-end']
        }], overlayTransofrmStyles: [{
            type: HostBinding,
            args: ['style.transform']
        }], flexStyles: [{
            type: HostBinding,
            args: ['style.flexBasis.px']
        }], items: [{
            type: Input
        }], drawerTemplate: [{
            type: ContentChild,
            args: [DrawerTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [DrawerFooterTemplateDirective]
        }], headerTemplate: [{
            type: ContentChild,
            args: [DrawerHeaderTemplateDirective]
        }], itemTemplate: [{
            type: ContentChild,
            args: [DrawerItemTemplateDirective]
        }] }); })();

/**
 * Serves as a container for the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}) and its content.
 */
class DrawerContainerComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    get hostClass() {
        return true;
    }
    get overlayClass() {
        return this.drawer.mode === 'overlay';
    }
    get miniClass() {
        return this.drawer.mini;
    }
    get pushClass() {
        return this.drawer.mode === 'push';
    }
    get isExpandedClass() {
        return this.drawer.expanded;
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get overlay() {
        return isPresent(this.drawer) &&
            this.drawer.expanded &&
            this.drawer.mode === 'overlay';
    }
    /**
     * @hidden
     */
    closeDrawer() {
        if (this.overlay && this.drawer.autoCollapse) {
            this.drawer.toggle(false);
        }
    }
}
DrawerContainerComponent.ɵfac = function DrawerContainerComponent_Factory(t) { return new (t || DrawerContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
DrawerContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerContainerComponent, selectors: [["kendo-drawer-container"]], contentQueries: function DrawerContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.drawer = _t.first);
    } }, hostVars: 11, hostBindings: function DrawerContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-drawer-container", ctx.hostClass)("k-drawer-overlay", ctx.overlayClass)("k-drawer-mini", ctx.miniClass)("k-drawer-push", ctx.pushClass)("k-drawer-expanded", ctx.isExpandedClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.drawer.container'
            }
        ])], ngContentSelectors: _c6, decls: 2, vars: 1, consts: [["class", "k-overlay", 3, "click", 4, "ngIf"], [1, "k-overlay", 3, "click"]], template: function DrawerContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, DrawerContainerComponent_div_0_Template, 1, 0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.overlay);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
DrawerContainerComponent.ctorParameters = () => [
    { type: LocalizationService }
];
DrawerContainerComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-drawer-container',] }],
    overlayClass: [{ type: HostBinding, args: ['class.k-drawer-overlay',] }],
    miniClass: [{ type: HostBinding, args: ['class.k-drawer-mini',] }],
    pushClass: [{ type: HostBinding, args: ['class.k-drawer-push',] }],
    isExpandedClass: [{ type: HostBinding, args: ['class.k-drawer-expanded',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    drawer: [{ type: ContentChild, args: [DrawerComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-drawer-container',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.drawer.container'
                    }
                ],
                template: `
        <div class="k-overlay" *ngIf="overlay" (click)="closeDrawer()"></div>
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-drawer-container']
        }], overlayClass: [{
            type: HostBinding,
            args: ['class.k-drawer-overlay']
        }], miniClass: [{
            type: HostBinding,
            args: ['class.k-drawer-mini']
        }], pushClass: [{
            type: HostBinding,
            args: ['class.k-drawer-push']
        }], isExpandedClass: [{
            type: HostBinding,
            args: ['class.k-drawer-expanded']
        }], drawer: [{
            type: ContentChild,
            args: [DrawerComponent]
        }] }); })();

/**
 * Represents the content of the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 */
class DrawerContentComponent {
    constructor() {
        this.hostClasses = true;
    }
}
DrawerContentComponent.ɵfac = function DrawerContentComponent_Factory(t) { return new (t || DrawerContentComponent)(); };
DrawerContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerContentComponent, selectors: [["kendo-drawer-content"]], hostVars: 2, hostBindings: function DrawerContentComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-drawer-content", ctx.hostClasses);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function DrawerContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
DrawerContentComponent.ctorParameters = () => [];
DrawerContentComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-drawer-content',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerContentComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-drawer-content',
                template: `
        <ng-content></ng-content>
    `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return []; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-drawer-content']
        }] }); })();

/**
 * Represents a template that defines the content of the whole Step.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperStepTemplate` directive inside the `<kendo-stepper>` tag.
 */
class StepperStepTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
StepperStepTemplateDirective.ɵfac = function StepperStepTemplateDirective_Factory(t) { return new (t || StepperStepTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
StepperStepTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StepperStepTemplateDirective, selectors: [["", "kendoStepperStepTemplate", ""]] });
/** @nocollapse */
StepperStepTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperStepTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoStepperStepTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the content of the Step label.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperLabelTemplate` directive inside the `<kendo-stepper>` tag.
 */
class StepperLabelTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
StepperLabelTemplateDirective.ɵfac = function StepperLabelTemplateDirective_Factory(t) { return new (t || StepperLabelTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
StepperLabelTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StepperLabelTemplateDirective, selectors: [["", "kendoStepperLabelTemplate", ""]] });
/** @nocollapse */
StepperLabelTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperLabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoStepperLabelTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents a template that defines the content of the Step indicator.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoStepperIndicatorTemplate` directive inside the `<kendo-stepper>` tag.
 */
class StepperIndicatorTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
StepperIndicatorTemplateDirective.ɵfac = function StepperIndicatorTemplateDirective_Factory(t) { return new (t || StepperIndicatorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
StepperIndicatorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StepperIndicatorTemplateDirective, selectors: [["", "kendoStepperIndicatorTemplate", ""]] });
/** @nocollapse */
StepperIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperIndicatorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoStepperIndicatorTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Arguments for the `activate` event of the Stepper.
 */
class StepperActivateEvent extends PreventableEvent {
}

const DEFAULT_CURRENT_STEP = 0;
const handlers = {};
handlers[Keys.ArrowLeft] = 'left';
handlers[Keys.ArrowRight] = 'right';
handlers[Keys.ArrowUp] = 'up';
handlers[Keys.ArrowDown] = 'down';
handlers[Keys.Home] = 'home';
handlers[Keys.End] = 'end';
handlers[Keys.Enter] = 'enter';
handlers[Keys.Space] = 'enter';
const handlersRTL = Object.assign({}, handlers);
handlersRTL[Keys.ArrowLeft] = 'right';
handlersRTL[Keys.ArrowRight] = 'left';
/**
 * @hidden
 */
class StepperService {
    constructor(localization, ngZone, changeDetector) {
        this.localization = localization;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.currentStep = DEFAULT_CURRENT_STEP;
        this.triggerValidation = new EventEmitter();
        this.focusedStepChange = new EventEmitter();
    }
    get handlers() {
        return this.localization.rtl ? handlersRTL : handlers;
    }
    emit(event, eventArgs) {
        const stepper = this.owner;
        if (hasObservers(stepper[event])) {
            stepper[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    }
    onActivate(currentIdx, originalEvent) {
        const eventArgs = new StepperActivateEvent({
            index: currentIdx,
            step: this.owner.steps[currentIdx],
            originalEvent: originalEvent,
            sender: this.owner
        });
        this.ngZone.run(() => {
            if (!this.emit('activate', eventArgs)) {
                this.currentStep = currentIdx;
                this.owner['currentStepChange'].emit(currentIdx);
                this.changeDetector.detectChanges();
            }
        });
    }
    validateSteps() {
        this.triggerValidation.emit();
    }
    keydown(e) {
        const current = this.focusedStep || this.currentStep;
        const handler = this.handlers[e.keyCode];
        if (!isPresent(current)) {
            return;
        }
        if (handler) {
            e.preventDefault();
            this[handler](e);
        }
    }
    left() {
        if (!this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    }
    right() {
        if (!this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    }
    up() {
        if (this.isHorizontal) {
            return;
        }
        this.focusPrevStep();
    }
    down() {
        if (this.isHorizontal) {
            return;
        }
        this.focusNextStep();
    }
    home() {
        this.focusedStep = 0;
        this.focusedStepChange.emit();
    }
    end() {
        this.focusedStep = this.owner.steps.length - 1;
        this.focusedStepChange.emit();
    }
    enter(event) {
        if (this.focusedStep === this.currentStep) {
            return;
        }
        if (this.isStepDisabled(this.focusedStep)) {
            return;
        }
        if (this.owner.linear && this.isPrevOrNextStep(this.focusedStep) === false) {
            return;
        }
        this.onActivate(this.focusedStep, event);
    }
    focus(focusedIdx) {
        this.focusedStep = focusedIdx;
    }
    focusNextStep() {
        if (this.focusedStep < this.owner.steps.length) {
            this.focusedStep += 1;
            this.focusedStepChange.emit();
        }
    }
    focusPrevStep() {
        if (this.focusedStep > 0) {
            this.focusedStep -= 1;
            this.focusedStepChange.emit();
        }
    }
    isStepDisabled(index) {
        return this.owner.steps[index].disabled;
    }
    isPrevOrNextStep(index) {
        return index === this.currentStep + 1 || index === this.currentStep - 1;
    }
    get isHorizontal() {
        return this.owner.orientation === 'horizontal';
    }
}
StepperService.ɵfac = function StepperService_Factory(t) { return new (t || StepperService)(ɵngcc0.ɵɵinject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef)); };
StepperService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: StepperService, factory: StepperService.ɵfac });
/** @nocollapse */
StepperService.ctorParameters = () => [
    { type: LocalizationService },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

const DEFAULT_ANIMATION_DURATION = 400;
/**
 * Represents the [Kendo UI Stepper component for Angular]({% slug overview_stepper %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-stepper [steps]="steps">
 *        </kendo-stepper>
 *    `
 * })
 * class AppComponent {
 *    public steps: Array<StepperStep> = [
 *      { label: 'Step One' }, { label: 'Step Two' }, { label: 'Step Three' }
 *    ];
 * }
 * ```
 */
class StepperComponent {
    constructor(renderer, elem, localization, stepperService) {
        this.renderer = renderer;
        this.elem = elem;
        this.localization = localization;
        this.stepperService = stepperService;
        this.hostClasses = true;
        this.ariaRole = 'navigation';
        this.displayStyle = 'grid';
        /**
         * Specifies the type of the steps in the Stepper.
         *
         * The possible values are:
         * * (Default) `indicator`
         * * `label`
         * * `full`
         */
        this.stepType = 'indicator';
        /**
         * Specifies the linear flow of the Stepper.
         *
         * @default true
         */
        this.linear = true;
        /**
         * Specifies the orientation of the Stepper
         * ([see example]({% slug orientation_stepper %})).
         *
         * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the duration of the progress indicator animation in milliseconds. Defaults to `400ms`.
         *
         * The possible values are:
         *  * Boolean
         *    * (Default) `true`
         *    * false
         *  * Number
         */
        this.animation = true;
        /**
         * Fires when a step is about to be activated. This event is preventable.
         */
        this.activate = new EventEmitter();
        /**
         * Fires when the `currentStep` property of the component was updated.
         * Used to provide a two-way binding for the `currentStep` property.
         */
        this.currentStepChange = new EventEmitter();
        this._steps = [];
        this.dynamicRTLSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.stepperService.owner = this;
    }
    get linearClass() {
        return this.linear;
    }
    /**
     * The index of the current step.
     */
    set currentStep(value) {
        this.stepperService.currentStep = value;
    }
    get currentStep() {
        return this.stepperService.currentStep;
    }
    /**
     * The collection of steps that will be rendered in the Stepper.
     * ([see example]({% slug step_appearance_stepper %}))
     */
    set steps(steps) {
        if (isPresent(steps) && steps.length > 0) {
            this._steps = steps;
        }
    }
    get steps() {
        return this._steps;
    }
    ngOnInit() {
        this.applyHostStyling();
    }
    ngOnChanges(changes) {
        if (changes.steps && !changes.steps.firstChange) {
            this.applyHostStyling();
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * Manually triggers the validity check configured by the [isValid]({% slug api_layout_stepperstep %}#toc-isvalid) property of the steps.
     *
     * Steps that have their [validate]({% slug api_layout_stepperstep %}#toc-validate) property set to `false`, will not be validated.
     */
    validateSteps() {
        this.stepperService.validateSteps();
    }
    applyHostStyling() {
        const stepFramesStyle = this.orientation === 'horizontal' ? 'grid-template-columns' : 'grid-template-rows';
        const stepFramesValue = `repeat(${this.steps.length * 2}, 1fr)`;
        this.renderer.setStyle(this.elem.nativeElement, stepFramesStyle, stepFramesValue);
    }
    /**
     * @hidden
     */
    get progressAnimation() {
        return { duration: this.animationDuration };
    }
    /**
     * @hidden
     */
    get animationDuration() {
        if (typeof this.animation === 'number') {
            return this.animation;
        }
        if (typeof this.animation === 'boolean' && this.animation) {
            return DEFAULT_ANIMATION_DURATION;
        }
        return 0;
    }
    /**
     * @hidden
     */
    get stepsListStyling() {
        if (this.orientation === 'horizontal') {
            return { 'grid-column-start': 1, 'grid-column-end': -1 };
        }
        return { 'grid-row-start': 1, 'grid-row-end': -1 };
    }
    /**
     * @hidden
     */
    get progressBarStyling() {
        if (this.orientation === 'horizontal') {
            return {
                'grid-column-start': 2,
                'grid-column-end': this.steps.length * 2
            };
        }
        return {
            'grid-row-start': 2,
            'grid-row-end': this.steps.length * 2
        };
    }
    /***
     * @hidden
     */
    get isHorizontal() {
        return this.stepperService.isHorizontal;
    }
}
StepperComponent.ɵfac = function StepperComponent_Factory(t) { return new (t || StepperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(StepperService)); };
StepperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StepperComponent, selectors: [["kendo-stepper"]], contentQueries: function StepperComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, StepperStepTemplateDirective, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, StepperLabelTemplateDirective, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, StepperIndicatorTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);
    } }, hostVars: 10, hostBindings: function StepperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.ariaRole)("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("display", ctx.displayStyle);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-stepper", ctx.hostClasses)("k-stepper-linear", ctx.linearClass);
    } }, inputs: { stepType: "stepType", linear: "linear", orientation: "orientation", animation: "animation", currentStep: "currentStep", steps: "steps", successIcon: "successIcon", errorIcon: "errorIcon" }, outputs: { activate: "activate", currentStepChange: "currentStepChange" }, exportAs: ["kendoStepper"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            StepperService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.stepper'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 16, consts: [["kendoStepperLocalizedMessages", "", 6, "optional"], ["kendoStepperList", "", 1, "k-step-list", 3, "stepType", "linear", "orientation", "steps", "currentStep", "successIcon", "errorIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "ngStyle"], [3, "animation", "max", "label", "orientation", "reverse", "value", "ngStyle", 4, "ngIf"], [3, "animation", "max", "label", "orientation", "reverse", "value", "ngStyle"]], template: function StepperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c13);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelement(2, "ol", 1);
        ɵngcc0.ɵɵtemplate(3, StepperComponent_kendo_progressbar_3_Template, 1, 8, "kendo-progressbar", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("k-step-list-horizontal", ctx.isHorizontal)("k-step-list-vertical", !ctx.isHorizontal);
        ɵngcc0.ɵɵproperty("stepType", ctx.stepType)("linear", ctx.linear)("orientation", ctx.orientation)("steps", ctx.steps)("currentStep", ctx.currentStep)("successIcon", ctx.successIcon)("errorIcon", ctx.errorIcon)("indicatorTemplate", ctx.indicatorTemplate == null ? null : ctx.indicatorTemplate.templateRef)("labelTemplate", ctx.labelTemplate == null ? null : ctx.labelTemplate.templateRef)("stepTemplate", ctx.stepTemplate == null ? null : ctx.stepTemplate.templateRef)("ngStyle", ctx.stepsListStyling);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.steps.length > 0);
    } }, directives: function () { return [LocalizedMessagesDirective,
        StepperListComponent, ɵngcc1.NgStyle, ɵngcc1.NgIf, ɵngcc5.ProgressBarComponent]; }, encapsulation: 2 });
/** @nocollapse */
StepperComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: LocalizationService },
    { type: StepperService }
];
StepperComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-stepper',] }],
    linearClass: [{ type: HostBinding, args: ['class.k-stepper-linear',] }],
    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    displayStyle: [{ type: HostBinding, args: ['style.display',] }],
    stepType: [{ type: Input }],
    linear: [{ type: Input }],
    orientation: [{ type: Input }],
    currentStep: [{ type: Input }],
    steps: [{ type: Input }],
    successIcon: [{ type: Input }],
    errorIcon: [{ type: Input }],
    animation: [{ type: Input }],
    activate: [{ type: Output }],
    currentStepChange: [{ type: Output }],
    stepTemplate: [{ type: ContentChild, args: [StepperStepTemplateDirective, { static: true },] }],
    labelTemplate: [{ type: ContentChild, args: [StepperLabelTemplateDirective, { static: true },] }],
    indicatorTemplate: [{ type: ContentChild, args: [StepperIndicatorTemplateDirective, { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoStepper',
                providers: [
                    LocalizationService,
                    StepperService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.stepper'
                    }
                ],
                selector: 'kendo-stepper',
                template: `
        <ng-container kendoStepperLocalizedMessages
            i18n-optional="kendo.stepper.optional|The text for the optional segment of the step label"
            optional="Optional"
         >
        </ng-container>
        <ol kendoStepperList
            [stepType]='stepType'
            [linear]='linear'
            [orientation]='orientation'
            [steps]='steps'
            [currentStep]='currentStep'
            [successIcon]='successIcon'
            [errorIcon]='errorIcon'
            [indicatorTemplate]='indicatorTemplate?.templateRef'
            [labelTemplate]='labelTemplate?.templateRef'
            [stepTemplate]='stepTemplate?.templateRef'
            class='k-step-list'
            [class.k-step-list-horizontal]='isHorizontal'
            [class.k-step-list-vertical]='!isHorizontal'
            [ngStyle]='stepsListStyling'>
        </ol>

        <kendo-progressbar *ngIf='steps.length > 0'
            [attr.aria-hidden]='true'
            [animation]='progressAnimation'
            [max]='steps.length - 1'
            [label]='false'
            [orientation]='orientation'
            [reverse]='!isHorizontal'
            [value]='currentStep'
            [ngStyle]='progressBarStyling'>
        </kendo-progressbar>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.LocalizationService }, { type: StepperService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-stepper']
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], displayStyle: [{
            type: HostBinding,
            args: ['style.display']
        }], stepType: [{
            type: Input
        }], linear: [{
            type: Input
        }], orientation: [{
            type: Input
        }], animation: [{
            type: Input
        }], activate: [{
            type: Output
        }], currentStepChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], linearClass: [{
            type: HostBinding,
            args: ['class.k-stepper-linear']
        }], currentStep: [{
            type: Input
        }], steps: [{
            type: Input
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], stepTemplate: [{
            type: ContentChild,
            args: [StepperStepTemplateDirective, { static: true }]
        }], labelTemplate: [{
            type: ContentChild,
            args: [StepperLabelTemplateDirective, { static: true }]
        }], indicatorTemplate: [{
            type: ContentChild,
            args: [StepperIndicatorTemplateDirective, { static: true }]
        }] }); })();

const SIZE_CLASSES = {
    'small': 'k-avatar-sm',
    'medium': 'k-avatar-md',
    'large': 'k-avatar-lg'
};
const SHAPE_CLASSES = {
    'circle': 'k-avatar-circle',
    'square': 'k-avatar-square',
    'rectangle': 'k-avatar-rectangle',
    'rounded': 'k-avatar-rounded'
};
/**
 * Displays images, icons or initials representing people or other entities.
 */
class AvatarComponent {
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
        /**
         * Specifies the appearance fill style of the avatar.
         *
         * The possible values are:
         * * `solid` (Default)
         * * `outline`
         *
         */
        this.fill = 'solid';
        /**
         * Sets a border to the avatar.
         */
        this.border = false;
        this._themeColor = 'primary';
        this._size = 'medium';
        this._shape = 'square';
        this.avatar = this.element.nativeElement;
    }
    /**
     * @hidden
     */
    get solidClass() {
        return this.fill === 'solid';
    }
    /**
     * @hidden
     */
    get outlineClass() {
        return this.fill === 'outline';
    }
    /**
     * @hidden
     */
    get borderClass() {
        return this.border;
    }
    /**
     * @hidden
     */
    get flexBasis() {
        return this.width;
    }
    /**
     * Sets the shape for the avatar.
     *
     * Possible values are:
     * * (Default) `square`
     * * `circle`
     * * `rectangle`
     * * `rounded`
     *
     */
    set shape(shape) {
        this.renderer.removeClass(this.avatar, SHAPE_CLASSES[this.shape]);
        this.renderer.addClass(this.avatar, SHAPE_CLASSES[shape]);
        this._shape = shape;
    }
    get shape() {
        return this._shape;
    }
    /**
     * Specifies the size of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-size)).
     *
     * The possible values are:
     * * `small`
     * * `medium` (Default)
     * * `large`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.avatar, SIZE_CLASSES[this.size]);
        this.renderer.addClass(this.avatar, SIZE_CLASSES[size]);
        this._size = size;
    }
    get size() {
        return this._size;
    }
    /**
     * Specifies the theme color of the avatar.
     * The theme color will be applied as background and border color, while also amending the text color accordingly.
     *
     * The possible values are:
     * * `primary` (Default)&mdash;Applies coloring based on primary theme color.
     * * `secondary`&mdash;Applies coloring based on secondary theme color.
     * * `tertiary`&mdash; Applies coloring based on tertiary theme color.
     * * `inherit`&mdash; Applies inherited coloring value.
     * * `info`&mdash;Applies coloring based on info theme color.
     * * `success`&mdash; Applies coloring based on success theme color.
     * * `warning`&mdash; Applies coloring based on warning theme color.
     * * `error`&mdash; Applies coloring based on error theme color.
     * * `dark`&mdash; Applies coloring based on dark theme color.
     * * `light`&mdash; Applies coloring based on light theme color.
     * * `inverse`&mdash; Applies coloring based on inverted theme color.
     *
     */
    set themeColor(themeColor) {
        this.renderer.removeClass(this.avatar, `k-avatar-${this.themeColor}`);
        this.renderer.addClass(this.avatar, `k-avatar-${themeColor}`);
        this._themeColor = themeColor;
    }
    get themeColor() {
        return this._themeColor;
    }
    /**
     * @hidden
     */
    get avatarWidth() {
        return this.width;
    }
    /**
     * @hidden
     */
    get avatarHeight() {
        return this.height;
    }
    ngAfterViewInit() {
        this.setAvatarClasses();
    }
    /**
     * @hidden
     */
    get imageUrl() {
        return `url(${this.imageSrc})`;
    }
    ngOnInit() {
        this.verifyProperties();
    }
    /**
     * @hidden
     */
    iconClasses() {
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
        if (this.iconClass) {
            return `${this.iconClass}`;
        }
    }
    /**
     * @hidden
     */
    get customAvatar() {
        return !(this.imageSrc || this.initials || this.icon || this.iconClass);
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        const inputsLength = inputs.filter((value) => value).length;
        if (inputsLength > 1) {
            throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
        }
    }
    setAvatarClasses() {
        this.renderer.addClass(this.avatar, SHAPE_CLASSES[this.shape]);
        this.renderer.addClass(this.avatar, `k-avatar-${this.themeColor}`);
        this.renderer.addClass(this.avatar, SIZE_CLASSES[this.size]);
    }
}
AvatarComponent.ɵfac = function AvatarComponent_Factory(t) { return new (t || AvatarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvatarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AvatarComponent, selectors: [["kendo-avatar"]], hostVars: 14, hostBindings: function AvatarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.flexBasis)("width", ctx.avatarWidth)("height", ctx.avatarHeight);
        ɵngcc0.ɵɵclassProp("k-avatar", ctx.hostClass)("k-avatar-solid", ctx.solidClass)("k-avatar-outline", ctx.outlineClass)("k-avatar-bordered", ctx.borderClass);
    } }, inputs: { fill: "fill", border: "border", shape: "shape", size: "size", themeColor: "themeColor", iconClass: "iconClass", width: "width", height: "height", cssStyle: "cssStyle", initials: "initials", icon: "icon", imageSrc: "imageSrc" }, ngContentSelectors: _c6, decls: 4, vars: 4, consts: [[4, "ngIf"], [1, "k-avatar-image", 3, "ngStyle"], [1, "k-avatar-text", 3, "ngStyle"], [1, "k-avatar-icon", 3, "ngStyle", "ngClass"]], template: function AvatarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, AvatarComponent_0_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, AvatarComponent_ng_container_1_Template, 2, 3, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, AvatarComponent_ng_container_2_Template, 3, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(3, AvatarComponent_ng_container_3_Template, 2, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.customAvatar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageSrc);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.initials);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon || ctx.iconClass);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgClass], encapsulation: 2 });
/** @nocollapse */
AvatarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
AvatarComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-avatar',] }],
    solidClass: [{ type: HostBinding, args: ['class.k-avatar-solid',] }],
    outlineClass: [{ type: HostBinding, args: ['class.k-avatar-outline',] }],
    borderClass: [{ type: HostBinding, args: ['class.k-avatar-bordered',] }],
    flexBasis: [{ type: HostBinding, args: ['style.flexBasis',] }],
    shape: [{ type: Input }],
    size: [{ type: Input }],
    themeColor: [{ type: Input }],
    fill: [{ type: Input }],
    border: [{ type: Input }],
    iconClass: [{ type: Input }],
    width: [{ type: Input }],
    avatarWidth: [{ type: HostBinding, args: ['style.width',] }],
    height: [{ type: Input }],
    avatarHeight: [{ type: HostBinding, args: ['style.height',] }],
    cssStyle: [{ type: Input }],
    initials: [{ type: Input }],
    icon: [{ type: Input }],
    imageSrc: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvatarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-avatar',
                template: `
        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <div class="k-avatar-image" [ngStyle]="cssStyle" [style.backgroundImage]="imageUrl"></div>
        </ng-container>

        <ng-container *ngIf="initials">
            <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass">
            <span class="k-avatar-icon" [ngStyle]="cssStyle" [ngClass]="iconClasses()"></span>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-avatar']
        }], fill: [{
            type: Input
        }], border: [{
            type: Input
        }], solidClass: [{
            type: HostBinding,
            args: ['class.k-avatar-solid']
        }], outlineClass: [{
            type: HostBinding,
            args: ['class.k-avatar-outline']
        }], borderClass: [{
            type: HostBinding,
            args: ['class.k-avatar-bordered']
        }], flexBasis: [{
            type: HostBinding,
            args: ['style.flexBasis']
        }], shape: [{
            type: Input
        }], size: [{
            type: Input
        }], themeColor: [{
            type: Input
        }], avatarWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], avatarHeight: [{
            type: HostBinding,
            args: ['style.height']
        }], iconClass: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }], initials: [{
            type: Input
        }], icon: [{
            type: Input
        }], imageSrc: [{
            type: Input
        }] }); })();

/**
 * Represents the [Kendo UI Card component for Angular]({% slug overview_card %})
 */
class CardComponent {
    constructor(localizationService) {
        this.localizationService = localizationService;
        this.hostClass = true;
        /**
         * Specifies the layout of the Card content.
         *
         * The possible values are:
         * * (Default) `vertical`
         * * `horizontal`
         *
         */
        this.orientation = 'vertical';
        /**
         * Defines the width of the Card.
         * Defaults to `285px`.
         */
        this.width = '285px';
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
    }
    get widthStyle() {
        return this.width;
    }
    get vertical() {
        return this.orientation === 'vertical';
    }
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
}
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["kendo-card"]], hostVars: 11, hostBindings: function CardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵstyleProp("width", ctx.widthStyle);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClass)("k-card", ctx.hostClass)("k-card-vertical", ctx.vertical)("k-card-horizontal", ctx.horizontal);
    } }, inputs: { orientation: "orientation", width: "width" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.card.component'
            }
        ])], ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
CardComponent.ctorParameters = () => [
    { type: LocalizationService }
];
CardComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-card',] }],
    widthStyle: [{ type: HostBinding, args: ['style.width',] }],
    vertical: [{ type: HostBinding, args: ['class.k-card-vertical',] }],
    horizontal: [{ type: HostBinding, args: ['class.k-card-horizontal',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    orientation: [{ type: Input }],
    width: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.card.component'
                    }
                ],
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-card']
        }], orientation: [{
            type: Input
        }], width: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], widthStyle: [{
            type: HostBinding,
            args: ['style.width']
        }], vertical: [{
            type: HostBinding,
            args: ['class.k-card-vertical']
        }], horizontal: [{
            type: HostBinding,
            args: ['class.k-card-horizontal']
        }] }); })();

/**
 * Specifies the content in the Card header.
 */
class CardHeaderComponent {
    constructor() {
        this.hostClass = true;
    }
}
CardHeaderComponent.ɵfac = function CardHeaderComponent_Factory(t) { return new (t || CardHeaderComponent)(); };
CardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardHeaderComponent, selectors: [["kendo-card-header"]], hostVars: 2, hostBindings: function CardHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-header", ctx.hostClass);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardHeaderComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-header',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-header',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-header']
        }] }); })();

/**
 * Specifies the content in the Card body.
 */
class CardBodyComponent {
    constructor() {
        this.hostClass = true;
    }
}
CardBodyComponent.ɵfac = function CardBodyComponent_Factory(t) { return new (t || CardBodyComponent)(); };
CardBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardBodyComponent, selectors: [["kendo-card-body"]], hostVars: 2, hostBindings: function CardBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-body", ctx.hostClass);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardBodyComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-body',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-body',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-body']
        }] }); })();

/**
 * Specifies the content in the Card footer.
 */
class CardFooterComponent {
    constructor() {
        this.hostClass = true;
    }
}
CardFooterComponent.ɵfac = function CardFooterComponent_Factory(t) { return new (t || CardFooterComponent)(); };
CardFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardFooterComponent, selectors: [["kendo-card-footer"]], hostVars: 2, hostBindings: function CardFooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-footer", ctx.hostClass);
    } }, ngContentSelectors: _c6, decls: 1, vars: 0, template: function CardFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
CardFooterComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-footer',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardFooterComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-footer',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-footer']
        }] }); })();

/**
 * Specifies the action buttons of the Card.
 * * ([see example]({% slug actions_card %})).
 */
class CardActionsComponent {
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the layout of the Card action buttons.
         *
         * * The possible values are:
         * * (Default) `horizontal`
         * * `vertical`
         *
         */
        this.orientation = 'horizontal';
        /**
         * Specifies the layout of the Card action buttons.
         *
         * The possible values are:
         * * (Default) `start`
         * * `center`
         * * `end`
         * * `stretched`
         *
         */
        this.layout = 'start';
        /**
         * Fires when the user clicks an action button.
         */
        this.action = new EventEmitter();
    }
    get stretchedClass() {
        return this.layout === 'stretched';
    }
    get startClass() {
        return this.layout === 'start';
    }
    get endClass() {
        return this.layout === 'end';
    }
    get centerClass() {
        return this.layout === 'center';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    onClick(action) {
        this.action.emit(action);
    }
    /**
     * @hidden
     */
    actionTemplate() {
        return this.actions instanceof TemplateRef;
    }
}
CardActionsComponent.ɵfac = function CardActionsComponent_Factory(t) { return new (t || CardActionsComponent)(); };
CardActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardActionsComponent, selectors: [["kendo-card-actions"]], hostVars: 14, hostBindings: function CardActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-actions", ctx.hostClass)("k-card-actions-stretched", ctx.stretchedClass)("k-card-actions-start", ctx.startClass)("k-card-actions-end", ctx.endClass)("k-card-actions-center", ctx.centerClass)("k-card-actions-vertical", ctx.verticalClass)("k-card-actions-horizontal", ctx.horizontalClass);
    } }, inputs: { orientation: "orientation", layout: "layout", actions: "actions" }, outputs: { action: "action" }, ngContentSelectors: _c6, decls: 3, vars: 3, consts: [[4, "ngIf"], ["type", "button", "class", "k-button", 3, "k-primary", "k-flat", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "k-button", 3, "click"], [3, "ngTemplateOutlet"]], template: function CardActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, CardActionsComponent_0_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, CardActionsComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, CardActionsComponent_2_Template, 1, 1, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.actions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.actionTemplate());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.actionTemplate());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
CardActionsComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-actions',] }],
    stretchedClass: [{ type: HostBinding, args: ['class.k-card-actions-stretched',] }],
    startClass: [{ type: HostBinding, args: ['class.k-card-actions-start',] }],
    endClass: [{ type: HostBinding, args: ['class.k-card-actions-end',] }],
    centerClass: [{ type: HostBinding, args: ['class.k-card-actions-center',] }],
    verticalClass: [{ type: HostBinding, args: ['class.k-card-actions-vertical',] }],
    horizontalClass: [{ type: HostBinding, args: ['class.k-card-actions-horizontal',] }],
    orientation: [{ type: Input }],
    layout: [{ type: Input }],
    actions: [{ type: Input }],
    action: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardActionsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-card-actions',
                template: `
        <ng-content *ngIf="!actions"></ng-content>

        <ng-container *ngIf="!actionTemplate()">
            <button type="button"
                class="k-button"
                [class.k-primary]="action.primary"
                [class.k-flat]="action.flat"
                (click)="onClick(action)"
                *ngFor="let action of actions"
            >
                {{ action.text }}
            </button>
        </ng-container>

        <ng-template [ngTemplateOutlet]="actions" *ngIf="actionTemplate()"></ng-template>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-actions']
        }], orientation: [{
            type: Input
        }], layout: [{
            type: Input
        }], action: [{
            type: Output
        }], stretchedClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-stretched']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-end']
        }], centerClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-center']
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-vertical']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-card-actions-horizontal']
        }], actions: [{
            type: Input
        }] }); })();

/**
 * Specifies a separator in the content of the Card.
 */
class CardSeparatorDirective {
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the orientation of the Card separator.
         *
         * The possible values are:
         * (Default) `horizontal`
         * `vertical`
         */
        this.orientation = 'horizontal';
    }
    get verticalClass() {
        return this.orientation === 'vertical';
    }
    get horizontalClass() {
        return this.orientation === 'horizontal';
    }
}
CardSeparatorDirective.ɵfac = function CardSeparatorDirective_Factory(t) { return new (t || CardSeparatorDirective)(); };
CardSeparatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardSeparatorDirective, selectors: [["", "kendoCardSeparator", ""]], hostVars: 8, hostBindings: function CardSeparatorDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("color", ctx.color);
        ɵngcc0.ɵɵclassProp("k-card-separator", ctx.hostClass)("k-separator-vertical", ctx.verticalClass)("k-separator-horizontal", ctx.horizontalClass);
    } }, inputs: { orientation: "orientation", color: "color" } });
CardSeparatorDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-separator',] }],
    verticalClass: [{ type: HostBinding, args: ['class.k-separator-vertical',] }],
    horizontalClass: [{ type: HostBinding, args: ['class.k-separator-horizontal',] }],
    color: [{ type: HostBinding, args: ['style.color',] }, { type: Input }],
    orientation: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSeparatorDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardSeparator]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-separator']
        }], orientation: [{
            type: Input
        }], verticalClass: [{
            type: HostBinding,
            args: ['class.k-separator-vertical']
        }], horizontalClass: [{
            type: HostBinding,
            args: ['class.k-separator-horizontal']
        }], color: [{
            type: HostBinding,
            args: ['style.color']
        }, {
            type: Input
        }] }); })();

/**
 * Specifies the text and styles for the title of the Card.
 */
class CardTitleDirective {
    constructor() {
        this.hostClass = true;
    }
}
CardTitleDirective.ɵfac = function CardTitleDirective_Factory(t) { return new (t || CardTitleDirective)(); };
CardTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardTitleDirective, selectors: [["", "kendoCardTitle", ""]], hostVars: 2, hostBindings: function CardTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-title", ctx.hostClass);
    } } });
CardTitleDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-title',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardTitle]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-title']
        }] }); })();

/**
 * Specifies the text and styles for the subtitle of the Card.
 */
class CardSubtitleDirective {
    constructor() {
        this.hostClass = true;
    }
}
CardSubtitleDirective.ɵfac = function CardSubtitleDirective_Factory(t) { return new (t || CardSubtitleDirective)(); };
CardSubtitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardSubtitleDirective, selectors: [["", "kendoCardSubtitle", ""]], hostVars: 2, hostBindings: function CardSubtitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-subtitle", ctx.hostClass);
    } } });
CardSubtitleDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-subtitle',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSubtitleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardSubtitle]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-subtitle']
        }] }); })();

/**
 * Specifies any media that will be displayed and aligned in the Card.
 */
class CardMediaDirective {
    constructor() {
        this.hostClass = true;
    }
}
CardMediaDirective.ɵfac = function CardMediaDirective_Factory(t) { return new (t || CardMediaDirective)(); };
CardMediaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CardMediaDirective, selectors: [["", "kendoCardMedia", ""]], hostVars: 2, hostBindings: function CardMediaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-card-media", ctx.hostClass);
    } } });
CardMediaDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-card-media',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardMediaDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoCardMedia]'
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-card-media']
        }] }); })();

/**
 * The settings of the Card action buttons.
 */
class CardAction {
}

const exportedModules = [
    AvatarComponent
];
const declarations = [
    ...exportedModules
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Avatar component.
 */
class AvatarModule {
}
AvatarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AvatarModule });
AvatarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AvatarModule_Factory(t) { return new (t || AvatarModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AvatarModule, { declarations: function () { return [AvatarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AvatarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [exportedModules],
                imports: [CommonModule]
            }]
    }], null, null); })();

const cardDirectives = [
    CardTitleDirective,
    CardSubtitleDirective,
    CardSeparatorDirective,
    CardMediaDirective
];
const exportedModules$1 = [
    CardComponent,
    CardHeaderComponent,
    CardBodyComponent,
    CardFooterComponent,
    CardActionsComponent,
    ...cardDirectives
];
const declarations$1 = [...exportedModules$1];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Card component.
 */
class CardModule {
}
CardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CardModule });
CardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CardModule_Factory(t) { return new (t || CardModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CardModule, { declarations: function () { return [CardComponent,
        CardHeaderComponent,
        CardBodyComponent,
        CardFooterComponent,
        CardActionsComponent,
        CardTitleDirective,
        CardSubtitleDirective,
        CardSeparatorDirective,
        CardMediaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CardComponent,
        CardHeaderComponent,
        CardBodyComponent,
        CardFooterComponent,
        CardActionsComponent,
        CardTitleDirective,
        CardSubtitleDirective,
        CardSeparatorDirective,
        CardMediaDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$1],
                exports: [exportedModules$1],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
const DRAWER_LINK_SELECTOR = '.k-drawer-link';
/**
 * @hidden
 */
const ACTIVE_NESTED_LINK_SELECTOR = ':focus:not(.k-state-disabled) .k-drawer-link';
/**
 * @hidden
 */
const nestedLink = (element, selector) => element.querySelector(selector);

/**
 * @hidden
 */
class DrawerItemComponent {
    constructor(drawer, element, renderer) {
        this.drawer = drawer;
        this.element = element;
        this.renderer = renderer;
    }
    get disabledClass() {
        return this.item.disabled;
    }
    get selectedClass() {
        return this.drawer.selectedIndices.indexOf(this.index) >= 0;
    }
    get label() {
        return this.item.text ? this.item.text : null;
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        const link = nestedLink(this.element.nativeElement, DRAWER_LINK_SELECTOR);
        if (link) {
            this.renderer.removeAttribute(link, 'tabindex');
        }
    }
    /**
     * @hidden
     */
    iconClasses(icon) {
        return `k-icon ${icon}`;
    }
}
DrawerItemComponent.ɵfac = function DrawerItemComponent_Factory(t) { return new (t || DrawerItemComponent)(ɵngcc0.ɵɵdirectiveInject(DrawerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
DrawerItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerItemComponent, selectors: [["", "kendoDrawerItem", ""]], hostVars: 7, hostBindings: function DrawerItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabledClass)("aria-selected", ctx.selectedClass)("aria-label", ctx.label);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabledClass)("k-state-selected", ctx.selectedClass);
    } }, inputs: { item: "item", index: "index", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded", disabled: "disabled", cssClass: "cssClass", cssStyle: "cssStyle" }, attrs: _c14, decls: 3, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], [3, "ngClass"], [1, "k-item-text"]], template: function DrawerItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerItemComponent_0_Template, 1, 4, undefined, 0);
        ɵngcc0.ɵɵtemplate(1, DrawerItemComponent_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.itemTemplate)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
/** @nocollapse */
DrawerItemComponent.ctorParameters = () => [
    { type: DrawerService },
    { type: ElementRef },
    { type: Renderer2 }
];
DrawerItemComponent.propDecorators = {
    item: [{ type: Input }],
    index: [{ type: Input }],
    itemTemplate: [{ type: Input }],
    mini: [{ type: Input }],
    expanded: [{ type: Input }],
    disabled: [{ type: Input }],
    cssClass: [{ type: Input }],
    cssStyle: [{ type: Input }],
    disabledClass: [{ type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.k-state-disabled',] }],
    selectedClass: [{ type: HostBinding, args: ['attr.aria-selected',] }, { type: HostBinding, args: ['class.k-state-selected',] }],
    label: [{ type: HostBinding, args: ['attr.aria-label',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerItemComponent, [{
        type: Component,
        args: [{
                selector: '[kendoDrawerItem]',
                template: `
        <ng-template *ngIf="itemTemplate; else defaultTemplate"
            [ngTemplateOutlet]="itemTemplate"
            [ngTemplateOutletContext]="{ $implicit: item }">
        </ng-template>

        <ng-template #defaultTemplate>
            <ng-container *ngIf="expanded">
                <span [ngClass]="iconClasses(item.icon)"></span>
                <span class="k-item-text">{{ item.text }}</span>
            </ng-container>
            <ng-container *ngIf="mini && !expanded">
                <span [ngClass]="iconClasses(item.icon)"></span>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: DrawerService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { disabledClass: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], selectedClass: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: HostBinding,
            args: ['class.k-state-selected']
        }], label: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], item: [{
            type: Input
        }], index: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], cssStyle: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
const DRAWER_ITEM_INDEX = 'data-kendo-drawer-index';

/**
 * @hidden
 */
class DrawerListComponent {
    constructor(drawerService, renderer, ngZone, changeDetector, element) {
        this.drawerService = drawerService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.element = element;
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.initialSelection();
        this.initDomEvents();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    initialSelection() {
        /* Differentiates a user selected item */
        if (this.drawerService.selectedIndices.length === 0) {
            this.drawerService.initSelection();
        }
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            this.subscriptions.add(this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this)));
            this.subscriptions.add(this.renderer.listen(nativeElement, 'keydown', this.keyDownHandler.bind(this)));
        });
    }
    clickHandler(e) {
        const itemIdx = this.getDrawerItemIndex(e.target);
        const item = this.items[itemIdx];
        if (!item) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        const args = {
            index: itemIdx,
            item: item,
            originalEvent: e
        };
        this.ngZone.run(() => {
            if (!this.drawerService.emit('select', args)) {
                this.drawerService.onSelect(itemIdx);
                this.changeDetector.detectChanges();
            }
        });
    }
    keyDownHandler(e) {
        const isEnterOrSpace = e.keyCode === Keys.Enter || e.keyCode === Keys.Space;
        if (!isEnterOrSpace) {
            return;
        }
        this.clickHandler(e);
        const link = nestedLink(this.element.nativeElement, ACTIVE_NESTED_LINK_SELECTOR);
        if (link) {
            link.click();
        }
        return false;
    }
    getDrawerItemIndex(target) {
        const item = closestItem(target, DRAWER_ITEM_INDEX, this.element.nativeElement);
        if (item) {
            return itemIndex(item, DRAWER_ITEM_INDEX);
        }
    }
}
DrawerListComponent.ɵfac = function DrawerListComponent_Factory(t) { return new (t || DrawerListComponent)(ɵngcc0.ɵɵdirectiveInject(DrawerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
DrawerListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DrawerListComponent, selectors: [["", "kendoDrawerList", ""]], inputs: { items: "items", itemTemplate: "itemTemplate", mini: "mini", expanded: "expanded" }, attrs: _c15, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoDrawerItem", "", "class", "k-drawer-item", "tabindex", "0", 3, "item", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle", 4, "ngIf"], ["class", "k-drawer-item k-drawer-separator", 3, "ngClass", "ngStyle", 4, "ngIf"], ["kendoDrawerItem", "", "tabindex", "0", 1, "k-drawer-item", 3, "item", "index", "mini", "expanded", "itemTemplate", "ngClass", "ngStyle"], [1, "k-drawer-item", "k-drawer-separator", 3, "ngClass", "ngStyle"]], template: function DrawerListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DrawerListComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, DrawerItemComponent, ɵngcc1.NgClass, ɵngcc1.NgStyle], encapsulation: 2 });
/** @nocollapse */
DrawerListComponent.ctorParameters = () => [
    { type: DrawerService },
    { type: Renderer2 },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
DrawerListComponent.propDecorators = {
    items: [{ type: Input }],
    itemTemplate: [{ type: Input }],
    mini: [{ type: Input }],
    expanded: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoDrawerList]',
                template: `
        <ng-container *ngFor="let item of items; let idx = index">
            <li *ngIf="!item.separator" kendoDrawerItem
                class="k-drawer-item"
                [item]="item"
                [index]="idx"
                [mini]="mini"
                [expanded]="expanded"
                [itemTemplate]="itemTemplate"
                [attr.${DRAWER_ITEM_INDEX}]="idx"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle"
                tabindex="0">
            </li>

            <li *ngIf="item.separator"
                class="k-drawer-item k-drawer-separator"
                [ngClass]="item.cssClass"
                [ngStyle]="item.cssStyle">
                &nbsp;
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: DrawerService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { items: [{
            type: Input
        }], itemTemplate: [{
            type: Input
        }], mini: [{
            type: Input
        }], expanded: [{
            type: Input
        }] }); })();

const templateDirectives = [
    DrawerTemplateDirective,
    DrawerHeaderTemplateDirective,
    DrawerFooterTemplateDirective,
    DrawerItemTemplateDirective
];
const exportedModules$2 = [
    DrawerComponent,
    DrawerContainerComponent,
    DrawerContentComponent,
    ...templateDirectives
];
const declarations$2 = [
    DrawerItemComponent,
    DrawerListComponent,
    ...exportedModules$2
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Drawer component.
 */
class DrawerModule {
}
DrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DrawerModule });
DrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DrawerModule_Factory(t) { return new (t || DrawerModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DrawerModule, { declarations: function () { return [DrawerItemComponent,
        DrawerListComponent,
        DrawerComponent,
        DrawerContainerComponent,
        DrawerContentComponent,
        DrawerTemplateDirective,
        DrawerHeaderTemplateDirective,
        DrawerFooterTemplateDirective,
        DrawerItemTemplateDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DrawerComponent,
        DrawerContainerComponent,
        DrawerContentComponent,
        DrawerTemplateDirective,
        DrawerHeaderTemplateDirective,
        DrawerFooterTemplateDirective,
        DrawerItemTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$2],
                exports: [exportedModules$2],
                imports: [CommonModule]
            }]
    }], null, null); })();

const exportedModules$3 = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
const declarations$3 = [
    ...exportedModules$3
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the PanelBar component.
 *
 * The module registers:
 * - `PanelBarComponent`&mdash;The `PanelBar` component class.
 * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.
 * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.
 * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.
 * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.
 */
class PanelBarModule {
}
PanelBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PanelBarModule });
PanelBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PanelBarModule_Factory(t) { return new (t || PanelBarModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PanelBarModule, { declarations: function () { return [PanelBarComponent,
        PanelBarItemComponent,
        PanelBarContentDirective,
        PanelBarItemTemplateDirective,
        PanelBarItemTitleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [PanelBarComponent,
        PanelBarItemComponent,
        PanelBarContentDirective,
        PanelBarItemTemplateDirective,
        PanelBarItemTitleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PanelBarModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$3],
                exports: [exportedModules$3],
                imports: [CommonModule]
            }]
    }], null, null); })();

const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');
const createMoveStream = (draggable) => mouseDown => draggable.kendoDrag
    .pipe(takeUntil(draggable.kendoRelease), map(({ pageX, pageY }) => ({
    originalX: mouseDown.pageX,
    originalY: mouseDown.pageY,
    pageX,
    pageY
})));
/**
 * @hidden
 */
class SplitterBarComponent {
    constructor(draggable, splitter, localization) {
        this.draggable = draggable;
        this.splitter = splitter;
        this.localization = localization;
        this.orientation = 'horizontal';
        this.index = 0;
        this.ariaRole = 'separator';
        this.focused = false;
        this.subscriptions = new Subscription();
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    get tabIndex() {
        return this.splitter.isStatic(this.index) ? -1 : 0;
    }
    get hostClasses() {
        const isHorizontal = this.orientation === 'horizontal';
        const isDraggable = this.splitter.isDraggable(this.index);
        const isStatic = this.splitter.isStatic(this.index);
        return classFromObject({
            'k-state-focused': this.focused,
            'k-splitbar': true,
            'k-splitbar-horizontal': isHorizontal,
            'k-splitbar-vertical': !isHorizontal,
            'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
            'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
            'k-splitbar-static-horizontal': isHorizontal && isStatic,
            'k-splitbar-static-vertical': !isHorizontal && isStatic
        });
    }
    get touchAction() {
        if (this.splitter.isDraggable(this.index)) {
            return 'none';
        }
    }
    get order() {
        return 2 * this.index + 1;
    }
    collapseAny() {
        if (this.expandLast) {
            this.toggleNext();
        }
        else {
            this.tryToggleNearest();
        }
    }
    onFocusIn() {
        this.focused = true;
    }
    onFocusOut() {
        this.focused = false;
    }
    onKeyDown(event) {
        const keyCode = event && event.keyCode;
        const isHorizontal = this.orientation === 'horizontal';
        const resize = delta => {
            event.preventDefault();
            const state$$1 = this.splitter.dragState(this.index);
            this.splitter.setSize(state$$1, delta);
        };
        if (keyCode === Keys.Enter) {
            event.preventDefault();
            this.collapseAny();
        }
        else if (isHorizontal && keyCode === Keys.ArrowLeft) {
            resize(-10);
        }
        else if (isHorizontal && keyCode === Keys.ArrowRight) {
            resize(10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowUp) {
            resize(-10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowDown) {
            resize(10);
        }
    }
    get expandLast() {
        const panes = this.splitter.panes;
        return panes.length === 2 && panes[1].collapsed;
    }
    ngOnInit() {
        let state$$1;
        const listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(() => this.splitter.isDraggable(this.index)), tap(() => state$$1 = this.splitter.dragState(this.index)), tap(() => this.splitter.toggleContentOverlay(this.index, true)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(({ pageX, pageY, originalX, originalY }) => {
            let delta;
            if (this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            this.splitter.setSize(state$$1, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(() => this.splitter.toggleContentOverlay(this.index, false)));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    togglePrevious() {
        this.splitter.tryToggle(this.index);
    }
    toggleNext() {
        this.splitter.tryToggle(this.index + 1);
    }
    previousArrowClass() {
        const pane = this.splitter.pane(this.index);
        const nextPane = this.splitter.pane(this.index + 1);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || nextPane.isHidden,
            'k-collapse-prev': isCollapsible,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    nextArrowClass() {
        const pane = this.splitter.pane(this.index + 1);
        const prevPane = this.splitter.pane(this.index);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || prevPane.isHidden,
            'k-collapse-next': isCollapsible,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    tryToggleNearest() {
        const prev = this.index;
        const next = this.index + 1;
        if (!this.splitter.tryToggle(prev)) {
            this.splitter.tryToggle(next);
        }
    }
}
SplitterBarComponent.ɵfac = function SplitterBarComponent_Factory(t) { return new (t || SplitterBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(SplitterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
SplitterBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SplitterBarComponent, selectors: [["kendo-splitter-bar"]], hostVars: 13, hostBindings: function SplitterBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function SplitterBarComponent_dblclick_HostBindingHandler() { return ctx.collapseAny(); })("focusin", function SplitterBarComponent_focusin_HostBindingHandler() { return ctx.onFocusIn(); })("focusout", function SplitterBarComponent_focusout_HostBindingHandler() { return ctx.onFocusOut(); })("keydown", function SplitterBarComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-orientation", ctx.orientation)("role", ctx.ariaRole)("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵclassMap(ctx.hostClasses);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.touchAction)("-ms-flex-order", ctx.order)("order", ctx.order);
        ɵngcc0.ɵɵclassProp("k-state-focused", ctx.focused);
    } }, inputs: { orientation: "orientation", index: "index" }, decls: 3, vars: 4, consts: [[3, "click"], [1, "k-resize-handle"]], template: function SplitterBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SplitterBarComponent_Template_div_click_0_listener() { return ctx.togglePrevious(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 0);
        ɵngcc0.ɵɵlistener("click", function SplitterBarComponent_Template_div_click_2_listener() { return ctx.toggleNext(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.previousArrowClass());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassMap(ctx.nextArrowClass());
    } }, encapsulation: 2 });
/** @nocollapse */
SplitterBarComponent.ctorParameters = () => [
    { type: DraggableDirective, decorators: [{ type: Host }] },
    { type: SplitterService },
    { type: LocalizationService }
];
SplitterBarComponent.propDecorators = {
    orientation: [{ type: Input }, { type: HostBinding, args: ['attr.aria-orientation',] }],
    index: [{ type: Input }],
    ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
    focused: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostClasses: [{ type: HostBinding, args: ['class',] }],
    touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
    order: [{ type: HostBinding, args: ['style.-ms-flex-order',] }, { type: HostBinding, args: ['style.order',] }],
    collapseAny: [{ type: HostListener, args: ['dblclick',] }],
    onFocusIn: [{ type: HostListener, args: ['focusin',] }],
    onFocusOut: [{ type: HostListener, args: ['focusout',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterBarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-splitter-bar',
                template: `
      <div [class]="previousArrowClass()" (click)="togglePrevious()"></div>
      <div class="k-resize-handle"></div>
      <div [class]="nextArrowClass()" (click)="toggleNext()"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc3.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: SplitterService }, { type: ɵngcc2.LocalizationService }]; }, { orientation: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-orientation']
        }], index: [{
            type: Input
        }], ariaRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], focused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], touchAction: [{
            type: HostBinding,
            args: ['style.touch-action']
        }], order: [{
            type: HostBinding,
            args: ['style.-ms-flex-order']
        }, {
            type: HostBinding,
            args: ['style.order']
        }], collapseAny: [{
            type: HostListener,
            args: ['dblclick']
        }], onFocusIn: [{
            type: HostListener,
            args: ['focusin']
        }], onFocusOut: [{
            type: HostListener,
            args: ['focusout']
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();

const exportedModules$4 = [
    SplitterComponent,
    SplitterPaneComponent
];
const declarations$4 = [
    SplitterBarComponent,
    ...exportedModules$4
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Splitter component.
 *
 * The module registers:
 * - `SplitterComponent`&mdash;The `Splitter` component class.
 * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.
 */
class SplitterModule {
}
SplitterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SplitterModule });
SplitterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SplitterModule_Factory(t) { return new (t || SplitterModule)(); }, imports: [[
            CommonModule,
            DraggableModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SplitterModule, { declarations: function () { return [SplitterBarComponent,
        SplitterComponent,
        SplitterPaneComponent]; }, imports: function () { return [CommonModule,
        DraggableModule]; }, exports: function () { return [SplitterComponent,
        SplitterPaneComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SplitterModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$4],
                exports: [exportedModules$4],
                imports: [
                    CommonModule,
                    DraggableModule
                ]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class StepperStepComponent {
    constructor(service, localization, ngZone) {
        this.service = service;
        this.localization = localization;
        this.ngZone = ngZone;
        this.isStepValid = undefined;
        this.shouldCheckValidity = undefined;
        this.subs = this.service.focusedStepChange.subscribe(() => {
            this.onFocusedStepChange();
        });
        this.subs.add(this.service.triggerValidation.subscribe(() => {
            this.handleValidityChecks();
        }));
    }
    get errorStepClass() {
        if (isPresent(this.isStepValid)) {
            return !this.isStepValid;
        }
        return false;
    }
    get successStepClass() {
        if (isPresent(this.isStepValid)) {
            return this.isStepValid;
        }
        return false;
    }
    ngOnInit() {
        this.handleValidityChecks();
    }
    ngOnChanges(changes) {
        if (changes.current && !changes.current.firstChange) {
            this.handleValidityChecks();
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    onFocusedStepChange() {
        this.ngZone.runOutsideAngular(() => {
            if (this.index === this.service.focusedStep) {
                this.stepLink.nativeElement.focus();
            }
        });
    }
    onFocus() {
        this.service.focus(this.index);
    }
    get tabIndexAttr() {
        const active = this.service.focusedStep || this.service.currentStep;
        return this.index === active ? 0 : -1;
    }
    get indicatorIconClasses() {
        if (this.step.icon) {
            return `k-icon k-i-${this.step.icon}`;
        }
        if (this.step.iconClass) {
            return `${this.step.iconClass}`;
        }
        if (this.shouldCheckValidity) {
            return this.validationIconClasses;
        }
    }
    get showIndicatorIcon() {
        if (this.shouldCheckValidity) {
            return true;
        }
        if (this.step.icon || this.step.iconClass) {
            return true;
        }
        return false;
    }
    get showLabelIcon() {
        if (this.shouldCheckValidity) {
            if (this.type === 'label') {
                return true;
            }
            if (this.step.icon || this.step.iconClass) {
                return true;
            }
        }
        return false;
    }
    get showLabelText() {
        return this.type === 'label' || this.type === 'full';
    }
    get validationIconClasses() {
        if (this.isStepValid) {
            return this.successIcon ? `${this.successIcon}` : 'k-icon k-i-check';
        }
        else {
            return this.errorIcon ? `${this.errorIcon}` : 'k-icon k-i-warning';
        }
    }
    get indicatorText() {
        const text = this.step.text;
        return text ? text : this.index + 1;
    }
    updateStepValidity() {
        if (typeof this.step.isValid === 'boolean') {
            return this.step.isValid;
        }
        if (typeof this.step.isValid === 'function') {
            return this.step.isValid(this.index);
        }
        return undefined;
    }
    get showIndicator() {
        return this.type === 'indicator' || this.type === 'full';
    }
    get showLabel() {
        if (this.type === 'label' || this.type === 'full') {
            return true;
        }
        return this.step.optional;
    }
    get optionalText() {
        return this.localization.get('optional');
    }
    get transitionDuration() {
        return this.service.owner.animationDuration;
    }
    _shouldCheckValidity() {
        if (isPresent(this.step.validate)) {
            if (typeof this.step.validate === 'boolean') {
                return this.step.validate;
            }
            if (typeof this.step.validate === 'function') {
                return this.step.validate(this.index);
            }
        }
        return isPresent(this.step.isValid) && this.index < this.current;
    }
    handleValidityChecks() {
        this.isStepValid = undefined;
        this.shouldCheckValidity = this._shouldCheckValidity();
        if (this.shouldCheckValidity) {
            this.isStepValid = this.updateStepValidity();
        }
    }
}
StepperStepComponent.ɵfac = function StepperStepComponent_Factory(t) { return new (t || StepperStepComponent)(ɵngcc0.ɵɵdirectiveInject(StepperService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
StepperStepComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StepperStepComponent, selectors: [["", "kendoStepperStep", ""]], viewQuery: function StepperStepComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c16, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepLink = _t.first);
    } }, hostVars: 4, hostBindings: function StepperStepComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-step-error", ctx.errorStepClass)("k-step-success", ctx.successStepClass);
    } }, inputs: { step: "step", index: "index", current: "current", type: "type", successIcon: "successIcon", errorIcon: "errorIcon", indicatorTemplate: "indicatorTemplate", labelTemplate: "labelTemplate", stepTemplate: "stepTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c17, decls: 4, vars: 6, consts: [["href", "#", 1, "k-step-link", 3, "focus"], ["stepLink", ""], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-step-indicator", "aria-hidden", "true", 3, "transition-duration", 4, "ngIf"], ["class", "k-step-label", 4, "ngIf"], ["aria-hidden", "true", 1, "k-step-indicator"], ["class", "k-step-indicator-icon", 3, "ngClass", 4, "ngIf"], ["class", "k-step-indicator-text", 4, "ngIf"], [1, "k-step-indicator-icon", 3, "ngClass"], [1, "k-step-indicator-text"], [1, "k-step-label"], ["class", "k-step-text", 4, "ngIf"], ["aria-hidden", "true", 3, "ngClass", 4, "ngIf"], ["class", "k-step-label-optional", 4, "ngIf"], [1, "k-step-text"], ["aria-hidden", "true", 3, "ngClass"], [1, "k-step-label-optional"]], template: function StepperStepComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵlistener("focus", function StepperStepComponent_Template_a_focus_0_listener() { return ctx.onFocus(); });
        ɵngcc0.ɵɵtemplate(2, StepperStepComponent_2_Template, 1, 5, undefined, 2);
        ɵngcc0.ɵɵtemplate(3, StepperStepComponent_ng_container_3_Template, 3, 2, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndexAttr)("title", ctx.step.label)("aria-disabled", ctx.step.disabled)("aria-current", ctx.index === ctx.current ? "step" : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.stepTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.stepTemplate);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgClass], encapsulation: 2 });
/** @nocollapse */
StepperStepComponent.ctorParameters = () => [
    { type: StepperService },
    { type: LocalizationService },
    { type: NgZone }
];
StepperStepComponent.propDecorators = {
    step: [{ type: Input }],
    index: [{ type: Input }],
    current: [{ type: Input }],
    type: [{ type: Input }],
    successIcon: [{ type: Input }],
    errorIcon: [{ type: Input }],
    indicatorTemplate: [{ type: Input }],
    labelTemplate: [{ type: Input }],
    stepTemplate: [{ type: Input }],
    stepLink: [{ type: ViewChild, args: ['stepLink', { static: true },] }],
    errorStepClass: [{ type: HostBinding, args: ['class.k-step-error',] }],
    successStepClass: [{ type: HostBinding, args: ['class.k-step-success',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperStepComponent, [{
        type: Component,
        args: [{
                selector: '[kendoStepperStep]',
                template: `
        <a href='#' class='k-step-link' #stepLink
            [attr.tabindex]='tabIndexAttr'
            [attr.title]='step.label'
            [attr.aria-disabled]='step.disabled'
            [attr.aria-current]='index === current ? "step" : null'
            (focus)='onFocus()'
        >
            <ng-template *ngIf='stepTemplate'
                [ngTemplateOutlet]='stepTemplate'
                [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
            </ng-template>

            <ng-container *ngIf='!stepTemplate'>
                <span *ngIf='showIndicator'
                    class='k-step-indicator'
                    aria-hidden='true'
                    [style.transition-duration.ms]='transitionDuration'
                >
                    <ng-template *ngIf='indicatorTemplate'
                        [ngTemplateOutlet]='indicatorTemplate'
                        [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                    </ng-template>

                    <ng-container *ngIf='!indicatorTemplate'>
                        <span *ngIf='showIndicatorIcon' class='k-step-indicator-icon' [ngClass]='indicatorIconClasses'></span>
                        <span class='k-step-indicator-text' *ngIf='!showIndicatorIcon'>{{ indicatorText }}</span>
                    </ng-container>
                </span>

                <span class='k-step-label' *ngIf='showLabel'>
                    <ng-template *ngIf='labelTemplate'
                        [ngTemplateOutlet]='labelTemplate'
                        [ngTemplateOutletContext]='{ $implicit: step, index: index }'>
                    </ng-template>

                    <ng-container *ngIf='!labelTemplate'>
                        <span class='k-step-text' *ngIf='showLabelText'>{{ step.label }}</span>
                        <span [ngClass]='validationIconClasses' *ngIf='showLabelIcon' aria-hidden='true'></span>
                        <span class='k-step-label-optional' *ngIf='step.optional'>({{optionalText}})</span>
                    </ng-container>
                </span>
            </ng-container>
        </a>
    `
            }]
    }], function () { return [{ type: StepperService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { errorStepClass: [{
            type: HostBinding,
            args: ['class.k-step-error']
        }], successStepClass: [{
            type: HostBinding,
            args: ['class.k-step-success']
        }], step: [{
            type: Input
        }], index: [{
            type: Input
        }], current: [{
            type: Input
        }], type: [{
            type: Input
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], indicatorTemplate: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], stepTemplate: [{
            type: Input
        }], stepLink: [{
            type: ViewChild,
            args: ['stepLink', { static: true }]
        }] }); })();

/**
 * @hidden
 */
const STEPPER_STEP_INDEX = 'data-kendo-stepper-index';

/**
 * @hidden
 */
class StepperListComponent {
    constructor(renderer, ngZone, service, element) {
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.service = service;
        this.element = element;
    }
    ngOnInit() {
        this.initDomEvents();
    }
    ngOnDestroy() {
        if (this.domSubs) {
            this.domSubs();
        }
    }
    get maxStepWidth() {
        return this.maxStepDimension('width');
    }
    get maxStepHeight() {
        return this.maxStepDimension('height');
    }
    maxStepDimension(dimension) {
        if (dimension === 'width' && this.orientation === 'vertical') {
            return null;
        }
        if (dimension === 'height' && this.orientation === 'horizontal') {
            return null;
        }
        return 100 / this.steps.length;
    }
    initDomEvents() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const nativeElement = this.element.nativeElement;
            const clickSubscription = this.renderer.listen(nativeElement, 'click', this.clickHandler.bind(this));
            const keydownSubscription = this.renderer.listen(nativeElement, 'keydown', (e) => {
                if (hasClass(e.target, 'k-step-link')) {
                    this.service.keydown(e);
                }
            });
            this.domSubs = () => {
                clickSubscription();
                keydownSubscription();
            };
        });
    }
    clickHandler(e) {
        e.preventDefault();
        const stepIdx = this.getStepIndex(e.target);
        const step = this.steps[stepIdx];
        if (!step || step.disabled) {
            return;
        }
        if (stepIdx === this.currentStep) {
            this.service.focus(stepIdx);
            return;
        }
        if (this.linear && this.service.isPrevOrNextStep(stepIdx) === false) {
            return;
        }
        this.service.onActivate(stepIdx, e);
    }
    getStepIndex(target) {
        const step = closestItem(target, STEPPER_STEP_INDEX, this.element.nativeElement);
        if (step) {
            return itemIndex(step, STEPPER_STEP_INDEX);
        }
    }
}
StepperListComponent.ɵfac = function StepperListComponent_Factory(t) { return new (t || StepperListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(StepperService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
StepperListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StepperListComponent, selectors: [["", "kendoStepperList", ""]], inputs: { linear: "linear", stepType: "stepType", orientation: "orientation", currentStep: "currentStep", steps: "steps", successIcon: "successIcon", errorIcon: "errorIcon", indicatorTemplate: "indicatorTemplate", labelTemplate: "labelTemplate", stepTemplate: "stepTemplate" }, attrs: _c19, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoStepperStep", "", 1, "k-step", 3, "type", "step", "index", "current", "successIcon", "errorIcon", "indicatorTemplate", "labelTemplate", "stepTemplate", "ngClass", "ngStyle"]], template: function StepperListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, StepperListComponent_ng_container_0_Template, 2, 28, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.steps);
    } }, directives: [ɵngcc1.NgForOf, StepperStepComponent, ɵngcc1.NgClass, ɵngcc1.NgStyle], encapsulation: 2 });
/** @nocollapse */
StepperListComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: NgZone },
    { type: StepperService },
    { type: ElementRef }
];
StepperListComponent.propDecorators = {
    linear: [{ type: Input }],
    stepType: [{ type: Input }],
    orientation: [{ type: Input }],
    currentStep: [{ type: Input }],
    steps: [{ type: Input }],
    successIcon: [{ type: Input }],
    errorIcon: [{ type: Input }],
    indicatorTemplate: [{ type: Input }],
    labelTemplate: [{ type: Input }],
    stepTemplate: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoStepperList]',
                template: `
        <ng-container *ngFor='let step of steps; let idx = index'>
            <li kendoStepperStep
                [attr.${STEPPER_STEP_INDEX}]='idx'
                [type]='stepType'
                [step]='step'
                [index]='idx'
                [current]='currentStep'
                [successIcon]='successIcon'
                [errorIcon]='errorIcon'
                [indicatorTemplate]='indicatorTemplate'
                [labelTemplate]='labelTemplate'
                [stepTemplate]='stepTemplate'
                class='k-step'
                [class.k-step-first]='idx === 0'
                [class.k-step-last]='idx === steps.length - 1'
                [class.k-step-done]='idx < currentStep'
                [class.k-step-current]='idx === currentStep'
                [class.k-step-optional]='step.optional'
                [class.k-step-disabled]='step.disabled'
                [ngClass]='step.cssClass'
                [ngStyle]='step.cssStyle'
                [style.max-width.%] = 'maxStepWidth'
                [style.max-height.%] = 'maxStepHeight'
            >
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: StepperService }, { type: ɵngcc0.ElementRef }]; }, { linear: [{
            type: Input
        }], stepType: [{
            type: Input
        }], orientation: [{
            type: Input
        }], currentStep: [{
            type: Input
        }], steps: [{
            type: Input
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], indicatorTemplate: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], stepTemplate: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = function Messages_Factory(t) { return ɵMessages_BaseFactory(t || Messages); };
Messages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { optional: "optional" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
Messages.propDecorators = {
    optional: [{ type: Input }]
};
const ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages);

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoStepperLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective)
                    }
                ],
                selector: `
      [kendoStepperLocalizedMessages]
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_layout %})).
 */
class CustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) { return new (t || CustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CustomMessagesComponent, selectors: [["kendo-stepper-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
CustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => CustomMessagesComponent)
                    }
                ],
                selector: 'kendo-stepper-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

const templateDirectives$1 = [
    StepperStepTemplateDirective,
    StepperLabelTemplateDirective,
    StepperIndicatorTemplateDirective
];
const exportedModules$5 = [
    StepperComponent,
    CustomMessagesComponent,
    ...templateDirectives$1
];
const declarations$5 = [
    StepperStepComponent,
    StepperListComponent,
    LocalizedMessagesDirective,
    ...exportedModules$5
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Stepper component.
 */
class StepperModule {
}
StepperModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StepperModule });
StepperModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function StepperModule_Factory(t) { return new (t || StepperModule)(); }, imports: [[CommonModule, ProgressBarModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StepperModule, { declarations: function () { return [StepperStepComponent,
        StepperListComponent,
        LocalizedMessagesDirective,
        StepperComponent,
        CustomMessagesComponent,
        StepperStepTemplateDirective,
        StepperLabelTemplateDirective,
        StepperIndicatorTemplateDirective]; }, imports: function () { return [CommonModule, ProgressBarModule]; }, exports: function () { return [StepperComponent,
        CustomMessagesComponent,
        StepperStepTemplateDirective,
        StepperLabelTemplateDirective,
        StepperIndicatorTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StepperModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$5],
                exports: [exportedModules$5],
                imports: [CommonModule, ProgressBarModule]
            }]
    }], null, null); })();

const exportedModules$6 = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective
];
const declarations$6 = [
    ...exportedModules$6
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TabStrip component.
 *
 * The module registers:
 * - `TabStripComponent`&mdash;The `TabStrip` component class.
 * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.
 * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.
 * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.
 */
class TabStripModule {
}
TabStripModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabStripModule });
TabStripModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TabStripModule_Factory(t) { return new (t || TabStripModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabStripModule, { declarations: function () { return [TabStripComponent,
        TabStripTabComponent,
        TabContentDirective,
        TabTitleDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TabStripComponent,
        TabStripTabComponent,
        TabContentDirective,
        TabTitleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabStripModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$6],
                exports: [exportedModules$6],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Layout components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Layout module
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LayoutModule], // import Layout module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class LayoutModule {
}
LayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LayoutModule });
LayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LayoutModule_Factory(t) { return new (t || LayoutModule)(); }, imports: [AvatarModule,
        CardModule,
        DrawerModule,
        PanelBarModule,
        SplitterModule,
        StepperModule,
        TabStripModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LayoutModule, { exports: [AvatarModule,
        CardModule,
        DrawerModule,
        PanelBarModule,
        SplitterModule,
        StepperModule,
        TabStripModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LayoutModule, [{
        type: NgModule,
        args: [{
                exports: [
                    AvatarModule,
                    CardModule,
                    DrawerModule,
                    PanelBarModule,
                    SplitterModule,
                    StepperModule,
                    TabStripModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { PreventableEvent, DrawerService, DrawerItemComponent, DrawerListComponent, DRAWER_ITEM_INDEX, CustomMessagesComponent, LocalizedMessagesDirective, Messages, PanelBarService, SplitterBarComponent, SplitterService, StepperListComponent, STEPPER_STEP_INDEX, StepperStepComponent, StepperService, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, SelectEvent, DrawerComponent, DrawerContainerComponent, DrawerContentComponent, DrawerSelectEvent, StepperComponent, StepperActivateEvent, AvatarComponent, CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent, CardActionsComponent, CardSeparatorDirective, CardTitleDirective, CardSubtitleDirective, CardMediaDirective, CardAction, AvatarModule, CardModule, DrawerModule, LayoutModule, PanelBarModule, SplitterModule, StepperModule, TabStripModule, DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective, StepperIndicatorTemplateDirective, StepperLabelTemplateDirective, StepperStepTemplateDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7OztnREFBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs0RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a0pBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFzSEU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJKQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0ZBbUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozt3REFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkdBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O3VFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUpBNkJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZIQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs0RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUhBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzRFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7c1JBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBZ0ZFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUpBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJKQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4SEFxQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REFnQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkJBU0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0pBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VLQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEdBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztpSkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnSEFnREU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0ZBb0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs2QkFlRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs2QkFRRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzZCQVFFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkJBUUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7aUdBc0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzttRUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBS0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztXQUtFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FLRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7aUdBcUJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs2SEE0QkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpR0FrREU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7aUhBaUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OElBQUM7QUFDRDtBQUNBO0FBQ0E7cUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFhRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7eUpBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBYUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmLCBPcHRpb25hbCwgaXNEZXZNb2RlLCBDb21wb25lbnQsIFNraXBTZWxmLCBIb3N0LCBFbGVtZW50UmVmLCBJbnB1dCwgVmlld0NoaWxkLCBIb3N0QmluZGluZywgVmlld0NoaWxkcmVuLCBDb250ZW50Q2hpbGRyZW4sIEV2ZW50RW1pdHRlciwgT3V0cHV0LCBDb250ZW50Q2hpbGQsIEhvc3RMaXN0ZW5lciwgUmVuZGVyZXIyLCBDaGFuZ2VEZXRlY3RvclJlZiwgTmdab25lLCBJbmplY3QsIFF1ZXJ5TGlzdCwgVmlld0VuY2Fwc3VsYXRpb24sIE5nTW9kdWxlLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCwgQ29tcG9uZW50TWVzc2FnZXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IEtleXMsIGhhc09ic2VydmVycywgRHJhZ2dhYmxlRGlyZWN0aXZlLCBEcmFnZ2FibGVNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCBhbmltYXRlLCBBVVRPX1NUWUxFLCBBbmltYXRpb25CdWlsZGVyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2UsIHRhcCwgZmlsdGVyLCBzd2l0Y2hNYXAsIGRlbGF5LCB0YWtlVW50aWwsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBQcm9ncmVzc0Jhck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXByb2dyZXNzYmFyJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBleHBhbmQgbW9kZXMgb2YgdGhlIFBhbmVsQmFyLlxuICogQnkgZGVmYXVsdCwgdGhlIGV4cGFuZCBtb2RlIGlzIHNldCB0byBgbXVsdGlwbGVgLlxuICovXG52YXIgUGFuZWxCYXJFeHBhbmRNb2RlO1xuKGZ1bmN0aW9uIChQYW5lbEJhckV4cGFuZE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgeW91IHRvIGV4cGFuZCBvbmx5IG9uZSBpdGVtIGF0IGEgdGltZS5cbiAgICAgKiBXaGVuIHlvdSBleHBhbmQgYW4gaXRlbSwgdGhlIGl0ZW0gdGhhdCB3YXMgcHJldmlvdXNseSBleHBhbmRlZCBpcyBjb2xsLlxuICAgICAqL1xuICAgIFBhbmVsQmFyRXhwYW5kTW9kZVtQYW5lbEJhckV4cGFuZE1vZGVbXCJTaW5nbGVcIl0gPSAwXSA9IFwiU2luZ2xlXCI7XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBleHBhbmQgb25seSBvbmUgaXRlbSBhdCBhIHRpbWUgYW5kIHJlcXVpcmVzIHlvdSB0byBzZXQgdGhlIGBoZWlnaHRgIHByb3BlcnR5LlxuICAgICAqIFRoZSBleHBhbmRlZCBhcmVhIG9jY3VwaWVzIHRoZSBlbnRpcmUgaGVpZ2h0IG9mIHRoZSBQYW5lbEJhci5cbiAgICAgKi9cbiAgICBQYW5lbEJhckV4cGFuZE1vZGVbUGFuZWxCYXJFeHBhbmRNb2RlW1wiRnVsbFwiXSA9IDFdID0gXCJGdWxsXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbW9kZSBvZiB0aGUgUGFuZWxCYXIuXG4gICAgICogQWxsb3dzIHlvdSB0byBleHBhbmQgbW9yZSB0aGFuIG9uZSBpdGVtIGF0IGEgdGltZS4gSXRlbXMgY2FuIGFsc28gYmUgdG9nZ2xlZC5cbiAgICAgKi9cbiAgICBQYW5lbEJhckV4cGFuZE1vZGVbUGFuZWxCYXJFeHBhbmRNb2RlW1wiTXVsdGlwbGVcIl0gPSAyXSA9IFwiTXVsdGlwbGVcIjtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgZXhwYW5kIG1vZGUgaXMgc2V0IHRvIGBtdWx0aXBsZWAuXG4gICAgICovXG4gICAgUGFuZWxCYXJFeHBhbmRNb2RlW1BhbmVsQmFyRXhwYW5kTW9kZVtcIkRlZmF1bHRcIl0gPSAyXSA9IFwiRGVmYXVsdFwiO1xufSkoUGFuZWxCYXJFeHBhbmRNb2RlIHx8IChQYW5lbEJhckV4cGFuZE1vZGUgPSB7fSkpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IG5leHRQYW5lbGJhcklkID0gMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQYW5lbEJhclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudFNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMua2VlcENvbnRlbnRTb3VyY2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGlsZFNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucGFyZW50JCA9IHRoaXMucGFyZW50U291cmNlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuJCA9IHRoaXMuY2hpbGRTb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMua2VlcENvbnRlbnQkID0gdGhpcy5rZWVwQ29udGVudFNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5wYklkID0gbmV4dFBhbmVsYmFySWQrKztcbiAgICB9XG4gICAgb25LZWVwQ29udGVudChrZWVwQ29udGVudCkge1xuICAgICAgICB0aGlzLmtlZXBDb250ZW50U291cmNlLm5leHQoa2VlcENvbnRlbnQpO1xuICAgIH1cbiAgICBvblNlbGVjdChldmVudCkge1xuICAgICAgICB0aGlzLmNoaWxkU291cmNlLm5leHQoZXZlbnQpO1xuICAgIH1cbiAgICBvbkZvY3VzKCkge1xuICAgICAgICB0aGlzLnBhcmVudFNvdXJjZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgICBvbkJsdXIoKSB7XG4gICAgICAgIHRoaXMucGFyZW50U291cmNlLm5leHQoZmFsc2UpO1xuICAgIH1cbn1cblBhbmVsQmFyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUGFuZWxCYXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW107XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29udGVudCB0ZW1wbGF0ZSBvZiB0aGUgZGVjbGFyYXRpdmVseSBpbml0aWFsaXplZCBQYW5lbEJhciBpdGVtcy5cbiAqIFRoZSBjb250ZW50IGNhbiBiZSBleHBhbmRlZCBvciBjb2xsYXBzZWQgdGhyb3VnaCB0aGUgaXRlbS5cbiAqL1xuY2xhc3MgUGFuZWxCYXJDb250ZW50RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuUGFuZWxCYXJDb250ZW50RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiW2tlbmRvUGFuZWxCYXJDb250ZW50XVwiXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBhbmVsQmFyQ29udGVudERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZGlyZWN0aXZlIG9mIHRoZSBQYW5lbEJhciB3aGljaCBoZWxwcyB0byBjdXN0b21pemUgdGhlIGl0ZW0gdGl0bGVcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfcGFuZWxiYXIgJX0jdG9jLWN1c3RvbWl6aW5nLXRoZS1hcHBlYXJhbmNlLW9mLXRoZS10aXRsZSkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1wYW5lbGJhcj5cbiAqICAgICAgICAgICAgPGtlbmRvLXBhbmVsYmFyLWl0ZW0gW3RpdGxlXT1cIidQYXJpcydcIiBbZXhwYW5kZWRdPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvUGFuZWxCYXJJdGVtVGl0bGU+XG4gKiAgICAgICAgICAgICAgICAgICAgQWRkaXRpb25hbCBDb250ZW50XG4gKiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICA8L2tlbmRvLXBhbmVsYmFyLWl0ZW0+XG4gKiAgICAgICAgPC9rZW5kby1wYW5lbGJhcj5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICpcbiAqIGBgYFxuICovXG5jbGFzcyBQYW5lbEJhckl0ZW1UaXRsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cblBhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9QYW5lbEJhckl0ZW1UaXRsZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbmxldCBuZXh0SWQgPSAwO1xuY29uc3QgcGFyc2VQYW5lbEJhckl0ZW1zID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLmlkKSB7XG4gICAgICAgICAgICBpdGVtLmlkID0gYGRlZmF1bHQtJHtuZXh0SWQrK31gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gcGFyc2VQYW5lbEJhckl0ZW1zKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufTtcbnZhciB1dGlsID0ge1xuICAgIHBhcnNlUGFuZWxCYXJJdGVtc1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1ByZXNlbnQgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cbmNvbnN0IGZvY3VzYWJsZVJlZ2V4ID0gL14oPzphfGlucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkL2k7XG5jb25zdCB0b0NsYXNzTGlzdCA9IChjbGFzc05hbWVzKSA9PiBTdHJpbmcoY2xhc3NOYW1lcykudHJpbSgpLnNwbGl0KCcgJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNGb2N1c2FibGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgICAgICBjb25zdCBza2lwVGFiID0gdGFiSW5kZXggPT09ICctMSc7XG4gICAgICAgIGxldCBmb2N1c2FibGUgPSB0YWJJbmRleCAhPT0gbnVsbCAmJiAhc2tpcFRhYjtcbiAgICAgICAgaWYgKGZvY3VzYWJsZVJlZ2V4LnRlc3QodGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGZvY3VzYWJsZSA9ICFlbGVtZW50LmRpc2FibGVkICYmICFza2lwVGFiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2N1c2FibGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ2xhc3MgPSAoZWxlbWVudCwgY2xhc3NOYW1lKSA9PiBCb29sZWFuKHRvQ2xhc3NMaXN0KGVsZW1lbnQuY2xhc3NOYW1lKS5maW5kKChuYW1lKSA9PiBuYW1lID09PSBjbGFzc05hbWUpKTtcbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKHRhcmdldCwgdGFyZ2V0QXR0ciwgcHJlZGljYXRlLCBzY29wZSkgPT4ge1xuICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKHRhcmdldCwgdGFyZ2V0QXR0cikpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgIT09IHNjb3BlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpdGVtSW5kZXggPSAoaXRlbSwgaW5kZXhBdHRyKSA9PiAraXRlbS5nZXRBdHRyaWJ1dGUoaW5kZXhBdHRyKTtcbmNvbnN0IGhhc0l0ZW1JbmRleCA9IChpdGVtLCBpbmRleEF0dHIpID0+IGlzUHJlc2VudChpdGVtLmdldEF0dHJpYnV0ZShpbmRleEF0dHIpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0SXRlbSA9ICh0YXJnZXQsIHRhcmdldEF0dHIsIHNjb3BlKSA9PiBjbG9zZXN0SW5TY29wZSh0YXJnZXQsIHRhcmdldEF0dHIsIGhhc0l0ZW1JbmRleCwgc2NvcGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IG5leHRJZCQxID0gMDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgaXRlbXMgb2YgdGhlIFBhbmVsQmFyLlxuICovXG5jbGFzcyBQYW5lbEJhckl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgZXZlbnRTZXJ2aWNlLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZSA9IGV2ZW50U2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBQYW5lbEJhciBpdGVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0jdG9jLXRpdGxlcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9ICdVbnRpdGxlZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdGhlIGNvbXBvbmVudCB0byBzZXQgdGhlIGBcImlkXCJgIHByb3BlcnR5IHRvIGVhY2ggaXRlbS5cbiAgICAgICAgICogVXNlZCB0byBzZXQgdGhlIGBpZGAgYXR0cmlidXRlcyBvZiB0aGUgbmVzdGVkIGVsZW1lbnRzIGFuZCB0byBlbmFibGUgdGhlIFdBSS1BUklBIHN1cHBvcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gYGRlZmF1bHQtJHtuZXh0SWQkMSsrfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBpY29uIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBuZXh0IHRvIHRoZSB0aXRsZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGl0ZW1zX3BhbmVsYmFyICV9I3RvYy10aXRsZS1pY29ucykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pY29uID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzICB0aGUgaWNvbiB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgbmV4dCB0byB0aGUgdGl0bGUgYnkgdXNpbmcgYSBjdXN0b20gQ1NTIGNsYXNzXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0jdG9jLXRpdGxlLWljb25zKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmljb25DbGFzcyA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgbG9jYXRpb24gb2YgdGhlIGltYWdlIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgbmV4dCB0byB0aGUgdGl0bGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpdGVtc19wYW5lbGJhciAlfSN0b2MtdGl0bGUtaW1hZ2VzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmltYWdlVXJsID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIGRpc2FibGVzIGEgUGFuZWxCYXIgaXRlbSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGl0ZW1zX3BhbmVsYmFyICV9I3RvYy1kaXNhYmxlZC1zdGF0ZSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgYSBQYW5lbEJhciBpdGVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaXRlbXNfcGFuZWxiYXIgJX0jdG9jLXNlbGVjdGVkLXN0YXRlKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2VlcENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDaGlsZEl0ZW1zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImluYWN0aXZlXCI7XG4gICAgICAgIHRoaXMucm9sZSA9IFwidHJlZWl0ZW1cIjtcbiAgICAgICAgdGhpcy50aXRsZUF0dHJpYnV0ZSA9IG51bGw7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JhcHBlckZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLl9leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGV2ZW50U2VydmljZS5wYXJlbnQkLnN1YnNjcmliZShmb2N1c2VkID0+IHRoaXMub25XcmFwcGVyRm9jdXNDaGFuZ2UoZm9jdXNlZCkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChldmVudFNlcnZpY2Uua2VlcENvbnRlbnQkLnN1YnNjcmliZShrZWVwQ29udGVudCA9PiB0aGlzLmtlZXBDb250ZW50ID0ga2VlcENvbnRlbnQpKTtcbiAgICAgICAgdGhpcy53cmFwcGVyRm9jdXNlZCA9IHBhcmVudCA/IHBhcmVudC5mb2N1c2VkIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgZXhwYW5kcyB0aGUgUGFuZWxCYXIgaXRlbSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGl0ZW1zX3BhbmVsYmFyICV9I3RvYy1leHBhbmRlZC1zdGF0ZSkpLlxuICAgICAqL1xuICAgIHNldCBleHBhbmRlZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhY3RpdmVTdGF0ZSA9IHRoaXMuYW5pbWF0ZSA/IFwiYWN0aXZlXCIgOiBcImFjdGl2ZVdpdGhvdXRBbmltYXRpb25cIjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHZhbHVlID8gYWN0aXZlU3RhdGUgOiBcImluYWN0aXZlXCI7XG4gICAgICAgIGlmICghdGhpcy5rZWVwQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVFeHBhbmRlZENoaWxkQW5pbWF0aW9ucyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXhwYW5kZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWQ7XG4gICAgfVxuICAgIGdldCBhbmltYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFNlcnZpY2UuYW5pbWF0ZTtcbiAgICB9XG4gICAgZ2V0IGtJdGVtQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQga1N0YXRlRGVmYXVsdENsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCBrU3RhdGVEaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGtTdGF0ZUV4cGFuZGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmV4cGFuZGVkICYmICh0aGlzLmhhc0NoaWxkSXRlbXMgfHwgdGhpcy5oYXNDb250ZW50KTtcbiAgICB9XG4gICAgZ2V0IGl0ZW1JZCgpIHtcbiAgICAgICAgcmV0dXJuICdrLXBhbmVsYmFyLScgKyB0aGlzLmV2ZW50U2VydmljZS5wYklkICsgJy1pdGVtLScgKyB0aGlzLmlkO1xuICAgIH1cbiAgICBnZXQgYXJpYUV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGFzQ2hpbGRJdGVtcyB8fCB0aGlzLmhhc0NvbnRlbnQpID8gIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5leHBhbmRlZCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBhcmlhU2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICBnZXQgYXJpYURpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IHRydWUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRpdGxlVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlVGVtcGxhdGVzLmxlbmd0aCA+IDAgPyB0aGlzLnRpdGxlVGVtcGxhdGVzLnRvQXJyYXkoKVswXS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhlYWRlckhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCAtICh0aGlzLmNvbnRlbnRXcmFwcGVyID8gdGhpcy5jb250ZW50V3JhcHBlci5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB0aGlzLmhhc0l0ZW1zID0gdGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmhpZGRlbikubGVuZ3RoID4gMDtcbiAgICAgICAgdGhpcy5oYXNDaGlsZEl0ZW1zID0gdGhpcy5jb250ZW50SXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gdGhpcykubGVuZ3RoID4gMCB8fCB0aGlzLmhhc0l0ZW1zO1xuICAgICAgICB0aGlzLmhhc0NvbnRlbnQgPSAodGhpcy5jb250ZW50VGVtcGxhdGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgICAgdGhpcy5jb250ZW50ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsaWRhdGVDb25maWd1cmF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuSXRlbXMgPSB0aGlzLnZpZXdDaGlsZEl0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcyA9IHRoaXMuY29udGVudEl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkl0ZW1BY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2Uub25TZWxlY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFpc0ZvY3VzYWJsZShlLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMub25JdGVtQWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpY29uQ2xhc3NlcygpIHtcbiAgICAgICAgbGV0IGljb24gPSB0aGlzLmljb24gPyAnay1pLScgKyB0aGlzLmljb24gOiBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2ljb24gfHwgdGhpcy5pY29uQ2xhc3NdOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgICAgIGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuICAgICAgICAgICAgZm9jdXNlZDogdGhpcy5mb2N1c2VkLFxuICAgICAgICAgICAgaWNvbjogdGhpcy5pY29uLFxuICAgICAgICAgICAgaWNvbkNsYXNzOiB0aGlzLmljb25DbGFzcyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IHRoaXMuaW1hZ2VVcmwsXG4gICAgICAgICAgICBzZWxlY3RlZDogdGhpcy5zZWxlY3RlZCxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnRpdGxlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzdWJUcmVlVmlld0l0ZW1zKCkge1xuICAgICAgICBsZXQgc3ViVHJlZSA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdDaGlsZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBzdWJUcmVlID0gc3ViVHJlZS5jb25jYXQoaXRlbS5zdWJUcmVlVmlld0l0ZW1zKCkpO1xuICAgICAgICAgICAgc3ViVHJlZS5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1YlRyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudCAmJiAodGhpcy5jb250ZW50VGVtcGxhdGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbjogbWl4ZWQgdGVtcGxhdGUgY29tcG9uZW50cyBhbmQgY29tcG9uZW50IHByb3BlcnR5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9nZ2xlQW5pbWF0aW9uU3RhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gdmFsdWUgJiYgdGhpcy5ldmVudFNlcnZpY2UuZXhwYW5kTW9kZSAhPT0gUGFuZWxCYXJFeHBhbmRNb2RlLlNpbmdsZSA/ICdhY3RpdmUnIDogJ2FjdGl2ZVdpdGhvdXRBbmltYXRpb24nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9nZ2xlRXhwYW5kZWRDaGlsZEFuaW1hdGlvbnModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5JdGVtcykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkl0ZW1zLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50b2dnbGVBbmltYXRpb25TdGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRvZ2dsZUV4cGFuZGVkQ2hpbGRBbmltYXRpb25zKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbldyYXBwZXJGb2N1c0NoYW5nZShmb2N1c2VkKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckZvY3VzZWQgPSBmb2N1c2VkO1xuICAgIH1cbn1cblBhbmVsQmFySXRlbUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcigndG9nZ2xlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2luYWN0aXZlJywgc3R5bGUoeyBkaXNwbGF5OiAnbm9uZScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIGRpc3BsYXk6ICdibG9jaycsIGhlaWdodDogMCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDIwMCwgc3R5bGUoeyBoZWlnaHQ6IEFVVE9fU1RZTEUgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2FjdGl2ZSA9PiAqJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCBoZWlnaHQ6IEFVVE9fU1RZTEUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgyMDAsIHN0eWxlKHsgaGVpZ2h0OiAwLCBkaXNwbGF5OiAnbm9uZScgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1BhbmVsYmFySXRlbScsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwia2VuZG8tcGFuZWxiYXItaXRlbVwiLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPHNwYW5cbiAgICAgICAgICAgICAgICAjaGVhZGVyXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstbGlua109XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1oZWFkZXJdPVwiIXBhcmVudFwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwiIWRpc2FibGVkICYmIHNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1mb2N1c2VkXT1cIiFkaXNhYmxlZCAmJiBmb2N1c2VkICYmIHdyYXBwZXJGb2N1c2VkXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwib25JdGVtQ2xpY2soJGV2ZW50KVwiPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAqbmdJZj1cImljb24gfHwgaWNvbkNsYXNzXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstaWNvblwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiaWNvbkNsYXNzZXNcIj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAqbmdJZj1cImltYWdlVXJsXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstaW1hZ2VcIlxuICAgICAgICAgICAgICAgIFtzcmNdPVwiaW1hZ2VVcmxcIlxuICAgICAgICAgICAgICAgIGFsdD1cIlwiPlxuICAgICAgICAgICAge3t0aXRsZX19XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwidGl0bGVUZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cImhhc0NoaWxkSXRlbXMgfHwgaGFzQ29udGVudFwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstaWNvbl09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LW5dPVwiZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLXBhbmVsYmFyLWNvbGxhcHNlXT1cImV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LXNdPVwiIWV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1wYW5lbGJhci1leHBhbmRdPVwiIWV4cGFuZGVkXCI+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPGRpdiAjY29udGVudFdyYXBwZXJcbiAgICAgICAgICAgICpuZ0lmPVwia2VlcENvbnRlbnQgfHwgKCFkaXNhYmxlZCAmJiBleHBhbmRlZCAmJiAoaGFzQ2hpbGRJdGVtcyB8fCBoYXNDb250ZW50KSlcIlxuICAgICAgICAgICAgW0B0b2dnbGVdPVwic3RhdGVcIlxuICAgICAgICAgICAgW2F0dHIucm9sZV09XCInZ3JvdXAnXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtaGlkZGVuXT1cIiFkaXNhYmxlZCAmJiAhZXhwYW5kZWRcIj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0NoaWxkSXRlbXMgJiYgIWl0ZW1zPy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5vdmVyZmxvd109XCJjb250ZW50T3ZlcmZsb3dcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHRdPVwiY29udGVudEhlaWdodFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLXBhbmVsIGstZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwia2VuZG8tcGFuZWxiYXItaXRlbVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzQ29udGVudCAmJiAhY29udGVudFwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLm92ZXJmbG93XT1cImNvbnRlbnRPdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodF09XCJjb250ZW50SGVpZ2h0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstY29udGVudFwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50VGVtcGxhdGUuZmlyc3QudGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBpY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhhc0l0ZW1zXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUub3ZlcmZsb3ddPVwiY29udGVudE92ZXJmbG93XCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0XT1cImNvbnRlbnRIZWlnaHRcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1wYW5lbCBrLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPlxuICAgICAgICAgICAgICAgICAgICA8a2VuZG8tcGFuZWxiYXItaXRlbSAqbmdJZj1cIiFpdGVtLmhpZGRlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwiaXRlbS50aXRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbaWRdPVwiaXRlbS5pZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbaWNvbl09XCJpdGVtLmljb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2ljb25DbGFzc109XCJpdGVtLmljb25DbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbaW1hZ2VVcmxdPVwiaXRlbS5pbWFnZVVybFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRdPVwiISFpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtleHBhbmRlZF09XCIhIWl0ZW0uZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cIiEhaXRlbS5kaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVdPVwidGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2l0ZW1zXT1cIml0ZW0uY2hpbGRyZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbnRlbnRdPVwiaXRlbS5jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDwva2VuZG8tcGFuZWxiYXItaXRlbT5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLm92ZXJmbG93XT1cImNvbnRlbnRPdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodF09XCJjb250ZW50SGVpZ2h0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstY29udGVudFwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IGljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmw6IGltYWdlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhdGVtcGxhdGVcIj57e2NvbnRlbnR9fTwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+YFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5QYW5lbEJhckl0ZW1Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBQYW5lbEJhckl0ZW1Db21wb25lbnQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNraXBTZWxmIH0sIHsgdHlwZTogSG9zdCB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH0sXG4gICAgeyB0eXBlOiBQYW5lbEJhclNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcblBhbmVsQmFySXRlbUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb25DbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW1hZ2VVcmw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0ZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbnRlbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0ZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGVhZGVyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaGVhZGVyJywge30sXSB9XSxcbiAgICBjb250ZW50V3JhcHBlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2NvbnRlbnRXcmFwcGVyJywge30sXSB9XSxcbiAgICByb2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLnJvbGUnLF0gfV0sXG4gICAgdGl0bGVBdHRyaWJ1dGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGl0bGUnLF0gfV0sXG4gICAga0l0ZW1DbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1pdGVtJyxdIH1dLFxuICAgIGtTdGF0ZURlZmF1bHRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kZWZhdWx0JyxdIH1dLFxuICAgIGtTdGF0ZURpc2FibGVkQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RhdGUtZGlzYWJsZWQnLF0gfV0sXG4gICAga1N0YXRlRXhwYW5kZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1leHBhbmRlZCcsXSB9XSxcbiAgICBpdGVtSWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2lkJyxdIH1dLFxuICAgIGFyaWFFeHBhbmRlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWV4cGFuZGVkJyxdIH1dLFxuICAgIGFyaWFTZWxlY3RlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXNlbGVjdGVkJyxdIH1dLFxuICAgIGFyaWFEaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWRpc2FibGVkJyxdIH1dLFxuICAgIHZpZXdDaGlsZEl0ZW1zOiBbeyB0eXBlOiBWaWV3Q2hpbGRyZW4sIGFyZ3M6IFtQYW5lbEJhckl0ZW1Db21wb25lbnQsXSB9XSxcbiAgICBjb250ZW50SXRlbXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW1BhbmVsQmFySXRlbUNvbXBvbmVudCxdIH1dLFxuICAgIGNvbnRlbnRUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbUGFuZWxCYXJDb250ZW50RGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9LF0gfV0sXG4gICAgdGl0bGVUZW1wbGF0ZXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW1BhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9LF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZGlyZWN0aXZlIG9mIHRoZSBQYW5lbEJhciB3aGljaCBoZWxwcyB0byBjdXN0b21pemUgdGhlIGl0ZW0gY29udGVudC5cbiAqL1xuY2xhc3MgUGFuZWxCYXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5QYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvUGFuZWxCYXJJdGVtVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5QYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBQYW5lbEJhciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfcGFuZWxiYXIgJX0pLlxuICovXG4vLyBUT0RPOiBhZGQgc3R5bGVzIGFzIGlucHV0IHByb3BcbmNsYXNzIFBhbmVsQmFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBldmVudFNlcnZpY2UsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGV4cGFuZCBtb2RlIG9mIHRoZSBQYW5lbEJhciB0aHJvdWdoIHRoZSBgUGFuZWxCYXJFeHBhbmRNb2RlYCBlbnVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhwYW5kbW9kZXNfcGFuZWxiYXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSBtb2RlcyBhcmU6XG4gICAgICAgICAqIC0gYFwic2luZ2xlXCJgJm1kYXNoO0V4cGFuZHMgb25seSBvbmUgaXRlbSBhdCBhIHRpbWUuIEV4cGFuZGluZyBhbiBpdGVtIGNvbGxhcHNlcyB0aGUgaXRlbSB0aGF0IHdhcyBwcmV2aW91c2x5IGV4cGFuZGVkLlxuICAgICAgICAgKiAtIGBcIm11bHRpcGxlXCJgJm1kYXNoO1RoZSBkZWZhdWx0IG1vZGUgb2YgdGhlIFBhbmVsQmFyLlxuICAgICAgICAgKiBFeHBhbmRzIG1vcmUgdGhhbiBvbmUgaXRlbSBhdCBhIHRpbWUuIEl0ZW1zIGNhbiBhbHNvIGJlIHRvZ2dsZWQuXG4gICAgICAgICAqIC0gYFwiZnVsbFwiYCZtZGFzaDtFeHBhbmRzIG9ubHkgb25lIGl0ZW0gYXQgYSB0aW1lLlxuICAgICAgICAgKiBUaGUgZXhwYW5kZWQgYXJlYSBvY2N1cGllcyB0aGUgZW50aXJlIGhlaWdodCBvZiB0aGUgUGFuZWxCYXIuIFJlcXVpcmVzIHlvdSB0byBzZXQgdGhlIGBoZWlnaHRgIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRNb2RlID0gUGFuZWxCYXJFeHBhbmRNb2RlLkRlZmF1bHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdGhlIFBhbmVsQmFyIHRvIG1vZGlmeSB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFuaW1hdGUgc3RhdGUgb2YgdGhlIFBhbmVsQmFyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYW5pbWF0aW9uc19wYW5lbGJhciAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGBcImZ1bGxcImAgZXhwYW5kIG1vZGUgaXMgdXNlZC5cbiAgICAgICAgICogVGhpcyBvcHRpb24gaXMgaWdub3JlZCBpbiB0aGUgYFwibXVsdGlwbGVcImAgYW5kIGBcInNpbmdsZVwiYCBleHBhbmQgbW9kZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IFwiNDAwcHhcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCBhIFBhbmVsQmFyIGl0ZW1cbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByb3V0aW5nX3BhbmVsYmFyICV9I3RvYy1nZXR0aW5nLXRoZS1zZWxlY3RlZC1pdGVtKSkuXG4gICAgICAgICAqIFRoZSBldmVudCBkYXRhIGNvbnRhaW5zIGFsbCBpdGVtcyB0aGF0IGFyZSBtb2RpZmllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJvbGUgPSBcInRyZWVcIjtcbiAgICAgICAgdGhpcy5hY3RpdmVEZXNjZW5kYW50ID0gXCJcIjtcbiAgICAgICAgdGhpcy5pc1ZpZXdJbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2tlZXBJdGVtQ29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuSGVpZ2h0ID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVsYmFySGVpZ2h0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgY29udGVudE92ZXJmbG93ID0gdGhpcy5leHBhbmRNb2RlID09PSBQYW5lbEJhckV4cGFuZE1vZGUuRnVsbCA/ICdhdXRvJyA6ICd2aXNpYmxlJztcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuSGVpZ2h0ICs9IGl0ZW0uaGVhZGVySGVpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5JdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uY29udGVudEhlaWdodCA9IFBhbmVsQmFyRXhwYW5kTW9kZS5GdWxsID09PSB0aGlzLmV4cGFuZE1vZGUgPyAocGFuZWxiYXJIZWlnaHQgLSBjaGlsZHJlbkhlaWdodCkgKyBcInB4XCIgOiAnYXV0byc7XG4gICAgICAgICAgICAgICAgaXRlbS5jb250ZW50T3ZlcmZsb3cgPSBjb250ZW50T3ZlcmZsb3c7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXlCaW5kaW5ncyA9IHRoaXMuY29tcHV0ZWRLZXlzO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZSA9IGV2ZW50U2VydmljZTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuY2hpbGRyZW4kLnN1YnNjcmliZShldmVudCA9PiB0aGlzLm9uSXRlbUFjdGlvbihldmVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBQYW5lbEJhciByZW5kZXJzIHRoZSBjb250ZW50IG9mIGFsbCBpdGVtcyBhbmQgdGhleSBhcmUgcGVyc2lzdGVkIGluIHRoZSBET01cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19wYW5lbGJhciAlfSN0b2MtY29sbGVjdGlvbnMpKS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIG9wdGlvbiBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAgKi9cbiAgICBnZXQga2VlcEl0ZW1Db250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2VlcEl0ZW1Db250ZW50O1xuICAgIH1cbiAgICBzZXQga2VlcEl0ZW1Db250ZW50KGtlZXBJdGVtQ29udGVudCkge1xuICAgICAgICB0aGlzLl9rZWVwSXRlbUNvbnRlbnQgPSBrZWVwSXRlbUNvbnRlbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLm9uS2VlcENvbnRlbnQoa2VlcEl0ZW1Db250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaXRlbXMgb2YgdGhlIFBhbmVsQmFyIGFzIGFuIGFycmF5IG9mIGBQYW5lbEJhckl0ZW1Nb2RlbGAgaW5zdGFuY2VzXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBpdGVtc19wYW5lbGJhciAlfSkpLlxuICAgICAqL1xuICAgIHNldCBpdGVtcyhkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHV0aWwucGFyc2VQYW5lbEJhckl0ZW1zKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cbiAgICBnZXQgaG9zdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kTW9kZSA9PT0gUGFuZWxCYXJFeHBhbmRNb2RlLkZ1bGwgPyB0aGlzLmhlaWdodCA6ICdhdXRvJztcbiAgICB9XG4gICAgZ2V0IG92ZXJmbG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRNb2RlID09PSBQYW5lbEJhckV4cGFuZE1vZGUuRnVsbCA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpbnZlcnRLZXlzKG9yaWdpbmFsLCBpbnZlcnRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gaW52ZXJ0ZWQgOiBvcmlnaW5hbDtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtLZXlzLlNwYWNlXTogKCkgPT4gdGhpcy5zZWxlY3RGb2N1c2VkSXRlbSgpLFxuICAgICAgICAgICAgW0tleXMuRW50ZXJdOiAoKSA9PiB0aGlzLnNlbGVjdEZvY3VzZWRJdGVtKCksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd1VwXTogKCkgPT4gdGhpcy5mb2N1c1ByZXZpb3VzSXRlbSgpLFxuICAgICAgICAgICAgW3RoaXMuaW52ZXJ0S2V5cyhLZXlzLkFycm93TGVmdCwgS2V5cy5BcnJvd1JpZ2h0KV06ICgpID0+IHRoaXMuY29sbGFwc2VJdGVtKCksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd0Rvd25dOiAoKSA9PiB0aGlzLmZvY3VzTmV4dEl0ZW0oKSxcbiAgICAgICAgICAgIFt0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd1JpZ2h0LCBLZXlzLkFycm93TGVmdCldOiAoKSA9PiB0aGlzLmV4cGFuZEl0ZW0oKSxcbiAgICAgICAgICAgIFtLZXlzLkVuZF06ICgpID0+IHRoaXMuZm9jdXNMYXN0SXRlbSgpLFxuICAgICAgICAgICAgW0tleXMuSG9tZV06ICgpID0+IHRoaXMuZm9jdXNGaXJzdEl0ZW0oKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uXG4gICAgICAgICAgICAuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5rZXlCaW5kaW5ncyA9IHRoaXMuY29tcHV0ZWRLZXlzKTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuYW5pbWF0ZSA9IHRoaXMuYW5pbWF0ZTtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZXhwYW5kTW9kZSA9IHRoaXMuZXhwYW5kTW9kZTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkl0ZW1zID0gdGhpcy52aWV3Q2hpbGRJdGVtcy50b0FycmF5KCk7XG4gICAgICAgICAgICB0aGlzLmFsbEl0ZW1zID0gdGhpcy52aWV3SXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuSXRlbXMgPSB0aGlzLmNvbnRlbnRDaGlsZEl0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHRoaXMuYWxsSXRlbXMgPSB0aGlzLmNvbnRlbnRJdGVtcy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3SW5pdCAmJiB0aGlzLmNoaWxkcmVuSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlld0luaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVDaGlsZHJlbkhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZmlndXJhdGlvbigpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydoZWlnaHQnXSB8fCBjaGFuZ2VzWydleHBhbmRNb2RlJ10gfHwgY2hhbmdlc1tcIml0ZW1zXCJdKSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMudXBkYXRlQ2hpbGRyZW5IZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTZXJ2aWNlLmFuaW1hdGUgPSB0aGlzLmFuaW1hdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuZXhwYW5kTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNlcnZpY2UuZXhwYW5kTW9kZSA9IHRoaXMuZXhwYW5kTW9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlID8gdGhpcy50ZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q2xpY2soZXZlbnQpIHtcbiAgICAgICAgY29uc3QgaXRlbUNsaWNrZWQgPSB0aGlzLnZpc2libGVJdGVtcygpLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmhlYWRlci5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZm9jdXNlZCAmJiBpdGVtQ2xpY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Db21wb25lbnRGb2N1cygpIHtcbiAgICAgICAgdGhpcy5ldmVudFNlcnZpY2Uub25Gb2N1cygpO1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hbGxJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgZm9jdXNlZEl0ZW1zID0gdmlzaWJsZUl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uZm9jdXNlZCk7XG4gICAgICAgICAgICBpZiAoIWZvY3VzZWRJdGVtcy5sZW5ndGggJiYgdmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlSXRlbXNbMF0uZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVEZXNjZW5kYW50ID0gdmlzaWJsZUl0ZW1zWzBdLml0ZW1JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Db21wb25lbnRCbHVyKCkge1xuICAgICAgICB0aGlzLmV2ZW50U2VydmljZS5vbkJsdXIoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudEtleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlzLlNwYWNlIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dVcCB8fCBldmVudC5rZXlDb2RlID09PSBLZXlzLkFycm93RG93biB8fFxuICAgICAgICAgICAgICAgIGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dMZWZ0IHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dSaWdodCB8fCBldmVudC5rZXlDb2RlID09PSBLZXlzLkhvbWUgfHxcbiAgICAgICAgICAgICAgICBldmVudC5rZXlDb2RlID09PSBLZXlzLkVuZCB8fCBldmVudC5rZXlDb2RlID09PSBLZXlzLlBhZ2VVcCB8fCBldmVudC5rZXlDb2RlID09PSBLZXlzLlBhZ2VEb3duKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmtleUJpbmRpbmdzW2V2ZW50LmtleUNvZGVdO1xuICAgICAgICAgICAgLy9UT0RPOiBjaGVjayBpZiBuZXh0IGl0ZW0gaXMgZGlzYWJsZWQgYW5kIHNraXAgb3BlcmF0aW9uP1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZpZXdJdGVtcygpIHtcbiAgICAgICAgbGV0IHRyZWVJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdDaGlsZEl0ZW1zLnRvQXJyYXkoKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgdHJlZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB0cmVlSXRlbXMgPSB0cmVlSXRlbXMuY29uY2F0KGl0ZW0uc3ViVHJlZVZpZXdJdGVtcygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmVlSXRlbXM7XG4gICAgfVxuICAgIHZhbGlkYXRlQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtcyAmJiAodGhpcy5jb250ZW50SXRlbXMgJiYgdGhpcy5jb250ZW50SXRlbXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb246IG1peGVkIHRlbXBsYXRlIGNvbXBvbmVudHMgYW5kIGl0ZW1zIHByb3BlcnR5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkl0ZW1BY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kaWZpZWRJdGVtcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmFsbEl0ZW1zXG4gICAgICAgICAgICAuZm9yRWFjaCgoY3VycmVudEl0ZW0pID0+IHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFN0YXRlID0gY3VycmVudEl0ZW0gPT09IGl0ZW07XG4gICAgICAgICAgICBsZXQgZm9jdXNlZFN0YXRlID0gc2VsZWN0ZWRTdGF0ZTtcbiAgICAgICAgICAgIHNlbGVjdGVkU3RhdGUgPSB0aGlzLnNlbGVjdGFibGUgPyBzZWxlY3RlZFN0YXRlIDogY3VycmVudEl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudEl0ZW0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkU3RhdGUgfHwgY3VycmVudEl0ZW0uZm9jdXNlZCAhPT0gZm9jdXNlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEl0ZW0uc2VsZWN0ZWQgPSBzZWxlY3RlZFN0YXRlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtLmZvY3VzZWQgPSBmb2N1c2VkU3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVEZXNjZW5kYW50ID0gZm9jdXNlZFN0YXRlID8gY3VycmVudEl0ZW0uaXRlbUlkIDogXCJcIjtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEl0ZW1zLnB1c2goY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kTW9kZSA9PT0gUGFuZWxCYXJFeHBhbmRNb2RlLk11bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5oYXNDaGlsZEl0ZW1zIHx8IGl0ZW0uaGFzQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZXhwYW5kZWQgPSAhaXRlbS5leHBhbmRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllZEl0ZW1zLmluZGV4T2YoaXRlbSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNpYmxpbmdzID0gaXRlbS5wYXJlbnQgPyBpdGVtLnBhcmVudC5jaGlsZHJlbkl0ZW1zIDogdGhpcy5jaGlsZHJlbkl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaGFzQ2hpbGRJdGVtcyB8fCBpdGVtLmhhc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nc1xuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY3VycmVudEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4cGFuZGVkU3RhdGUgPSBjdXJyZW50SXRlbSA9PT0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmV4cGFuZGVkICE9PSBleHBhbmRlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlbS5leHBhbmRlZCA9IGV4cGFuZGVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWRJdGVtcy5pbmRleE9mKGN1cnJlbnRJdGVtKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEl0ZW1zLnB1c2goY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KG1vZGlmaWVkSXRlbXMubWFwKGN1cnJlbnRJdGVtID0+IGN1cnJlbnRJdGVtLnNlcmlhbGl6ZSgpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNWaXNpYmxlKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUl0ZW1zID0gdGhpcy52aXNpYmxlSXRlbXMoKTtcbiAgICAgICAgcmV0dXJuIHZpc2libGVJdGVtcy5zb21lKGkgPT4gaSA9PT0gaXRlbSk7XG4gICAgfVxuICAgIGdldFZpc2libGVQYXJlbnQoaXRlbSkge1xuICAgICAgICBjb25zdCB2aXNpYmxlSXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcygpO1xuICAgICAgICBpZiAoIWl0ZW0ucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZUl0ZW1zLnNvbWUoaSA9PiBpID09PSBpdGVtLnBhcmVudCkgPyBpdGVtLnBhcmVudCA6IHRoaXMuZ2V0VmlzaWJsZVBhcmVudChpdGVtLnBhcmVudCk7XG4gICAgfVxuICAgIGZvY3VzSXRlbShhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUl0ZW1zID0gdGhpcy52aXNpYmxlSXRlbXMoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHZpc2libGVJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmZvY3VzZWQpO1xuICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSB2aXNpYmxlSXRlbXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgbGV0IG5leHRJdGVtO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbGV0IGZvY3VzZWRJdGVtID0gdGhpcy5hbGxJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5mb2N1c2VkKTtcbiAgICAgICAgICAgIGZvY3VzZWRJdGVtLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gdGhpcy5nZXRWaXNpYmxlUGFyZW50KGZvY3VzZWRJdGVtKTtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IHZpc2libGVJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtID09PSBjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJsYXN0SXRlbVwiOlxuICAgICAgICAgICAgICAgIG5leHRJdGVtID0gdmlzaWJsZUl0ZW1zW3Zpc2libGVJdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaXJzdEl0ZW1cIjpcbiAgICAgICAgICAgICAgICBuZXh0SXRlbSA9IHZpc2libGVJdGVtc1swXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJuZXh0SXRlbVwiOlxuICAgICAgICAgICAgICAgIG5leHRJdGVtID0gdmlzaWJsZUl0ZW1zW2N1cnJlbnRJbmRleCA8IHZpc2libGVJdGVtcy5sZW5ndGggLSAxID8gY3VycmVudEluZGV4ICsgMSA6IDBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInByZXZpb3VzSXRlbVwiOlxuICAgICAgICAgICAgICAgIG5leHRJdGVtID0gdmlzaWJsZUl0ZW1zW2N1cnJlbnRJbmRleCA+IDAgPyBjdXJyZW50SW5kZXggLSAxIDogdmlzaWJsZUl0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEl0ZW0gJiYgbmV4dEl0ZW0gJiYgY3VycmVudEl0ZW0gIT09IG5leHRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVGb2N1cyhjdXJyZW50SXRlbSwgbmV4dEl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVGb2N1cyhmcm9tLCB0bykge1xuICAgICAgICBmcm9tLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdG8uZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRvLml0ZW1JZDtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRJdGVtcyA9IG5ldyBBcnJheShmcm9tLnNlcmlhbGl6ZSgpLCB0by5zZXJpYWxpemUoKSk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UuZW1pdChtb2RpZmllZEl0ZW1zKTtcbiAgICB9XG4gICAgZm9jdXNMYXN0SXRlbSgpIHtcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0oXCJsYXN0SXRlbVwiKTtcbiAgICB9XG4gICAgZm9jdXNGaXJzdEl0ZW0oKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJdGVtKFwiZmlyc3RJdGVtXCIpO1xuICAgIH1cbiAgICBmb2N1c05leHRJdGVtKCkge1xuICAgICAgICB0aGlzLmZvY3VzSXRlbShcIm5leHRJdGVtXCIpO1xuICAgIH1cbiAgICBmb2N1c1ByZXZpb3VzSXRlbSgpIHtcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0oXCJwcmV2aW91c0l0ZW1cIik7XG4gICAgfVxuICAgIGV4cGFuZEl0ZW0oKSB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbSA9IHRoaXMuYWxsSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5mb2N1c2VkKVswXTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZShjdXJyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gdGhpcy5nZXRWaXNpYmxlUGFyZW50KGN1cnJlbnRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uaGFzQ2hpbGRJdGVtcyB8fCBjdXJyZW50SXRlbS5oYXNDb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRJdGVtLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkl0ZW1BY3Rpb24oY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEl0ZW0uaGFzQ2hpbGRJdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGRJbmRleCA9IGN1cnJlbnRJdGVtLmNoaWxkcmVuSXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENoaWxkSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVGb2N1cyhjdXJyZW50SXRlbSwgY3VycmVudEl0ZW0uY2hpbGRyZW5JdGVtc1tmaXJzdENoaWxkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGFwc2VJdGVtKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SXRlbSA9IHRoaXMuYWxsSXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5mb2N1c2VkKVswXTtcbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSXRlbUFjdGlvbihjdXJyZW50SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEl0ZW0ucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVGb2N1cyhjdXJyZW50SXRlbSwgY3VycmVudEl0ZW0ucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RGb2N1c2VkSXRlbSgpIHtcbiAgICAgICAgbGV0IGZvY3VzZWRJdGVtID0gdGhpcy5hbGxJdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmZvY3VzZWQpWzBdO1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKGZvY3VzZWRJdGVtKSkge1xuICAgICAgICAgICAgZm9jdXNlZEl0ZW0uZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9jdXNlZEl0ZW0gPSB0aGlzLmdldFZpc2libGVQYXJlbnQoZm9jdXNlZEl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb2N1c2VkSXRlbSkge1xuICAgICAgICAgICAgZm9jdXNlZEl0ZW0ub25JdGVtQWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaWJsZUl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0VmlzaWJsZUl0ZW1zKHRoaXMuY2hpbGRyZW5JdGVtcyk7XG4gICAgfVxuICAgIGZsYXRWaXNpYmxlSXRlbXMobGlzdE9mSXRlbXMgPSBuZXcgQXJyYXkoKSwgZmxhdHRlZEl0ZW1zID0gbmV3IEFycmF5KCkpIHtcbiAgICAgICAgbGlzdE9mSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmV4cGFuZGVkICYmIGl0ZW0uaGFzQ2hpbGRJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsYXRWaXNpYmxlSXRlbXMoaXRlbS5jaGlsZHJlbkl0ZW1zLCBmbGF0dGVkSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmbGF0dGVkSXRlbXM7XG4gICAgfVxufVxuUGFuZWxCYXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvUGFuZWxiYXInLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBQYW5lbEJhclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5wYW5lbGJhcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wYW5lbGJhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgKm5nSWY9XCJjb250ZW50Q2hpbGRJdGVtcyAmJiAhaXRlbXNcIiBzZWxlY3Q9XCJrZW5kby1wYW5lbGJhci1pdGVtXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXRlbXM/Lmxlbmd0aFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPlxuICAgICAgICAgICAgICAgIDxrZW5kby1wYW5lbGJhci1pdGVtICpuZ0lmPVwiIWl0ZW0uaGlkZGVuXCJcbiAgICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJpdGVtLnRpdGxlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtpZF09XCJpdGVtLmlkXCJcbiAgICAgICAgICAgICAgICAgICAgIFtpY29uXT1cIml0ZW0uaWNvblwiXG4gICAgICAgICAgICAgICAgICAgICBbaWNvbkNsYXNzXT1cIml0ZW0uaWNvbkNsYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgIFtpbWFnZVVybF09XCJpdGVtLmltYWdlVXJsXCJcbiAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZF09XCIhIWl0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgW2V4cGFuZGVkXT1cIiEhaXRlbS5leHBhbmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiISFpdGVtLmRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZV09XCJ0ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICBbaXRlbXNdPVwiaXRlbS5jaGlsZHJlblwiXG4gICAgICAgICAgICAgICAgICAgICBbY29udGVudF09XCJpdGVtLmNvbnRlbnRcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLXBhbmVsYmFyLWl0ZW0+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBhbmVsQmFyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUGFuZWxCYXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5QYW5lbEJhckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBleHBhbmRNb2RlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmltYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoZWlnaHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGtlZXBJdGVtQ29udGVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXRlbXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXRlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgdGFiSW5kZXg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGFiSW5kZXgnLF0gfV0sXG4gICAgcm9sZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5yb2xlJyxdIH1dLFxuICAgIGFjdGl2ZURlc2NlbmRhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50JyxdIH1dLFxuICAgIGhvc3RIZWlnaHQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLmhlaWdodCcsXSB9XSxcbiAgICBvdmVyZmxvdzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUub3ZlcmZsb3cnLF0gfV0sXG4gICAgZGlyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICB0ZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbUGFuZWxCYXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBjb250ZW50SXRlbXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW1BhbmVsQmFySXRlbUNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgY29udGVudENoaWxkSXRlbXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW1BhbmVsQmFySXRlbUNvbXBvbmVudCxdIH1dLFxuICAgIHZpZXdDaGlsZEl0ZW1zOiBbeyB0eXBlOiBWaWV3Q2hpbGRyZW4sIGFyZ3M6IFtQYW5lbEJhckl0ZW1Db21wb25lbnQsXSB9XSxcbiAgICBvbkNvbXBvbmVudENsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV0sXG4gICAgb25Db21wb25lbnRGb2N1czogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2ZvY3VzJyxdIH1dLFxuICAgIG9uQ29tcG9uZW50Qmx1cjogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2JsdXInLF0gfV0sXG4gICAgb25Db21wb25lbnRLZXlEb3duOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsna2V5ZG93bicsIFsnJGV2ZW50J10sXSB9XSxcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay13aWRnZXQnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXBhbmVsYmFyJyxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHBhbmUgY29tcG9uZW50IG9mIHRoZSBTcGxpdHRlci5cbiAqL1xuY2xhc3MgU3BsaXR0ZXJQYW5lQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCByZW5kZXJlciwgY2RyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byByZXNpemUgdGhlIHBhbmUgYW5kIHByb3ZpZGUgc3BhY2UgZm9yIG90aGVyIHBhbmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gaGlkZSB0aGUgcGFuZSBhbmQgcHJvdmlkZSBzcGFjZSBmb3Igb3RoZXIgcGFuZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgb3ZlcmZsb3dpbmcgY29udGVudCBpcyBzY3JvbGxhYmxlIG9yIGhpZGRlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIHBhbmUgaXMgaW5pdGlhbGx5IGNvbGxhcHNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluc1NwbGl0dGVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgcmVzaXplcyB0aGUgU3BsaXR0ZXIgcGFuZS5cbiAgICAgICAgICogVGhlIGV2ZW50IGRhdGEgY29udGFpbnMgdGhlIG5ldyBwYW5lIHNpemUuXG4gICAgICAgICAqIEFsbG93cyBhIHR3by13YXkgYmluZGluZyBvZiB0aGUgcGFuZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBjb2xsYXBzZWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICAgICAqIFRoZSBldmVudCBkYXRhIGNvbnRhaW5zIHRoZSBuZXcgcHJvcGVydHkgc3RhdGUuXG4gICAgICAgICAqIEFsbG93cyBhIHR3by13YXkgYmluZGluZyBvZiB0aGUgYGNvbGxhcHNlZGAgcGFuZSBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcmNlRXhwYW5kID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgb3JkZXIocGFuZU9yZGVyKSB7XG4gICAgICAgIHRoaXMuX29yZGVyID0gcGFuZU9yZGVyO1xuICAgICAgICB0aGlzLnNldE9yZGVyU3R5bGVzKCk7XG4gICAgfVxuICAgIGdldCBvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIHBhbmUuXG4gICAgICogSGFzIHRvIGJlIGJldHdlZW4gdGhlIGBtaW5gIGFuZCBgbWF4YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldCBzaXplKG5ld1NpemUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnLW1zLWZsZXgtcHJlZmVycmVkLXNpemUnLCBuZXdTaXplKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnZmxleC1iYXNpcycsIG5ld1NpemUpO1xuICAgICAgICBpZiAodGhpcy5zdGF0aWNQYW5lQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgJ2stcGFuZS1zdGF0aWMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2stcGFuZS1zdGF0aWMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldCBpc0hpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkO1xuICAgIH1cbiAgICBnZXQgc3R5bGVEaXNwbGF5RmxleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnNTcGxpdHRlcjtcbiAgICB9XG4gICAgZ2V0IHN0YXRpY1BhbmVDbGFzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VFeHBhbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMucmVzaXphYmxlICYmICF0aGlzLmNvbGxhcHNpYmxlIHx8IHRoaXMuZml4ZWRTaXplO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsYWJsZVBhbmVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsYWJsZTtcbiAgICB9XG4gICAgZ2V0IGZpeGVkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSAmJiB0aGlzLnNpemUubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsICdrLXN0YXRlLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCAnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdrLXN0YXRlLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCAnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb21wdXRlZFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b2dnbGVPdmVybGF5KHNob3cpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGVudCA9IHNob3c7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRldGVjdENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldE9yZGVyU3R5bGVzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJy1tcy1mbGV4LW9yZGVyJywgdGhpcy5vcmRlcik7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ29yZGVyJywgdGhpcy5vcmRlcik7XG4gICAgfVxufVxuU3BsaXR0ZXJQYW5lQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1NwbGl0dGVyUGFuZScsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zcGxpdHRlci1wYW5lJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWNvbGxhcHNlZFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGRpdiAqbmdJZj1cIm92ZXJsYXlDb250ZW50XCIgY2xhc3M9XCJrLXNwbGl0dGVyLW92ZXJsYXkgay1vdmVybGF5XCI+PC9kaXY+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TcGxpdHRlclBhbmVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5TcGxpdHRlclBhbmVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb3JkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXNpemFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbGxhcHNpYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzY3JvbGxhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2xsYXBzZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9yaWVudGF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb250YWluc1NwbGl0dGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvdmVybGF5Q29udGVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2l6ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbGxhcHNlZENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHN0eWxlRGlzcGxheUZsZXg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstcGFuZS1mbGV4JyxdIH1dLFxuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1wYW5lJyxdIH1dLFxuICAgIHN0YXRpY1BhbmVDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1wYW5lLXN0YXRpYycsXSB9XSxcbiAgICBzY3JvbGxhYmxlUGFuZUNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXNjcm9sbGFibGUnLF0gfV1cbn07XG5cbmNvbnN0IFNJWklOR19ET0NfTElOSyA9ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvbGF5b3V0L3NwbGl0dGVyL3BhbmVzLyN0b2Mtc2l6ZSc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3BsaXR0ZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih6b25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIHRyeVRvZ2dsZShwYW5lSW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMucGFuZShwYW5lSW5kZXgpO1xuICAgICAgICBpZiAocGFuZS5jb2xsYXBzaWJsZSkge1xuICAgICAgICAgICAgcGFuZS5jb2xsYXBzZWQgPSAhcGFuZS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICBwYW5lLmNvbGxhcHNlZENoYW5nZS5lbWl0KHBhbmUuY29sbGFwc2VkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmxheW91dENoYW5nZSwge30pO1xuICAgICAgICAgICAgaWYgKHBhbmUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcGFuZS5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90Q29sbGFwc2VkID0gdGhpcy5wYW5lcy5maWx0ZXIocCA9PiAhcC5jb2xsYXBzZWQpO1xuICAgICAgICBjb25zdCBhbGxIYXZlRml4ZWRTaXplID0gbm90Q29sbGFwc2VkLmV2ZXJ5KHAgPT4gcC5maXhlZFNpemUpO1xuICAgICAgICBub3RDb2xsYXBzZWRbbm90Q29sbGFwc2VkLmxlbmd0aCAtIDFdLmZvcmNlRXhwYW5kID0gYWxsSGF2ZUZpeGVkU2l6ZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHBhbmUuY29sbGFwc2libGU7XG4gICAgfVxuICAgIHRvZ2dsZUNvbnRlbnRPdmVybGF5KGluZGV4LCBzaG93KSB7XG4gICAgICAgIHRoaXMucGFuZShpbmRleCkudG9nZ2xlT3ZlcmxheShzaG93KTtcbiAgICAgICAgdGhpcy5wYW5lKGluZGV4ICsgMSkudG9nZ2xlT3ZlcmxheShzaG93KTtcbiAgICB9XG4gICAgZHJhZ1N0YXRlKHNwbGl0YmFySW5kZXgpIHtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnBhbmUoc3BsaXRiYXJJbmRleCk7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5wYW5lKHNwbGl0YmFySW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwcmV2LmNvbXB1dGVkU2l6ZSArIG5leHQuY29tcHV0ZWRTaXplO1xuICAgICAgICBjb25zdCBweCA9IHMgPT4gdGhpcy50b1BpeGVscyhzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXY6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogc3BsaXRiYXJJbmRleCxcbiAgICAgICAgICAgICAgICBpbml0aWFsU2l6ZTogcHJldi5jb21wdXRlZFNpemUsXG4gICAgICAgICAgICAgICAgbWluOiBweChwcmV2Lm1pbikgfHwgdG90YWwgLSBweChuZXh0Lm1heCkgfHwgMCxcbiAgICAgICAgICAgICAgICBtYXg6IHB4KHByZXYubWF4KSB8fCB0b3RhbCAtIHB4KG5leHQubWluKSB8fCB0b3RhbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogc3BsaXRiYXJJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFNpemU6IG5leHQuY29tcHV0ZWRTaXplLFxuICAgICAgICAgICAgICAgIG1pbjogcHgobmV4dC5taW4pIHx8IHRvdGFsIC0gcHgocHJldi5tYXgpIHx8IDAsXG4gICAgICAgICAgICAgICAgbWF4OiBweChuZXh0Lm1heCkgfHwgdG90YWwgLSBweChwcmV2Lm1pbikgfHwgdG90YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0U2l6ZShzdGF0ZSQkMSwgZGVsdGEpIHtcbiAgICAgICAgY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2KSk7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9IChwYW5lU3RhdGUsIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMucGFuZShwYW5lU3RhdGUuaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc3BsaXR0ZXJTaXplID0gdGhpcy5jb250YWluZXJTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdTaXplID0gY2xhbXAocGFuZVN0YXRlLm1pbiwgcGFuZVN0YXRlLm1heCwgcGFuZVN0YXRlLmluaXRpYWxTaXplICsgY2hhbmdlKTtcbiAgICAgICAgICAgIGxldCBzaXplID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGVyY2VudChwYW5lLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9ICgxMDAgKiBuZXdTaXplIC8gc3BsaXR0ZXJTaXplKSArIFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IG5ld1NpemUgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYW5lLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHBhbmUuc2l6ZUNoYW5nZSwgc2l6ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLnBhbmUoc3RhdGUkJDEucHJldi5pbmRleCk7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnBhbmUoc3RhdGUkJDEubmV4dC5pbmRleCk7XG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBwYW5lIHRvIHJlc2l6ZVxuICAgICAgICBpZiAocHJldi5maXhlZFNpemUgJiYgbmV4dC5maXhlZFNpemUpIHtcbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIGJvdGggcGFuZXNcbiAgICAgICAgICAgIHJlc2l6ZShzdGF0ZSQkMS5wcmV2LCBkZWx0YSk7XG4gICAgICAgICAgICByZXNpemUoc3RhdGUkJDEubmV4dCwgLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXh0LmNvbGxhcHNpYmxlIHx8IG5leHQuZml4ZWRTaXplKSB7XG4gICAgICAgICAgICAvLyByZXNpemluZyBuZXh0XG4gICAgICAgICAgICByZXNpemUoc3RhdGUkJDEubmV4dCwgLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIHByZXZcbiAgICAgICAgICAgIHJlc2l6ZShzdGF0ZSQkMS5wcmV2LCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KHRoaXMubGF5b3V0Q2hhbmdlLCB7fSk7XG4gICAgfVxuICAgIGlzRHJhZ2dhYmxlKHNwbGl0QmFySW5kZXgpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMucGFuZShzcGxpdEJhckluZGV4KTtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMucGFuZShzcGxpdEJhckluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IGJldHdlZW5SZXNpemFibGVQYW5lcyA9IHByZXYucmVzaXphYmxlICYmIG5leHQucmVzaXphYmxlO1xuICAgICAgICBjb25zdCBuZWFyQ29sbGFwc2VkUGFuZSA9IHByZXYuY29sbGFwc2VkIHx8IG5leHQuY29sbGFwc2VkO1xuICAgICAgICByZXR1cm4gYmV0d2VlblJlc2l6YWJsZVBhbmVzICYmICFuZWFyQ29sbGFwc2VkUGFuZTtcbiAgICB9XG4gICAgaXNTdGF0aWMoc3BsaXRCYXJJbmRleCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5wYW5lKHNwbGl0QmFySW5kZXgpO1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5wYW5lKHNwbGl0QmFySW5kZXggKyAxKTtcbiAgICAgICAgY29uc3QgYmV0d2VlblJlc2l6YWJsZVBhbmVzID0gcHJldi5yZXNpemFibGUgJiYgbmV4dC5yZXNpemFibGU7XG4gICAgICAgIGNvbnN0IG5lYXJDb2xsYXBzaWJsZVBhbmUgPSBwcmV2LmNvbGxhcHNpYmxlIHx8IG5leHQuY29sbGFwc2libGU7XG4gICAgICAgIHJldHVybiAhYmV0d2VlblJlc2l6YWJsZVBhbmVzICYmICFuZWFyQ29sbGFwc2libGVQYW5lO1xuICAgIH1cbiAgICBwYW5lKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5wYW5lcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFuZXMgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5wYW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYW5lc1tpbmRleF07XG4gICAgfVxuICAgIGNvbmZpZ3VyZSh7IHBhbmVzLCBvcmllbnRhdGlvbiwgY29udGFpbmVyU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMucGFuZXMgPSBwYW5lcztcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcGFuZS5vcmRlciA9IGluZGV4ICogMjtcbiAgICAgICAgICAgIHBhbmUub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgY29uc3QgYWxsRml4ZWQgPSBwYW5lcy5sZW5ndGggJiYgIXBhbmVzLnNvbWUocGFuZSA9PiAhcGFuZS5maXhlZFNpemUpO1xuICAgICAgICAgICAgaWYgKGFsbEZpeGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgICAgICAgICAgICAgVGhlIFNwbGl0dGVyIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBwYW5lIHdpdGhvdXQgYSBzZXQgc2l6ZS5cbiAgICAgICAgICAgICAgICAgICAgU2VlICR7U0laSU5HX0RPQ19MSU5LfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBjb250YWluZXJTaXplO1xuICAgIH1cbiAgICBpc1BlcmNlbnQoc2l6ZSkge1xuICAgICAgICByZXR1cm4gLyUkLy50ZXN0KHNpemUpO1xuICAgIH1cbiAgICB0b1BpeGVscyhzaXplKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZsb2F0KHNpemUpO1xuICAgICAgICBpZiAodGhpcy5pc1BlcmNlbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh0aGlzLmNvbnRhaW5lclNpemUoKSAqIHJlc3VsdCAvIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW1pdChlbWl0dGVyLCBhcmdzKSB7XG4gICAgICAgIGlmIChlbWl0dGVyLm9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gZW1pdHRlci5lbWl0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblNwbGl0dGVyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU3BsaXR0ZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFNwbGl0dGVyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19zcGxpdHRlciAlfSkuXG4gKlxuICogYGBgdHMtcHJldmlld1xuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLXNwbGl0dGVyIHN0eWxlPVwiaGVpZ2h0OiAyODBweDtcIj5cbiAqXG4gKiAgICAgICAgICA8a2VuZG8tc3BsaXR0ZXItcGFuZSBbY29sbGFwc2libGVdPVwidHJ1ZVwiIHNpemU9XCIzMCVcIj5cbiAqICAgICAgICAgICAgPGgzPklubmVyIHNwbGl0dGVyIC8gbGVmdCBwYW5lPC9oMz5cbiAqICAgICAgICAgICAgPHA+UmVzaXphYmxlIGFuZCBjb2xsYXBzaWJsZS48L3A+XG4gKiAgICAgICAgICA8L2tlbmRvLXNwbGl0dGVyLXBhbmU+XG4gKlxuICogICAgICAgICAgPGtlbmRvLXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgICAgICAgIDxoMz5Jbm5lciBzcGxpdHRlciAvIGNlbnRlciBwYW5lPC9oMz5cbiAqICAgICAgICAgICAgPHA+UmVzaXphYmxlIG9ubHkuPC9wPlxuICogICAgICAgICAgPC9rZW5kby1zcGxpdHRlci1wYW5lPlxuICpcbiAqICAgICAgICAgIDxrZW5kby1zcGxpdHRlci1wYW5lIFtjb2xsYXBzaWJsZV09XCJ0cnVlXCIgc2l6ZT1cIjMwJVwiPlxuICogICAgICAgICAgICA8aDM+SW5uZXIgc3BsaXR0ZXIgLyByaWdodCBwYW5lPC9oMz5cbiAqICAgICAgICAgICAgPHA+UmVzaXphYmxlIGFuZCBjb2xsYXBzaWJsZS48L3A+XG4gKiAgICAgICAgICA8L2tlbmRvLXNwbGl0dGVyLXBhbmU+XG4gKlxuICogICAgICAgIDwva2VuZG8tc3BsaXR0ZXI+XG4gKiAgICAgIGAsXG4gKiAgICBzdHlsZXM6IFsgYFxuICogICAgICAgIGgzIHsgZm9udC1zaXplOiAxLjJlbTsgfVxuICogICAgICAgIGgzLCBwIHsgbWFyZ2luOiAxMHB4OyBwYWRkaW5nOiAwOyB9XG4gKiAgICBgIF1cbiAqICB9KVxuICogIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICogYGBgXG4gKi9cbmNsYXNzIFNwbGl0dGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBzcGxpdHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbiwgZW5jbG9zaW5nUGFuZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNwbGl0dGVyU2VydmljZSA9IHNwbGl0dGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwYW5lcyB3aXRoaW4gdGhlIFNwbGl0dGVyLlxuICAgICAgICAgKiBQYW5lcyBpbiBhIGhvcml6b250YWwgU3BsaXR0ZXIgYXJlIHBsYWNlZCBob3Jpem9udGFsbHkuXG4gICAgICAgICAqIFBhbmVzIGluIGEgdmVydGljYWwgU3BsaXR0ZXIgYXJlIHBsYWNlZCB2ZXJ0aWNhbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgdGhpcy5hcmlhUm9sZSA9ICdzcGxpdHRlcic7XG4gICAgICAgIGlmIChlbmNsb3NpbmdQYW5lKSB7XG4gICAgICAgICAgICBlbmNsb3NpbmdQYW5lLmNvbnRhaW5zU3BsaXR0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBoYW5kbGVyIG9ubHkgcnVucyBpbiBOZ1pvbmUgaWYgdGhlcmUgYXJlIGJvdW5kIGhhbmRsZXJzXG4gICAgICAgIC8vIHRoaXMgbGluZSBtZXJnZXMgYm90aCBzdHJlYW1zXG4gICAgICAgIHRoaXMubGF5b3V0Q2hhbmdlID0gdGhpcy5zcGxpdHRlclNlcnZpY2UubGF5b3V0Q2hhbmdlO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSA9IHRoaXMuY29uZmlndXJlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsSG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbEhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMucmVjb25maWd1cmUoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5vcmllbnRhdGlvbiAmJiAhY2hhbmdlcy5vcmllbnRhdGlvbi5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25maWd1cmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNoYW5nZXMoKTtcbiAgICB9XG4gICAgcmVjb25maWd1cmUoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICAgIHRoaXMucGFuZUNoYW5nZXNTdWJzY3JpcHRpb24gPSB0aGlzLnBhbmVzLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMuY29uZmlndXJlKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lQ2hhbmdlc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wYW5lQ2hhbmdlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5wYW5lQ2hhbmdlc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlndXJlKCkge1xuICAgICAgICB0aGlzLnNwbGl0dGVyU2VydmljZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgcGFuZXM6IHRoaXMucGFuZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgb3JpZW50YXRpb246IHRoaXMub3JpZW50YXRpb24sXG4gICAgICAgICAgICBjb250YWluZXJTaXplOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG59XG5TcGxpdHRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9TcGxpdHRlcicsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zcGxpdHRlcicsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIFNwbGl0dGVyU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnNwbGl0ZXInXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJrZW5kby1zcGxpdHRlci1wYW5lXCI+PC9uZy1jb250ZW50PlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJcbiAgICAgICAgbGV0IHBhbmUgb2YgcGFuZXM7XG4gICAgICAgIGxldCBpbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgbGFzdCA9IGxhc3Q7XG4gICAgICBcIj5cbiAgICAgICAgPGtlbmRvLXNwbGl0dGVyLWJhclxuICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgKm5nSWY9XCIhbGFzdFwiXG4gICAgICAgICAgW2luZGV4XT1cImluZGV4XCJcbiAgICAgICAgICBbb3JpZW50YXRpb25dPVwib3JpZW50YXRpb25cIj5cbiAgICAgICAgPC9rZW5kby1zcGxpdHRlci1iYXI+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNwbGl0dGVyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogU3BsaXR0ZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTcGxpdHRlclBhbmVDb21wb25lbnQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSG9zdCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1NwbGl0dGVyUGFuZUNvbXBvbmVudCxdIH1dIH1cbl07XG5TcGxpdHRlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBvcmllbnRhdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGF5b3V0Q2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstd2lkZ2V0JyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zcGxpdHRlcicsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3BsaXR0ZXItZmxleCcsXSB9XSxcbiAgICBob3Jpem9udGFsSG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3BsaXR0ZXItaG9yaXpvbnRhbCcsXSB9XSxcbiAgICB2ZXJ0aWNhbEhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXNwbGl0dGVyLXZlcnRpY2FsJyxdIH1dLFxuICAgIGRpcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5kaXInLF0gfV0sXG4gICAgYXJpYVJvbGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XSxcbiAgICBwYW5lczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbU3BsaXR0ZXJQYW5lQ29tcG9uZW50LF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29udGVudCB0ZW1wbGF0ZSBvZiB0aGUgS2VuZG8gVUkgVGFiU3RyaXAuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGEgYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9UYWJDb250ZW50YCBpbnNpZGUgdGhlIGNvbXBvbmVudCB0YWcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxrZW5kby10YWJzdHJpcCBbbmdTdHlsZV09XCJ7J3dpZHRoJzogJzQwMHB4J31cIiBbYW5pbWF0ZV09XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgPGtlbmRvLXRhYnN0cmlwLXRhYiBbdGl0bGVdPVwiJ1BhcmlzJ1wiIFtzZWxlY3RlZF09XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UYWJDb250ZW50PlxuICogICAgICAgICAgICAgICA8aDM+Q29udGVudCAxPC9oMz5cbiAqICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgPC9rZW5kby10YWJzdHJpcC10YWI+XG4gKlxuICogICAgICAgICAgIDxrZW5kby10YWJzdHJpcC10YWIgW3RpdGxlXT1cIidTb2ZpYSdcIj5cbiAqICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RhYkNvbnRlbnQ+XG4gKiAgICAgICAgICAgICAgIDxoMz5Db250ZW50IDI8L2gzPlxuICogICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICA8L2tlbmRvLXRhYnN0cmlwLXRhYj5cbiAqICAgICAgICAgPC9rZW5kby10YWJzdHJpcD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICpcbiAqIGBgYFxuICovXG5jbGFzcyBUYWJDb250ZW50RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuVGFiQ29udGVudERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVGFiQ29udGVudF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRhYkNvbnRlbnREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRpdGxlIHRlbXBsYXRlIG9mIHRoZSBLZW5kbyBVSSBUYWJTdHJpcC5cbiAqIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsIG5lc3QgYSBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb1RhYlRpdGxlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBjb21wb25lbnQgdGFnLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8a2VuZG8tdGFic3RyaXAgW25nU3R5bGVdPVwieyd3aWR0aCc6ICc0MDBweCd9XCIgW2FuaW1hdGVdPVwidHJ1ZVwiPlxuICogICAgICAgICAgIDxrZW5kby10YWJzdHJpcC10YWIgW3RpdGxlXT1cIidQYXJpcydcIiBbc2VsZWN0ZWRdPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVGFiVGl0bGU+XG4gKiAgICAgICAgICAgICAgIFRpdGxlXG4gKiAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVGFiQ29udGVudD5cbiAqICAgICAgICAgICAgICAgPGgzPkNvbnRlbnQgMTwvaDM+XG4gKiAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgIDwva2VuZG8tdGFic3RyaXAtdGFiPlxuICpcbiAqICAgICAgICAgICA8a2VuZG8tdGFic3RyaXAtdGFiIFt0aXRsZV09XCInU29maWEnXCI+XG4gKiAgICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UYWJDb250ZW50PlxuICogICAgICAgICAgICAgICA8aDM+Q29udGVudCAyPC9oMz5cbiAqICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgPC9rZW5kby10YWJzdHJpcC10YWI+XG4gKiAgICAgICAgIDwva2VuZG8tdGFic3RyaXA+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgVGFiVGl0bGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5UYWJUaXRsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVGFiVGl0bGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UYWJUaXRsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGFiIGNvbXBvbmVudCBvZiB0aGUgVGFiU3RyaXAuXG4gKi9cbmNsYXNzIFRhYlN0cmlwVGFiQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFiQ29udGVudCA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICB9XG4gICAgZ2V0IHRhYkNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJDb250ZW50LmZpcnN0O1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snc2VsZWN0ZWQnXSAmJiAhY2hhbmdlc1snc2VsZWN0ZWQnXS5pc0ZpcnN0Q2hhbmdlKCkpIHsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0aGlzLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgfVxufVxuVGFiU3RyaXBUYWJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvVGFiU3RyaXBUYWInLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGFic3RyaXAtdGFiJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblRhYlN0cmlwVGFiQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRpdGxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3NzQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBfdGFiQ29udGVudDogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbVGFiQ29udGVudERpcmVjdGl2ZSxdIH1dLFxuICAgIHRhYlRpdGxlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtUYWJUaXRsZURpcmVjdGl2ZSxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdGAgZXZlbnQgb2YgdGhlIFRhYlN0cmlwLlxuICogVGhlIGBzZWxlY3RgIGV2ZW50IGZpcmVzIHdoZW4gYSB0YWIgaXMgc2VsZWN0ZWQgKGNsaWNrZWQpLlxuICovXG5jbGFzcyBTZWxlY3RFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmb3IgdGhlIGBzZWxlY3RgIGV2ZW50LlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgdGFiLlxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgc2VsZWN0ZWQgdGFiLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCB0aXRsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFRhYlN0cmlwIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld190YWJzdHJpcCAlfSkuXG4gKi9cbmNsYXNzIFRhYlN0cmlwQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHJlbmRlcmVyLCB3cmFwcGVyKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSB0YWIgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWJzLiBEZWZhdWx0cyB0byBgdG9wYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiUG9zaXRpb24gPSAndG9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGNvbXBvbmVudCByZW5kZXJzIGFsbCB0YWJzIGFuZCB0aGV5IGFyZSBwZXJzaXN0ZWQgaW4gdGhlIERPTS5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgYGtlZXBUYWJDb250ZW50YCBpcyBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwVGFiQ29udGVudCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSB0YWIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld190YWJzdHJpcCAlfSN0b2MtYmFzaWMtdXNhZ2UpKS5cbiAgICAgICAgICogVGhlIGV2ZW50IGRhdGEgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBzZWxlY3RlZCB0YWIgYW5kIGl0cyB0aXRsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiU2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5rZXlCaW5kaW5ncyA9IHRoaXMuY29tcHV0ZWRLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIFRhYlN0cmlwLlxuICAgICAqL1xuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIGdldCB0YWJzQXRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYlBvc2l0aW9uID09PSAndG9wJztcbiAgICB9XG4gICAgZ2V0IHRhYnNBdFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJQb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICB9XG4gICAgZ2V0IHRhYnNBdEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiUG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgIH1cbiAgICBnZXQgdGFic0F0TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiUG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICB9XG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb250ZW50Q2xhc3MoYWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSAhdGhpcy5rZWVwVGFiQ29udGVudCB8fCBhY3RpdmU7XG4gICAgICAgIHJldHVybiB2aXNpYmxlID8gJ2stY29udGVudCBrLXN0YXRlLWFjdGl2ZScgOiAnay1jb250ZW50JztcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFt0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd0xlZnQsIEtleXMuQXJyb3dSaWdodCldOiAoc2VsZWN0ZWRJbmRleCkgPT4gdGhpcy5wcmV2TmF2aWdhdGFibGVJbmRleChzZWxlY3RlZEluZGV4KSxcbiAgICAgICAgICAgIFt0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd1JpZ2h0LCBLZXlzLkFycm93TGVmdCldOiAoc2VsZWN0ZWRJbmRleCkgPT4gdGhpcy5uZXh0TmF2aWdhdGFibGVJbmRleChzZWxlY3RlZEluZGV4KSxcbiAgICAgICAgICAgIFt0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd0Rvd24sIEtleXMuQXJyb3dVcCldOiAoc2VsZWN0ZWRJbmRleCkgPT4gdGhpcy5uZXh0TmF2aWdhdGFibGVJbmRleChzZWxlY3RlZEluZGV4KSxcbiAgICAgICAgICAgIFt0aGlzLmludmVydEtleXMoS2V5cy5BcnJvd1VwLCBLZXlzLkFycm93RG93bildOiAoc2VsZWN0ZWRJbmRleCkgPT4gdGhpcy5wcmV2TmF2aWdhdGFibGVJbmRleChzZWxlY3RlZEluZGV4KSxcbiAgICAgICAgICAgIFtLZXlzLkhvbWVdOiAoKSA9PiB0aGlzLmZpcnN0TmF2aWdhdGFibGVJbmRleCgpLFxuICAgICAgICAgICAgW0tleXMuRW5kXTogKCkgPT4gdGhpcy5sYXN0TmF2aWdhdGFibGVJbmRleCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGFic0FsaWdubWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnZmxleC1zdGFydCcsXG4gICAgICAgICAgICBlbmQ6ICdmbGV4LWVuZCcsXG4gICAgICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICAgICAganVzdGlmeTogJ3NwYWNlLWJldHdlZW4nXG4gICAgICAgIH1bdGhpcy50YWJBbGlnbm1lbnRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaW52ZXJ0S2V5cyhvcmlnaW5hbCwgaW52ZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/IGludmVydGVkIDogb3JpZ2luYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IHRoaXMudGFibGlzdC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy50YWJQb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy50YWJQb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICAgIGNvbnN0IGlzQXJyb3dVcCA9IGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dVcDtcbiAgICAgICAgY29uc3QgaXNBcnJvd0Rvd24gPSBldmVudC5rZXlDb2RlID09PSBLZXlzLkFycm93RG93bjtcbiAgICAgICAgY29uc3QgaXNBcnJvd0xlZnQgPSBldmVudC5rZXlDb2RlID09PSBLZXlzLkFycm93TGVmdDtcbiAgICAgICAgY29uc3QgaXNBcnJvd1JpZ2h0ID0gZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5BcnJvd1JpZ2h0O1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsICYmIChpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0hvcml6b250YWwgJiYgKGlzQXJyb3dMZWZ0IHx8IGlzQXJyb3dSaWdodCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5TcGFjZSB8fCBpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24gfHwgaXNBcnJvd0xlZnQgfHwgaXNBcnJvd1JpZ2h0IHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuSG9tZSB8fFxuICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5FbmQgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5QYWdlVXAgfHwgZXZlbnQua2V5Q29kZSA9PT0gS2V5cy5QYWdlRG93bikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy50YWJzLnRvQXJyYXkoKS5maW5kSW5kZXgodGFiID0+IHRhYi5hY3RpdmUgJiYgIXRhYi5kaXNhYmxlZCk7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RUYWIodGhpcy5maXJzdE5hdmlnYXRhYmxlSW5kZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnZXRUYWJJbmRleCA9IHRoaXMua2V5QmluZGluZ3NbZXZlbnQua2V5Q29kZV07XG4gICAgICAgICAgICBpZiAoZ2V0VGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBnZXRUYWJJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPT0gbmV4dEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFiKGdldFRhYkluZGV4KHNlbGVjdGVkSW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRhYlBhbmVsSWQoaWQpIHtcbiAgICAgICAgcmV0dXJuICdrLXRhYnN0cmlwLXRhYnBhbmVsLScgKyBpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRhYklkKGlkKSB7XG4gICAgICAgIHJldHVybiAnay10YWJzdHJpcC10YWItJyArIGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IGEgdGFiIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB0YWIgdGhhdCB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGVjdFRhYihpbmRleCkge1xuICAgICAgICBjb25zdCB0YWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW2luZGV4XTtcbiAgICAgICAgaWYgKCF0YWIgfHwgQm9vbGVhbih0YWIuZGlzYWJsZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWJIZWFkaW5nQ29udGFpbmVycy50b0FycmF5KClbaW5kZXhdLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGFiLCBpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblRhYkNsaWNrKG9yaWdpbmFsRXZlbnQsIHRhYkluZGV4KSB7XG4gICAgICAgIGlmIChpc0ZvY3VzYWJsZShvcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdFRhYih0YWJJbmRleCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uXG4gICAgICAgICAgICAuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5rZXlCaW5kaW5ncyA9IHRoaXMuY29tcHV0ZWRLZXlzKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJzdE5hdmlnYXRhYmxlSW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGFic1tpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxhc3ROYXZpZ2F0YWJsZUluZGV4KCkge1xuICAgICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzLnRvQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRhYnMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCF0YWJzW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk5hdmlnYXRhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAtIDEgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0TmF2aWdhdGFibGVJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gc2VsZWN0ZWRJbmRleCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIXRhYnNbaV0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdE5hdmlnYXRhYmxlSW5kZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgbmV4dE5hdmlnYXRhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCArIDEgPj0gdGhpcy50YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3ROYXZpZ2F0YWJsZUluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicy50b0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzZWxlY3RlZEluZGV4ICsgMTsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGFic1tpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgKyAxID09PSB0YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0TmF2aWdhdGFibGVJbmRleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRFdmVudCh0YWIsIHNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0QXJncyA9IG5ldyBTZWxlY3RFdmVudChzZWxlY3RlZEluZGV4LCB0YWIudGl0bGUpO1xuICAgICAgICB0aGlzLnRhYlNlbGVjdC5lbWl0KHNlbGVjdEFyZ3MpO1xuICAgICAgICBpZiAoIXNlbGVjdEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgIXRhYi5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUgPSB0aGlzLmFuaW1hdGU7XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcbiAgICAgICAgICAgIHRhYi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGVBbGwoKSB7XG4gICAgICAgIHRoaXMudGFicy5mb3JFYWNoKCh0YWIpID0+IHtcbiAgICAgICAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuVGFiU3RyaXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3N0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2FjdGl2ZScsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IGFjdGl2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnNDAwbXMgZWFzZS1pbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby50YWJzdHJpcCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RhYlN0cmlwJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRhYnN0cmlwJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXRhYnNBdEJvdHRvbVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRpbmdcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGFic0F0Qm90dG9tXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29udGVudFwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGluZ1wiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjaGVhZGluZz5cbiAgICAgICAgICAgIDx1bFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1yZXNldCBrLXRhYnN0cmlwLWl0ZW1zXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuanVzdGlmeUNvbnRlbnRdPVwidGFic0FsaWdubWVudFwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInRhYmxpc3RcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duKT1cIm9uS2V5RG93bigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAjdGFibGlzdFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnM7IGxldCBpID0gaW5kZXg7XCIgKGNsaWNrKT1cIm9uVGFiQ2xpY2soJGV2ZW50LCBpKVwiXG4gICAgICAgICAgICAgICAgICAgICN0YWJIZWFkaW5nQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgICAgICBbaWRdPVwidGFiSWQoaSlcIlxuICAgICAgICAgICAgICAgICAgICBbdGFiSW5kZXhdPVwidGFiLmFjdGl2ZSA/IDAgOiAtMVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInRhYi5jc3NDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWl0ZW1dPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRlZmF1bHRdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWFjdGl2ZV09XCJ0YWIuYWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtZGlzYWJsZWRdPVwidGFiLmRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJ0YWIuYWN0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCJ0YWJQYW5lbElkKGkpXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgID48c3BhbiBjbGFzcz1cImstbGlua1wiPnt7IHRhYi50aXRsZSB9fTxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIudGFiVGl0bGU/LnRlbXBsYXRlUmVmXCI+PC9uZy10ZW1wbGF0ZT48L3NwYW4+PC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjY29udGVudD5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtdGFiIFtuZ0Zvck9mXT1cInRhYnNcIiBsZXQtaT1cImluZGV4XCI+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBbQHN0YXRlXT1cInRhYi5hY3RpdmUgJiYgX2FuaW1hdGUgPyAnYWN0aXZlJyA6ICdpbmFjdGl2ZSdcIlxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInRhYi5hY3RpdmUgfHwga2VlcFRhYkNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjb250ZW50Q2xhc3ModGFiLmFjdGl2ZSlcIlxuICAgICAgICAgICAgICAgICAgICBbdGFiSW5kZXhdPVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICAgICAgICAgICAgICAgIFtpZF09XCJ0YWJQYW5lbElkKGkpXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIXRhYi5hY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cInRhYi5hY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwidGFiSWQoaSlcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cInRhYi5kaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFiLnRhYkNvbnRlbnQ/LnRlbXBsYXRlUmVmXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UYWJTdHJpcENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuVGFiU3RyaXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaGVpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmltYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJBbGlnbm1lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYlBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBrZWVwVGFiQ29udGVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFibGlzdDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3RhYmxpc3QnLF0gfV0sXG4gICAgdGFiU2VsZWN0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstd2lkZ2V0JyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay10YWJzdHJpcCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZmxvYXR3cmFwJyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1oZWFkZXInLF0gfV0sXG4gICAgdGFic0F0VG9wOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRhYnN0cmlwLXRvcCcsXSB9XSxcbiAgICB0YWJzQXRSaWdodDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay10YWJzdHJpcC1yaWdodCcsXSB9XSxcbiAgICB0YWJzQXRCb3R0b206IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstdGFic3RyaXAtYm90dG9tJyxdIH1dLFxuICAgIHRhYnNBdExlZnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstdGFic3RyaXAtbGVmdCcsXSB9XSxcbiAgICBkaXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dLFxuICAgIHRhYnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW1RhYlN0cmlwVGFiQ29tcG9uZW50LF0gfV0sXG4gICAgdGFiSGVhZGluZ0NvbnRhaW5lcnM6IFt7IHR5cGU6IFZpZXdDaGlsZHJlbiwgYXJnczogWyd0YWJIZWFkaW5nQ29udGFpbmVyJyxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIERyYXdlci5cbiAqIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvRHJhd2VyVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tZHJhd2VyPmAgdGFnLlxuICogVXNpbmcgdGhpcyB0ZW1wbGF0ZSBkaXJlY3RpdmUgd2lsbCBvdmVycmlkZSBhbGwgb3RoZXIgdGVtcGxhdGVzLFxuICogZm9yIGV4YW1wbGUsIGBrZW5kb0RyYXdlckhlYWRlclRlbXBsYXRlYCBhbmQgYGtlbmRvRHJhd2VySXRlbVRlbXBsYXRlYC5cbiAqL1xuY2xhc3MgRHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5EcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhd2VyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGl0ZW0gY29udGVudCBvZiB0aGUgRHJhd2VyLlxuICogVG8gZGVmaW5lIHRoZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9EcmF3ZXJJdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tZHJhd2VyPmAgdGFnLlxuICovXG5jbGFzcyBEcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5EcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYXdlckl0ZW1UZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRyYXdlckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGhlYWRlciBjb250ZW50IG9mIHRoZSBEcmF3ZXIuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb0RyYXdlckhlYWRlclRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBgPGtlbmRvLWRyYXdlcj5gIHRhZy5cbiAqL1xuY2xhc3MgRHJhd2VySGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5EcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhd2VySGVhZGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGZvb3RlciBjb250ZW50IG9mIHRoZSBEcmF3ZXIuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb0RyYXdlckZvb3RlclRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBgPGtlbmRvLWRyYXdlcj5gIHRhZy5cbiAqL1xuY2xhc3MgRHJhd2VyRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5EcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhd2VyRm9vdGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbWluaUV4cGFuZFB1c2goZHVyYXRpb24sIHdpZHRoLCBtaW5pV2lkdGgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IG92ZXJmbG93OiAnaGlkZGVuJywgZmxleEJhc2lzOiBgJHttaW5pV2lkdGh9cHhgIH0pLFxuICAgICAgICBhbmltYXRlKGAke2R1cmF0aW9ufW1zIGVhc2UtaW5gLCBzdHlsZSh7IGZsZXhCYXNpczogYCR7d2lkdGh9cHhgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbWluaUNvbGxhcHNlUHVzaChkdXJhdGlvbiwgd2lkdGgsIG1pbmlXaWR0aCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgb3ZlcmZsb3c6ICdoaWRkZW4nLCBmbGV4QmFzaXM6IGAke3dpZHRofXB4YCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBmbGV4QmFzaXM6IGAke21pbmlXaWR0aH1weGAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICpcbiAqL1xuZnVuY3Rpb24gbWluaUV4cGFuZE92ZXJsYXkoZHVyYXRpb24sIHdpZHRoLCBtaW5pV2lkdGgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IHdpZHRoOiBgJHttaW5pV2lkdGh9cHhgIH0pLFxuICAgICAgICBhbmltYXRlKGAke2R1cmF0aW9ufW1zIGVhc2UtaW5gLCBzdHlsZSh7IG92ZXJmbG93OiAnaGlkZGVuJywgd2lkdGg6IGAke3dpZHRofXB4YCB9KSlcbiAgICBdO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFB1c2goZHVyYXRpb24sIHdpZHRoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIGZsZXhCYXNpczogJzBweCcgfSksXG4gICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHsgZmxleEJhc2lzOiBgJHt3aWR0aH1weGAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjb2xsYXBzZVB1c2goZHVyYXRpb24sIHdpZHRoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyBmbGV4QmFzaXM6IGAke3dpZHRofXB4YCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIGZsZXhCYXNpczogYDBweGAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBleHBhbmRSVExPdmVybGF5KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDEwMCUpYCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMClgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kT3ZlcmxheShkdXJhdGlvbiwgcG9zaXRpb24pIHtcbiAgICBjb25zdCB0cmFuc2xhdGVEaXIgPSBwb3NpdGlvbiAhPT0gJ2VuZCcgPyBgLTEwMCVgIDogYDEwMCVgO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke3RyYW5zbGF0ZURpcn0pYCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMClgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbWluaUNvbGxhcHNlT3ZlcmxheShkdXJhdGlvbiwgd2lkdGgsIG1pbmlXaWR0aCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0eWxlKHsgd2lkdGg6IGAke3dpZHRofXB4YCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIHdpZHRoOiBgJHttaW5pV2lkdGh9cHhgIH0pKVxuICAgIF07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29sbGFwc2VPdmVybGF5KGR1cmF0aW9uLCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHRyYW5zbGF0ZURpciA9IHBvc2l0aW9uICE9PSAnZW5kJyA/ICctMTAwJScgOiAnMTAwJSc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKDApYCB9KSxcbiAgICAgICAgYW5pbWF0ZShgJHtkdXJhdGlvbn1tcyBlYXNlLWluYCwgc3R5bGUoeyBvdmVyZmxvdzogJ2hpZGRlbicsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVEaXJ9KWAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjb2xsYXBzZVJUTE92ZXJsYXkoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoMClgIH0pLFxuICAgICAgICBhbmltYXRlKGAke2R1cmF0aW9ufW1zIGVhc2UtaW5gLCBzdHlsZSh7IG92ZXJmbG93OiAnaGlkZGVuJywgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgxMDAlKWAgfSkpXG4gICAgXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBleHBhbmRBbmltYXRpb24oc2V0dGluZ3MpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNldHRpbmdzLmFuaW1hdGlvbi5kdXJhdGlvbjtcbiAgICBjb25zdCB3aWR0aCA9IHNldHRpbmdzLndpZHRoO1xuICAgIGNvbnN0IG1pbmlXaWR0aCA9IHNldHRpbmdzLm1pbmlXaWR0aDtcbiAgICBjb25zdCBtb2RlID0gc2V0dGluZ3MubW9kZTtcbiAgICBjb25zdCBtaW5pID0gc2V0dGluZ3MubWluaTtcbiAgICBjb25zdCBydGwgPSBzZXR0aW5ncy5ydGw7XG4gICAgY29uc3QgcG9zaXRpb24gPSBzZXR0aW5ncy5wb3NpdGlvbjtcbiAgICBpZiAobWluaSAmJiBtb2RlID09PSAncHVzaCcpIHtcbiAgICAgICAgcmV0dXJuIG1pbmlFeHBhbmRQdXNoKGR1cmF0aW9uLCB3aWR0aCwgbWluaVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKCFtaW5pICYmIG1vZGUgPT09ICdwdXNoJykge1xuICAgICAgICByZXR1cm4gZXhwYW5kUHVzaChkdXJhdGlvbiwgd2lkdGgpO1xuICAgIH1cbiAgICBpZiAoIW1pbmkgJiYgbW9kZSA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgIHJldHVybiBydGwgPyBleHBhbmRSVExPdmVybGF5KGR1cmF0aW9uKSA6IGV4cGFuZE92ZXJsYXkoZHVyYXRpb24sIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKG1pbmkgJiYgbW9kZSA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgIHJldHVybiBtaW5pRXhwYW5kT3ZlcmxheShkdXJhdGlvbiwgd2lkdGgsIG1pbmlXaWR0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvbGxhcHNlQW5pbWF0aW9uKHNldHRpbmdzKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBzZXR0aW5ncy5hbmltYXRpb24uZHVyYXRpb247XG4gICAgY29uc3Qgd2lkdGggPSBzZXR0aW5ncy53aWR0aDtcbiAgICBjb25zdCBtaW5pV2lkdGggPSBzZXR0aW5ncy5taW5pV2lkdGg7XG4gICAgY29uc3QgbW9kZSA9IHNldHRpbmdzLm1vZGU7XG4gICAgY29uc3QgbWluaSA9IHNldHRpbmdzLm1pbmk7XG4gICAgY29uc3QgcnRsID0gc2V0dGluZ3MucnRsO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gc2V0dGluZ3MucG9zaXRpb247XG4gICAgaWYgKG1pbmkgJiYgbW9kZSA9PT0gJ3B1c2gnKSB7XG4gICAgICAgIHJldHVybiBtaW5pQ29sbGFwc2VQdXNoKGR1cmF0aW9uLCB3aWR0aCwgbWluaVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKCFtaW5pICYmIG1vZGUgPT09ICdwdXNoJykge1xuICAgICAgICByZXR1cm4gY29sbGFwc2VQdXNoKGR1cmF0aW9uLCB3aWR0aCk7XG4gICAgfVxuICAgIGlmICghbWluaSAmJiBtb2RlID09PSAnb3ZlcmxheScpIHtcbiAgICAgICAgcmV0dXJuIHJ0bCA/IGNvbGxhcHNlUlRMT3ZlcmxheShkdXJhdGlvbikgOiBjb2xsYXBzZU92ZXJsYXkoZHVyYXRpb24sIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKG1pbmkgJiYgbW9kZSA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgIHJldHVybiBtaW5pQ29sbGFwc2VPdmVybGF5KGR1cmF0aW9uLCB3aWR0aCwgbWluaVdpZHRoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdGAgZXZlbnQgb2YgdGhlIERyYXdlci5cbiAqL1xuY2xhc3MgRHJhd2VyU2VsZWN0RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYXdlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcyA9IFtdO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGRyYXdlciA9IHRoaXMub3duZXI7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBEcmF3ZXJTZWxlY3RFdmVudChPYmplY3QuYXNzaWduKHt9LCBhcmdzLCB7IHNlbmRlcjogZHJhd2VyIH0pKTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyhkcmF3ZXJbZXZlbnRdKSkge1xuICAgICAgICAgICAgZHJhd2VyW2V2ZW50XS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgb25TZWxlY3Qoc2VsZWN0ZWRJZHgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljZXMgPSBbc2VsZWN0ZWRJZHhdO1xuICAgICAgICBjb25zdCBkcmF3ZXIgPSB0aGlzLm93bmVyO1xuICAgICAgICBpZiAoZHJhd2VyLmF1dG9Db2xsYXBzZSAmJiAhZHJhd2VyLm1pbmltaXplZCkge1xuICAgICAgICAgICAgZHJhd2VyLnRvZ2dsZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLm93bmVyLml0ZW1zO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuRHJhd2VyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuY29uc3QgREVGQVVMVF9BTklNQVRJT04gPSB7IHR5cGU6ICdzbGlkZScsIGR1cmF0aW9uOiAyMDAgfTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERyYXdlciBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfZHJhd2VyICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tZHJhd2VyLWNvbnRhaW5lcj5cbiAqICAgICAgICAgICAgIDxrZW5kby1kcmF3ZXIgI2RyYXdlclxuICogICAgICAgICAgICAgICAgICBbaXRlbXNdPVwiaXRlbXNcIlxuICogICAgICAgICAgICAgICAgICBbbW9kZV09XCInb3ZlcmxheSdcIlxuICogICAgICAgICAgICAgICAgICBbKGV4cGFuZGVkKV09XCJleHBhbmRlZFwiPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZHJhd2VyPlxuICogICAgICAgICAgICAgIDxrZW5kby1kcmF3ZXItY29udGVudD5cbiAqICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cImRyYXdlci50b2dnbGUoKVwiPk9wZW4gdGhlIERyYXdlcjwvYnV0dG9uPlxuICogICAgICAgICAgICAgIDwva2VuZG8tZHJhd2VyLWNvbnRlbnQ+XG4gKiAgICAgICAgPC9rZW5kby1kcmF3ZXItY29udGFpbmVyPlxuICogICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICBwdWJsaWMgZXhwYW5kZWQgPSBmYWxzZTtcbiAqXG4gKiAgICBwdWJsaWMgaXRlbXM6IGFueVtdID0gW1xuICogICAgICB7IHRleHQ6ICdJbmJveCcsIGljb246ICdrLWktaW5ib3gnIH0sXG4gKiAgICAgIHsgdGV4dDogJ05vdGlmaWNhdGlvbnMnLCBpY29uOiAnay1pLWJlbGwnIH0sXG4gKiAgICAgIHsgdGV4dDogJ0RhdGUnLCBpY29uOiAnay1pLWNhbGVuZGFyJyB9XG4gKiAgICBdO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIERyYXdlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYnVpbGRlciwgbG9jYWxpemF0aW9uU2VydmljZSwgZHJhd2VyU2VydmljZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmRyYXdlclNlcnZpY2UgPSBkcmF3ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbW9kZSBpbiB3aGljaCB0aGUgRHJhd2VyIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYG92ZXJsYXlgXG4gICAgICAgICAqICogYHB1c2hgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnb3ZlcmxheSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBEcmF3ZXJcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwb3NpdGlvbmluZ19kcmF3ZXIgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogKERlZmF1bHQpIGBzdGFydGBcbiAgICAgICAgICogKiBgZW5kYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdzdGFydCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBtaW5pIChjb21wYWN0KSB2aWV3IG9mIHRoZSBEcmF3ZXIgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjb2xsYXBzZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBleHBhbmRtb2Rlc3Bvc2l0aW9uc19kcmF3ZXIgJX0jdG9jLW1pbmktdmlldykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5pID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHN0YXRlIG9mIHRoZSBEcmF3ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSB3aWR0aCBvZiB0aGUgRHJhd2VyIHdoZW4gaXQgaXMgZXhwYW5kZWQuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGAyNDBgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IDI0MDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSBEcmF3ZXIgd2hlbiB0aGUgbWluaSB2aWV3IGlzIGVuYWJsZWRcbiAgICAgICAgICogYW5kIHRoZSBjb21wb25lbnQgaXMgY29sbGFwc2VkLiBEZWZhdWx0cyB0byBgNjBgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5pV2lkdGggPSA1MDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgRHJhd2VyIHdpbGwgYmUgYXV0b21hdGljYWxseSBjb2xsYXBzZWQgd2hlbiBhbiBpdGVtXG4gICAgICAgICAqIG9yIHRoZSBvdmVybGF5IGlzIGNsaWNrZWQuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0NvbGxhcHNlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIHNldHRpbmdzIG9mIHRoZSBEcmF3ZXIuXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgaW50ZXJhY3Rpb25fZHJhd2VyICV9I3RvYy10b2dnbGluZy1iZXR3ZWVuLXN0YXRlcykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiBCb29sZWFuXG4gICAgICAgICAqICAgICogKERlZmF1bHQpIGB0cnVlYFxuICAgICAgICAgKiAgICAqIGBmYWxzZWBcbiAgICAgICAgICogKiBgRHJhd2VyQW5pbWF0aW9uYFxuICAgICAgICAgKiAgICAqIChEZWZhdWx0KSBgdHlwZT86ICdzbGlkZSdgXG4gICAgICAgICAqICAgICogYGR1cmF0aW9uYCZtZGFzaDtBY2NlcHRzIGEgbnVtYmVyIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gYDMwMG1zYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gREVGQVVMVF9BTklNQVRJT047XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBEcmF3ZXIgaXMgZXhwYW5kZWQgYW5kIGl0cyBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIERyYXdlciBpcyBjb2xsYXBzZWQgYW5kIGl0cyBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIERyYXdlciBpdGVtIGlzIHNlbGVjdGVkLiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgZXhwYW5kZWRgIHByb3BlcnR5IG9mIHRoZSBjb21wb25lbnQgd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqIFVzZWQgdG8gcHJvdmlkZSBhIHR3by13YXkgYmluZGluZyBmb3IgdGhlIGBleHBhbmRlZGAgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ0bCA9IHJ0bDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kcmF3ZXJTZXJ2aWNlLm93bmVyID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0UG9zaXRpb25DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09ICdzdGFydCc7XG4gICAgfVxuICAgIGdldCBlbmRQb3NpdGlvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gJ2VuZCc7XG4gICAgfVxuICAgIGdldCBvdmVybGF5VHJhbnNvZnJtU3R5bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAncHVzaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCB8fCB0aGlzLm1pbmltaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGVYKDBweClgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdHJhbnNsYXRlWCgtMTAwJSlgO1xuICAgIH1cbiAgICBnZXQgZmxleFN0eWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuZGVkICYmICF0aGlzLm1pbmltaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyV2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGl0ZW1zIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgRHJhd2VyLlxuICAgICAqL1xuICAgIHNldCBpdGVtcyhpdGVtcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGl0ZW1zKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyU2VydmljZS5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG1pbmltaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaSAmJiAhdGhpcy5leHBhbmRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkcmF3ZXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW1pemVkID8gdGhpcy5taW5pV2lkdGggOiB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBEcmF3ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwYW5kZWQ/IC0gQm9vbGVhbi4gU3BlY2lmaWVzIGlmIHRoZSBEcmF3ZXIgd2lsbCBiZSBleHBhbmRlZCBvciBjb2xsYXBzZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKGV4cGFuZGVkKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5leHBhbmRlZDtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGlzUHJlc2VudChleHBhbmRlZCkgPyBleHBhbmRlZCA6ICFwcmV2aW91cztcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5kZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gZmFsc2UgJiYgIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuZGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRW5kLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHsgdGhpcy5vbkFuaW1hdGlvbkVuZChjdXJyZW50KTsgfSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2N1cnJlbnQgPyAnZXhwYW5kJyA6ICdjb2xsYXBzZSddLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkFuaW1hdGlvbkVuZChjdXJyZW50RXhwYW5kZWQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRFeHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFeHBhbmRlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuICAgIGFuaW1hdGUoZXhwYW5kZWQpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICBtaW5pOiB0aGlzLm1pbmksXG4gICAgICAgICAgICBtaW5pV2lkdGg6IHRoaXMubWluaVdpZHRoLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBydGw6IHRoaXMucnRsLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICBhbmltYXRpb246ICh0eXBlb2YgdGhpcy5hbmltYXRpb24gIT09ICdib29sZWFuJykgPyB0aGlzLmFuaW1hdGlvbiA6IERFRkFVTFRfQU5JTUFUSU9OXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGV4cGFuZGVkID8gZXhwYW5kQW5pbWF0aW9uKHNldHRpbmdzKSA6IGNvbGxhcHNlQW5pbWF0aW9uKHNldHRpbmdzKTtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5jcmVhdGVQbGF5ZXIoYW5pbWF0aW9uLCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgfVxuICAgIGNyZWF0ZVBsYXllcihhbmltYXRpb24sIGFuaW1hdGVkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5idWlsZGVyLmJ1aWxkKGFuaW1hdGlvbik7XG4gICAgICAgIGxldCBwbGF5ZXIgPSBmYWN0b3J5LmNyZWF0ZShhbmltYXRlZEVsZW1lbnQpO1xuICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICB9XG59XG5EcmF3ZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvRHJhd2VyJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRHJhd2VyU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmRyYXdlcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kcmF3ZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWRyYXdlci13cmFwcGVyXCIgKm5nSWY9XCJleHBhbmRlZCB8fCBtaW5pXCIgW3N0eWxlLndpZHRoLnB4XT1cImRyYXdlcldpZHRoXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWRyYXdlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaGVhZGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJoZWFkZXJUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICAgICAgPHVsIGtlbmRvRHJhd2VyTGlzdFxuICAgICAgICAgICAgICAgICAgICBbaXRlbXNdPVwiaXRlbXNcIiBbbWluaV09XCJtaW5pXCIgW2V4cGFuZGVkXT1cImV4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2l0ZW1UZW1wbGF0ZV09XCJpdGVtVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRyYXdlci1pdGVtc1wiPlxuICAgICAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJmb290ZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImZvb3RlclRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZHJhd2VyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRyYXdlclRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9kaXY+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmF3ZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBBbmltYXRpb25CdWlsZGVyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBEcmF3ZXJTZXJ2aWNlIH1cbl07XG5EcmF3ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstd2lkZ2V0JyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1kcmF3ZXInLF0gfV0sXG4gICAgc3RhcnRQb3NpdGlvbkNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWRyYXdlci1zdGFydCcsXSB9XSxcbiAgICBlbmRQb3NpdGlvbkNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWRyYXdlci1lbmQnLF0gfV0sXG4gICAgb3ZlcmxheVRyYW5zb2ZybVN0eWxlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUudHJhbnNmb3JtJyxdIH1dLFxuICAgIGZsZXhTdHlsZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLmZsZXhCYXNpcy5weCcsXSB9XSxcbiAgICBtb2RlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3NpdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluaTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXhwYW5kZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdpZHRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW5pV2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGF1dG9Db2xsYXBzZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXRlbXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpcmVjdGlvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5kaXInLF0gfV0sXG4gICAgYW5pbWF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHBhbmQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2xsYXBzZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlbGVjdDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGV4cGFuZGVkQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgZHJhd2VyVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0RyYXdlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZm9vdGVyVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0RyYXdlckZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgaGVhZGVyVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0RyYXdlckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgaXRlbVRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtEcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXSB9XVxufTtcblxuLyoqXG4gKiBTZXJ2ZXMgYXMgYSBjb250YWluZXIgZm9yIHRoZSBbS2VuZG8gVUkgRHJhd2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19kcmF3ZXIgJX0pIGFuZCBpdHMgY29udGVudC5cbiAqL1xuY2xhc3MgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydGwgPSBydGw7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgb3ZlcmxheUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIubW9kZSA9PT0gJ292ZXJsYXknO1xuICAgIH1cbiAgICBnZXQgbWluaUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIubWluaTtcbiAgICB9XG4gICAgZ2V0IHB1c2hDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLm1vZGUgPT09ICdwdXNoJztcbiAgICB9XG4gICAgZ2V0IGlzRXhwYW5kZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLmV4cGFuZGVkO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZHJhd2VyKSAmJlxuICAgICAgICAgICAgdGhpcy5kcmF3ZXIuZXhwYW5kZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyLm1vZGUgPT09ICdvdmVybGF5JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsb3NlRHJhd2VyKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5ICYmIHRoaXMuZHJhd2VyLmF1dG9Db2xsYXBzZSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3ZXIudG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkRyYXdlckNvbnRhaW5lckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZHJhd2VyLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5kcmF3ZXIuY29udGFpbmVyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1vdmVybGF5XCIgKm5nSWY9XCJvdmVybGF5XCIgKGNsaWNrKT1cImNsb3NlRHJhd2VyKClcIj48L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1kcmF3ZXItY29udGFpbmVyJyxdIH1dLFxuICAgIG92ZXJsYXlDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1kcmF3ZXItb3ZlcmxheScsXSB9XSxcbiAgICBtaW5pQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZHJhd2VyLW1pbmknLF0gfV0sXG4gICAgcHVzaENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWRyYXdlci1wdXNoJyxdIH1dLFxuICAgIGlzRXhwYW5kZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1kcmF3ZXItZXhwYW5kZWQnLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBkcmF3ZXI6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0RyYXdlckNvbXBvbmVudCxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbnRlbnQgb2YgdGhlIFtLZW5kbyBVSSBEcmF3ZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2RyYXdlciAlfSkuXG4gKi9cbmNsYXNzIERyYXdlckNvbnRlbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICB9XG59XG5EcmF3ZXJDb250ZW50Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1kcmF3ZXItY29udGVudCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmF3ZXJDb250ZW50Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW107XG5EcmF3ZXJDb250ZW50Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWRyYXdlci1jb250ZW50JyxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIHdob2xlIFN0ZXAuXG4gKiBUbyBkZWZpbmUgdGhlIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWdcbiAqIHdpdGggdGhlIGBrZW5kb1N0ZXBwZXJTdGVwVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tc3RlcHBlcj5gIHRhZy5cbiAqL1xuY2xhc3MgU3RlcHBlclN0ZXBUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cblN0ZXBwZXJTdGVwVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1N0ZXBwZXJTdGVwVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TdGVwcGVyU3RlcFRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRlbXBsYXRlIHRoYXQgZGVmaW5lcyB0aGUgY29udGVudCBvZiB0aGUgU3RlcCBsYWJlbC5cbiAqIFRvIGRlZmluZSB0aGUgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvU3RlcHBlckxhYmVsVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tc3RlcHBlcj5gIHRhZy5cbiAqL1xuY2xhc3MgU3RlcHBlckxhYmVsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5TdGVwcGVyTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU3RlcHBlckxhYmVsVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TdGVwcGVyTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZW1wbGF0ZSB0aGF0IGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIFN0ZXAgaW5kaWNhdG9yLlxuICogVG8gZGVmaW5lIHRoZSB0ZW1wbGF0ZSwgbmVzdCBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnXG4gKiB3aXRoIHRoZSBga2VuZG9TdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tc3RlcHBlcj5gIHRhZy5cbiAqL1xuY2xhc3MgU3RlcHBlckluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuU3RlcHBlckluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9TdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TdGVwcGVySW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgYWN0aXZhdGVgIGV2ZW50IG9mIHRoZSBTdGVwcGVyLlxuICovXG5jbGFzcyBTdGVwcGVyQWN0aXZhdGVFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xufVxuXG5jb25zdCBERUZBVUxUX0NVUlJFTlRfU1RFUCA9IDA7XG5jb25zdCBoYW5kbGVycyA9IHt9O1xuaGFuZGxlcnNbS2V5cy5BcnJvd0xlZnRdID0gJ2xlZnQnO1xuaGFuZGxlcnNbS2V5cy5BcnJvd1JpZ2h0XSA9ICdyaWdodCc7XG5oYW5kbGVyc1tLZXlzLkFycm93VXBdID0gJ3VwJztcbmhhbmRsZXJzW0tleXMuQXJyb3dEb3duXSA9ICdkb3duJztcbmhhbmRsZXJzW0tleXMuSG9tZV0gPSAnaG9tZSc7XG5oYW5kbGVyc1tLZXlzLkVuZF0gPSAnZW5kJztcbmhhbmRsZXJzW0tleXMuRW50ZXJdID0gJ2VudGVyJztcbmhhbmRsZXJzW0tleXMuU3BhY2VdID0gJ2VudGVyJztcbmNvbnN0IGhhbmRsZXJzUlRMID0gT2JqZWN0LmFzc2lnbih7fSwgaGFuZGxlcnMpO1xuaGFuZGxlcnNSVExbS2V5cy5BcnJvd0xlZnRdID0gJ3JpZ2h0JztcbmhhbmRsZXJzUlRMW0tleXMuQXJyb3dSaWdodF0gPSAnbGVmdCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3RlcHBlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgbmdab25lLCBjaGFuZ2VEZXRlY3Rvcikge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IERFRkFVTFRfQ1VSUkVOVF9TVEVQO1xuICAgICAgICB0aGlzLnRyaWdnZXJWYWxpZGF0aW9uID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmZvY3VzZWRTdGVwQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgaGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyBoYW5kbGVyc1JUTCA6IGhhbmRsZXJzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCBldmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3RlcHBlciA9IHRoaXMub3duZXI7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnMoc3RlcHBlcltldmVudF0pKSB7XG4gICAgICAgICAgICBzdGVwcGVyW2V2ZW50XS5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgb25BY3RpdmF0ZShjdXJyZW50SWR4LCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IG5ldyBTdGVwcGVyQWN0aXZhdGVFdmVudCh7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudElkeCxcbiAgICAgICAgICAgIHN0ZXA6IHRoaXMub3duZXIuc3RlcHNbY3VycmVudElkeF0sXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgc2VuZGVyOiB0aGlzLm93bmVyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVtaXQoJ2FjdGl2YXRlJywgZXZlbnRBcmdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBjdXJyZW50SWR4O1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXJbJ2N1cnJlbnRTdGVwQ2hhbmdlJ10uZW1pdChjdXJyZW50SWR4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhbGlkYXRlU3RlcHMoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclZhbGlkYXRpb24uZW1pdCgpO1xuICAgIH1cbiAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZm9jdXNlZFN0ZXAgfHwgdGhpcy5jdXJyZW50U3RlcDtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbZS5rZXlDb2RlXTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpc1toYW5kbGVyXShlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZWZ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c1ByZXZTdGVwKCk7XG4gICAgfVxuICAgIHJpZ2h0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c05leHRTdGVwKCk7XG4gICAgfVxuICAgIHVwKCkge1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzUHJldlN0ZXAoKTtcbiAgICB9XG4gICAgZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c05leHRTdGVwKCk7XG4gICAgfVxuICAgIGhvbWUoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZFN0ZXAgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzZWRTdGVwQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLmZvY3VzZWRTdGVwID0gdGhpcy5vd25lci5zdGVwcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmZvY3VzZWRTdGVwQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgZW50ZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFN0ZXAgPT09IHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1N0ZXBEaXNhYmxlZCh0aGlzLmZvY3VzZWRTdGVwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm93bmVyLmxpbmVhciAmJiB0aGlzLmlzUHJldk9yTmV4dFN0ZXAodGhpcy5mb2N1c2VkU3RlcCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkFjdGl2YXRlKHRoaXMuZm9jdXNlZFN0ZXAsIGV2ZW50KTtcbiAgICB9XG4gICAgZm9jdXMoZm9jdXNlZElkeCkge1xuICAgICAgICB0aGlzLmZvY3VzZWRTdGVwID0gZm9jdXNlZElkeDtcbiAgICB9XG4gICAgZm9jdXNOZXh0U3RlcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFN0ZXAgPCB0aGlzLm93bmVyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkU3RlcCArPSAxO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkU3RlcENoYW5nZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXNQcmV2U3RlcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZFN0ZXAgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRTdGVwIC09IDE7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRTdGVwQ2hhbmdlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0ZXBEaXNhYmxlZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25lci5zdGVwc1tpbmRleF0uZGlzYWJsZWQ7XG4gICAgfVxuICAgIGlzUHJldk9yTmV4dFN0ZXAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSB0aGlzLmN1cnJlbnRTdGVwICsgMSB8fCBpbmRleCA9PT0gdGhpcy5jdXJyZW50U3RlcCAtIDE7XG4gICAgfVxuICAgIGdldCBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm93bmVyLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxufVxuU3RlcHBlclNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblN0ZXBwZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuXG5jb25zdCBERUZBVUxUX0FOSU1BVElPTl9EVVJBVElPTiA9IDQwMDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIFN0ZXBwZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3N0ZXBwZXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1zdGVwcGVyIFtzdGVwc109XCJzdGVwc1wiPlxuICogICAgICAgIDwva2VuZG8tc3RlcHBlcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgcHVibGljIHN0ZXBzOiBBcnJheTxTdGVwcGVyU3RlcD4gPSBbXG4gKiAgICAgIHsgbGFiZWw6ICdTdGVwIE9uZScgfSwgeyBsYWJlbDogJ1N0ZXAgVHdvJyB9LCB7IGxhYmVsOiAnU3RlcCBUaHJlZScgfVxuICogICAgXTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBTdGVwcGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbSwgbG9jYWxpemF0aW9uLCBzdGVwcGVyU2VydmljZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlID0gc3RlcHBlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyaWFSb2xlID0gJ25hdmlnYXRpb24nO1xuICAgICAgICB0aGlzLmRpc3BsYXlTdHlsZSA9ICdncmlkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgdHlwZSBvZiB0aGUgc3RlcHMgaW4gdGhlIFN0ZXBwZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgaW5kaWNhdG9yYFxuICAgICAgICAgKiAqIGBsYWJlbGBcbiAgICAgICAgICogKiBgZnVsbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcFR5cGUgPSAnaW5kaWNhdG9yJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbGluZWFyIGZsb3cgb2YgdGhlIFN0ZXBwZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZWFyID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIFN0ZXBwZXJcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvcmllbnRhdGlvbl9zdGVwcGVyICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgaG9yaXpvbnRhbGBcbiAgICAgICAgICogKiBgdmVydGljYWxgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHRzIHRvIGA0MDBtc2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAgKiBCb29sZWFuXG4gICAgICAgICAqICAgICogKERlZmF1bHQpIGB0cnVlYFxuICAgICAgICAgKiAgICAqIGZhbHNlXG4gICAgICAgICAqICAqIE51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIHN0ZXAgaXMgYWJvdXQgdG8gYmUgYWN0aXZhdGVkLiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGBjdXJyZW50U3RlcGAgcHJvcGVydHkgb2YgdGhlIGNvbXBvbmVudCB3YXMgdXBkYXRlZC5cbiAgICAgICAgICogVXNlZCB0byBwcm92aWRlIGEgdHdvLXdheSBiaW5kaW5nIGZvciB0aGUgYGN1cnJlbnRTdGVwYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXBDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3N0ZXBzID0gW107XG4gICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLm93bmVyID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVhckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBzdGVwLlxuICAgICAqL1xuICAgIHNldCBjdXJyZW50U3RlcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmN1cnJlbnRTdGVwID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjdXJyZW50U3RlcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHBlclNlcnZpY2UuY3VycmVudFN0ZXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIHN0ZXBzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgU3RlcHBlci5cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHN0ZXBfYXBwZWFyYW5jZV9zdGVwcGVyICV9KSlcbiAgICAgKi9cbiAgICBzZXQgc3RlcHMoc3RlcHMpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzdGVwcykgJiYgc3RlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3RlcHMgPSBzdGVwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RlcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwcztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlIb3N0U3R5bGluZygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnN0ZXBzICYmICFjaGFuZ2VzLnN0ZXBzLmZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5SG9zdFN0eWxpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgdHJpZ2dlcnMgdGhlIHZhbGlkaXR5IGNoZWNrIGNvbmZpZ3VyZWQgYnkgdGhlIFtpc1ZhbGlkXSh7JSBzbHVnIGFwaV9sYXlvdXRfc3RlcHBlcnN0ZXAgJX0jdG9jLWlzdmFsaWQpIHByb3BlcnR5IG9mIHRoZSBzdGVwcy5cbiAgICAgKlxuICAgICAqIFN0ZXBzIHRoYXQgaGF2ZSB0aGVpciBbdmFsaWRhdGVdKHslIHNsdWcgYXBpX2xheW91dF9zdGVwcGVyc3RlcCAlfSN0b2MtdmFsaWRhdGUpIHByb3BlcnR5IHNldCB0byBgZmFsc2VgLCB3aWxsIG5vdCBiZSB2YWxpZGF0ZWQuXG4gICAgICovXG4gICAgdmFsaWRhdGVTdGVwcygpIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS52YWxpZGF0ZVN0ZXBzKCk7XG4gICAgfVxuICAgIGFwcGx5SG9zdFN0eWxpbmcoKSB7XG4gICAgICAgIGNvbnN0IHN0ZXBGcmFtZXNTdHlsZSA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnIDogJ2dyaWQtdGVtcGxhdGUtcm93cyc7XG4gICAgICAgIGNvbnN0IHN0ZXBGcmFtZXNWYWx1ZSA9IGByZXBlYXQoJHt0aGlzLnN0ZXBzLmxlbmd0aCAqIDJ9LCAxZnIpYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCwgc3RlcEZyYW1lc1N0eWxlLCBzdGVwRnJhbWVzVmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHByb2dyZXNzQW5pbWF0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGFuaW1hdGlvbkR1cmF0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYW5pbWF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5hbmltYXRpb24gPT09ICdib29sZWFuJyAmJiB0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfQU5JTUFUSU9OX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0ZXBzTGlzdFN0eWxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICdncmlkLWNvbHVtbi1zdGFydCc6IDEsICdncmlkLWNvbHVtbi1lbmQnOiAtMSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICdncmlkLXJvdy1zdGFydCc6IDEsICdncmlkLXJvdy1lbmQnOiAtMSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHByb2dyZXNzQmFyU3R5bGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnZ3JpZC1jb2x1bW4tc3RhcnQnOiAyLFxuICAgICAgICAgICAgICAgICdncmlkLWNvbHVtbi1lbmQnOiB0aGlzLnN0ZXBzLmxlbmd0aCAqIDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdncmlkLXJvdy1zdGFydCc6IDIsXG4gICAgICAgICAgICAnZ3JpZC1yb3ctZW5kJzogdGhpcy5zdGVwcy5sZW5ndGggKiAyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHBlclNlcnZpY2UuaXNIb3Jpem9udGFsO1xuICAgIH1cbn1cblN0ZXBwZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvU3RlcHBlcicsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFN0ZXBwZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uc3RlcHBlcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zdGVwcGVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvU3RlcHBlckxvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLW9wdGlvbmFsPVwia2VuZG8uc3RlcHBlci5vcHRpb25hbHxUaGUgdGV4dCBmb3IgdGhlIG9wdGlvbmFsIHNlZ21lbnQgb2YgdGhlIHN0ZXAgbGFiZWxcIlxuICAgICAgICAgICAgb3B0aW9uYWw9XCJPcHRpb25hbFwiXG4gICAgICAgICA+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8b2wga2VuZG9TdGVwcGVyTGlzdFxuICAgICAgICAgICAgW3N0ZXBUeXBlXT0nc3RlcFR5cGUnXG4gICAgICAgICAgICBbbGluZWFyXT0nbGluZWFyJ1xuICAgICAgICAgICAgW29yaWVudGF0aW9uXT0nb3JpZW50YXRpb24nXG4gICAgICAgICAgICBbc3RlcHNdPSdzdGVwcydcbiAgICAgICAgICAgIFtjdXJyZW50U3RlcF09J2N1cnJlbnRTdGVwJ1xuICAgICAgICAgICAgW3N1Y2Nlc3NJY29uXT0nc3VjY2Vzc0ljb24nXG4gICAgICAgICAgICBbZXJyb3JJY29uXT0nZXJyb3JJY29uJ1xuICAgICAgICAgICAgW2luZGljYXRvclRlbXBsYXRlXT0naW5kaWNhdG9yVGVtcGxhdGU/LnRlbXBsYXRlUmVmJ1xuICAgICAgICAgICAgW2xhYmVsVGVtcGxhdGVdPSdsYWJlbFRlbXBsYXRlPy50ZW1wbGF0ZVJlZidcbiAgICAgICAgICAgIFtzdGVwVGVtcGxhdGVdPSdzdGVwVGVtcGxhdGU/LnRlbXBsYXRlUmVmJ1xuICAgICAgICAgICAgY2xhc3M9J2stc3RlcC1saXN0J1xuICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1saXN0LWhvcml6b250YWxdPSdpc0hvcml6b250YWwnXG4gICAgICAgICAgICBbY2xhc3Muay1zdGVwLWxpc3QtdmVydGljYWxdPSchaXNIb3Jpem9udGFsJ1xuICAgICAgICAgICAgW25nU3R5bGVdPSdzdGVwc0xpc3RTdHlsaW5nJz5cbiAgICAgICAgPC9vbD5cblxuICAgICAgICA8a2VuZG8tcHJvZ3Jlc3NiYXIgKm5nSWY9J3N0ZXBzLmxlbmd0aCA+IDAnXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWhpZGRlbl09J3RydWUnXG4gICAgICAgICAgICBbYW5pbWF0aW9uXT0ncHJvZ3Jlc3NBbmltYXRpb24nXG4gICAgICAgICAgICBbbWF4XT0nc3RlcHMubGVuZ3RoIC0gMSdcbiAgICAgICAgICAgIFtsYWJlbF09J2ZhbHNlJ1xuICAgICAgICAgICAgW29yaWVudGF0aW9uXT0nb3JpZW50YXRpb24nXG4gICAgICAgICAgICBbcmV2ZXJzZV09JyFpc0hvcml6b250YWwnXG4gICAgICAgICAgICBbdmFsdWVdPSdjdXJyZW50U3RlcCdcbiAgICAgICAgICAgIFtuZ1N0eWxlXT0ncHJvZ3Jlc3NCYXJTdHlsaW5nJz5cbiAgICAgICAgPC9rZW5kby1wcm9ncmVzc2Jhcj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblN0ZXBwZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFN0ZXBwZXJTZXJ2aWNlIH1cbl07XG5TdGVwcGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RlcHBlcicsXSB9XSxcbiAgICBsaW5lYXJDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGVwcGVyLWxpbmVhcicsXSB9XSxcbiAgICBhcmlhUm9sZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5yb2xlJyxdIH1dLFxuICAgIGRpcmVjdGlvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5kaXInLF0gfV0sXG4gICAgZGlzcGxheVN0eWxlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5kaXNwbGF5JyxdIH1dLFxuICAgIHN0ZXBUeXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsaW5lYXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9yaWVudGF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjdXJyZW50U3RlcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RlcHM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN1Y2Nlc3NJY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBlcnJvckljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFuaW1hdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aXZhdGU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjdXJyZW50U3RlcENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHN0ZXBUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbU3RlcHBlclN0ZXBUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIGxhYmVsVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW1N0ZXBwZXJMYWJlbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgaW5kaWNhdG9yVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW1N0ZXBwZXJJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSxdIH1dXG59O1xuXG5jb25zdCBTSVpFX0NMQVNTRVMgPSB7XG4gICAgJ3NtYWxsJzogJ2stYXZhdGFyLXNtJyxcbiAgICAnbWVkaXVtJzogJ2stYXZhdGFyLW1kJyxcbiAgICAnbGFyZ2UnOiAnay1hdmF0YXItbGcnXG59O1xuY29uc3QgU0hBUEVfQ0xBU1NFUyA9IHtcbiAgICAnY2lyY2xlJzogJ2stYXZhdGFyLWNpcmNsZScsXG4gICAgJ3NxdWFyZSc6ICdrLWF2YXRhci1zcXVhcmUnLFxuICAgICdyZWN0YW5nbGUnOiAnay1hdmF0YXItcmVjdGFuZ2xlJyxcbiAgICAncm91bmRlZCc6ICdrLWF2YXRhci1yb3VuZGVkJ1xufTtcbi8qKlxuICogRGlzcGxheXMgaW1hZ2VzLCBpY29ucyBvciBpbml0aWFscyByZXByZXNlbnRpbmcgcGVvcGxlIG9yIG90aGVyIGVudGl0aWVzLlxuICovXG5jbGFzcyBBdmF0YXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhcHBlYXJhbmNlIGZpbGwgc3R5bGUgb2YgdGhlIGF2YXRhci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogYHNvbGlkYCAoRGVmYXVsdClcbiAgICAgICAgICogKiBgb3V0bGluZWBcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsbCA9ICdzb2xpZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgYm9yZGVyIHRvIHRoZSBhdmF0YXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90aGVtZUNvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICB0aGlzLl9zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIHRoaXMuX3NoYXBlID0gJ3NxdWFyZSc7XG4gICAgICAgIHRoaXMuYXZhdGFyID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc29saWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbCA9PT0gJ3NvbGlkJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvdXRsaW5lQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGwgPT09ICdvdXRsaW5lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBib3JkZXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGZsZXhCYXNpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNoYXBlIGZvciB0aGUgYXZhdGFyLlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIChEZWZhdWx0KSBgc3F1YXJlYFxuICAgICAqICogYGNpcmNsZWBcbiAgICAgKiAqIGByZWN0YW5nbGVgXG4gICAgICogKiBgcm91bmRlZGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCBzaGFwZShzaGFwZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuYXZhdGFyLCBTSEFQRV9DTEFTU0VTW3RoaXMuc2hhcGVdKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmF2YXRhciwgU0hBUEVfQ0xBU1NFU1tzaGFwZV0pO1xuICAgICAgICB0aGlzLl9zaGFwZSA9IHNoYXBlO1xuICAgIH1cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBzaXplIG9mIHRoZSBhdmF0YXJcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwcGVhcmFuY2VfYXZhdGFyICV9I3RvYy1zaXplKSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAqIGBzbWFsbGBcbiAgICAgKiAqIGBtZWRpdW1gIChEZWZhdWx0KVxuICAgICAqICogYGxhcmdlYFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuYXZhdGFyLCBTSVpFX0NMQVNTRVNbdGhpcy5zaXplXSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5hdmF0YXIsIFNJWkVfQ0xBU1NFU1tzaXplXSk7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdGhlbWUgY29sb3Igb2YgdGhlIGF2YXRhci5cbiAgICAgKiBUaGUgdGhlbWUgY29sb3Igd2lsbCBiZSBhcHBsaWVkIGFzIGJhY2tncm91bmQgYW5kIGJvcmRlciBjb2xvciwgd2hpbGUgYWxzbyBhbWVuZGluZyB0aGUgdGV4dCBjb2xvciBhY2NvcmRpbmdseS5cbiAgICAgKlxuICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAqICogYHByaW1hcnlgIChEZWZhdWx0KSZtZGFzaDtBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIHByaW1hcnkgdGhlbWUgY29sb3IuXG4gICAgICogKiBgc2Vjb25kYXJ5YCZtZGFzaDtBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIHNlY29uZGFyeSB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGB0ZXJ0aWFyeWAmbWRhc2g7IEFwcGxpZXMgY29sb3JpbmcgYmFzZWQgb24gdGVydGlhcnkgdGhlbWUgY29sb3IuXG4gICAgICogKiBgaW5oZXJpdGAmbWRhc2g7IEFwcGxpZXMgaW5oZXJpdGVkIGNvbG9yaW5nIHZhbHVlLlxuICAgICAqICogYGluZm9gJm1kYXNoO0FwcGxpZXMgY29sb3JpbmcgYmFzZWQgb24gaW5mbyB0aGVtZSBjb2xvci5cbiAgICAgKiAqIGBzdWNjZXNzYCZtZGFzaDsgQXBwbGllcyBjb2xvcmluZyBiYXNlZCBvbiBzdWNjZXNzIHRoZW1lIGNvbG9yLlxuICAgICAqICogYHdhcm5pbmdgJm1kYXNoOyBBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIHdhcm5pbmcgdGhlbWUgY29sb3IuXG4gICAgICogKiBgZXJyb3JgJm1kYXNoOyBBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIGVycm9yIHRoZW1lIGNvbG9yLlxuICAgICAqICogYGRhcmtgJm1kYXNoOyBBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIGRhcmsgdGhlbWUgY29sb3IuXG4gICAgICogKiBgbGlnaHRgJm1kYXNoOyBBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIGxpZ2h0IHRoZW1lIGNvbG9yLlxuICAgICAqICogYGludmVyc2VgJm1kYXNoOyBBcHBsaWVzIGNvbG9yaW5nIGJhc2VkIG9uIGludmVydGVkIHRoZW1lIGNvbG9yLlxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHRoZW1lQ29sb3IodGhlbWVDb2xvcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuYXZhdGFyLCBgay1hdmF0YXItJHt0aGlzLnRoZW1lQ29sb3J9YCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5hdmF0YXIsIGBrLWF2YXRhci0ke3RoZW1lQ29sb3J9YCk7XG4gICAgICAgIHRoaXMuX3RoZW1lQ29sb3IgPSB0aGVtZUNvbG9yO1xuICAgIH1cbiAgICBnZXQgdGhlbWVDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lQ29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYXZhdGFyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGF2YXRhckhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0QXZhdGFyQ2xhc3NlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGltYWdlVXJsKCkge1xuICAgICAgICByZXR1cm4gYHVybCgke3RoaXMuaW1hZ2VTcmN9KWA7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnZlcmlmeVByb3BlcnRpZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGljb25DbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gYGstaWNvbiBrLWktJHt0aGlzLmljb259YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pY29uQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmljb25DbGFzc31gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY3VzdG9tQXZhdGFyKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmltYWdlU3JjIHx8IHRoaXMuaW5pdGlhbHMgfHwgdGhpcy5pY29uIHx8IHRoaXMuaWNvbkNsYXNzKTtcbiAgICB9XG4gICAgdmVyaWZ5UHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFt0aGlzLmljb24gfHwgdGhpcy5pY29uQ2xhc3MsIHRoaXMuaW1hZ2VTcmMsIHRoaXMuaW5pdGlhbHNdO1xuICAgICAgICBjb25zdCBpbnB1dHNMZW5ndGggPSBpbnB1dHMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICAgICAgSW52YWxpZCBwcm9wZXJ0eSBjb25maWd1cmF0aW9uIGdpdmVuLlxuICAgICAgICAgICAgICAgIFRoZSBrZW5kby1hdmF0YXIgY29tcG9uZW50IGNhbiBhY2NlcHQgb25seSBvbmUgb2Y6XG4gICAgICAgICAgICAgICAgaWNvbiwgaW1hZ2VTcmMgb3IgaW5pdGlhbHMgcHJvcGVydGllcy5cbiAgICAgICAgICAgIGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEF2YXRhckNsYXNzZXMoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5hdmF0YXIsIFNIQVBFX0NMQVNTRVNbdGhpcy5zaGFwZV0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuYXZhdGFyLCBgay1hdmF0YXItJHt0aGlzLnRoZW1lQ29sb3J9YCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5hdmF0YXIsIFNJWkVfQ0xBU1NFU1t0aGlzLnNpemVdKTtcbiAgICB9XG59XG5BdmF0YXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWF2YXRhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgKm5nSWY9XCJjdXN0b21BdmF0YXJcIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImltYWdlU3JjXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1hdmF0YXItaW1hZ2VcIiBbbmdTdHlsZV09XCJjc3NTdHlsZVwiIFtzdHlsZS5iYWNrZ3JvdW5kSW1hZ2VdPVwiaW1hZ2VVcmxcIj48L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImluaXRpYWxzXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstYXZhdGFyLXRleHRcIiBbbmdTdHlsZV09XCJjc3NTdHlsZVwiPnt7IGluaXRpYWxzLnN1YnN0cmluZygwLCAyKSB9fTwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImljb24gfHwgaWNvbkNsYXNzXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstYXZhdGFyLWljb25cIiBbbmdTdHlsZV09XCJjc3NTdHlsZVwiIFtuZ0NsYXNzXT1cImljb25DbGFzc2VzKClcIj48L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQXZhdGFyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG5BdmF0YXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWF2YXRhcicsXSB9XSxcbiAgICBzb2xpZENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWF2YXRhci1zb2xpZCcsXSB9XSxcbiAgICBvdXRsaW5lQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstYXZhdGFyLW91dGxpbmUnLF0gfV0sXG4gICAgYm9yZGVyQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstYXZhdGFyLWJvcmRlcmVkJyxdIH1dLFxuICAgIGZsZXhCYXNpczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUuZmxleEJhc2lzJyxdIH1dLFxuICAgIHNoYXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0aGVtZUNvbG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWxsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBib3JkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb25DbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgd2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGF2YXRhcldpZHRoOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS53aWR0aCcsXSB9XSxcbiAgICBoZWlnaHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGF2YXRhckhlaWdodDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUuaGVpZ2h0JyxdIH1dLFxuICAgIGNzc1N0eWxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbml0aWFsczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaWNvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW1hZ2VTcmM6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBDYXJkIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19jYXJkICV9KVxuICovXG5jbGFzcyBDYXJkQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbGF5b3V0IG9mIHRoZSBDYXJkIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgdmVydGljYWxgXG4gICAgICAgICAqICogYGhvcml6b250YWxgXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSBDYXJkLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMjg1cHhgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICcyODVweCc7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydGwgPSBydGw7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCB3aWR0aFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9XG4gICAgZ2V0IHZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgZ2V0IGhvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNhcmRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhcmQnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY2FyZC5jb21wb25lbnQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNhcmRDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5DYXJkQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay13aWRnZXQnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQnLF0gfV0sXG4gICAgd2lkdGhTdHlsZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUud2lkdGgnLF0gfV0sXG4gICAgdmVydGljYWw6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC12ZXJ0aWNhbCcsXSB9XSxcbiAgICBob3Jpem9udGFsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtaG9yaXpvbnRhbCcsXSB9XSxcbiAgICBkaXJlY3Rpb246IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dLFxuICAgIG9yaWVudGF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB3aWR0aDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb250ZW50IGluIHRoZSBDYXJkIGhlYWRlci5cbiAqL1xuY2xhc3MgQ2FyZEhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG59XG5DYXJkSGVhZGVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYXJkLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkNhcmRIZWFkZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtaGVhZGVyJyxdIH1dXG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29udGVudCBpbiB0aGUgQ2FyZCBib2R5LlxuICovXG5jbGFzcyBDYXJkQm9keUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG59XG5DYXJkQm9keUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2FyZC1ib2R5JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuQ2FyZEJvZHlDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtYm9keScsXSB9XVxufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGNvbnRlbnQgaW4gdGhlIENhcmQgZm9vdGVyLlxuICovXG5jbGFzcyBDYXJkRm9vdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn1cbkNhcmRGb290ZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNhcmQtZm9vdGVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuQ2FyZEZvb3RlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC1mb290ZXInLF0gfV1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhY3Rpb24gYnV0dG9ucyBvZiB0aGUgQ2FyZC5cbiAqICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhY3Rpb25zX2NhcmQgJX0pKS5cbiAqL1xuY2xhc3MgQ2FyZEFjdGlvbnNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGxheW91dCBvZiB0aGUgQ2FyZCBhY3Rpb24gYnV0dG9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYGhvcml6b250YWxgXG4gICAgICAgICAqICogYHZlcnRpY2FsYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbGF5b3V0IG9mIHRoZSBDYXJkIGFjdGlvbiBidXR0b25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYHN0YXJ0YFxuICAgICAgICAgKiAqIGBjZW50ZXJgXG4gICAgICAgICAqICogYGVuZGBcbiAgICAgICAgICogKiBgc3RyZXRjaGVkYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSAnc3RhcnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgYW4gYWN0aW9uIGJ1dHRvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aW9uID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgc3RyZXRjaGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gJ3N0cmV0Y2hlZCc7XG4gICAgfVxuICAgIGdldCBzdGFydENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09ICdzdGFydCc7XG4gICAgfVxuICAgIGdldCBlbmRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0ID09PSAnZW5kJztcbiAgICB9XG4gICAgZ2V0IGNlbnRlckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09ICdjZW50ZXInO1xuICAgIH1cbiAgICBnZXQgdmVydGljYWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KGFjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBhY3Rpb25UZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucyBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkNhcmRBY3Rpb25zQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jYXJkLWFjdGlvbnMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50ICpuZ0lmPVwiIWFjdGlvbnNcIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFhY3Rpb25UZW1wbGF0ZSgpXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1idXR0b25cIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLXByaW1hcnldPVwiYWN0aW9uLnByaW1hcnlcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLWZsYXRdPVwiYWN0aW9uLmZsYXRcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJvbkNsaWNrKGFjdGlvbilcIlxuICAgICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBhY3Rpb24gb2YgYWN0aW9uc1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3sgYWN0aW9uLnRleHQgfX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiYWN0aW9uc1wiICpuZ0lmPVwiYWN0aW9uVGVtcGxhdGUoKVwiPjwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuQ2FyZEFjdGlvbnNDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtYWN0aW9ucycsXSB9XSxcbiAgICBzdHJldGNoZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1jYXJkLWFjdGlvbnMtc3RyZXRjaGVkJyxdIH1dLFxuICAgIHN0YXJ0Q2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC1hY3Rpb25zLXN0YXJ0JyxdIH1dLFxuICAgIGVuZENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtYWN0aW9ucy1lbmQnLF0gfV0sXG4gICAgY2VudGVyQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC1hY3Rpb25zLWNlbnRlcicsXSB9XSxcbiAgICB2ZXJ0aWNhbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtYWN0aW9ucy12ZXJ0aWNhbCcsXSB9XSxcbiAgICBob3Jpem9udGFsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC1hY3Rpb25zLWhvcml6b250YWwnLF0gfV0sXG4gICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxheW91dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aW9uOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgc2VwYXJhdG9yIGluIHRoZSBjb250ZW50IG9mIHRoZSBDYXJkLlxuICovXG5jbGFzcyBDYXJkU2VwYXJhdG9yRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgQ2FyZCBzZXBhcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAoRGVmYXVsdCkgYGhvcml6b250YWxgXG4gICAgICAgICAqIGB2ZXJ0aWNhbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgZ2V0IGhvcml6b250YWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICB9XG59XG5DYXJkU2VwYXJhdG9yRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYXJkU2VwYXJhdG9yXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkNhcmRTZXBhcmF0b3JEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNhcmQtc2VwYXJhdG9yJyxdIH1dLFxuICAgIHZlcnRpY2FsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc2VwYXJhdG9yLXZlcnRpY2FsJyxdIH1dLFxuICAgIGhvcml6b250YWxDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zZXBhcmF0b3ItaG9yaXpvbnRhbCcsXSB9XSxcbiAgICBjb2xvcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUuY29sb3InLF0gfSwgeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcmllbnRhdGlvbjogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSB0ZXh0IGFuZCBzdHlsZXMgZm9yIHRoZSB0aXRsZSBvZiB0aGUgQ2FyZC5cbiAqL1xuY2xhc3MgQ2FyZFRpdGxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn1cbkNhcmRUaXRsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FyZFRpdGxlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkNhcmRUaXRsZURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC10aXRsZScsXSB9XVxufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIHRleHQgYW5kIHN0eWxlcyBmb3IgdGhlIHN1YnRpdGxlIG9mIHRoZSBDYXJkLlxuICovXG5jbGFzcyBDYXJkU3VidGl0bGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxufVxuQ2FyZFN1YnRpdGxlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DYXJkU3VidGl0bGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuQ2FyZFN1YnRpdGxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1jYXJkLXN1YnRpdGxlJyxdIH1dXG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbnkgbWVkaWEgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBhbmQgYWxpZ25lZCBpbiB0aGUgQ2FyZC5cbiAqL1xuY2xhc3MgQ2FyZE1lZGlhRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbn1cbkNhcmRNZWRpYURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2FyZE1lZGlhXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkNhcmRNZWRpYURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY2FyZC1tZWRpYScsXSB9XVxufTtcblxuLyoqXG4gKiBUaGUgc2V0dGluZ3Mgb2YgdGhlIENhcmQgYWN0aW9uIGJ1dHRvbnMuXG4gKi9cbmNsYXNzIENhcmRBY3Rpb24ge1xufVxuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMgPSBbXG4gICAgQXZhdGFyQ29tcG9uZW50XG5dO1xuY29uc3QgZGVjbGFyYXRpb25zID0gW1xuICAgIC4uLmV4cG9ydGVkTW9kdWxlc1xuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEF2YXRhciBjb21wb25lbnQuXG4gKi9cbmNsYXNzIEF2YXRhck1vZHVsZSB7XG59XG5BdmF0YXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9uc10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlc10sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuY29uc3QgY2FyZERpcmVjdGl2ZXMgPSBbXG4gICAgQ2FyZFRpdGxlRGlyZWN0aXZlLFxuICAgIENhcmRTdWJ0aXRsZURpcmVjdGl2ZSxcbiAgICBDYXJkU2VwYXJhdG9yRGlyZWN0aXZlLFxuICAgIENhcmRNZWRpYURpcmVjdGl2ZVxuXTtcbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQxID0gW1xuICAgIENhcmRDb21wb25lbnQsXG4gICAgQ2FyZEhlYWRlckNvbXBvbmVudCxcbiAgICBDYXJkQm9keUNvbXBvbmVudCxcbiAgICBDYXJkRm9vdGVyQ29tcG9uZW50LFxuICAgIENhcmRBY3Rpb25zQ29tcG9uZW50LFxuICAgIC4uLmNhcmREaXJlY3RpdmVzXG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDEgPSBbLi4uZXhwb3J0ZWRNb2R1bGVzJDFdO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgQ2FyZCBjb21wb25lbnQuXG4gKi9cbmNsYXNzIENhcmRNb2R1bGUge1xufVxuQ2FyZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDFdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkMV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IERSQVdFUl9MSU5LX1NFTEVDVE9SID0gJy5rLWRyYXdlci1saW5rJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBBQ1RJVkVfTkVTVEVEX0xJTktfU0VMRUNUT1IgPSAnOmZvY3VzOm5vdCguay1zdGF0ZS1kaXNhYmxlZCkgLmstZHJhd2VyLWxpbmsnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5lc3RlZExpbmsgPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEcmF3ZXJJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkcmF3ZXIsIGVsZW1lbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZHJhd2VyID0gZHJhd2VyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLnNlbGVjdGVkSW5kaWNlcy5pbmRleE9mKHRoaXMuaW5kZXgpID49IDA7XG4gICAgfVxuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS50ZXh0ID8gdGhpcy5pdGVtLnRleHQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBsaW5rID0gbmVzdGVkTGluayh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgRFJBV0VSX0xJTktfU0VMRUNUT1IpO1xuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUobGluaywgJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGljb25DbGFzc2VzKGljb24pIHtcbiAgICAgICAgcmV0dXJuIGBrLWljb24gJHtpY29ufWA7XG4gICAgfVxufVxuRHJhd2VySXRlbUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhd2VySXRlbV0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIml0ZW1UZW1wbGF0ZTsgZWxzZSBkZWZhdWx0VGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiaXRlbVRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ICRpbXBsaWNpdDogaXRlbSB9XCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0VGVtcGxhdGU+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZXhwYW5kZWRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBbbmdDbGFzc109XCJpY29uQ2xhc3NlcyhpdGVtLmljb24pXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pdGVtLXRleHRcIj57eyBpdGVtLnRleHQgfX08L3NwYW4+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJtaW5pICYmICFleHBhbmRlZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cImljb25DbGFzc2VzKGl0ZW0uaWNvbilcIj48L3NwYW4+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRyYXdlckl0ZW1Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBEcmF3ZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfVxuXTtcbkRyYXdlckl0ZW1Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaXRlbTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1UZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluaTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXhwYW5kZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjc3NDbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3NzU3R5bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1kaXNhYmxlZCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RhdGUtZGlzYWJsZWQnLF0gfV0sXG4gICAgc2VsZWN0ZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXNlbGVjdGVkJyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1zZWxlY3RlZCcsXSB9XSxcbiAgICBsYWJlbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWxhYmVsJyxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgRFJBV0VSX0lURU1fSU5ERVggPSAnZGF0YS1rZW5kby1kcmF3ZXItaW5kZXgnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRHJhd2VyTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZHJhd2VyU2VydmljZSwgcmVuZGVyZXIsIG5nWm9uZSwgY2hhbmdlRGV0ZWN0b3IsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kcmF3ZXJTZXJ2aWNlID0gZHJhd2VyU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmluaXRpYWxTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5pbml0RG9tRXZlbnRzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaW5pdGlhbFNlbGVjdGlvbigpIHtcbiAgICAgICAgLyogRGlmZmVyZW50aWF0ZXMgYSB1c2VyIHNlbGVjdGVkIGl0ZW0gKi9cbiAgICAgICAgaWYgKHRoaXMuZHJhd2VyU2VydmljZS5zZWxlY3RlZEluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdlclNlcnZpY2UuaW5pdFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3RlbihuYXRpdmVFbGVtZW50LCAnY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKG5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJywgdGhpcy5rZXlEb3duSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgICBjb25zdCBpdGVtSWR4ID0gdGhpcy5nZXREcmF3ZXJJdGVtSW5kZXgoZS50YXJnZXQpO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc1tpdGVtSWR4XTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgaW5kZXg6IGl0ZW1JZHgsXG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRyYXdlclNlcnZpY2UuZW1pdCgnc2VsZWN0JywgYXJncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdlclNlcnZpY2Uub25TZWxlY3QoaXRlbUlkeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlEb3duSGFuZGxlcihlKSB7XG4gICAgICAgIGNvbnN0IGlzRW50ZXJPclNwYWNlID0gZS5rZXlDb2RlID09PSBLZXlzLkVudGVyIHx8IGUua2V5Q29kZSA9PT0gS2V5cy5TcGFjZTtcbiAgICAgICAgaWYgKCFpc0VudGVyT3JTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpY2tIYW5kbGVyKGUpO1xuICAgICAgICBjb25zdCBsaW5rID0gbmVzdGVkTGluayh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgQUNUSVZFX05FU1RFRF9MSU5LX1NFTEVDVE9SKTtcbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsuY2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldERyYXdlckl0ZW1JbmRleCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNsb3Nlc3RJdGVtKHRhcmdldCwgRFJBV0VSX0lURU1fSU5ERVgsIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtSW5kZXgoaXRlbSwgRFJBV0VSX0lURU1fSU5ERVgpO1xuICAgICAgICB9XG4gICAgfVxufVxuRHJhd2VyTGlzdENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhd2VyTGlzdF0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXM7IGxldCBpZHggPSBpbmRleFwiPlxuICAgICAgICAgICAgPGxpICpuZ0lmPVwiIWl0ZW0uc2VwYXJhdG9yXCIga2VuZG9EcmF3ZXJJdGVtXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWRyYXdlci1pdGVtXCJcbiAgICAgICAgICAgICAgICBbaXRlbV09XCJpdGVtXCJcbiAgICAgICAgICAgICAgICBbaW5kZXhdPVwiaWR4XCJcbiAgICAgICAgICAgICAgICBbbWluaV09XCJtaW5pXCJcbiAgICAgICAgICAgICAgICBbZXhwYW5kZWRdPVwiZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgIFtpdGVtVGVtcGxhdGVdPVwiaXRlbVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICBbYXR0ci4ke0RSQVdFUl9JVEVNX0lOREVYfV09XCJpZHhcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIml0ZW0uY3NzQ2xhc3NcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cIml0ZW0uY3NzU3R5bGVcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiPlxuICAgICAgICAgICAgPC9saT5cblxuICAgICAgICAgICAgPGxpICpuZ0lmPVwiaXRlbS5zZXBhcmF0b3JcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kcmF3ZXItaXRlbSBrLWRyYXdlci1zZXBhcmF0b3JcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIml0ZW0uY3NzQ2xhc3NcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cIml0ZW0uY3NzU3R5bGVcIj5cbiAgICAgICAgICAgICAgICAmbmJzcDtcbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHJhd2VyTGlzdENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERyYXdlclNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuRHJhd2VyTGlzdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBpdGVtczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXRlbVRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW5pOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbmNvbnN0IHRlbXBsYXRlRGlyZWN0aXZlcyA9IFtcbiAgICBEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcmF3ZXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmVcbl07XG5jb25zdCBleHBvcnRlZE1vZHVsZXMkMiA9IFtcbiAgICBEcmF3ZXJDb21wb25lbnQsXG4gICAgRHJhd2VyQ29udGFpbmVyQ29tcG9uZW50LFxuICAgIERyYXdlckNvbnRlbnRDb21wb25lbnQsXG4gICAgLi4udGVtcGxhdGVEaXJlY3RpdmVzXG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDIgPSBbXG4gICAgRHJhd2VySXRlbUNvbXBvbmVudCxcbiAgICBEcmF3ZXJMaXN0Q29tcG9uZW50LFxuICAgIC4uLmV4cG9ydGVkTW9kdWxlcyQyXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRHJhd2VyIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgRHJhd2VyTW9kdWxlIHtcbn1cbkRyYXdlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDJdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkMl0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuY29uc3QgZXhwb3J0ZWRNb2R1bGVzJDMgPSBbXG4gICAgUGFuZWxCYXJDb21wb25lbnQsXG4gICAgUGFuZWxCYXJJdGVtQ29tcG9uZW50LFxuICAgIFBhbmVsQmFyQ29udGVudERpcmVjdGl2ZSxcbiAgICBQYW5lbEJhckl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBQYW5lbEJhckl0ZW1UaXRsZURpcmVjdGl2ZVxuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyQzID0gW1xuICAgIC4uLmV4cG9ydGVkTW9kdWxlcyQzXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUGFuZWxCYXIgY29tcG9uZW50LlxuICpcbiAqIFRoZSBtb2R1bGUgcmVnaXN0ZXJzOlxuICogLSBgUGFuZWxCYXJDb21wb25lbnRgJm1kYXNoO1RoZSBgUGFuZWxCYXJgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFBhbmVsQmFySXRlbUNvbXBvbmVudGAmbWRhc2g7VGhlIGBQYW5lbEJhckl0ZW1gIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFBhbmVsQmFyQ29udGVudENvbXBvbmVudGAmbWRhc2g7VGhlIGBQYW5lbEJhckNvbnRlbnRgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFBhbmVsQmFySXRlbVRlbXBsYXRlRGlyZWN0aXZlJm1kYXNoO1RoZSBgUGFuZWxCYXJJdGVtVGVtcGxhdGVgIGRpcmVjdGl2ZS5cbiAqIC0gYFBhbmVsQmFySXRlbVRpdGxlRGlyZWN0aXZlJm1kYXNoO1RoZSBgUGFuZWxCYXJJdGVtVGl0bGVgIGRpcmVjdGl2ZS5cbiAqL1xuY2xhc3MgUGFuZWxCYXJNb2R1bGUge1xufVxuUGFuZWxCYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyQzXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDNdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmNvbnN0IHN0b3BQcm9wYWdhdGlvbiA9ICh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50IH0pID0+IHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcbmNvbnN0IHByZXZlbnRPbkRibENsaWNrID0gcmVsZWFzZSA9PiBtb3VzZURvd24gPT4gb2YobW91c2VEb3duKS5waXBlKGRlbGF5KDE1MCksIHRha2VVbnRpbChyZWxlYXNlKSk7XG5jb25zdCBjbGFzc0Zyb21PYmplY3QgPSBjbGFzc2VzID0+IE9iamVjdC5rZXlzKGNsYXNzZXMpLmZpbHRlcihjID0+IGNsYXNzZXNbY10pLmpvaW4oJyAnKTtcbmNvbnN0IGNyZWF0ZU1vdmVTdHJlYW0gPSAoZHJhZ2dhYmxlKSA9PiBtb3VzZURvd24gPT4gZHJhZ2dhYmxlLmtlbmRvRHJhZ1xuICAgIC5waXBlKHRha2VVbnRpbChkcmFnZ2FibGUua2VuZG9SZWxlYXNlKSwgbWFwKCh7IHBhZ2VYLCBwYWdlWSB9KSA9PiAoe1xuICAgIG9yaWdpbmFsWDogbW91c2VEb3duLnBhZ2VYLFxuICAgIG9yaWdpbmFsWTogbW91c2VEb3duLnBhZ2VZLFxuICAgIHBhZ2VYLFxuICAgIHBhZ2VZXG59KSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNwbGl0dGVyQmFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUsIHNwbGl0dGVyLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHRoaXMuc3BsaXR0ZXIgPSBzcGxpdHRlcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmFyaWFSb2xlID0gJ3NlcGFyYXRvcic7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0dGVyLmlzU3RhdGljKHRoaXMuaW5kZXgpID8gLTEgOiAwO1xuICAgIH1cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSB0aGlzLnNwbGl0dGVyLmlzRHJhZ2dhYmxlKHRoaXMuaW5kZXgpO1xuICAgICAgICBjb25zdCBpc1N0YXRpYyA9IHRoaXMuc3BsaXR0ZXIuaXNTdGF0aWModGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiBjbGFzc0Zyb21PYmplY3Qoe1xuICAgICAgICAgICAgJ2stc3RhdGUtZm9jdXNlZCc6IHRoaXMuZm9jdXNlZCxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyJzogdHJ1ZSxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyLWhvcml6b250YWwnOiBpc0hvcml6b250YWwsXG4gICAgICAgICAgICAnay1zcGxpdGJhci12ZXJ0aWNhbCc6ICFpc0hvcml6b250YWwsXG4gICAgICAgICAgICAnay1zcGxpdGJhci1kcmFnZ2FibGUtaG9yaXpvbnRhbCc6IGlzSG9yaXpvbnRhbCAmJiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyLWRyYWdnYWJsZS12ZXJ0aWNhbCc6ICFpc0hvcml6b250YWwgJiYgaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICAnay1zcGxpdGJhci1zdGF0aWMtaG9yaXpvbnRhbCc6IGlzSG9yaXpvbnRhbCAmJiBpc1N0YXRpYyxcbiAgICAgICAgICAgICdrLXNwbGl0YmFyLXN0YXRpYy12ZXJ0aWNhbCc6ICFpc0hvcml6b250YWwgJiYgaXNTdGF0aWNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCB0b3VjaEFjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BsaXR0ZXIuaXNEcmFnZ2FibGUodGhpcy5pbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9yZGVyKCkge1xuICAgICAgICByZXR1cm4gMiAqIHRoaXMuaW5kZXggKyAxO1xuICAgIH1cbiAgICBjb2xsYXBzZUFueSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kTGFzdCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVOZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyeVRvZ2dsZU5lYXJlc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkZvY3VzSW4oKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIG9uRm9jdXNPdXQoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50ICYmIGV2ZW50LmtleUNvZGU7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgY29uc3QgcmVzaXplID0gZGVsdGEgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlJCQxID0gdGhpcy5zcGxpdHRlci5kcmFnU3RhdGUodGhpcy5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyLnNldFNpemUoc3RhdGUkJDEsIGRlbHRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlQW55KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNIb3Jpem9udGFsICYmIGtleUNvZGUgPT09IEtleXMuQXJyb3dMZWZ0KSB7XG4gICAgICAgICAgICByZXNpemUoLTEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0hvcml6b250YWwgJiYga2V5Q29kZSA9PT0gS2V5cy5BcnJvd1JpZ2h0KSB7XG4gICAgICAgICAgICByZXNpemUoMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0hvcml6b250YWwgJiYga2V5Q29kZSA9PT0gS2V5cy5BcnJvd1VwKSB7XG4gICAgICAgICAgICByZXNpemUoLTEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNIb3Jpem9udGFsICYmIGtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duKSB7XG4gICAgICAgICAgICByZXNpemUoMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBleHBhbmRMYXN0KCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMuc3BsaXR0ZXIucGFuZXM7XG4gICAgICAgIHJldHVybiBwYW5lcy5sZW5ndGggPT09IDIgJiYgcGFuZXNbMV0uY29sbGFwc2VkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgbGV0IHN0YXRlJCQxO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuZHJhZ2dhYmxlLmtlbmRvUHJlc3MucGlwZSh0YXAoc3RvcFByb3BhZ2F0aW9uKSwgZmlsdGVyKCgpID0+IHRoaXMuc3BsaXR0ZXIuaXNEcmFnZ2FibGUodGhpcy5pbmRleCkpLCB0YXAoKCkgPT4gc3RhdGUkJDEgPSB0aGlzLnNwbGl0dGVyLmRyYWdTdGF0ZSh0aGlzLmluZGV4KSksIHRhcCgoKSA9PiB0aGlzLnNwbGl0dGVyLnRvZ2dsZUNvbnRlbnRPdmVybGF5KHRoaXMuaW5kZXgsIHRydWUpKSwgc3dpdGNoTWFwKHByZXZlbnRPbkRibENsaWNrKHRoaXMuZHJhZ2dhYmxlLmtlbmRvUmVsZWFzZSkpLCBzd2l0Y2hNYXAoY3JlYXRlTW92ZVN0cmVhbSh0aGlzLmRyYWdnYWJsZSkpKS5zdWJzY3JpYmUoKHsgcGFnZVgsIHBhZ2VZLCBvcmlnaW5hbFgsIG9yaWdpbmFsWSB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGVsdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcGFnZVkgLSBvcmlnaW5hbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IG9yaWdpbmFsWCAtIHBhZ2VYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBwYWdlWCAtIG9yaWdpbmFsWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXIuc2V0U2l6ZShzdGF0ZSQkMSwgZGVsdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5kcmFnZ2FibGUua2VuZG9SZWxlYXNlLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNwbGl0dGVyLnRvZ2dsZUNvbnRlbnRPdmVybGF5KHRoaXMuaW5kZXgsIGZhbHNlKSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlUHJldmlvdXMoKSB7XG4gICAgICAgIHRoaXMuc3BsaXR0ZXIudHJ5VG9nZ2xlKHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICB0b2dnbGVOZXh0KCkge1xuICAgICAgICB0aGlzLnNwbGl0dGVyLnRyeVRvZ2dsZSh0aGlzLmluZGV4ICsgMSk7XG4gICAgfVxuICAgIHByZXZpb3VzQXJyb3dDbGFzcygpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuc3BsaXR0ZXIucGFuZSh0aGlzLmluZGV4KTtcbiAgICAgICAgY29uc3QgbmV4dFBhbmUgPSB0aGlzLnNwbGl0dGVyLnBhbmUodGhpcy5pbmRleCArIDEpO1xuICAgICAgICBjb25zdCBpc0NvbGxhcHNpYmxlID0gcGFuZS5jb2xsYXBzaWJsZTtcbiAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBwYW5lLmNvbGxhcHNlZDtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICByZXR1cm4gY2xhc3NGcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICdrLWljb24nOiB0cnVlLFxuICAgICAgICAgICAgJ2staGlkZGVuJzogIWlzQ29sbGFwc2libGUgfHwgbmV4dFBhbmUuaXNIaWRkZW4sXG4gICAgICAgICAgICAnay1jb2xsYXBzZS1wcmV2JzogaXNDb2xsYXBzaWJsZSxcbiAgICAgICAgICAgICdrLWktYXJyb3ctNjAtbGVmdCc6IGlzQ29sbGFwc2libGUgJiYgaXNIb3Jpem9udGFsICYmICFpc0NvbGxhcHNlZCxcbiAgICAgICAgICAgICdrLWktYXJyb3ctNjAtcmlnaHQnOiBpc0NvbGxhcHNpYmxlICYmIGlzSG9yaXpvbnRhbCAmJiBpc0NvbGxhcHNlZCxcbiAgICAgICAgICAgICdrLWktYXJyb3ctNjAtdXAnOiBpc0NvbGxhcHNpYmxlICYmICFpc0hvcml6b250YWwgJiYgIWlzQ29sbGFwc2VkLFxuICAgICAgICAgICAgJ2staS1hcnJvdy02MC1kb3duJzogaXNDb2xsYXBzaWJsZSAmJiAhaXNIb3Jpem9udGFsICYmIGlzQ29sbGFwc2VkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0QXJyb3dDbGFzcygpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuc3BsaXR0ZXIucGFuZSh0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IHByZXZQYW5lID0gdGhpcy5zcGxpdHRlci5wYW5lKHRoaXMuaW5kZXgpO1xuICAgICAgICBjb25zdCBpc0NvbGxhcHNpYmxlID0gcGFuZS5jb2xsYXBzaWJsZTtcbiAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBwYW5lLmNvbGxhcHNlZDtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICByZXR1cm4gY2xhc3NGcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICdrLWljb24nOiB0cnVlLFxuICAgICAgICAgICAgJ2staGlkZGVuJzogIWlzQ29sbGFwc2libGUgfHwgcHJldlBhbmUuaXNIaWRkZW4sXG4gICAgICAgICAgICAnay1jb2xsYXBzZS1uZXh0JzogaXNDb2xsYXBzaWJsZSxcbiAgICAgICAgICAgICdrLWktYXJyb3ctNjAtcmlnaHQnOiBpc0NvbGxhcHNpYmxlICYmIGlzSG9yaXpvbnRhbCAmJiAhaXNDb2xsYXBzZWQsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLWxlZnQnOiBpc0NvbGxhcHNpYmxlICYmIGlzSG9yaXpvbnRhbCAmJiBpc0NvbGxhcHNlZCxcbiAgICAgICAgICAgICdrLWktYXJyb3ctNjAtZG93bic6IGlzQ29sbGFwc2libGUgJiYgIWlzSG9yaXpvbnRhbCAmJiAhaXNDb2xsYXBzZWQsXG4gICAgICAgICAgICAnay1pLWFycm93LTYwLXVwJzogaXNDb2xsYXBzaWJsZSAmJiAhaXNIb3Jpem9udGFsICYmIGlzQ29sbGFwc2VkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cnlUb2dnbGVOZWFyZXN0KCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pbmRleDtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgICBpZiAoIXRoaXMuc3BsaXR0ZXIudHJ5VG9nZ2xlKHByZXYpKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyLnRyeVRvZ2dsZShuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblNwbGl0dGVyQmFyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zcGxpdHRlci1iYXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICA8ZGl2IFtjbGFzc109XCJwcmV2aW91c0Fycm93Q2xhc3MoKVwiIChjbGljayk9XCJ0b2dnbGVQcmV2aW91cygpXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiay1yZXNpemUtaGFuZGxlXCI+PC9kaXY+XG4gICAgICA8ZGl2IFtjbGFzc109XCJuZXh0QXJyb3dDbGFzcygpXCIgKGNsaWNrKT1cInRvZ2dsZU5leHQoKVwiPjwvZGl2PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU3BsaXR0ZXJCYXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBEcmFnZ2FibGVEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEhvc3QgfV0gfSxcbiAgICB7IHR5cGU6IFNwbGl0dGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuU3BsaXR0ZXJCYXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLW9yaWVudGF0aW9uJyxdIH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhcmlhUm9sZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5yb2xlJyxdIH1dLFxuICAgIGZvY3VzZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RhdGUtZm9jdXNlZCcsXSB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci50YWJpbmRleCcsXSB9XSxcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MnLF0gfV0sXG4gICAgdG91Y2hBY3Rpb246IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLnRvdWNoLWFjdGlvbicsXSB9XSxcbiAgICBvcmRlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUuLW1zLWZsZXgtb3JkZXInLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5vcmRlcicsXSB9XSxcbiAgICBjb2xsYXBzZUFueTogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2RibGNsaWNrJyxdIH1dLFxuICAgIG9uRm9jdXNJbjogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2ZvY3VzaW4nLF0gfV0sXG4gICAgb25Gb2N1c091dDogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2ZvY3Vzb3V0JyxdIH1dLFxuICAgIG9uS2V5RG93bjogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2tleWRvd24nLCBbJyRldmVudCddLF0gfV1cbn07XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQ0ID0gW1xuICAgIFNwbGl0dGVyQ29tcG9uZW50LFxuICAgIFNwbGl0dGVyUGFuZUNvbXBvbmVudFxuXTtcbmNvbnN0IGRlY2xhcmF0aW9ucyQ0ID0gW1xuICAgIFNwbGl0dGVyQmFyQ29tcG9uZW50LFxuICAgIC4uLmV4cG9ydGVkTW9kdWxlcyQ0XG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgU3BsaXR0ZXIgY29tcG9uZW50LlxuICpcbiAqIFRoZSBtb2R1bGUgcmVnaXN0ZXJzOlxuICogLSBgU3BsaXR0ZXJDb21wb25lbnRgJm1kYXNoO1RoZSBgU3BsaXR0ZXJgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFNwbGl0dGVyUGFuZUNvbXBvbmVudGAmbWRhc2g7VGhlIGBTcGxpdHRlclBhbmVgIGNvbXBvbmVudCBjbGFzcy5cbiAqL1xuY2xhc3MgU3BsaXR0ZXJNb2R1bGUge1xufVxuU3BsaXR0ZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyQ0XSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDRdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBEcmFnZ2FibGVNb2R1bGVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTdGVwcGVyU3RlcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmlzU3RlcFZhbGlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNob3VsZENoZWNrVmFsaWRpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3VicyA9IHRoaXMuc2VydmljZS5mb2N1c2VkU3RlcENoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkZvY3VzZWRTdGVwQ2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKHRoaXMuc2VydmljZS50cmlnZ2VyVmFsaWRhdGlvbi5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWxpZGl0eUNoZWNrcygpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldCBlcnJvclN0ZXBDbGFzcygpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmlzU3RlcFZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzU3RlcFZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3NTdGVwQ2xhc3MoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pc1N0ZXBWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3RlcFZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsaWRpdHlDaGVja3MoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5jdXJyZW50ICYmICFjaGFuZ2VzLmN1cnJlbnQuZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsaWRpdHlDaGVja3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicykge1xuICAgICAgICAgICAgdGhpcy5zdWJzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Gb2N1c2VkU3RlcENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMuc2VydmljZS5mb2N1c2VkU3RlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcExpbmsubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25Gb2N1cygpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmZvY3VzKHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXhBdHRyKCkge1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLnNlcnZpY2UuZm9jdXNlZFN0ZXAgfHwgdGhpcy5zZXJ2aWNlLmN1cnJlbnRTdGVwO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PT0gYWN0aXZlID8gMCA6IC0xO1xuICAgIH1cbiAgICBnZXQgaW5kaWNhdG9ySWNvbkNsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXAuaWNvbikge1xuICAgICAgICAgICAgcmV0dXJuIGBrLWljb24gay1pLSR7dGhpcy5zdGVwLmljb259YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGVwLmljb25DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuc3RlcC5pY29uQ2xhc3N9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uSWNvbkNsYXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNob3dJbmRpY2F0b3JJY29uKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGVwLmljb24gfHwgdGhpcy5zdGVwLmljb25DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc2hvd0xhYmVsSWNvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tWYWxpZGl0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcC5pY29uIHx8IHRoaXMuc3RlcC5pY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzaG93TGFiZWxUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnbGFiZWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Z1bGwnO1xuICAgIH1cbiAgICBnZXQgdmFsaWRhdGlvbkljb25DbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0ZXBWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc0ljb24gPyBgJHt0aGlzLnN1Y2Nlc3NJY29ufWAgOiAnay1pY29uIGstaS1jaGVjayc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckljb24gPyBgJHt0aGlzLmVycm9ySWNvbn1gIDogJ2staWNvbiBrLWktd2FybmluZyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGluZGljYXRvclRleHQoKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnN0ZXAudGV4dDtcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0IDogdGhpcy5pbmRleCArIDE7XG4gICAgfVxuICAgIHVwZGF0ZVN0ZXBWYWxpZGl0eSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0ZXAuaXNWYWxpZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwLmlzVmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0ZXAuaXNWYWxpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcC5pc1ZhbGlkKHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBzaG93SW5kaWNhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnaW5kaWNhdG9yJyB8fCB0aGlzLnR5cGUgPT09ICdmdWxsJztcbiAgICB9XG4gICAgZ2V0IHNob3dMYWJlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xhYmVsJyB8fCB0aGlzLnR5cGUgPT09ICdmdWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcC5vcHRpb25hbDtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbmFsVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldCgnb3B0aW9uYWwnKTtcbiAgICB9XG4gICAgZ2V0IHRyYW5zaXRpb25EdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5vd25lci5hbmltYXRpb25EdXJhdGlvbjtcbiAgICB9XG4gICAgX3Nob3VsZENoZWNrVmFsaWRpdHkoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGVwLnZhbGlkYXRlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0ZXAudmFsaWRhdGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXAudmFsaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RlcC52YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXAudmFsaWRhdGUodGhpcy5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnN0ZXAuaXNWYWxpZCkgJiYgdGhpcy5pbmRleCA8IHRoaXMuY3VycmVudDtcbiAgICB9XG4gICAgaGFuZGxlVmFsaWRpdHlDaGVja3MoKSB7XG4gICAgICAgIHRoaXMuaXNTdGVwVmFsaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHRoaXMuX3Nob3VsZENoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tWYWxpZGl0eSkge1xuICAgICAgICAgICAgdGhpcy5pc1N0ZXBWYWxpZCA9IHRoaXMudXBkYXRlU3RlcFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5TdGVwcGVyU3RlcENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU3RlcHBlclN0ZXBdJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YSBocmVmPScjJyBjbGFzcz0nay1zdGVwLWxpbmsnICNzdGVwTGlua1xuICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPSd0YWJJbmRleEF0dHInXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09J3N0ZXAubGFiZWwnXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT0nc3RlcC5kaXNhYmxlZCdcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY3VycmVudF09J2luZGV4ID09PSBjdXJyZW50ID8gXCJzdGVwXCIgOiBudWxsJ1xuICAgICAgICAgICAgKGZvY3VzKT0nb25Gb2N1cygpJ1xuICAgICAgICA+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9J3N0ZXBUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09J3N0ZXBUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPSd7ICRpbXBsaWNpdDogc3RlcCwgaW5kZXg6IGluZGV4IH0nPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nIXN0ZXBUZW1wbGF0ZSc+XG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9J3Nob3dJbmRpY2F0b3InXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPSdrLXN0ZXAtaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj0ndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb24tZHVyYXRpb24ubXNdPSd0cmFuc2l0aW9uRHVyYXRpb24nXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9J2luZGljYXRvclRlbXBsYXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPSdpbmRpY2F0b3JUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09J3sgJGltcGxpY2l0OiBzdGVwLCBpbmRleDogaW5kZXggfSc+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nIWluZGljYXRvclRlbXBsYXRlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPSdzaG93SW5kaWNhdG9ySWNvbicgY2xhc3M9J2stc3RlcC1pbmRpY2F0b3ItaWNvbicgW25nQ2xhc3NdPSdpbmRpY2F0b3JJY29uQ2xhc3Nlcyc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2stc3RlcC1pbmRpY2F0b3ItdGV4dCcgKm5nSWY9JyFzaG93SW5kaWNhdG9ySWNvbic+e3sgaW5kaWNhdG9yVGV4dCB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2stc3RlcC1sYWJlbCcgKm5nSWY9J3Nob3dMYWJlbCc+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj0nbGFiZWxUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT0nbGFiZWxUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09J3sgJGltcGxpY2l0OiBzdGVwLCBpbmRleDogaW5kZXggfSc+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nIWxhYmVsVGVtcGxhdGUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2stc3RlcC10ZXh0JyAqbmdJZj0nc2hvd0xhYmVsVGV4dCc+e3sgc3RlcC5sYWJlbCB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT0ndmFsaWRhdGlvbkljb25DbGFzc2VzJyAqbmdJZj0nc2hvd0xhYmVsSWNvbicgYXJpYS1oaWRkZW49J3RydWUnPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdrLXN0ZXAtbGFiZWwtb3B0aW9uYWwnICpuZ0lmPSdzdGVwLm9wdGlvbmFsJz4oe3tvcHRpb25hbFRleHR9fSk8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2E+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TdGVwcGVyU3RlcENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFN0ZXBwZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblN0ZXBwZXJTdGVwQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHN0ZXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjdXJyZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0eXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdWNjZXNzSWNvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXJyb3JJY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbmRpY2F0b3JUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGFiZWxUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RlcFRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGVwTGluazogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3N0ZXBMaW5rJywgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIGVycm9yU3RlcENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0ZXAtZXJyb3InLF0gfV0sXG4gICAgc3VjY2Vzc1N0ZXBDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGVwLXN1Y2Nlc3MnLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTVEVQUEVSX1NURVBfSU5ERVggPSAnZGF0YS1rZW5kby1zdGVwcGVyLWluZGV4JztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFN0ZXBwZXJMaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgbmdab25lLCBzZXJ2aWNlLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmluaXREb21FdmVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbVN1YnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3VicygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtYXhTdGVwV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heFN0ZXBEaW1lbnNpb24oJ3dpZHRoJyk7XG4gICAgfVxuICAgIGdldCBtYXhTdGVwSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhTdGVwRGltZW5zaW9uKCdoZWlnaHQnKTtcbiAgICB9XG4gICAgbWF4U3RlcERpbWVuc2lvbihkaW1lbnNpb24pIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ3dpZHRoJyAmJiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0JyAmJiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxMDAgLyB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICB9XG4gICAgaW5pdERvbUV2ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGlja1N1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKG5hdGl2ZUVsZW1lbnQsICdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY29uc3Qga2V5ZG93blN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKG5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MoZS50YXJnZXQsICdrLXN0ZXAtbGluaycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZS5rZXlkb3duKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kb21TdWJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAga2V5ZG93blN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3Qgc3RlcElkeCA9IHRoaXMuZ2V0U3RlcEluZGV4KGUudGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuc3RlcHNbc3RlcElkeF07XG4gICAgICAgIGlmICghc3RlcCB8fCBzdGVwLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXBJZHggPT09IHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5mb2N1cyhzdGVwSWR4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lYXIgJiYgdGhpcy5zZXJ2aWNlLmlzUHJldk9yTmV4dFN0ZXAoc3RlcElkeCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9uQWN0aXZhdGUoc3RlcElkeCwgZSk7XG4gICAgfVxuICAgIGdldFN0ZXBJbmRleCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IGNsb3Nlc3RJdGVtKHRhcmdldCwgU1RFUFBFUl9TVEVQX0lOREVYLCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUluZGV4KHN0ZXAsIFNURVBQRVJfU1RFUF9JTkRFWCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5TdGVwcGVyTGlzdENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU3RlcHBlckxpc3RdJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj0nbGV0IHN0ZXAgb2Ygc3RlcHM7IGxldCBpZHggPSBpbmRleCc+XG4gICAgICAgICAgICA8bGkga2VuZG9TdGVwcGVyU3RlcFxuICAgICAgICAgICAgICAgIFthdHRyLiR7U1RFUFBFUl9TVEVQX0lOREVYfV09J2lkeCdcbiAgICAgICAgICAgICAgICBbdHlwZV09J3N0ZXBUeXBlJ1xuICAgICAgICAgICAgICAgIFtzdGVwXT0nc3RlcCdcbiAgICAgICAgICAgICAgICBbaW5kZXhdPSdpZHgnXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRdPSdjdXJyZW50U3RlcCdcbiAgICAgICAgICAgICAgICBbc3VjY2Vzc0ljb25dPSdzdWNjZXNzSWNvbidcbiAgICAgICAgICAgICAgICBbZXJyb3JJY29uXT0nZXJyb3JJY29uJ1xuICAgICAgICAgICAgICAgIFtpbmRpY2F0b3JUZW1wbGF0ZV09J2luZGljYXRvclRlbXBsYXRlJ1xuICAgICAgICAgICAgICAgIFtsYWJlbFRlbXBsYXRlXT0nbGFiZWxUZW1wbGF0ZSdcbiAgICAgICAgICAgICAgICBbc3RlcFRlbXBsYXRlXT0nc3RlcFRlbXBsYXRlJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdrLXN0ZXAnXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1maXJzdF09J2lkeCA9PT0gMCdcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGVwLWxhc3RdPSdpZHggPT09IHN0ZXBzLmxlbmd0aCAtIDEnXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1kb25lXT0naWR4IDwgY3VycmVudFN0ZXAnXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RlcC1jdXJyZW50XT0naWR4ID09PSBjdXJyZW50U3RlcCdcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGVwLW9wdGlvbmFsXT0nc3RlcC5vcHRpb25hbCdcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGVwLWRpc2FibGVkXT0nc3RlcC5kaXNhYmxlZCdcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109J3N0ZXAuY3NzQ2xhc3MnXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPSdzdGVwLmNzc1N0eWxlJ1xuICAgICAgICAgICAgICAgIFtzdHlsZS5tYXgtd2lkdGguJV0gPSAnbWF4U3RlcFdpZHRoJ1xuICAgICAgICAgICAgICAgIFtzdHlsZS5tYXgtaGVpZ2h0LiVdID0gJ21heFN0ZXBIZWlnaHQnXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblN0ZXBwZXJMaXN0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFN0ZXBwZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG5TdGVwcGVyTGlzdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBsaW5lYXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0ZXBUeXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcmllbnRhdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3VycmVudFN0ZXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0ZXBzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdWNjZXNzSWNvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXJyb3JJY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbmRpY2F0b3JUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGFiZWxUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RlcFRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuTWVzc2FnZXMucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb3B0aW9uYWw6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn1cbkxvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkTWVzc2FnZXNEaXJlY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBgXG4gICAgICBba2VuZG9TdGVwcGVyTG9jYWxpemVkTWVzc2FnZXNdXG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Mb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJ0bF9sYXlvdXQgJX0pKS5cbiAqL1xuY2xhc3MgQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbkN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3RlcHBlci1tZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG5jb25zdCB0ZW1wbGF0ZURpcmVjdGl2ZXMkMSA9IFtcbiAgICBTdGVwcGVyU3RlcFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIFN0ZXBwZXJMYWJlbFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIFN0ZXBwZXJJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQ1ID0gW1xuICAgIFN0ZXBwZXJDb21wb25lbnQsXG4gICAgQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgLi4udGVtcGxhdGVEaXJlY3RpdmVzJDFcbl07XG5jb25zdCBkZWNsYXJhdGlvbnMkNSA9IFtcbiAgICBTdGVwcGVyU3RlcENvbXBvbmVudCxcbiAgICBTdGVwcGVyTGlzdENvbXBvbmVudCxcbiAgICBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICAuLi5leHBvcnRlZE1vZHVsZXMkNVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFN0ZXBwZXIgY29tcG9uZW50LlxuICovXG5jbGFzcyBTdGVwcGVyTW9kdWxlIHtcbn1cblN0ZXBwZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9ucyQ1XSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRNb2R1bGVzJDVdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFByb2dyZXNzQmFyTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkNiA9IFtcbiAgICBUYWJTdHJpcENvbXBvbmVudCxcbiAgICBUYWJTdHJpcFRhYkNvbXBvbmVudCxcbiAgICBUYWJDb250ZW50RGlyZWN0aXZlLFxuICAgIFRhYlRpdGxlRGlyZWN0aXZlXG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDYgPSBbXG4gICAgLi4uZXhwb3J0ZWRNb2R1bGVzJDZcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBUYWJTdHJpcCBjb21wb25lbnQuXG4gKlxuICogVGhlIG1vZHVsZSByZWdpc3RlcnM6XG4gKiAtIGBUYWJTdHJpcENvbXBvbmVudGAmbWRhc2g7VGhlIGBUYWJTdHJpcGAgY29tcG9uZW50IGNsYXNzLlxuICogLSBgVGFiU3RyaXBUYWJDb21wb25lbnRgJm1kYXNoO1RoZSBgVGFiU3RyaXBUYWJgIGNvbXBvbmVudCBjbGFzcy5cbiAqIC0gYFRhYkNvbnRlbnREaXJlY3RpdmVgJm1kYXNoO1RoZSB0YWIgY29udGVudCBkaXJlY3RpdmUgdXNlZCBvbiB0aGUgYDxuZy10ZW1wbGF0ZT5gIHRhZy5cbiAqIC0gYFRhYlRpdGxlRGlyZWN0aXZlYCZtZGFzaDtUaGUgdGFiIHRpdGxlIGRpcmVjdGl2ZSB1c2VkIG9uIHRoZSBgPG5nLXRlbXBsYXRlPmAgdGFnLlxuICovXG5jbGFzcyBUYWJTdHJpcE1vZHVsZSB7XG59XG5UYWJTdHJpcE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDZdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkNl0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgTGF5b3V0IGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgTGF5b3V0IG1vZHVsZVxuICogaW1wb3J0IHsgTGF5b3V0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbGF5b3V0JztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgTGF5b3V0TW9kdWxlXSwgLy8gaW1wb3J0IExheW91dCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIExheW91dE1vZHVsZSB7XG59XG5MYXlvdXRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQXZhdGFyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBDYXJkTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBEcmF3ZXJNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFBhbmVsQmFyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBTcGxpdHRlck1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgU3RlcHBlck1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgVGFiU3RyaXBNb2R1bGVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgUHJldmVudGFibGVFdmVudCwgRHJhd2VyU2VydmljZSwgRHJhd2VySXRlbUNvbXBvbmVudCwgRHJhd2VyTGlzdENvbXBvbmVudCwgRFJBV0VSX0lURU1fSU5ERVgsIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSwgTWVzc2FnZXMsIFBhbmVsQmFyU2VydmljZSwgU3BsaXR0ZXJCYXJDb21wb25lbnQsIFNwbGl0dGVyU2VydmljZSwgU3RlcHBlckxpc3RDb21wb25lbnQsIFNURVBQRVJfU1RFUF9JTkRFWCwgU3RlcHBlclN0ZXBDb21wb25lbnQsIFN0ZXBwZXJTZXJ2aWNlLCBQYW5lbEJhckNvbXBvbmVudCwgUGFuZWxCYXJJdGVtQ29tcG9uZW50LCBQYW5lbEJhckNvbnRlbnREaXJlY3RpdmUsIFBhbmVsQmFySXRlbVRlbXBsYXRlRGlyZWN0aXZlLCBQYW5lbEJhckl0ZW1UaXRsZURpcmVjdGl2ZSwgUGFuZWxCYXJFeHBhbmRNb2RlLCBTcGxpdHRlckNvbXBvbmVudCwgU3BsaXR0ZXJQYW5lQ29tcG9uZW50LCBUYWJTdHJpcENvbXBvbmVudCwgVGFiU3RyaXBUYWJDb21wb25lbnQsIFRhYkNvbnRlbnREaXJlY3RpdmUsIFRhYlRpdGxlRGlyZWN0aXZlLCBTZWxlY3RFdmVudCwgRHJhd2VyQ29tcG9uZW50LCBEcmF3ZXJDb250YWluZXJDb21wb25lbnQsIERyYXdlckNvbnRlbnRDb21wb25lbnQsIERyYXdlclNlbGVjdEV2ZW50LCBTdGVwcGVyQ29tcG9uZW50LCBTdGVwcGVyQWN0aXZhdGVFdmVudCwgQXZhdGFyQ29tcG9uZW50LCBDYXJkQ29tcG9uZW50LCBDYXJkSGVhZGVyQ29tcG9uZW50LCBDYXJkQm9keUNvbXBvbmVudCwgQ2FyZEZvb3RlckNvbXBvbmVudCwgQ2FyZEFjdGlvbnNDb21wb25lbnQsIENhcmRTZXBhcmF0b3JEaXJlY3RpdmUsIENhcmRUaXRsZURpcmVjdGl2ZSwgQ2FyZFN1YnRpdGxlRGlyZWN0aXZlLCBDYXJkTWVkaWFEaXJlY3RpdmUsIENhcmRBY3Rpb24sIEF2YXRhck1vZHVsZSwgQ2FyZE1vZHVsZSwgRHJhd2VyTW9kdWxlLCBMYXlvdXRNb2R1bGUsIFBhbmVsQmFyTW9kdWxlLCBTcGxpdHRlck1vZHVsZSwgU3RlcHBlck1vZHVsZSwgVGFiU3RyaXBNb2R1bGUsIERyYXdlclRlbXBsYXRlRGlyZWN0aXZlLCBEcmF3ZXJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsIERyYXdlckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCBEcmF3ZXJGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgU3RlcHBlckluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLCBTdGVwcGVyTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSwgU3RlcHBlclN0ZXBUZW1wbGF0ZURpcmVjdGl2ZSB9O1xuIl19