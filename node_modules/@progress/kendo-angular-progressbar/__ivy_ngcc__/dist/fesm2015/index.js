/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { isDevMode, HostBinding, Input, EventEmitter, Component, NgZone, Renderer2, Output, ViewChild, NgModule } from '@angular/core';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { hasObservers } from '@progress/kendo-angular-common';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["progressStatus"];
const _c1 = ["progressStatusWrap"];
function ProgressBarComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.formattedLabelValue);
} }
function ProgressBarComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.formattedLabelValue);
} }
function ChunkProgressBarComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "li", 2);
} if (rf & 2) {
    const chunk_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.orientationStyles.width)("height", ctx_r0.orientationStyles.height);
    ɵngcc0.ɵɵclassProp("k-first", i_r2 === 0)("k-last", i_r2 === ctx_r0.chunkCount - 1)("k-state-selected", chunk_r1);
    ɵngcc0.ɵɵproperty("ngClass", chunk_r1 ? ctx_r0.progressCssClass : ctx_r0.emptyCssClass)("ngStyle", chunk_r1 ? ctx_r0.progressCssStyle : ctx_r0.emptyCssStyle);
} }
const MIN_MAX_ERROR_MESSAGE = `The max value should be greater than the min.`;
/**
 * @hidden
 */
const LABEL_DECIMALS = 3;
/**
 * @hidden
 */
const MIN_RATIO = 0.0001;

/**
 * @hidden
 */
const reverseChunks = (orientation, reverse) => (orientation === 'vertical' && !reverse || orientation === 'horizontal' && reverse);
/**
 * @hidden
 */
const formatValue = (value, min, max, label) => {
    const defaultFormattedValue = truncateNumber(value);
    if (typeof label !== 'boolean') {
        if (typeof label.format === 'string') {
            switch (label.format) {
                case 'value':
                    return defaultFormattedValue;
                case 'percent':
                    return `${Math.floor(calculatePercentage(value, min, max))}%`;
                default:
                    return defaultFormattedValue;
            }
        }
        else if (typeof label.format === 'function') {
            return label.format(value);
        }
        else {
            return defaultFormattedValue;
        }
    }
    return defaultFormattedValue;
};
/**
 * @hidden
 */
const validateRange = (min, max) => {
    if (isDevMode && min > max) {
        throw new Error(MIN_MAX_ERROR_MESSAGE);
    }
};
/**
 * @hidden
 */
const adjustValueToRange = (min, max, value) => Math.max(Math.min(value, max), min);
/**
 * @hidden
 */
const calculatePercentage = (value, min, max) => {
    const onePercent = Math.abs((max - min) / 100);
    return Math.abs((value - min) / onePercent);
};
/**
 * @hidden
 */
const truncateNumber = (value) => {
    const numberParts = value.toString().split('.');
    return numberParts.length === 1 ? `${numberParts[0]}` : `${numberParts[0]}.${numberParts[1].substr(0, LABEL_DECIMALS)}`;
};
/**
 * @hidden
 */
const calculateRatio = (min, max, value) => Math.max((value - min) / (max - min), MIN_RATIO);
/**
 * @hidden
 */
const extractValueFromChanges = (changes, type, value) => changes[type] && changes[type].currentValue !== undefined ? changes[type].currentValue : value;
/**
 * @hidden
 */
const runAnimation = (changes, animation, previousValue, displayValue) => animation && typeof requestAnimationFrame !== 'undefined' && changes.value && previousValue !== displayValue;
/**
 * @hidden
 */
const stopCurrentAnimation = (changes) => {
    const isAnimationChanged = Boolean(changes.animation);
    const hasAnimation = isAnimationChanged && changes.animation.currentValue;
    return isAnimationChanged && !hasAnimation;
};

/**
 * @hidden
 */
class ProgressBarBase {
    /**
     * @hidden
     */
    constructor(localization) {
        this.localization = localization;
        this.widgetClasses = true;
        this.roleAttribute = 'progressbar';
        /**
         * The maximum value of the ProgressBar.
         * Defaults to `100`.
         */
        this.max = 100;
        /**
         * The minimum value of the ProgressBar.
         * Defaults to `0`.
         */
        this.min = 0;
        /**
         * The value of the ProgressBar.
         * Has to be between `min` and `max`.
         * By default, the value is equal to the `min` value.
         */
        /**
         * The value of the ProgressBar.
         * Has to be between `min` and `max`.
         * Defaults to `0`.
         */
        this.value = 0;
        /**
         * Defines the orientation of the ProgressBar
         * ([see example]({% slug progressbar_orientation %})).
         * Defaults to `horizontal`.
         */
        this.orientation = 'horizontal';
        /**
         * If set to `true`, the ProgressBar will be disabled
         * ([see example]({% slug progressbar_disabled %})).
         * It will still allow you to change its value.
         * Defaults to `false`.
         */
        this.disabled = false;
        /**
         * If set to `true`, the ProgressBar will be reversed
         * ([see example]({% slug progressbar_direction %})).
         * Defaults to `false`.
         */
        this.reverse = false;
        /**
         * Sets the `indeterminate` state of the ProgressBar.
         * Defaults to `false`.
         */
        this.indeterminate = false;
        this.displayValue = 0;
        this.previousValue = 0;
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    get isHorizontal() {
        return this.orientation === 'horizontal';
    }
    get isVertical() {
        return this.orientation === 'vertical';
    }
    get disabledClass() {
        return this.disabled;
    }
    get reverseClass() {
        return this.reverse;
    }
    get indeterminateClass() {
        return this.indeterminate;
    }
    get dirAttribute() {
        return this.direction;
    }
    get ariaMinAttribute() {
        return String(this.min);
    }
    get ariaMaxAttribute() {
        return String(this.max);
    }
    get ariaValueAttribute() {
        return this.indeterminate ? undefined : String(this.displayValue);
    }
    /**
     * @hidden
     */
    get isCompleted() {
        return this.value === this.max;
    }
    /**
     * @hidden
     */
    get statusWidth() {
        return this.orientation === 'horizontal' ? this._progressRatio * 100 : 100;
    }
    /**
     * @hidden
     */
    get statusHeight() {
        return this.orientation === 'vertical' ? this._progressRatio * 100 : 100;
    }
    /**
     * @hidden
     */
    get statusWrapperWidth() {
        return this.orientation === 'horizontal' ? 100 / this._progressRatio : 100;
    }
    /**
     * @hidden
     */
    get statusWrapperHeight() {
        return this.orientation === 'vertical' ? 100 / this._progressRatio : 100;
    }
    get _progressRatio() {
        return calculateRatio(this.min, this.max, this.displayValue);
    }
    ngOnChanges(changes) {
        const min = extractValueFromChanges(changes, 'min', this.min);
        const max = extractValueFromChanges(changes, 'max', this.max);
        const value = extractValueFromChanges(changes, 'value', this.value);
        if (changes.min || changes.max || changes.value) {
            if (changes.min || changes.max) {
                validateRange(min, max);
            }
            if (changes.value) {
                if (value == null || Number.isNaN(value)) {
                    this.value = min;
                }
                const previousValue = this.displayValue;
                this.displayValue = adjustValueToRange(this.min, this.max, value);
                this.previousValue = previousValue;
            }
            this.min = min;
            this.max = max;
            this.displayValue = adjustValueToRange(this.min, this.max, value);
        }
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
}
ProgressBarBase.ɵfac = function ProgressBarBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ProgressBarBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ProgressBarBase, hostVars: 19, hostBindings: function ProgressBarBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.roleAttribute)("dir", ctx.dirAttribute)("aria-valuemin", ctx.ariaMinAttribute)("aria-valuemax", ctx.ariaMaxAttribute)("aria-valuenow", ctx.ariaValueAttribute);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-progressbar", ctx.widgetClasses)("k-progressbar-horizontal", ctx.isHorizontal)("k-progressbar-vertical", ctx.isVertical)("k-state-disabled", ctx.disabledClass)("k-progressbar-reverse", ctx.reverseClass)("k-progressbar-indeterminate", ctx.indeterminateClass);
    } }, inputs: { max: "max", min: "min", value: "value", orientation: "orientation", disabled: "disabled", reverse: "reverse", indeterminate: "indeterminate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
ProgressBarBase.propDecorators = {
    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-progressbar',] }],
    isHorizontal: [{ type: HostBinding, args: ['class.k-progressbar-horizontal',] }],
    isVertical: [{ type: HostBinding, args: ['class.k-progressbar-vertical',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    reverseClass: [{ type: HostBinding, args: ['class.k-progressbar-reverse',] }],
    indeterminateClass: [{ type: HostBinding, args: ['class.k-progressbar-indeterminate',] }],
    dirAttribute: [{ type: HostBinding, args: ['attr.dir',] }],
    roleAttribute: [{ type: HostBinding, args: ['attr.role',] }],
    ariaMinAttribute: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],
    ariaMaxAttribute: [{ type: HostBinding, args: ['attr.aria-valuemax',] }],
    ariaValueAttribute: [{ type: HostBinding, args: ['attr.aria-valuenow',] }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    value: [{ type: Input }],
    orientation: [{ type: Input }],
    disabled: [{ type: Input }],
    reverse: [{ type: Input }],
    indeterminate: [{ type: Input }]
};


/**
 * Represents the [Kendo UI ProgressBar component for Angular]({% slug overview_progressbar %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-progressbar [value]="value">
 *        </kendo-progressbar>
 *    `
 * })
 * class AppComponent {
 *     public value = 50;
 * }
 * ```
 */
class ProgressBarComponent extends ProgressBarBase {
    /**
     * @hidden
     */
    constructor(localization, zone, renderer) {
        super(localization);
        this.localization = localization;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * Determines whether the status label will be visible.
         * Defaults to `true`&mdash;the label will be visible and displayed with the default
         * `LabelSettings` having its position set to `end` and its format set to `value`.
         */
        this.label = true;
        /**
         * The animation configuration of the ProgressBar.
         * Defaults to `false`.
         */
        this.animation = false;
        /**
         * Fires when the animation which indicates the latest value change is completed.
         */
        this.animationEnd = new EventEmitter();
    }
    /**
     * @hidden
     */
    get showLabel() {
        if (typeof this.label === 'boolean') {
            return this.label;
        }
        else {
            if (this.label && !this.label.hasOwnProperty('visible')) {
                this.label.visible = true;
            }
            return this.label.visible;
        }
    }
    /**
     * @hidden
     */
    get labelPosition() {
        if (typeof this.label === 'boolean') {
            return 'end';
        }
        else {
            if (this.label && !this.label.hasOwnProperty('position')) {
                this.label.position = 'end';
            }
            return this.label.position;
        }
    }
    /**
     * @hidden
     */
    get isPositionStart() {
        return this.labelPosition === 'start';
    }
    /**
     * @hidden
     */
    get isPositionCenter() {
        return this.labelPosition === 'center';
    }
    /**
     * @hidden
     */
    get isPositionEnd() {
        return this.labelPosition === 'end';
    }
    /**
     * @hidden
     */
    get formattedLabelValue() {
        return formatValue(this.displayValue, this.min, this.max, this.label);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (this.isAnimationInProgress && stopCurrentAnimation(changes)) {
            this.cancelCurrentAnimation = true;
        }
        if (runAnimation(changes, this.animation, this.previousValue, this.displayValue) && !changes.value.firstChange) {
            this.startAnimation(this.previousValue);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
    }
    /**
     * @hidden
     */
    startAnimation(previousValue) {
        this.isAnimationInProgress = true;
        const element = this.progressStatusElement.nativeElement;
        const wrapperElement = this.progressStatusWrapperElement.nativeElement;
        const animationOptions = this.getAnimationOptions(previousValue);
        this.zone.runOutsideAngular(() => {
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
            const animate = () => {
                const elapsed = new Date().getTime() - animationOptions.startTime;
                const position = Math.min(elapsed / animationOptions.duration, 1);
                const size = animationOptions.startSize + animationOptions.deltaSize * position;
                const wrapperSize = (100 / size) * 100;
                this.renderValueChange(element, wrapperElement, animationOptions.property, size, wrapperSize);
                if (position < 1) {
                    if (this.cancelCurrentAnimation) {
                        this.resetProgress(element, wrapperElement, animationOptions.property);
                        return;
                    }
                    this.animationFrame = requestAnimationFrame(animate);
                }
                else {
                    this.stopAnimation(previousValue);
                }
            };
            animate();
        });
    }
    /**
     * @hidden
     */
    get animationDuration() {
        if (typeof this.animation === 'boolean') {
            return 400;
        }
        else {
            if (this.animation && !this.animation.hasOwnProperty('duration')) {
                this.animation.duration = 400;
            }
            return this.animation.duration;
        }
    }
    stopAnimation(value) {
        if (hasObservers(this.animationEnd)) {
            this.zone.run(() => {
                this.animationEnd.emit({
                    from: value,
                    to: this.displayValue
                });
            });
        }
        this.zone.run(() => {
            this.isAnimationInProgress = false;
        });
    }
    getAnimationOptions(value) {
        const isHorizontal = this.orientation === 'horizontal';
        const previousRatio = calculateRatio(this.min, this.max, value);
        const previousStatusWidth = isHorizontal ? previousRatio * 100 : 100;
        const previousStatusHeight = !isHorizontal ? previousRatio * 100 : 100;
        const property = isHorizontal ? 'width' : 'height';
        const startTime = new Date().getTime();
        const startSize = isHorizontal ? previousStatusWidth : previousStatusHeight;
        const deltaSize = isHorizontal ? this.statusWidth - previousStatusWidth : this.statusHeight - previousStatusHeight;
        const duration = this.animationDuration * Math.abs((deltaSize / 100));
        return {
            property,
            startTime,
            startSize,
            deltaSize,
            duration
        };
    }
    renderValueChange(element, wrapperElement, property, size, wrapperSize) {
        this.renderer.setStyle(element, property, size + '%');
        this.renderer.setStyle(wrapperElement, property, wrapperSize + '%');
    }
    resetProgress(element, wrapperElement, property) {
        const size = calculateRatio(this.min, this.max, this.value);
        const newSize = size * 100;
        const newWrapperSize = 100 / size;
        this.renderValueChange(element, wrapperElement, property, newSize, newWrapperSize);
        this.zone.run(() => {
            this.cancelCurrentAnimation = false;
            this.isAnimationInProgress = false;
        });
    }
}
ProgressBarComponent.ɵfac = function ProgressBarComponent_Factory(t) { return new (t || ProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ProgressBarComponent, selectors: [["kendo-progressbar"]], viewQuery: function ProgressBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.progressStatusElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.progressStatusWrapperElement = _t.first);
    } }, inputs: { label: "label", animation: "animation", progressCssStyle: "progressCssStyle", progressCssClass: "progressCssClass", emptyCssStyle: "emptyCssStyle", emptyCssClass: "emptyCssClass" }, outputs: { animationEnd: "animationEnd" }, exportAs: ["kendoProgressBar"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.progressbar'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 28, consts: [[1, "k-progress-status-wrap", 3, "ngStyle", "ngClass"], ["class", "k-progress-status", 4, "ngIf"], [1, "k-state-selected", 3, "ngStyle", "ngClass"], ["progressStatus", ""], [1, "k-progress-status-wrap"], ["progressStatusWrap", ""], [1, "k-progress-status"]], template: function ProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, ProgressBarComponent_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵelementStart(4, "span", 4, 5);
        ɵngcc0.ɵɵtemplate(6, ProgressBarComponent_span_6_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-progress-start", ctx.isPositionStart)("k-progress-center", ctx.isPositionCenter)("k-progress-end", ctx.isPositionEnd);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.emptyCssStyle)("ngClass", ctx.emptyCssClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.statusWidth, "%")("height", ctx.statusHeight, "%");
        ɵngcc0.ɵɵclassProp("k-complete", ctx.isCompleted);
        ɵngcc0.ɵɵproperty("ngStyle", ctx.progressCssStyle)("ngClass", ctx.progressCssClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.statusWrapperWidth, "%")("height", ctx.statusWrapperHeight, "%");
        ɵngcc0.ɵɵclassProp("k-progress-start", ctx.isPositionStart)("k-progress-center", ctx.isPositionCenter)("k-progress-end", ctx.isPositionEnd);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc2.NgStyle, ɵngcc2.NgClass, ɵngcc2.NgIf], encapsulation: 2 });
/** @nocollapse */
ProgressBarComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: NgZone },
    { type: Renderer2 }
];
ProgressBarComponent.propDecorators = {
    label: [{ type: Input }],
    progressCssStyle: [{ type: Input }],
    progressCssClass: [{ type: Input }],
    emptyCssStyle: [{ type: Input }],
    emptyCssClass: [{ type: Input }],
    animation: [{ type: Input }],
    animationEnd: [{ type: Output }],
    progressStatusElement: [{ type: ViewChild, args: ['progressStatus', { static: false },] }],
    progressStatusWrapperElement: [{ type: ViewChild, args: ['progressStatusWrap', { static: false },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProgressBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoProgressBar',
                selector: 'kendo-progressbar',
                template: `
        <span class="k-progress-status-wrap"
            [class.k-progress-start]="isPositionStart"
            [class.k-progress-center]="isPositionCenter"
            [class.k-progress-end]="isPositionEnd"
            [ngStyle]="emptyCssStyle"
            [ngClass]="emptyCssClass">
            <span *ngIf="showLabel" class="k-progress-status">{{formattedLabelValue}}</span>
        </span>
        <div
            #progressStatus
            class="k-state-selected"
            [class.k-complete]="isCompleted"
            [ngStyle]="progressCssStyle"
            [ngClass]="progressCssClass"
            [style.width.%]="statusWidth"
            [style.height.%]="statusHeight"
            >
            <span
                #progressStatusWrap
                class="k-progress-status-wrap"
                [style.width.%]="statusWrapperWidth"
                [style.height.%]="statusWrapperHeight"
                [class.k-progress-start]="isPositionStart"
                [class.k-progress-center]="isPositionCenter"
                [class.k-progress-end]="isPositionEnd"
                >
                <span *ngIf="showLabel" class="k-progress-status">{{formattedLabelValue}}</span>
            </span>
        </div>
       `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.progressbar'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { label: [{
            type: Input
        }], animation: [{
            type: Input
        }], animationEnd: [{
            type: Output
        }], progressCssStyle: [{
            type: Input
        }], progressCssClass: [{
            type: Input
        }], emptyCssStyle: [{
            type: Input
        }], emptyCssClass: [{
            type: Input
        }], progressStatusElement: [{
            type: ViewChild,
            args: ['progressStatus', { static: false }]
        }], progressStatusWrapperElement: [{
            type: ViewChild,
            args: ['progressStatusWrap', { static: false }]
        }] }); })();

/**
 * Represents the [Kendo UI ChunkProgressBar component for Angular]({% slug overview_chunkprogressbar %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-chunkprogressbar [value]="value">
 *        </kendo-chunkprogressbar>
 *    `
 * })
 * class AppComponent {
 *     public value = 40;
 * }
 * ```
 */
class ChunkProgressBarComponent extends ProgressBarBase {
    /**
     * @hidden
     */
    constructor(localization) {
        super(localization);
        this.localization = localization;
        /**
         * Sets the number of chunks into which the ChunkProgressBar will be split.
         * Defaults to `5`.
         */
        this.chunkCount = 5;
        this._orientationStyles = {
            width: `${this.chunkSizePercentage}%`
        };
    }
    /**
     * @hidden
     */
    get chunks() {
        const count = this.chunkCount;
        const chunks = Array(count).fill(false);
        const completedChunks = Math.floor(this._progressRatio * count);
        for (let i = 0; i < completedChunks; i++) {
            chunks[i] = true;
        }
        if (reverseChunks(this.orientation, this.reverse)) {
            chunks.reverse();
        }
        return chunks;
    }
    /**
     * @hidden
     */
    get chunkSizePercentage() {
        return 100 / this.chunkCount;
    }
    /**
     * @hidden
     */
    get orientationStyles() {
        if (this.orientation === 'horizontal') {
            this._orientationStyles.width = `${this.chunkSizePercentage}%`;
            this._orientationStyles.height = undefined;
        }
        else {
            this._orientationStyles.height = `${this.chunkSizePercentage}%`;
            this._orientationStyles.width = undefined;
        }
        return this._orientationStyles;
    }
}
ChunkProgressBarComponent.ɵfac = function ChunkProgressBarComponent_Factory(t) { return new (t || ChunkProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ChunkProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChunkProgressBarComponent, selectors: [["kendo-chunkprogressbar"]], inputs: { chunkCount: "chunkCount", progressCssStyle: "progressCssStyle", progressCssClass: "progressCssClass", emptyCssStyle: "emptyCssStyle", emptyCssClass: "emptyCssClass" }, exportAs: ["kendoChunkProgressBar"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.chunkprogressbar'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "k-reset"], ["class", "k-item", 3, "k-first", "k-last", "k-state-selected", "ngClass", "ngStyle", "width", "height", 4, "ngFor", "ngForOf"], [1, "k-item", 3, "ngClass", "ngStyle"]], template: function ChunkProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, ChunkProgressBarComponent_li_1_Template, 1, 12, "li", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.chunks);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgClass, ɵngcc2.NgStyle], encapsulation: 2 });
/** @nocollapse */
ChunkProgressBarComponent.ctorParameters = () => [
    { type: LocalizationService }
];
ChunkProgressBarComponent.propDecorators = {
    chunkCount: [{ type: Input }],
    progressCssStyle: [{ type: Input }],
    progressCssClass: [{ type: Input }],
    emptyCssStyle: [{ type: Input }],
    emptyCssClass: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChunkProgressBarComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoChunkProgressBar',
                selector: 'kendo-chunkprogressbar',
                template: `
        <ul class="k-reset">
            <li class="k-item" *ngFor="let chunk of chunks; let i = index;"
                [class.k-first]="i === 0"
                [class.k-last]="i === chunkCount - 1"
                [class.k-state-selected]="chunk"
                [ngClass]="chunk ? progressCssClass : emptyCssClass"
                [ngStyle]="chunk ? progressCssStyle : emptyCssStyle"
                [style.width]="orientationStyles.width"
                [style.height]="orientationStyles.height"
                >
            </li>
        </ul>
    `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.chunkprogressbar'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, { chunkCount: [{
            type: Input
        }], progressCssStyle: [{
            type: Input
        }], progressCssClass: [{
            type: Input
        }], emptyCssStyle: [{
            type: Input
        }], emptyCssClass: [{
            type: Input
        }] }); })();

const COMPONENT_DIRECTIVES = [ProgressBarComponent, ChunkProgressBarComponent];
const MODULES = [CommonModule];
/**
 * @hidden
 */
class ProgressBarModule {
}
ProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ProgressBarModule });
ProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ProgressBarModule_Factory(t) { return new (t || ProgressBarModule)(); }, imports: [MODULES] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ProgressBarModule, { declarations: [ProgressBarComponent,
        ChunkProgressBarComponent], imports: [CommonModule], exports: [ProgressBarComponent,
        ChunkProgressBarComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: COMPONENT_DIRECTIVES,
                exports: COMPONENT_DIRECTIVES,
                imports: MODULES
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ProgressBarBase, ProgressBarComponent, ChunkProgressBarComponent, ProgressBarModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OE1BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dGQTRDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzsyRkEyQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBpc0Rldk1vZGUsIEhvc3RCaW5kaW5nLCBJbnB1dCwgRXZlbnRFbWl0dGVyLCBDb21wb25lbnQsIE5nWm9uZSwgUmVuZGVyZXIyLCBPdXRwdXQsIFZpZXdDaGlsZCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UsIEwxME5fUFJFRklYIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBoYXNPYnNlcnZlcnMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9NQVhfRVJST1JfTUVTU0FHRSA9IGBUaGUgbWF4IHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gdGhlIG1pbi5gO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IExBQkVMX0RFQ0lNQUxTID0gMztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBNSU5fUkFUSU8gPSAwLjAwMDE7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZXZlcnNlQ2h1bmtzID0gKG9yaWVudGF0aW9uLCByZXZlcnNlKSA9PiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgIXJldmVyc2UgfHwgb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiByZXZlcnNlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXRWYWx1ZSA9ICh2YWx1ZSwgbWluLCBtYXgsIGxhYmVsKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdEZvcm1hdHRlZFZhbHVlID0gdHJ1bmNhdGVOdW1iZXIodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsLmZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobGFiZWwuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlcmNlbnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7TWF0aC5mbG9vcihjYWxjdWxhdGVQZXJjZW50YWdlKHZhbHVlLCBtaW4sIG1heCkpfSVgO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxhYmVsLmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVkVmFsdWU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHZhbGlkYXRlUmFuZ2UgPSAobWluLCBtYXgpID0+IHtcbiAgICBpZiAoaXNEZXZNb2RlICYmIG1pbiA+IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUlOX01BWF9FUlJPUl9NRVNTQUdFKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGFkanVzdFZhbHVlVG9SYW5nZSA9IChtaW4sIG1heCwgdmFsdWUpID0+IE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVBlcmNlbnRhZ2UgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgY29uc3Qgb25lUGVyY2VudCA9IE1hdGguYWJzKChtYXggLSBtaW4pIC8gMTAwKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoKHZhbHVlIC0gbWluKSAvIG9uZVBlcmNlbnQpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0cnVuY2F0ZU51bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG51bWJlclBhcnRzID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgIHJldHVybiBudW1iZXJQYXJ0cy5sZW5ndGggPT09IDEgPyBgJHtudW1iZXJQYXJ0c1swXX1gIDogYCR7bnVtYmVyUGFydHNbMF19LiR7bnVtYmVyUGFydHNbMV0uc3Vic3RyKDAsIExBQkVMX0RFQ0lNQUxTKX1gO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjYWxjdWxhdGVSYXRpbyA9IChtaW4sIG1heCwgdmFsdWUpID0+IE1hdGgubWF4KCh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKSwgTUlOX1JBVElPKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHRyYWN0VmFsdWVGcm9tQ2hhbmdlcyA9IChjaGFuZ2VzLCB0eXBlLCB2YWx1ZSkgPT4gY2hhbmdlc1t0eXBlXSAmJiBjaGFuZ2VzW3R5cGVdLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gY2hhbmdlc1t0eXBlXS5jdXJyZW50VmFsdWUgOiB2YWx1ZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBydW5BbmltYXRpb24gPSAoY2hhbmdlcywgYW5pbWF0aW9uLCBwcmV2aW91c1ZhbHVlLCBkaXNwbGF5VmFsdWUpID0+IGFuaW1hdGlvbiAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJyAmJiBjaGFuZ2VzLnZhbHVlICYmIHByZXZpb3VzVmFsdWUgIT09IGRpc3BsYXlWYWx1ZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzdG9wQ3VycmVudEFuaW1hdGlvbiA9IChjaGFuZ2VzKSA9PiB7XG4gICAgY29uc3QgaXNBbmltYXRpb25DaGFuZ2VkID0gQm9vbGVhbihjaGFuZ2VzLmFuaW1hdGlvbik7XG4gICAgY29uc3QgaGFzQW5pbWF0aW9uID0gaXNBbmltYXRpb25DaGFuZ2VkICYmIGNoYW5nZXMuYW5pbWF0aW9uLmN1cnJlbnRWYWx1ZTtcbiAgICByZXR1cm4gaXNBbmltYXRpb25DaGFuZ2VkICYmICFoYXNBbmltYXRpb247XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJvZ3Jlc3NCYXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLndpZGdldENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnJvbGVBdHRyaWJ1dGUgPSAncHJvZ3Jlc3NiYXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIFByb2dyZXNzQmFyLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMTAwYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4ID0gMTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIFByb2dyZXNzQmFyLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIFByb2dyZXNzQmFyLlxuICAgICAgICAgKiBIYXMgdG8gYmUgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgYG1pbmAgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBQcm9ncmVzc0Jhci5cbiAgICAgICAgICogSGFzIHRvIGJlIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBQcm9ncmVzc0JhclxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByb2dyZXNzYmFyX29yaWVudGF0aW9uICV9KSkuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBob3Jpem9udGFsYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgUHJvZ3Jlc3NCYXIgd2lsbCBiZSBkaXNhYmxlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByb2dyZXNzYmFyX2Rpc2FibGVkICV9KSkuXG4gICAgICAgICAqIEl0IHdpbGwgc3RpbGwgYWxsb3cgeW91IHRvIGNoYW5nZSBpdHMgdmFsdWUuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgUHJvZ3Jlc3NCYXIgd2lsbCBiZSByZXZlcnNlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByb2dyZXNzYmFyX2RpcmVjdGlvbiAlfSkpLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBgaW5kZXRlcm1pbmF0ZWAgc3RhdGUgb2YgdGhlIFByb2dyZXNzQmFyLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24gPSBsb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGdldCBpc1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgcmV2ZXJzZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlO1xuICAgIH1cbiAgICBnZXQgaW5kZXRlcm1pbmF0ZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRldGVybWluYXRlO1xuICAgIH1cbiAgICBnZXQgZGlyQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIGdldCBhcmlhTWluQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMubWluKTtcbiAgICB9XG4gICAgZ2V0IGFyaWFNYXhBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5tYXgpO1xuICAgIH1cbiAgICBnZXQgYXJpYVZhbHVlQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRldGVybWluYXRlID8gdW5kZWZpbmVkIDogU3RyaW5nKHRoaXMuZGlzcGxheVZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc0NvbXBsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoaXMubWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gdGhpcy5fcHJvZ3Jlc3NSYXRpbyAqIDEwMCA6IDEwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzdGF0dXNIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gdGhpcy5fcHJvZ3Jlc3NSYXRpbyAqIDEwMCA6IDEwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzdGF0dXNXcmFwcGVyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAxMDAgLyB0aGlzLl9wcm9ncmVzc1JhdGlvIDogMTAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c1dyYXBwZXJIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gMTAwIC8gdGhpcy5fcHJvZ3Jlc3NSYXRpbyA6IDEwMDtcbiAgICB9XG4gICAgZ2V0IF9wcm9ncmVzc1JhdGlvKCkge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlUmF0aW8odGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLmRpc3BsYXlWYWx1ZSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgbWluID0gZXh0cmFjdFZhbHVlRnJvbUNoYW5nZXMoY2hhbmdlcywgJ21pbicsIHRoaXMubWluKTtcbiAgICAgICAgY29uc3QgbWF4ID0gZXh0cmFjdFZhbHVlRnJvbUNoYW5nZXMoY2hhbmdlcywgJ21heCcsIHRoaXMubWF4KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBleHRyYWN0VmFsdWVGcm9tQ2hhbmdlcyhjaGFuZ2VzLCAndmFsdWUnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKGNoYW5nZXMubWluIHx8IGNoYW5nZXMubWF4IHx8IGNoYW5nZXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLm1pbiB8fCBjaGFuZ2VzLm1heCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlUmFuZ2UobWluLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBtaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLmRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IGFkanVzdFZhbHVlVG9SYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gYWRqdXN0VmFsdWVUb1JhbmdlKHRoaXMubWluLCB0aGlzLm1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Qcm9ncmVzc0JhckJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgd2lkZ2V0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay13aWRnZXQnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXByb2dyZXNzYmFyJyxdIH1dLFxuICAgIGlzSG9yaXpvbnRhbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1wcm9ncmVzc2Jhci1ob3Jpem9udGFsJyxdIH1dLFxuICAgIGlzVmVydGljYWw6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstcHJvZ3Jlc3NiYXItdmVydGljYWwnLF0gfV0sXG4gICAgZGlzYWJsZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcsXSB9XSxcbiAgICByZXZlcnNlQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstcHJvZ3Jlc3NiYXItcmV2ZXJzZScsXSB9XSxcbiAgICBpbmRldGVybWluYXRlQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstcHJvZ3Jlc3NiYXItaW5kZXRlcm1pbmF0ZScsXSB9XSxcbiAgICBkaXJBdHRyaWJ1dGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dLFxuICAgIHJvbGVBdHRyaWJ1dGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XSxcbiAgICBhcmlhTWluQXR0cmlidXRlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmFyaWEtdmFsdWVtaW4nLF0gfV0sXG4gICAgYXJpYU1heEF0dHJpYnV0ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXZhbHVlbWF4JyxdIH1dLFxuICAgIGFyaWFWYWx1ZUF0dHJpYnV0ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXZhbHVlbm93JyxdIH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXZlcnNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbmRldGVybWluYXRlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgUHJvZ3Jlc3NCYXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3Byb2dyZXNzYmFyICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tcHJvZ3Jlc3NiYXIgW3ZhbHVlXT1cInZhbHVlXCI+XG4gKiAgICAgICAgPC9rZW5kby1wcm9ncmVzc2Jhcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyB2YWx1ZSA9IDUwO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFByb2dyZXNzQmFyQ29tcG9uZW50IGV4dGVuZHMgUHJvZ3Jlc3NCYXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCB6b25lLCByZW5kZXJlcikge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24pO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdGF0dXMgbGFiZWwgd2lsbCBiZSB2aXNpYmxlLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgdHJ1ZWAmbWRhc2g7dGhlIGxhYmVsIHdpbGwgYmUgdmlzaWJsZSBhbmQgZGlzcGxheWVkIHdpdGggdGhlIGRlZmF1bHRcbiAgICAgICAgICogYExhYmVsU2V0dGluZ3NgIGhhdmluZyBpdHMgcG9zaXRpb24gc2V0IHRvIGBlbmRgIGFuZCBpdHMgZm9ybWF0IHNldCB0byBgdmFsdWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYWJlbCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFByb2dyZXNzQmFyLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGFuaW1hdGlvbiB3aGljaCBpbmRpY2F0ZXMgdGhlIGxhdGVzdCB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25FbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd0xhYmVsKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGFiZWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbCAmJiAhdGhpcy5sYWJlbC5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsLnZpc2libGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBsYWJlbFBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGFiZWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwgJiYgIXRoaXMubGFiZWwuaGFzT3duUHJvcGVydHkoJ3Bvc2l0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLnBvc2l0aW9uID0gJ2VuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzUG9zaXRpb25TdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxQb3NpdGlvbiA9PT0gJ3N0YXJ0JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc1Bvc2l0aW9uQ2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnY2VudGVyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc1Bvc2l0aW9uRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnZW5kJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBmb3JtYXR0ZWRMYWJlbFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUodGhpcy5kaXNwbGF5VmFsdWUsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5sYWJlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGlvbkluUHJvZ3Jlc3MgJiYgc3RvcEN1cnJlbnRBbmltYXRpb24oY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQ3VycmVudEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkFuaW1hdGlvbihjaGFuZ2VzLCB0aGlzLmFuaW1hdGlvbiwgdGhpcy5wcmV2aW91c1ZhbHVlLCB0aGlzLmRpc3BsYXlWYWx1ZSkgJiYgIWNoYW5nZXMudmFsdWUuZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24odGhpcy5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc3RhcnRBbmltYXRpb24ocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByb2dyZXNzU3RhdHVzRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCB3cmFwcGVyRWxlbWVudCA9IHRoaXMucHJvZ3Jlc3NTdGF0dXNXcmFwcGVyRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gdGhpcy5nZXRBbmltYXRpb25PcHRpb25zKHByZXZpb3VzVmFsdWUpO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gYW5pbWF0aW9uT3B0aW9ucy5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBNYXRoLm1pbihlbGFwc2VkIC8gYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGFuaW1hdGlvbk9wdGlvbnMuc3RhcnRTaXplICsgYW5pbWF0aW9uT3B0aW9ucy5kZWx0YVNpemUgKiBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyU2l6ZSA9ICgxMDAgLyBzaXplKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZhbHVlQ2hhbmdlKGVsZW1lbnQsIHdyYXBwZXJFbGVtZW50LCBhbmltYXRpb25PcHRpb25zLnByb3BlcnR5LCBzaXplLCB3cmFwcGVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxDdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJvZ3Jlc3MoZWxlbWVudCwgd3JhcHBlckVsZW1lbnQsIGFuaW1hdGlvbk9wdGlvbnMucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24ocHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFuaW1hdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgYW5pbWF0aW9uRHVyYXRpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5hbmltYXRpb24gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIDQwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbiAmJiAhdGhpcy5hbmltYXRpb24uaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5kdXJhdGlvbiA9IDQwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbi5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wQW5pbWF0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5hbmltYXRpb25FbmQpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLmRpc3BsYXlWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QW5pbWF0aW9uT3B0aW9ucyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUmF0aW8gPSBjYWxjdWxhdGVSYXRpbyh0aGlzLm1pbiwgdGhpcy5tYXgsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0dXNXaWR0aCA9IGlzSG9yaXpvbnRhbCA/IHByZXZpb3VzUmF0aW8gKiAxMDAgOiAxMDA7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdHVzSGVpZ2h0ID0gIWlzSG9yaXpvbnRhbCA/IHByZXZpb3VzUmF0aW8gKiAxMDAgOiAxMDA7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNIb3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gaXNIb3Jpem9udGFsID8gcHJldmlvdXNTdGF0dXNXaWR0aCA6IHByZXZpb3VzU3RhdHVzSGVpZ2h0O1xuICAgICAgICBjb25zdCBkZWx0YVNpemUgPSBpc0hvcml6b250YWwgPyB0aGlzLnN0YXR1c1dpZHRoIC0gcHJldmlvdXNTdGF0dXNXaWR0aCA6IHRoaXMuc3RhdHVzSGVpZ2h0IC0gcHJldmlvdXNTdGF0dXNIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hbmltYXRpb25EdXJhdGlvbiAqIE1hdGguYWJzKChkZWx0YVNpemUgLyAxMDApKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgc3RhcnRTaXplLFxuICAgICAgICAgICAgZGVsdGFTaXplLFxuICAgICAgICAgICAgZHVyYXRpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyVmFsdWVDaGFuZ2UoZWxlbWVudCwgd3JhcHBlckVsZW1lbnQsIHByb3BlcnR5LCBzaXplLCB3cmFwcGVyU2l6ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5LCBzaXplICsgJyUnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh3cmFwcGVyRWxlbWVudCwgcHJvcGVydHksIHdyYXBwZXJTaXplICsgJyUnKTtcbiAgICB9XG4gICAgcmVzZXRQcm9ncmVzcyhlbGVtZW50LCB3cmFwcGVyRWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVJhdGlvKHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy52YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSBzaXplICogMTAwO1xuICAgICAgICBjb25zdCBuZXdXcmFwcGVyU2l6ZSA9IDEwMCAvIHNpemU7XG4gICAgICAgIHRoaXMucmVuZGVyVmFsdWVDaGFuZ2UoZWxlbWVudCwgd3JhcHBlckVsZW1lbnQsIHByb3BlcnR5LCBuZXdTaXplLCBuZXdXcmFwcGVyU2l6ZSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxDdXJyZW50QW5pbWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5Qcm9ncmVzc0JhckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9Qcm9ncmVzc0JhcicsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wcm9ncmVzc2JhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXByb2dyZXNzLXN0YXR1cy13cmFwXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXByb2dyZXNzLXN0YXJ0XT1cImlzUG9zaXRpb25TdGFydFwiXG4gICAgICAgICAgICBbY2xhc3Muay1wcm9ncmVzcy1jZW50ZXJdPVwiaXNQb3NpdGlvbkNlbnRlclwiXG4gICAgICAgICAgICBbY2xhc3Muay1wcm9ncmVzcy1lbmRdPVwiaXNQb3NpdGlvbkVuZFwiXG4gICAgICAgICAgICBbbmdTdHlsZV09XCJlbXB0eUNzc1N0eWxlXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cImVtcHR5Q3NzQ2xhc3NcIj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwic2hvd0xhYmVsXCIgY2xhc3M9XCJrLXByb2dyZXNzLXN0YXR1c1wiPnt7Zm9ybWF0dGVkTGFiZWxWYWx1ZX19PC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgICNwcm9ncmVzc1N0YXR1c1xuICAgICAgICAgICAgY2xhc3M9XCJrLXN0YXRlLXNlbGVjdGVkXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLWNvbXBsZXRlXT1cImlzQ29tcGxldGVkXCJcbiAgICAgICAgICAgIFtuZ1N0eWxlXT1cInByb2dyZXNzQ3NzU3R5bGVcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwicHJvZ3Jlc3NDc3NDbGFzc1wiXG4gICAgICAgICAgICBbc3R5bGUud2lkdGguJV09XCJzdGF0dXNXaWR0aFwiXG4gICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LiVdPVwic3RhdHVzSGVpZ2h0XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgI3Byb2dyZXNzU3RhdHVzV3JhcFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay1wcm9ncmVzcy1zdGF0dXMtd3JhcFwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoLiVdPVwic3RhdHVzV3JhcHBlcldpZHRoXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LiVdPVwic3RhdHVzV3JhcHBlckhlaWdodFwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstcHJvZ3Jlc3Mtc3RhcnRdPVwiaXNQb3NpdGlvblN0YXJ0XCJcbiAgICAgICAgICAgICAgICBbY2xhc3Muay1wcm9ncmVzcy1jZW50ZXJdPVwiaXNQb3NpdGlvbkNlbnRlclwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstcHJvZ3Jlc3MtZW5kXT1cImlzUG9zaXRpb25FbmRcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cInNob3dMYWJlbFwiIGNsYXNzPVwiay1wcm9ncmVzcy1zdGF0dXNcIj57e2Zvcm1hdHRlZExhYmVsVmFsdWV9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLnByb2dyZXNzYmFyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Qcm9ncmVzc0JhckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH1cbl07XG5Qcm9ncmVzc0JhckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBsYWJlbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHJvZ3Jlc3NDc3NTdHlsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHJvZ3Jlc3NDc3NDbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZW1wdHlDc3NTdHlsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZW1wdHlDc3NDbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYW5pbWF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmltYXRpb25FbmQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBwcm9ncmVzc1N0YXR1c0VsZW1lbnQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydwcm9ncmVzc1N0YXR1cycsIHsgc3RhdGljOiBmYWxzZSB9LF0gfV0sXG4gICAgcHJvZ3Jlc3NTdGF0dXNXcmFwcGVyRWxlbWVudDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3Byb2dyZXNzU3RhdHVzV3JhcCcsIHsgc3RhdGljOiBmYWxzZSB9LF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIENodW5rUHJvZ3Jlc3NCYXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2NodW5rcHJvZ3Jlc3NiYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgIDxrZW5kby1jaHVua3Byb2dyZXNzYmFyIFt2YWx1ZV09XCJ2YWx1ZVwiPlxuICogICAgICAgIDwva2VuZG8tY2h1bmtwcm9ncmVzc2Jhcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgIHB1YmxpYyB2YWx1ZSA9IDQwO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBQcm9ncmVzc0JhckJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgY2h1bmtzIGludG8gd2hpY2ggdGhlIENodW5rUHJvZ3Jlc3NCYXIgd2lsbCBiZSBzcGxpdC5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYDVgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVua0NvdW50ID0gNTtcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb25TdHlsZXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYCR7dGhpcy5jaHVua1NpemVQZXJjZW50YWdlfSVgXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY2h1bmtzKCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY2h1bmtDb3VudDtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gQXJyYXkoY291bnQpLmZpbGwoZmFsc2UpO1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRDaHVua3MgPSBNYXRoLmZsb29yKHRoaXMuX3Byb2dyZXNzUmF0aW8gKiBjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcGxldGVkQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNodW5rc1tpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldmVyc2VDaHVua3ModGhpcy5vcmllbnRhdGlvbiwgdGhpcy5yZXZlcnNlKSkge1xuICAgICAgICAgICAgY2h1bmtzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNodW5rU2l6ZVBlcmNlbnRhZ2UoKSB7XG4gICAgICAgIHJldHVybiAxMDAgLyB0aGlzLmNodW5rQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgb3JpZW50YXRpb25TdHlsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uU3R5bGVzLndpZHRoID0gYCR7dGhpcy5jaHVua1NpemVQZXJjZW50YWdlfSVgO1xuICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25TdHlsZXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25TdHlsZXMuaGVpZ2h0ID0gYCR7dGhpcy5jaHVua1NpemVQZXJjZW50YWdlfSVgO1xuICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25TdHlsZXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uU3R5bGVzO1xuICAgIH1cbn1cbkNodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvQ2h1bmtQcm9ncmVzc0JhcicsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaHVua3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dWwgY2xhc3M9XCJrLXJlc2V0XCI+XG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJrLWl0ZW1cIiAqbmdGb3I9XCJsZXQgY2h1bmsgb2YgY2h1bmtzOyBsZXQgaSA9IGluZGV4O1wiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstZmlyc3RdPVwiaSA9PT0gMFwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstbGFzdF09XCJpID09PSBjaHVua0NvdW50IC0gMVwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwiY2h1bmtcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNodW5rID8gcHJvZ3Jlc3NDc3NDbGFzcyA6IGVtcHR5Q3NzQ2xhc3NcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNodW5rID8gcHJvZ3Jlc3NDc3NTdHlsZSA6IGVtcHR5Q3NzU3R5bGVcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aF09XCJvcmllbnRhdGlvblN0eWxlcy53aWR0aFwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodF09XCJvcmllbnRhdGlvblN0eWxlcy5oZWlnaHRcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmNodW5rcHJvZ3Jlc3NiYXInXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5DaHVua1Byb2dyZXNzQmFyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNodW5rQ291bnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb2dyZXNzQ3NzU3R5bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb2dyZXNzQ3NzQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGVtcHR5Q3NzU3R5bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGVtcHR5Q3NzQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBDT01QT05FTlRfRElSRUNUSVZFUyA9IFtQcm9ncmVzc0JhckNvbXBvbmVudCwgQ2h1bmtQcm9ncmVzc0JhckNvbXBvbmVudF07XG5jb25zdCBNT0RVTEVTID0gW0NvbW1vbk1vZHVsZV07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJvZ3Jlc3NCYXJNb2R1bGUge1xufVxuUHJvZ3Jlc3NCYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogQ09NUE9ORU5UX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogQ09NUE9ORU5UX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgaW1wb3J0czogTU9EVUxFU1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IFByb2dyZXNzQmFyQmFzZSwgUHJvZ3Jlc3NCYXJDb21wb25lbnQsIENodW5rUHJvZ3Jlc3NCYXJDb21wb25lbnQsIFByb2dyZXNzQmFyTW9kdWxlIH07XG4iXX0=