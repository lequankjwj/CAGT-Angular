/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, OnDestroy, ViewContainerRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { PopupService } from '@progress/kendo-angular-popup';
import { PopupSettings, PreventableEvent, PaletteSettings, OutputFormat, ActiveColorClickEvent, ColorPickerView, GradientSettings } from './models';
import { LocalizationService } from '@progress/kendo-angular-l10n';
/**
 * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).
 * Designed to replace the `<input type="color">` HTML5 tag which is not widely supported in browsers.
 */
import * as ɵngcc0 from '@angular/core';
export declare class ColorPickerComponent implements OnDestroy, ControlValueAccessor {
    private popupService;
    /**
     * @hidden
     */
    hostClasses: boolean;
    /**
     * @hidden
     */
    direction: string;
    /**
     * @hidden
     */
    focusableId: string;
    /**
     * Sets what view the ColorPicker will render in the popup.
     */
    view: ColorPickerView;
    /**
     * Sets the read-only state of the ColorPicker.
     */
    readonly: boolean;
    /**
     * Sets the disabled state of the ColorPicker.
     */
    disabled: boolean;
    /**
     * Specifies the output format of the ColorPicker.
     * The input value may be in a different format. However, it will be parsed into the output `format`
     * after the component processes it.
     *
     * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.
     *
     * The supported values are:
     * * `rgba` (default)
     * * `hex`
     * * [`name`](https://www.w3.org/wiki/CSS/Properties/color/keywords)
     */
    format: OutputFormat;
    /**
     * Specifies the value of the initially selected color.
     */
    value: string;
    /**
     * Configures the popup of the ColorPicker.
     */
    popupSettings: PopupSettings;
    /**
     * Configures the palette that is displayed in the ColorPicker popup.
     */
    paletteSettings: PaletteSettings;
    /**
     * Configures the gradient that is displayed in the ColorPicker popup.
     */
    gradientSettings: GradientSettings;
    /**
     * Defines the name of an [existing icon in the Kendo UI theme]({% slug icons %}).
     * Provide only the name of the icon without the `k-icon` or the `k-i-` prefixes.
     * For example, `edit-tools` will be parsed to `k-icon k-i-edit-tools`.
     */
    icon: string;
    /**
     * A CSS class name which displays an icon in the ColorPicker button.
     * `iconClass` is compatible with the `ngClass` syntax.
     *
     * Takes precedence over `icon` if both are defined.
     */
    iconClass: string | Array<string> | {
        [key: string]: boolean;
    };
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    tabindex: number;
    /**
     * Fires each time the value is changed.
     */
    valueChange: EventEmitter<any>;
    /**
     * Fires each time the popup is about to open.
     * This event is preventable. If you cancel it, the popup will remain closed.
     */
    open: EventEmitter<PreventableEvent>;
    /**
     * Fires each time the popup is about to close.
     * This event is preventable. If you cancel it, the popup will remain open.
     */
    close: EventEmitter<PreventableEvent>;
    /**
     * Fires each time ColorPicker is focused.
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires each time the ColorPicker is blurred.
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires each time the left side of the ColorPicker wrapper is clicked.
     * The event is triggered regardless of whether a ColorPicker icon is set or not.
     *
     * The [`ActiveColorClickEvent`]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
     */
    activeColorClick: EventEmitter<ActiveColorClickEvent>;
    /**
     * Indicates whether the ColorPicker wrapper is focused.
     */
    isFocused: boolean;
    /**
     * Indicates whether the ColorPicker popup is open.
     */
    readonly isOpen: boolean;
    /**
     * @hidden
     */
    readonly iconStyles: string | string[] | {
        [key: string]: boolean;
    };
    /**
     * Provides a reference to a container element inside the component markup.
     * The container element references the location of the appended popup&mdash;
     * for example, inside the component markup.
     */
    container: ViewContainerRef;
    private wrapper;
    private popupTemplate;
    private palette;
    private popupRef;
    private _value;
    private _tabindex;
    private _popupSettings;
    private _paletteSettings;
    private _gradientSettings;
    private dynamicRTLSubscription;
    constructor(popupService: PopupService, localizationService: LocalizationService);
    ngOnInit(): void;
    ngOnChanges(changes: any): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    handleWrapperClick(): void;
    /**
     * @hidden
     */
    handleActiveColorClick(): void;
    /**
     * Focuses the wrapper of the ColorPicker.
     */
    focus(): void;
    /**
     * @hidden
     */
    handleWrapperFocus(): void;
    /**
     * Blurs the ColorPicker.
     */
    blur(): void;
    /**
     * @hidden
     */
    handleWrapperBlur(): void;
    /**
     * Clears the color value of the ColorPicker.
     */
    reset(): void;
    /**
     * Toggles the popup of the ColorPicker.
     * Does not trigger the `open` and `close` events of the component.
     *
     * @param open An optional parameter. Specifies whether the popup will be opened or closed.
     */
    toggle(open?: boolean): void;
    /**
     * @hidden
     */
    handleValueChange(color: string, closePopup: boolean): void;
    /**
     * @hidden
     */
    handlePopupBlur(event: FocusEvent): void;
    /**
     * @hidden
     */
    writeValue(value: string): void;
    /**
     * @hidden
     */
    registerOnChange(fn: any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: any): void;
    /**
     * @hidden
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * @hidden
     */
    handleWrapperKeyDown(event: any): void;
    /**
     * @hidden
     */
    handlePopupKeyDown(keyCode: number): void;
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty(): boolean;
    private toggleWithEvents;
    private openPopup;
    private closePopup;
    private notifyNgTouched;
    private notifyNgChanged;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ColorPickerComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ColorPickerComponent, "kendo-colorpicker", never, { "focusableId": "focusableId"; "view": "view"; "readonly": "readonly"; "disabled": "disabled"; "format": "format"; "value": "value"; "popupSettings": "popupSettings"; "paletteSettings": "paletteSettings"; "gradientSettings": "gradientSettings"; "tabindex": "tabindex"; "icon": "icon"; "iconClass": "iconClass"; }, { "valueChange": "valueChange"; "open": "open"; "close": "close"; "onFocus": "focus"; "onBlur": "blur"; "activeColorClick": "activeColorClick"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3JwaWNrZXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNvbG9ycGlja2VyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFBvcHVwU2VydmljZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbmltcG9ydCB7IFBvcHVwU2V0dGluZ3MsIFByZXZlbnRhYmxlRXZlbnQsIFBhbGV0dGVTZXR0aW5ncywgT3V0cHV0Rm9ybWF0LCBBY3RpdmVDb2xvckNsaWNrRXZlbnQsIENvbG9yUGlja2VyVmlldywgR3JhZGllbnRTZXR0aW5ncyB9IGZyb20gJy4vbW9kZWxzJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIENvbG9yUGlja2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19jb2xvcnBpY2tlciAlfSkuXG4gKiBEZXNpZ25lZCB0byByZXBsYWNlIHRoZSBgPGlucHV0IHR5cGU9XCJjb2xvclwiPmAgSFRNTDUgdGFnIHdoaWNoIGlzIG5vdCB3aWRlbHkgc3VwcG9ydGVkIGluIGJyb3dzZXJzLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDb2xvclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIHByaXZhdGUgcG9wdXBTZXJ2aWNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBob3N0Q2xhc3NlczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGlyZWN0aW9uOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGZvY3VzYWJsZUlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGF0IHZpZXcgdGhlIENvbG9yUGlja2VyIHdpbGwgcmVuZGVyIGluIHRoZSBwb3B1cC5cbiAgICAgKi9cbiAgICB2aWV3OiBDb2xvclBpY2tlclZpZXc7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVhZC1vbmx5IHN0YXRlIG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKi9cbiAgICByZWFkb25seTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBvdXRwdXQgZm9ybWF0IG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKiBUaGUgaW5wdXQgdmFsdWUgbWF5IGJlIGluIGEgZGlmZmVyZW50IGZvcm1hdC4gSG93ZXZlciwgaXQgd2lsbCBiZSBwYXJzZWQgaW50byB0aGUgb3V0cHV0IGBmb3JtYXRgXG4gICAgICogYWZ0ZXIgdGhlIGNvbXBvbmVudCBwcm9jZXNzZXMgaXQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYGdyYWRpZW50YCB2aWV3IGlzIHVzZWQgd2l0aCB0aGUgYG9wYWNpdHlgIG9wdGlvbiBzZXQgdG8gdHJ1ZSwgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZCBhbmQgYHJnYmFgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOlxuICAgICAqICogYHJnYmFgIChkZWZhdWx0KVxuICAgICAqICogYGhleGBcbiAgICAgKiAqIFtgbmFtZWBdKGh0dHBzOi8vd3d3LnczLm9yZy93aWtpL0NTUy9Qcm9wZXJ0aWVzL2NvbG9yL2tleXdvcmRzKVxuICAgICAqL1xuICAgIGZvcm1hdDogT3V0cHV0Rm9ybWF0O1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIGluaXRpYWxseSBzZWxlY3RlZCBjb2xvci5cbiAgICAgKi9cbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBvcHVwIG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKi9cbiAgICBwb3B1cFNldHRpbmdzOiBQb3B1cFNldHRpbmdzO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBhbGV0dGUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIENvbG9yUGlja2VyIHBvcHVwLlxuICAgICAqL1xuICAgIHBhbGV0dGVTZXR0aW5nczogUGFsZXR0ZVNldHRpbmdzO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGdyYWRpZW50IHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBDb2xvclBpY2tlciBwb3B1cC5cbiAgICAgKi9cbiAgICBncmFkaWVudFNldHRpbmdzOiBHcmFkaWVudFNldHRpbmdzO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG5hbWUgb2YgYW4gW2V4aXN0aW5nIGljb24gaW4gdGhlIEtlbmRvIFVJIHRoZW1lXSh7JSBzbHVnIGljb25zICV9KS5cbiAgICAgKiBQcm92aWRlIG9ubHkgdGhlIG5hbWUgb2YgdGhlIGljb24gd2l0aG91dCB0aGUgYGstaWNvbmAgb3IgdGhlIGBrLWktYCBwcmVmaXhlcy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYGVkaXQtdG9vbHNgIHdpbGwgYmUgcGFyc2VkIHRvIGBrLWljb24gay1pLWVkaXQtdG9vbHNgLlxuICAgICAqL1xuICAgIGljb246IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBIENTUyBjbGFzcyBuYW1lIHdoaWNoIGRpc3BsYXlzIGFuIGljb24gaW4gdGhlIENvbG9yUGlja2VyIGJ1dHRvbi5cbiAgICAgKiBgaWNvbkNsYXNzYCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGBuZ0NsYXNzYCBzeW50YXguXG4gICAgICpcbiAgICAgKiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgYGljb25gIGlmIGJvdGggYXJlIGRlZmluZWQuXG4gICAgICovXG4gICAgaWNvbkNsYXNzOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBib29sZWFuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBbYHRhYmluZGV4YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICB0YWJpbmRleDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBwb3B1cCBpcyBhYm91dCB0byBvcGVuLlxuICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBjbG9zZWQuXG4gICAgICovXG4gICAgb3BlbjogRXZlbnRFbWl0dGVyPFByZXZlbnRhYmxlRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCBpdCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIG9wZW4uXG4gICAgICovXG4gICAgY2xvc2U6IEV2ZW50RW1pdHRlcjxQcmV2ZW50YWJsZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgQ29sb3JQaWNrZXIgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIENvbG9yUGlja2VyIGlzIGJsdXJyZWQuXG4gICAgICovXG4gICAgb25CbHVyOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGxlZnQgc2lkZSBvZiB0aGUgQ29sb3JQaWNrZXIgd3JhcHBlciBpcyBjbGlja2VkLlxuICAgICAqIFRoZSBldmVudCBpcyB0cmlnZ2VyZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGEgQ29sb3JQaWNrZXIgaWNvbiBpcyBzZXQgb3Igbm90LlxuICAgICAqXG4gICAgICogVGhlIFtgQWN0aXZlQ29sb3JDbGlja0V2ZW50YF0oeyUgc2x1ZyBhcGlfaW5wdXRzX2FjdGl2ZWNvbG9yY2xpY2tldmVudCAlfSkgZXZlbnQgcHJvdmlkZXMgdGhlIG9wdGlvbiB0byBwcmV2ZW50IHRoZSBwb3B1cCBvcGVuaW5nLlxuICAgICAqL1xuICAgIGFjdGl2ZUNvbG9yQ2xpY2s6IEV2ZW50RW1pdHRlcjxBY3RpdmVDb2xvckNsaWNrRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBDb2xvclBpY2tlciB3cmFwcGVyIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgaXNGb2N1c2VkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBDb2xvclBpY2tlciBwb3B1cCBpcyBvcGVuLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlzT3BlbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaWNvblN0eWxlczogc3RyaW5nIHwgc3RyaW5nW10gfCB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IGJvb2xlYW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHJlZmVyZW5jZSB0byBhIGNvbnRhaW5lciBlbGVtZW50IGluc2lkZSB0aGUgY29tcG9uZW50IG1hcmt1cC5cbiAgICAgKiBUaGUgY29udGFpbmVyIGVsZW1lbnQgcmVmZXJlbmNlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGFwcGVuZGVkIHBvcHVwJm1kYXNoO1xuICAgICAqIGZvciBleGFtcGxlLCBpbnNpZGUgdGhlIGNvbXBvbmVudCBtYXJrdXAuXG4gICAgICovXG4gICAgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xuICAgIHByaXZhdGUgd3JhcHBlcjtcbiAgICBwcml2YXRlIHBvcHVwVGVtcGxhdGU7XG4gICAgcHJpdmF0ZSBwYWxldHRlO1xuICAgIHByaXZhdGUgcG9wdXBSZWY7XG4gICAgcHJpdmF0ZSBfdmFsdWU7XG4gICAgcHJpdmF0ZSBfdGFiaW5kZXg7XG4gICAgcHJpdmF0ZSBfcG9wdXBTZXR0aW5ncztcbiAgICBwcml2YXRlIF9wYWxldHRlU2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBfZ3JhZGllbnRTZXR0aW5ncztcbiAgICBwcml2YXRlIGR5bmFtaWNSVExTdWJzY3JpcHRpb247XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlOiBQb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2U6IExvY2FsaXphdGlvblNlcnZpY2UpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogYW55KTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVXcmFwcGVyQ2xpY2soKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWN0aXZlQ29sb3JDbGljaygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHdyYXBwZXIgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAqL1xuICAgIGZvY3VzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVdyYXBwZXJGb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKi9cbiAgICBibHVyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVdyYXBwZXJCbHVyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjb2xvciB2YWx1ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgcmVzZXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBwb3B1cCBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICogRG9lcyBub3QgdHJpZ2dlciB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW4gQW4gb3B0aW9uYWwgcGFyYW1ldGVyLiBTcGVjaWZpZXMgd2hldGhlciB0aGUgcG9wdXAgd2lsbCBiZSBvcGVuZWQgb3IgY2xvc2VkLlxuICAgICAqL1xuICAgIHRvZ2dsZShvcGVuPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVZhbHVlQ2hhbmdlKGNvbG9yOiBzdHJpbmcsIGNsb3NlUG9wdXA6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQb3B1cEJsdXIoZXZlbnQ6IEZvY3VzRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlcktleURvd24oZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVBvcHVwS2V5RG93bihrZXlDb2RlOiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKTogYm9vbGVhbjtcbiAgICBwcml2YXRlIHRvZ2dsZVdpdGhFdmVudHM7XG4gICAgcHJpdmF0ZSBvcGVuUG9wdXA7XG4gICAgcHJpdmF0ZSBjbG9zZVBvcHVwO1xuICAgIHByaXZhdGUgbm90aWZ5TmdUb3VjaGVkO1xuICAgIHByaXZhdGUgbm90aWZ5TmdDaGFuZ2VkO1xufVxuIl19