/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, EventEmitter, OnChanges, Renderer2, SimpleChanges, NgZone, Injector, ChangeDetectorRef } from '@angular/core';
import { AbstractControl, ControlValueAccessor, Validator } from '@angular/forms';
import { MaskingService } from './masking.service';
/**
 * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-maskedtextbox
 *          [mask]="mask"
 *          [value]="value">
 *      </kendo-maskedtextbox>
 *     `
 * })
 *
 * class AppComponent {
 *  public value: string = "9580128055807792";
 *  public mask: string = "0000-0000-0000-0000";
 * }
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class MaskedTextBoxComponent implements ControlValueAccessor, OnChanges, Validator {
    private service;
    private renderer;
    private hostElement;
    private ngZone;
    private injector;
    private changeDetector;
    /**
     * @hidden
     */
    focusableId: string;
    /**
     * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).
     */
    disabled: boolean;
    /**
     * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).
     */
    readonly: boolean;
    /**
     * Sets the title of the `input` element.
     */
    title: string;
    direction: string;
    hostClasses: boolean;
    readonly hostDisabledClass: boolean;
    /**
     * Represents the current mask ([see example]({% slug value_maskedtextbox %})).
     * If no mask is set, the component behaves as a standard `type="text"` input.
     *
     * > If the mask allows for spaces, set the [`promptPlaceholder`]({% slug api_inputs_maskedtextboxcomponent %}#toc-promptplaceholder)
     * to a character that is not accepted by the mask.
     */
    mask: string;
    /**
     * Provides a value for the MaskedTextBox.
     */
    value: string;
    /**
     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).
     */
    rules: {
        [key: string]: RegExp;
    };
    /**
     * Represents a prompt character for the masked value.
     * @default `_`
     */
    prompt: string;
    /**
     * Indicates a character which represents an empty position in the raw value.
     * @default ' '
     */
    promptPlaceholder: string;
    /**
     * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).
     * @default false
     */
    includeLiterals: boolean;
    /**
     * Specifies if the mask should be shown on focus for empty value.
     */
    maskOnFocus: boolean;
    /**
     * Determines whether the built-in mask validator is enforced when a form is validated
     * ([see example]({% slug validation_maskedtextbox %})).
     * @default true
     */
    maskValidation: boolean;
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    tabindex: number;
    /**
     * @hidden
     */
    tabIndex: number;
    /**
     * Fires each time the user focuses the `input` element.
     *
     * > To wire the event programmatically, use the `onFocus` property.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-maskedtextbox (focus)="handleFocus()"></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent {
     *   public handleFocus(): void {
     *      console.log("Component is focused");
     *   }
     * }
     * ```
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires each time the `input` element gets blurred.
     *
     * > To wire the event programmatically, use the `onBlur` property.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-maskedtextbox (blur)="handleBlur()"></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent {
     *   public handleBlur(): void {
     *      console.log("Component is blurred");
     *   }
     * }
     * ```
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires each time the value changes.
     */
    valueChange: EventEmitter<string>;
    /**
     * Represents the `ElementRef` of the visible `input` element.
     */
    input: ElementRef;
    protected isFocused: boolean;
    private maskedValue;
    private focusClick;
    private defaultRules;
    private _rules;
    private isPasted;
    private selection;
    private control;
    constructor(service: MaskingService, renderer: Renderer2, hostElement: ElementRef, ngZone: NgZone, injector: Injector, changeDetector: ChangeDetectorRef, rtl: boolean);
    ngOnInit(): void;
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.
     */
    isEmpty(): boolean;
    /**
     * @hidden
     */
    handleFocus: () => void;
    /**
     * @hidden
     */
    handleClick: () => void;
    /**
     * @hidden
     */
    handleBlur: () => void;
    /**
     * @hidden
     */
    handleDragDrop(): boolean;
    /**
     * Focuses the MaskedTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="maskedinput.focus()">Focus the input</button>
     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus(): void;
    /**
     * Blurs the MaskedTextBox.
     */
    blur(): void;
    /**
     * @hidden
     */
    pasteHandler(e: any): void;
    /**
     * @hidden
     */
    inputHandler(e: any): void;
    /**
     * @hidden
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * @hidden
     * Writes a new value to the element.
     */
    writeValue(value: string): void;
    /**
     * @hidden
     * Sets the function that will be called when a `change` event is triggered.
     */
    registerOnChange(fn: (_: any) => void): void;
    /**
     * @hidden
     * Sets the function that will be called when a `touch` event is triggered.
     */
    registerOnTouched(fn: () => void): void;
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * @hidden
     */
    validate(_: AbstractControl): any;
    /**
     * @hidden
     */
    updateValue(maskedValue: string): void;
    protected onChange: (_: any) => void;
    protected onTouched: () => void;
    private updateInput;
    private extractChanges;
    private updateService;
    private setSelection;
    private readonly emptyMask;
    private setFocusSelection;
    private focused;
    private normalizeValue;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MaskedTextBoxComponent, [null, null, null, null, null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MaskedTextBoxComponent, "kendo-maskedtextbox", ["kendoMaskedTextBox"], { "focusableId": "focusableId"; "disabled": "disabled"; "readonly": "readonly"; "prompt": "prompt"; "promptPlaceholder": "promptPlaceholder"; "includeLiterals": "includeLiterals"; "maskOnFocus": "maskOnFocus"; "maskValidation": "maskValidation"; "tabindex": "tabindex"; "rules": "rules"; "tabIndex": "tabIndex"; "value": "value"; "title": "title"; "mask": "mask"; }, { "onFocus": "focus"; "onBlur": "blur"; "valueChange": "valueChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFza2VkdGV4dGJveC5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsibWFza2VkdGV4dGJveC5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2VzLCBOZ1pvbmUsIEluamVjdG9yLCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTWFza2luZ1NlcnZpY2UgfSBmcm9tICcuL21hc2tpbmcuc2VydmljZSc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBNYXNrZWRUZXh0Qm94IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19tYXNrZWR0ZXh0Ym94ICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICA8a2VuZG8tbWFza2VkdGV4dGJveFxuICogICAgICAgICAgW21hc2tdPVwibWFza1wiXG4gKiAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIj5cbiAqICAgICAgPC9rZW5kby1tYXNrZWR0ZXh0Ym94PlxuICogICAgIGBcbiAqIH0pXG4gKlxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICBwdWJsaWMgdmFsdWU6IHN0cmluZyA9IFwiOTU4MDEyODA1NTgwNzc5MlwiO1xuICogIHB1YmxpYyBtYXNrOiBzdHJpbmcgPSBcIjAwMDAtMDAwMC0wMDAwLTAwMDBcIjtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNYXNrZWRUZXh0Qm94Q29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uQ2hhbmdlcywgVmFsaWRhdG9yIHtcbiAgICBwcml2YXRlIHNlcnZpY2U7XG4gICAgcHJpdmF0ZSByZW5kZXJlcjtcbiAgICBwcml2YXRlIGhvc3RFbGVtZW50O1xuICAgIHByaXZhdGUgbmdab25lO1xuICAgIHByaXZhdGUgaW5qZWN0b3I7XG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZm9jdXNhYmxlSWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIE1hc2tlZFRleHRCb3ggaXMgZGlzYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9tYXNrZWR0ZXh0Ym94ICV9KSkuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBNYXNrZWRUZXh0Qm94IGlzIGluIGl0cyByZWFkLW9ubHkgc3RhdGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9tYXNrZWR0ZXh0Ym94ICV9KSkuXG4gICAgICovXG4gICAgcmVhZG9ubHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGl0bGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgKi9cbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRpcmVjdGlvbjogc3RyaW5nO1xuICAgIGhvc3RDbGFzc2VzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGhvc3REaXNhYmxlZENsYXNzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbWFzayAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHZhbHVlX21hc2tlZHRleHRib3ggJX0pKS5cbiAgICAgKiBJZiBubyBtYXNrIGlzIHNldCwgdGhlIGNvbXBvbmVudCBiZWhhdmVzIGFzIGEgc3RhbmRhcmQgYHR5cGU9XCJ0ZXh0XCJgIGlucHV0LlxuICAgICAqXG4gICAgICogPiBJZiB0aGUgbWFzayBhbGxvd3MgZm9yIHNwYWNlcywgc2V0IHRoZSBbYHByb21wdFBsYWNlaG9sZGVyYF0oeyUgc2x1ZyBhcGlfaW5wdXRzX21hc2tlZHRleHRib3hjb21wb25lbnQgJX0jdG9jLXByb21wdHBsYWNlaG9sZGVyKVxuICAgICAqIHRvIGEgY2hhcmFjdGVyIHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBtYXNrLlxuICAgICAqL1xuICAgIG1hc2s6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHZhbHVlIGZvciB0aGUgTWFza2VkVGV4dEJveC5cbiAgICAgKi9cbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgdGhlIFJlZ0V4cC1iYXNlZCBtYXNrIHZhbGlkYXRpb24gYXJyYXkgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBtYXNrc19tYXNrZWR0ZXh0Ym94ICV9KSkuXG4gICAgICovXG4gICAgcnVsZXM6IHtcbiAgICAgICAgW2tleTogc3RyaW5nXTogUmVnRXhwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIHByb21wdCBjaGFyYWN0ZXIgZm9yIHRoZSBtYXNrZWQgdmFsdWUuXG4gICAgICogQGRlZmF1bHQgYF9gXG4gICAgICovXG4gICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGEgY2hhcmFjdGVyIHdoaWNoIHJlcHJlc2VudHMgYW4gZW1wdHkgcG9zaXRpb24gaW4gdGhlIHJhdyB2YWx1ZS5cbiAgICAgKiBAZGVmYXVsdCAnICdcbiAgICAgKi9cbiAgICBwcm9tcHRQbGFjZWhvbGRlcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgbGl0ZXJhbHMgaW4gdGhlIHJhdyB2YWx1ZSAgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB2YWx1ZV9tYXNrZWR0ZXh0Ym94ICV9KSkuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBpbmNsdWRlTGl0ZXJhbHM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBtYXNrIHNob3VsZCBiZSBzaG93biBvbiBmb2N1cyBmb3IgZW1wdHkgdmFsdWUuXG4gICAgICovXG4gICAgbWFza09uRm9jdXM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidWlsdC1pbiBtYXNrIHZhbGlkYXRvciBpcyBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyB2YWxpZGF0ZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHZhbGlkYXRpb25fbWFza2VkdGV4dGJveCAlfSkpLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBtYXNrVmFsaWRhdGlvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIFtgdGFiaW5kZXhgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4KSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHRhYmluZGV4OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRhYkluZGV4OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgKlxuICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25Gb2N1c2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLW1hc2tlZHRleHRib3g+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBoYW5kbGVGb2N1cygpOiB2b2lkIHtcbiAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGZvY3VzZWRcIik7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uRm9jdXM6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgYGlucHV0YCBlbGVtZW50IGdldHMgYmx1cnJlZC5cbiAgICAgKlxuICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8a2VuZG8tbWFza2VkdGV4dGJveCAoYmx1cik9XCJoYW5kbGVCbHVyKClcIj48L2tlbmRvLW1hc2tlZHRleHRib3g+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBoYW5kbGVCbHVyKCk6IHZvaWQge1xuICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgYmx1cnJlZFwiKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25CbHVyOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICovXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGBFbGVtZW50UmVmYCBvZiB0aGUgdmlzaWJsZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAgICovXG4gICAgaW5wdXQ6IEVsZW1lbnRSZWY7XG4gICAgcHJvdGVjdGVkIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIG1hc2tlZFZhbHVlO1xuICAgIHByaXZhdGUgZm9jdXNDbGljaztcbiAgICBwcml2YXRlIGRlZmF1bHRSdWxlcztcbiAgICBwcml2YXRlIF9ydWxlcztcbiAgICBwcml2YXRlIGlzUGFzdGVkO1xuICAgIHByaXZhdGUgc2VsZWN0aW9uO1xuICAgIHByaXZhdGUgY29udHJvbDtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlOiBNYXNraW5nU2VydmljZSwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgaG9zdEVsZW1lbnQ6IEVsZW1lbnRSZWYsIG5nWm9uZTogTmdab25lLCBpbmplY3RvcjogSW5qZWN0b3IsIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZiwgcnRsOiBib29sZWFuKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgTWFza2VkVGV4dEJveCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZvY3VzOiAoKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogKCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQmx1cjogKCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ0Ryb3AoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBNYXNrZWRUZXh0Qm94LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cIm1hc2tlZGlucHV0LmZvY3VzKClcIj5Gb2N1cyB0aGUgaW5wdXQ8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggI21hc2tlZGlucHV0Pjwva2VuZG8tbWFza2VkdGV4dGJveD5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgTWFza2VkVGV4dEJveC5cbiAgICAgKi9cbiAgICBibHVyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHBhc3RlSGFuZGxlcihlOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpbnB1dEhhbmRsZXIoZTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFdyaXRlcyBhIG5ldyB2YWx1ZSB0byB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIGB0b3VjaGAgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShfOiBBYnN0cmFjdENvbnRyb2wpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHVwZGF0ZVZhbHVlKG1hc2tlZFZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBvbkNoYW5nZTogKF86IGFueSkgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgb25Ub3VjaGVkOiAoKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgdXBkYXRlSW5wdXQ7XG4gICAgcHJpdmF0ZSBleHRyYWN0Q2hhbmdlcztcbiAgICBwcml2YXRlIHVwZGF0ZVNlcnZpY2U7XG4gICAgcHJpdmF0ZSBzZXRTZWxlY3Rpb247XG4gICAgcHJpdmF0ZSByZWFkb25seSBlbXB0eU1hc2s7XG4gICAgcHJpdmF0ZSBzZXRGb2N1c1NlbGVjdGlvbjtcbiAgICBwcml2YXRlIGZvY3VzZWQ7XG4gICAgcHJpdmF0ZSBub3JtYWxpemVWYWx1ZTtcbn1cbiJdfQ==