/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { EventEmitter, Injector, Renderer2, NgZone, ChangeDetectorRef, ElementRef } from '@angular/core';
import { Subscription } from 'rxjs';
import { NgControl } from '@angular/forms';
import { LabelTemplateDirective } from './label-template.directive';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
export declare abstract class SliderBase {
    protected localizationService: LocalizationService;
    protected injector: Injector;
    protected renderer: Renderer2;
    protected ngZone: NgZone;
    protected changeDetector: ChangeDetectorRef;
    protected hostElement: ElementRef;
    /**
     * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
     * for each tick is its Slider value. If you use a callback function, the function accepts an argument
     * that holds the value of the component and returns a string with the new title.
     */
    title: (value: number) => string;
    /**
     * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
     *
     * The available options are:
     * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
     * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
     * * `both`&mdash; (Default) The tick marks are located on both sides of the track.
     * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
     */
    tickPlacement: string;
    /**
     * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
     * ([see example]({% slug orientation_slider %})).
     */
    vertical: boolean;
    /**
     * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
     * The attribute accepts both integers and floating-point numbers.
     */
    min: number;
    /**
     * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
     * The attribute accepts both integers and floating-point numbers.
     */
    max: number;
    /**
     * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
     * Accepts positive values only. Can be an integer or a floating-point number.
     */
    smallStep: number;
    /**
     * Specifies that every n<sup>th</sup> tick will be large and will have a label
     * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
     * Accepts positive integer values only.
     */
    largeStep: number;
    /**
     * Sets the width between each two ticks along the track ([see example]({% slug ticks_slider %}#toc-width)). The value
     * has to be set in pixels. If no `fixedTickWidth` is provided, the Slider automatically adjusts the tick width to
     * accommodate the elements within the size of the component.
     */
    fixedTickWidth: number;
    /**
     * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).
     */
    disabled: boolean;
    /**
     * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
     */
    readonly: boolean;
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
     */
    tabindex: number;
    /**
     * Fires each time the user focuses the component.
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires each time the component is blurred.
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires each time the user selects a new value.
     */
    valueChange: EventEmitter<any>;
    direction: string;
    readonly horizontalClass: boolean;
    readonly verticalClass: boolean;
    sliderClass: boolean;
    widgetClass: boolean;
    readonly disabledClass: boolean;
    wrapper: ElementRef;
    track: ElementRef;
    sliderSelection: ElementRef;
    ticksContainer: ElementRef;
    ticks: any;
    labelTemplate: LabelTemplateDirective;
    protected subscriptions: Subscription;
    protected isFocused: boolean;
    protected isDragged: boolean;
    protected control: NgControl;
    constructor(localizationService: LocalizationService, injector: Injector, renderer: Renderer2, ngZone: NgZone, changeDetector: ChangeDetectorRef, hostElement: ElementRef);
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean): void;
    ngOnInit(): void;
    /**
     * @hidden
     */
    abstract sizeComponent(animate?: boolean): void;
    /**
     * @hidden
     */
    readonly isDisabled: boolean;
    /**
     * @hidden
     */
    ifEnabled: Function;
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty(): boolean;
    protected readonly reverse: boolean;
    protected readonly keyBinding: Object;
    protected resetStyles(elements: HTMLElement[]): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SliderBase, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<SliderBase, never, never, { "title": "title"; "tickPlacement": "tickPlacement"; "vertical": "vertical"; "min": "min"; "max": "max"; "smallStep": "smallStep"; "largeStep": "largeStep"; "disabled": "disabled"; "readonly": "readonly"; "tabindex": "tabindex"; "fixedTickWidth": "fixedTickWidth"; }, { "onFocus": "focus"; "onBlur": "blur"; "valueChange": "valueChange"; }, ["labelTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLWJhc2UuZC50cyIsInNvdXJjZXMiOlsic2xpZGVyLWJhc2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEluamVjdG9yLCBSZW5kZXJlcjIsIE5nWm9uZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vbGFiZWwtdGVtcGxhdGUuZGlyZWN0aXZlJztcbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBTbGlkZXJCYXNlIHtcbiAgICBwcm90ZWN0ZWQgbG9jYWxpemF0aW9uU2VydmljZTogTG9jYWxpemF0aW9uU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgaW5qZWN0b3I6IEluamVjdG9yO1xuICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyO1xuICAgIHByb3RlY3RlZCBuZ1pvbmU6IE5nWm9uZTtcbiAgICBwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIHByb3RlY3RlZCBob3N0RWxlbWVudDogRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB0aXRsZSBvZiB0aGUgdGlja3MgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aWNrc19zbGlkZXIgJX0jdG9jLXRpdGxlcykpLiBUaGUgZGVmYXVsdCB0aXRsZVxuICAgICAqIGZvciBlYWNoIHRpY2sgaXMgaXRzIFNsaWRlciB2YWx1ZS4gSWYgeW91IHVzZSBhIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gYWNjZXB0cyBhbiBhcmd1bWVudFxuICAgICAqIHRoYXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgbmV3IHRpdGxlLlxuICAgICAqL1xuICAgIHRpdGxlOiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIERlbm90ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIG1hcmtzIGluIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aWNrc19zbGlkZXIgJX0jdG9jLXBsYWNlbWVudCkpLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgKiAqIGBiZWZvcmVgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIHRvIHRoZSB0b3Agc2lkZSBvZiB0aGUgaG9yaXpvbnRhbCB0cmFjayBvciB0byB0aGUgbGVmdCBzaWRlIG9mIGEgdmVydGljYWwgdHJhY2suXG4gICAgICogKiBgYWZ0ZXJgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIHRvIHRoZSBib3R0b20gc2lkZSBvZiB0aGUgaG9yaXpvbnRhbCB0cmFjayBvciB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdmVydGljYWwgdHJhY2suXG4gICAgICogKiBgYm90aGAmbWRhc2g7IChEZWZhdWx0KSBUaGUgdGljayBtYXJrcyBhcmUgbG9jYXRlZCBvbiBib3RoIHNpZGVzIG9mIHRoZSB0cmFjay5cbiAgICAgKiAqIGBub25lYCZtZGFzaDtUaGUgdGljayBtYXJrcyBhcmUgbm90IHZpc2libGUuIFRoZSBhY3R1YWwgZWxlbWVudHMgYXJlIG5vdCBhZGRlZCB0byB0aGUgRE9NIHRyZWUuXG4gICAgICovXG4gICAgdGlja1BsYWNlbWVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIElmIGB2ZXJ0aWNhbGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBTbGlkZXIgY2hhbmdlcyBmcm9tIGhvcml6b250YWwgdG8gdmVydGljYWxcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG9yaWVudGF0aW9uX3NsaWRlciAlfSkpLlxuICAgICAqL1xuICAgIHZlcnRpY2FsOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVkZWZpbmVkc3RlcHNfc2xpZGVyICV9I3RvYy1zbWFsbC1zdGVwcykpLlxuICAgICAqIFRoZSBhdHRyaWJ1dGUgYWNjZXB0cyBib3RoIGludGVnZXJzIGFuZCBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqL1xuICAgIG1pbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVkZWZpbmVkc3RlcHNfc2xpZGVyICV9I3RvYy1zbWFsbC1zdGVwcykpLlxuICAgICAqIFRoZSBhdHRyaWJ1dGUgYWNjZXB0cyBib3RoIGludGVnZXJzIGFuZCBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqL1xuICAgIG1heDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGVwIHZhbHVlIG9mIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVkZWZpbmVkc3RlcHNfc2xpZGVyICV9I3RvYy1zbWFsbC1zdGVwcykpLlxuICAgICAqIEFjY2VwdHMgcG9zaXRpdmUgdmFsdWVzIG9ubHkuIENhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIHNtYWxsU3RlcDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGF0IGV2ZXJ5IG48c3VwPnRoPC9zdXA+IHRpY2sgd2lsbCBiZSBsYXJnZSBhbmQgd2lsbCBoYXZlIGEgbGFiZWxcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWRlZmluZWRzdGVwc19zbGlkZXIgJX0jdG9jLWxhcmdlLXN0ZXBzKSkuXG4gICAgICogQWNjZXB0cyBwb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlcyBvbmx5LlxuICAgICAqL1xuICAgIGxhcmdlU3RlcDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdpZHRoIGJldHdlZW4gZWFjaCB0d28gdGlja3MgYWxvbmcgdGhlIHRyYWNrIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGlja3Nfc2xpZGVyICV9I3RvYy13aWR0aCkpLiBUaGUgdmFsdWVcbiAgICAgKiBoYXMgdG8gYmUgc2V0IGluIHBpeGVscy4gSWYgbm8gYGZpeGVkVGlja1dpZHRoYCBpcyBwcm92aWRlZCwgdGhlIFNsaWRlciBhdXRvbWF0aWNhbGx5IGFkanVzdHMgdGhlIHRpY2sgd2lkdGggdG9cbiAgICAgKiBhY2NvbW1vZGF0ZSB0aGUgZWxlbWVudHMgd2l0aGluIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgZml4ZWRUaWNrV2lkdGg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFNsaWRlciBpcyBkaXNhYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkc3RhdGVfc2xpZGVyICV9KSkuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBTbGlkZXIgaXMgaW4gaXRzIHJlYWQtb25seSBzdGF0ZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlYWRvbmx5X3NsaWRlciAlfSkpLlxuICAgICAqL1xuICAgIHJlYWRvbmx5OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBTbGlkZXIuXG4gICAgICovXG4gICAgdGFiaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIG9uRm9jdXM6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgY29tcG9uZW50IGlzIGJsdXJyZWQuXG4gICAgICovXG4gICAgb25CbHVyOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgZGlyZWN0aW9uOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgaG9yaXpvbnRhbENsYXNzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHZlcnRpY2FsQ2xhc3M6IGJvb2xlYW47XG4gICAgc2xpZGVyQ2xhc3M6IGJvb2xlYW47XG4gICAgd2lkZ2V0Q2xhc3M6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgZGlzYWJsZWRDbGFzczogYm9vbGVhbjtcbiAgICB3cmFwcGVyOiBFbGVtZW50UmVmO1xuICAgIHRyYWNrOiBFbGVtZW50UmVmO1xuICAgIHNsaWRlclNlbGVjdGlvbjogRWxlbWVudFJlZjtcbiAgICB0aWNrc0NvbnRhaW5lcjogRWxlbWVudFJlZjtcbiAgICB0aWNrczogYW55O1xuICAgIGxhYmVsVGVtcGxhdGU6IExhYmVsVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgcHJvdGVjdGVkIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbjtcbiAgICBwcm90ZWN0ZWQgaXNGb2N1c2VkOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBpc0RyYWdnZWQ6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGNvbnRyb2w6IE5nQ29udHJvbDtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb25TZXJ2aWNlOiBMb2NhbGl6YXRpb25TZXJ2aWNlLCBpbmplY3RvcjogSW5qZWN0b3IsIHJlbmRlcmVyOiBSZW5kZXJlcjIsIG5nWm9uZTogTmdab25lLCBjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGhvc3RFbGVtZW50OiBFbGVtZW50UmVmKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFic3RyYWN0IHNpemVDb21wb25lbnQoYW5pbWF0ZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWFkb25seSBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpZkVuYWJsZWQ6IEZ1bmN0aW9uO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBGbG9hdGluZ0xhYmVsIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcmV2ZXJzZTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkga2V5QmluZGluZzogT2JqZWN0O1xuICAgIHByb3RlY3RlZCByZXNldFN0eWxlcyhlbGVtZW50czogSFRNTEVsZW1lbnRbXSk6IHZvaWQ7XG59XG4iXX0=