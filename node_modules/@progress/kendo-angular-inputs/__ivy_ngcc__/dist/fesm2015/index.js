/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { isDevMode, Directive, TemplateRef, Optional, EventEmitter, Input, Output, HostBinding, ViewChild, ElementRef, ContentChild, Component, forwardRef, Injector, Renderer2, NgZone, ChangeDetectorRef, Inject, Injectable, HostListener, ViewChildren, NgModule, ViewContainerRef, ContentChildren } from '@angular/core';
import { NgControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, RadioControlValueAccessor } from '@angular/forms';
import { Subscription, fromEvent, interval, merge, Observable } from 'rxjs';
import { take, filter, concatMap, startWith, takeUntil, skip, debounceTime } from 'rxjs/operators';
import { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';
import { Keys, guid, hasObservers, anyChanged, isDocumentAvailable, KendoInput, isChanged, DraggableModule, EventsModule, ResizeSensorModule } from '@progress/kendo-angular-common';
import { browser, mobileOS } from '@progress/kendo-common';
import { IntlService } from '@progress/kendo-angular-intl';
import { CommonModule } from '@angular/common';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { Color, parseColor, namedColors } from '@progress/kendo-drawing';

/**
 * @hidden
 *
 * Checks if the value is `null` or `undefined`. Falsy values like '', 0, false, NaN, etc. are regarded as present.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@progress/kendo-angular-common';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@progress/kendo-angular-intl';
import * as ɵngcc5 from '@progress/kendo-angular-popup';

const _c0 = ["wrap"];
const _c1 = ["track"];
const _c2 = ["sliderSelection"];
const _c3 = ["ticks"];
const _c4 = ["draghandle"];
const _c5 = ["decreaseButton"];
const _c6 = ["increaseButton"];
var I18N_7;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the **Increase** button of the Slider.
     * @meaning kendo.slider.increment
     */ 
    const MSG_EXTERNAL_8302125540024939132$$DIST_FESM2015_INDEX_JS_8 = goog.getMsg("increment");
    I18N_7 = MSG_EXTERNAL_8302125540024939132$$DIST_FESM2015_INDEX_JS_8;
}
else {
    I18N_7 = $localize `:kendo.slider.increment|The title of the **Increase** button of the Slider.␟0fa71630d40c425b9c366afd7f6c3cecc5bef59d␟8302125540024939132:increment`;
}
var I18N_9;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the **Decrease** button of the Slider.
     * @meaning kendo.slider.decrement
     */ 
    const MSG_EXTERNAL_652458644240352212$$DIST_FESM2015_INDEX_JS_10 = goog.getMsg("decrement");
    I18N_9 = MSG_EXTERNAL_652458644240352212$$DIST_FESM2015_INDEX_JS_10;
}
else {
    I18N_9 = $localize `:kendo.slider.decrement|The title of the **Decrease** button of the Slider.␟042c26f68d78afd6834ea46a5f7533850fe8c800␟652458644240352212:decrement`;
}
var I18N_11;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the drag handle of the Slider.
     * @meaning kendo.slider.dragHandle
     */ 
    const MSG_EXTERNAL_9117416417579607469$$DIST_FESM2015_INDEX_JS_12 = goog.getMsg("Drag");
    I18N_11 = MSG_EXTERNAL_9117416417579607469$$DIST_FESM2015_INDEX_JS_12;
}
else {
    I18N_11 = $localize `:kendo.slider.dragHandle|The title of the drag handle of the Slider.␟481eb98e9cd8ef8e8b22051796441901e883763d␟9117416417579607469:Drag`;
}
const _c13 = ["increment", I18N_7, "decrement", I18N_9, "dragHandle", I18N_11];
function SliderComponent_a_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 13, 14);
    ɵngcc0.ɵɵelement(2, "span", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r1.decrementMessage);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.decrementMessage);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-w", !ctx_r1.vertical)("k-i-arrow-s", ctx_r1.vertical);
} }
function SliderComponent_a_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 16, 17);
    ɵngcc0.ɵɵelement(2, "span", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r2.incrementMessage);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.incrementMessage);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-i-arrow-e", !ctx_r2.vertical)("k-i-arrow-n", ctx_r2.vertical);
} }
function SliderComponent_ul_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 18, 19);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r3.title)("vertical", ctx_r3.vertical)("step", ctx_r3.smallStep)("largeStep", ctx_r3.largeStep)("min", ctx_r3.min)("max", ctx_r3.max)("labelTemplate", ctx_r3.labelTemplate == null ? null : ctx_r3.labelTemplate.templateRef);
} }
const _c14 = function (a0, a1, a2, a3) { return { focus: a0, blur: a1, click: a2, keydown: a3 }; };
const _c15 = ["draghandleStart"];
const _c16 = ["draghandleEnd"];
var I18N_17;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the **Start** drag handle of the Slider.
     * @meaning kendo.rangeslider.dragHandleStart
     */ 
    const MSG_EXTERNAL_1512034289801794423$$DIST_FESM2015_INDEX_JS_18 = goog.getMsg("Drag");
    I18N_17 = MSG_EXTERNAL_1512034289801794423$$DIST_FESM2015_INDEX_JS_18;
}
else {
    I18N_17 = $localize `:kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.␟4487c64285c2d8cdb336be783b6cb9304ce86007␟1512034289801794423:Drag`;
}
var I18N_19;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the **End** drag handle of the Slider.
     * @meaning kendo.rangeslider.dragHandleEnd
     */ 
    const MSG_EXTERNAL_6915505327582510906$$DIST_FESM2015_INDEX_JS_20 = goog.getMsg("Drag");
    I18N_19 = MSG_EXTERNAL_6915505327582510906$$DIST_FESM2015_INDEX_JS_20;
}
else {
    I18N_19 = $localize `:kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.␟d6af522570cc1aff06104cee4b7780d6835e01d1␟6915505327582510906:Drag`;
}
const _c21 = ["dragHandleStart", I18N_17, "dragHandleEnd", I18N_19];
function RangeSliderComponent_ul_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 12, 13);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tickTitle", ctx_r1.title)("vertical", ctx_r1.vertical)("step", ctx_r1.smallStep)("largeStep", ctx_r1.largeStep)("min", ctx_r1.min)("max", ctx_r1.max)("labelTemplate", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);
} }
const _c22 = function (a0, a1) { return { click: a0, keydown: a1 }; };
const _c23 = ["wrapper"];
var I18N_24;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The **On** label of the Switch.
     * @meaning kendo.switch.on
     */ 
    const MSG_EXTERNAL_818154782831456441$$DIST_FESM2015_INDEX_JS_25 = goog.getMsg("ON");
    I18N_24 = MSG_EXTERNAL_818154782831456441$$DIST_FESM2015_INDEX_JS_25;
}
else {
    I18N_24 = $localize `:kendo.switch.on|The **On** label of the Switch.␟155f0a38198ffbf0429c5dbf9765e74f246a8617␟818154782831456441:ON`;
}
var I18N_26;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The **Off** label of the Switch.
     * @meaning kendo.switch.off
     */ 
    const MSG_EXTERNAL_759820891948194060$$DIST_FESM2015_INDEX_JS_27 = goog.getMsg("OFF");
    I18N_26 = MSG_EXTERNAL_759820891948194060$$DIST_FESM2015_INDEX_JS_27;
}
else {
    I18N_26 = $localize `:kendo.switch.off|The **Off** label of the Switch.␟79df1a6d2b35c32b2948e3cee56dd3ffe28127bc␟759820891948194060:OFF`;
}
const _c28 = ["on", I18N_24, "off", I18N_26];
const _c29 = function (a0, a1, a2, a3) { return { click: a0, keydown: a1, focus: a2, blur: a3 }; };
function TextBoxContainerComponent_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("for", ctx_r0.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.floatingLabel);
} }
const _c30 = ["*"];
const _c31 = ["numericInput"];
const _c32 = ["numericWrap"];
var I18N_33;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title for the **Increment** button in the NumericTextBox
     * @meaning kendo.numerictextbox.increment
     */ 
    const MSG_EXTERNAL_4467784268438010275$$DIST_FESM2015_INDEX_JS_34 = goog.getMsg("Increase value");
    I18N_33 = MSG_EXTERNAL_4467784268438010275$$DIST_FESM2015_INDEX_JS_34;
}
else {
    I18N_33 = $localize `:kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox␟0fc68540ffa04fdc246cf6cf8a1fed085f8b19a5␟4467784268438010275:Increase value`;
}
var I18N_35;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title for the **Decrement** button in the NumericTextBox
     * @meaning kendo.numerictextbox.decrement
     */ 
    const MSG_EXTERNAL_3960022057994897997$$DIST_FESM2015_INDEX_JS_36 = goog.getMsg("Decrease value");
    I18N_35 = MSG_EXTERNAL_3960022057994897997$$DIST_FESM2015_INDEX_JS_36;
}
else {
    I18N_35 = $localize `:kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox␟df4751834075bf970c77d0da2c960b4e19a6b0dd␟3960022057994897997:Decrease value`;
}
const _c37 = ["increment", I18N_33, "decrement", I18N_35];
const _c38 = function (a0, a1) { return { mouseup: a0, mouseleave: a1 }; };
const _c39 = function (a0) { return { mousedown: a0 }; };
function NumericTextBoxComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵelementStart(1, "span", 7);
    ɵngcc0.ɵɵelement(2, "span", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", 9);
    ɵngcc0.ɵɵelement(4, "span", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(11, _c38, ctx_r2.releaseArrow, ctx_r2.releaseArrow));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r2.arrowDirection === ctx_r2.ArrowDirection.Up);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(14, _c39, ctx_r2.increasePress))("title", ctx_r2.incrementTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.incrementTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵclassProp("k-state-active", ctx_r2.arrowDirection === ctx_r2.ArrowDirection.Down);
    ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction1(16, _c39, ctx_r2.decreasePress))("title", ctx_r2.decrementTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.decrementTitle);
} }
const _c40 = function (a0, a1) { return { mousewheel: a0, DOMMouseScroll: a1 }; };
const _c41 = function (a0, a1, a2, a3, a4, a5, a6) { return { mousedown: a0, dragenter: a1, keydown: a2, input: a3, focus: a4, blur: a5, paste: a6 }; };
const _c42 = ["input"];
const _c43 = function (a0, a1, a2, a3, a4) { return { focus: a0, blur: a1, click: a2, dragstart: a3, drop: a4 }; };
const _c44 = ["tickElement"];
const _c45 = ["kendoSliderTicks", ""];
function SliderTicksComponent_li_0_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵelementContainer(1, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.labelTemplate || _r1)("ngTemplateOutletContext", tick_r3);
} }
function SliderTicksComponent_li_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementContainerEnd();
} }
function SliderTicksComponent_li_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 2, 3);
    ɵngcc0.ɵɵelementContainerStart(2, 4);
    ɵngcc0.ɵɵtemplate(3, SliderTicksComponent_li_0_span_3_Template, 2, 2, "span", 5);
    ɵngcc0.ɵɵtemplate(4, SliderTicksComponent_li_0_ng_container_4_Template, 2, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("title", ctx_r0.tickTitle(tick_r3.value));
    ɵngcc0.ɵɵproperty("ngClass", tick_r3.classes);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngSwitch", tick_r3.large);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", false);
} }
function SliderTicksComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const value_r8 = ctx.value;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.tickTitle(value_r8), " ");
} }
var I18N_46;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title for the **Clear** button in the TextBox.
     * @meaning kendo.textbox.clear
     */ 
    const MSG_EXTERNAL_2651889799249671820$$DIST_FESM2015_INDEX_JS_47 = goog.getMsg("Clear");
    I18N_46 = MSG_EXTERNAL_2651889799249671820$$DIST_FESM2015_INDEX_JS_47;
}
else {
    I18N_46 = $localize `:kendo.textbox.clear|The title for the **Clear** button in the TextBox.␟e6edd360fd0d3c873c0d94a3aecd3c407d31da5a␟2651889799249671820:Clear`;
}
const _c48 = ["clear", I18N_46];
function TextBoxComponent_3_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_3_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.prefixTemplate == null ? null : ctx_r0.prefixTemplate.templateRef);
} }
function TextBoxComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r2.errorIconClasses);
} }
function TextBoxComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.successIconClasses);
} }
function TextBoxComponent_span_9_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵlistener("click", function TextBoxComponent_span_9_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.clearValue(); })("mousedown", function TextBoxComponent_span_9_Template_span_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); return $event.preventDefault(); })("keydown.enter", function TextBoxComponent_span_9_Template_span_keydown_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.clearValue($event); })("keydown.space", function TextBoxComponent_span_9_Template_span_keydown_space_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.clearValue($event); });
    ɵngcc0.ɵɵelement(1, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tabindex", ctx_r4.tabIndex)("title", ctx_r4.clearTitle());
    ɵngcc0.ɵɵattribute("aria-label", ctx_r4.clearTitle());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r4.clearButtonClasses);
} }
function TextBoxComponent_10_ng_template_0_Template(rf, ctx) { }
function TextBoxComponent_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TextBoxComponent_10_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.suffixTemplate == null ? null : ctx_r5.suffixTemplate.templateRef);
} }
const _c49 = function (a0, a1, a2) { return { focus: a0, blur: a1, input: a2 }; };
const _c50 = ["palette"];
const _c51 = ["container"];
const _c52 = ["popupTemplate"];
function ColorPickerComponent_span_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
function ColorPickerComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵlistener("click", function ColorPickerComponent_span_2_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.handleActiveColorClick(); });
    ɵngcc0.ɵɵtemplate(1, ColorPickerComponent_span_2_span_1_Template, 1, 0, "span", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r1.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.value);
} }
function ColorPickerComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵlistener("click", function ColorPickerComponent_span_3_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.handleActiveColorClick(); });
    ɵngcc0.ɵɵelement(1, "span", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r2.iconStyles);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r2.value);
} }
function ColorPickerComponent_ng_template_6_kendo_colorgradient_0_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-colorgradient", 15);
    ɵngcc0.ɵɵlistener("focusout", function ColorPickerComponent_ng_template_6_kendo_colorgradient_0_Template_kendo_colorgradient_focusout_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.handlePopupBlur($event); })("valueChange", function ColorPickerComponent_ng_template_6_kendo_colorgradient_0_Template_kendo_colorgradient_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.handleValueChange($event, false); })("keydown", function ColorPickerComponent_ng_template_6_kendo_colorgradient_0_Template_kendo_colorgradient_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.handlePopupKeyDown($event.keyCode); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", ctx_r11.value)("format", ctx_r11.format)("opacity", ctx_r11.gradientSettings.opacity)("clearButton", ctx_r11.gradientSettings.clearButton);
} }
function ColorPickerComponent_ng_template_6_kendo_colorpalette_1_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-colorpalette", 16, 17);
    ɵngcc0.ɵɵlistener("blur", function ColorPickerComponent_ng_template_6_kendo_colorpalette_1_Template_kendo_colorpalette_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(2); return ctx_r18.handlePopupBlur($event); })("cellSelection", function ColorPickerComponent_ng_template_6_kendo_colorpalette_1_Template_kendo_colorpalette_cellSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r20 = ɵngcc0.ɵɵnextContext(2); return ctx_r20.handleValueChange($event, true); })("mousedown", function ColorPickerComponent_ng_template_6_kendo_colorpalette_1_Template_kendo_colorpalette_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); return $event.preventDefault(); })("keydown", function ColorPickerComponent_ng_template_6_kendo_colorpalette_1_Template_kendo_colorpalette_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r22 = ɵngcc0.ɵɵnextContext(2); return ctx_r22.handlePopupKeyDown($event.keyCode); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("palette", ctx_r12.paletteSettings.palette)("columns", ctx_r12.paletteSettings.columns)("tileSize", ctx_r12.paletteSettings.tileSize)("format", ctx_r12.format)("value", ctx_r12.value);
} }
function ColorPickerComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ColorPickerComponent_ng_template_6_kendo_colorgradient_0_Template, 1, 4, "kendo-colorgradient", 13);
    ɵngcc0.ɵɵtemplate(1, ColorPickerComponent_ng_template_6_kendo_colorpalette_1_Template, 2, 5, "kendo-colorpalette", 14);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.view === "gradient" || ctx_r4.view === "combo");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.view === "palette" || ctx_r4.view === "combo");
} }
const _c53 = function (a1, a2) { return { "k-picker-wrap": true, "k-state-disabled": a1, "k-state-focused": a2 }; };
const _c54 = function (a0, a1, a2, a3) { return { backgroundColor: a0, width: a1, height: a2, minWidth: a3 }; };
function ColorPaletteComponent_tr_3_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener("click", function ColorPaletteComponent_tr_3_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const color_r4 = ctx.$implicit; const colIndex_r5 = ctx.index; const rowIndex_r2 = ɵngcc0.ɵɵnextContext().index; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleCellSelection(color_r4, { row: rowIndex_r2, col: colIndex_r5 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const color_r4 = ctx.$implicit;
    const colIndex_r5 = ctx.index;
    const rowIndex_r2 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-state-selected", (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.row) === rowIndex_r2 && (ctx_r3.focusedCell == null ? null : ctx_r3.focusedCell.col) === colIndex_r5);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction4(4, _c54, color_r4, ctx_r3.tileLayout.width + "px", ctx_r3.tileLayout.height + "px", ctx_r3.tileLayout.width + "px"));
    ɵngcc0.ɵɵattribute("value", color_r4);
} }
function ColorPaletteComponent_tr_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 3);
    ɵngcc0.ɵɵtemplate(1, ColorPaletteComponent_tr_3_td_1_Template, 1, 9, "td", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", row_r1);
} }
const _c55 = ["alphaSlider"];
const _c56 = ["gradientWrapper"];
const _c57 = ["dragHandle"];
function ColorGradientComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_span_7_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.reset(); });
    ɵngcc0.ɵɵelement(1, "span", 11);
    ɵngcc0.ɵɵelementEnd();
} }
function ColorGradientComponent_kendo_slider_9_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-slider", 12, 13);
    ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_kendo_slider_9_Template_kendo_slider_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.handleAlphaSliderChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r3.disabled)("readonly", ctx_r3.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 100)("smallStep", 1)("largeStep", 10)("value", ctx_r3.alphaSliderValue);
} }
function ColorInputComponent_kendo_numerictextbox_6_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-numerictextbox", 9);
    ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_kendo_numerictextbox_6_Template_kendo_numerictextbox_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.rgba.a = $event; })("blur", function ColorInputComponent_kendo_numerictextbox_6_Template_kendo_numerictextbox_blur_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_kendo_numerictextbox_6_Template_kendo_numerictextbox_valueChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleRgbaValueChange(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("min", 0)("max", 1)("value", ctx_r1.rgba.a)("autoCorrect", true)("spinners", false)("step", 0.01)("format", "n2")("decimals", 2);
} }
function ColorInputComponent_div_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtext(1, "a");
    ɵngcc0.ɵɵelementEnd();
} }
function FormFieldComponent_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "hasHints"]);
} }
function FormFieldComponent_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "hasErrors"]);
} }
const _c58 = [[["label"], ["kendo-label"]], "*", [["kendo-formhint"]], [["kendo-formerror"]]];
const _c59 = ["label, kendo-label", "*", "kendo-formhint", "kendo-formerror"];
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const areSame = (value1, value2) => value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);
/**
 * @hidden
 */
const requiresZoneOnBlur = (ngControl) => ngControl &&
    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur'));
/**
 * @hidden
 *
 * Fits the contender number into the specified bounds. If the number is NaN or null, the min is returned.
 *
 * @param contender Represents the number you want to fit into specified bounds.
 * @param min The inclusive lower bound number.
 * @param max The inclusive upper bound number.
 */
const fitIntoBounds = (contender, min, max) => {
    if (!isPresent(contender) || isNaN(contender)) {
        return min;
    }
    return contender <= min ? min : contender >= max ? max : contender;
};

/**
 * @hidden
 */
const MAX_PRECISION = 20;
/**
 * @hidden
 */
const limitPrecision = (precision) => Math.min(precision, MAX_PRECISION);
/**
 * @hidden
 */
const fractionLength = (value) => {
    return (String(value).split('.')[1] || "").length;
};
const maxFractionLength = (value1, value2) => {
    return Math.max(fractionLength(value1), fractionLength(value2));
};
/**
 * @hidden
 */
const toFixedPrecision = (value, precision) => {
    const maxPrecision = limitPrecision(precision);
    return parseFloat(value.toFixed(maxPrecision));
};
/**
 * @hidden
 */
const add = (value1, value2) => {
    const maxPrecision = maxFractionLength(value1, value2);
    return toFixedPrecision(value1 + value2, maxPrecision);
};
/**
 * @hidden
 */
const subtract = (value1, value2) => {
    return add(value1, -value2);
};
/**
 * @hidden
 */
const multiply = (value1, value2) => {
    const maxPrecision = fractionLength(value1) + fractionLength(value2);
    return toFixedPrecision(value1 * value2, maxPrecision);
};
/**
 * @hidden
 */
const divide = (dividend, divisor) => {
    if (divisor === 0) {
        return NaN;
    }
    const power = maxFractionLength(dividend, divisor);
    const correctionValue = Math.pow(10, power);
    return ((correctionValue * dividend) / (correctionValue * divisor));
};
/**
 * @hidden
 */
const remainder = (dividend, divisor) => {
    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));
};

/**
 * @hidden
 */
const calculateFixedTrackSize = ({ max, min, smallStep, fixedTickWidth }) => ((max - min) / smallStep) * fixedTickWidth;
/**
 * @hidden
 */
const calculateTrackSize = (wrapperWidth, offset, showButtons = true) => {
    const BUTTONS_COUNT = 2;
    const trackOffset = showButtons ? parseFloat(offset) * BUTTONS_COUNT : 0;
    const trackWidth = wrapperWidth - trackOffset;
    return Math.floor(trackWidth);
};
/**
 * @hidden
 */
const calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {
    if (smallStep <= 0) {
        throw new Error('Invalid argument: smallStep must be a positive number');
    }
    const adjustedRange = Math.abs(subtract(max, min));
    const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));
    const result = add(adjustedRatio, 1);
    return result;
};
/**
 * @hidden
 */
const calculateValueFromTick = (index, { max, min, smallStep, reverse, vertical }) => {
    const value = add(min, multiply(index, smallStep));
    return vertical || reverse ? Math.abs(subtract(value, max)) : value;
};
/**
 * @hidden
 */
const calculateHandlePosition = ({ handleWidth, trackWidth, min, max, reverse, value }) => {
    const halfHandleWidth = Math.floor(handleWidth / 2);
    const step = trackWidth / Math.abs(max - min);
    let pos = isPresent(value) ? step * (value - min) : min;
    if (reverse) {
        pos = trackWidth - pos;
    }
    return Math.floor(pos - halfHandleWidth);
};
/**
 * @hidden
 */
const decreaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {
    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    const stepValue = subtract(value, min);
    let result;
    const stepRemainder = remainder(stepValue, step);
    if (stepRemainder === 0) {
        result = subtract(stepValue, step);
    }
    else {
        result = subtract(stepValue, stepRemainder);
    }
    return limitValue(add(result, min), min, max);
};
/**
 * @hidden
 */
const increaseValueToStep = (value, { max, min, smallStep, largeStep }, large = false) => {
    const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    const stepValue = subtract(value, min);
    const stepRemainder = remainder(stepValue, step);
    const result = add(subtract(stepValue, stepRemainder), step);
    return limitValue(add(result, min), min, max);
};
/**
 * @hidden
 */
const isStartHandle = (dragHandle) => dragHandle.id.indexOf('k-start-handle') > -1;
/**
 * @hidden
 */
const snapValue = (value, options) => {
    const { smallStep, min, max } = options;
    const limited = limitValue(value, min, max);
    if (value !== limited) {
        return limited;
    }
    const left = decreaseValueToStep(value, options);
    const right = increaseValueToStep(value, options);
    if ((value - min) % smallStep === 0) {
        return value;
    }
    if (right - value <= (right - left) / 2) {
        return right;
    }
    return left;
};
/**
 * @hidden
 */
const trimValue = (max, min, value) => {
    if (value > max) {
        return max;
    }
    if (value < min) {
        return min;
    }
    return value;
};
/**
 * @hidden
 */
const trimValueRange = (max, min, value) => {
    return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];
};
/**
 * @hidden
 */
const identity = (value) => value;
/**
 * @hidden
 */
const isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);
/**
 * @hidden
 */
const elementOffset = (element) => {
    const box = element.getBoundingClientRect();
    const documentElement = document.documentElement;
    return {
        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)
    };
};
/**
 * @hidden
 */
const limitValue = (value, min, max) => {
    return Math.max(Math.min(value, max), min);
};
/**
 * @hidden
 */
const eventValue = (eventArgs, scaleElement, options) => {
    const { min, max, vertical, rtl } = options;
    const trackOffset = elementOffset(scaleElement);
    const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;
    const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);
    const offsetValue = offset * scale;
    let value = rtl || vertical ? max - offsetValue : min + offsetValue;
    const stepFractionLength = fractionLength(options.smallStep);
    value = toFixedPrecision(value, stepFractionLength + 1);
    return snapValue(value, options);
};
/**
 * @hidden
 */
const isButton = (element) => {
    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;
};
/**
 * @hidden
 */
const increment = (options) => {
    return increaseValueToStep(options.value, options);
};
/**
 * @hidden
 */
const decrement = (options) => {
    return decreaseValueToStep(options.value, options);
};
/**
 * @hidden
 */
const incrementLarge = (options) => {
    return increaseValueToStep(options.value, options, true);
};
/**
 * @hidden
 */
const decrementLarge = (options) => {
    return decreaseValueToStep(options.value, options, true);
};
/**
 * @hidden
 */
const validateValue = (value) => {
    if (isDevMode && value && value[0] > value[1]) {
        throw new Error('[RangeSlider] The start value should not be greater than the end value.');
    }
};

/**
 * @hidden
 */
class SliderModelBase {
    constructor(props, wrapper, track, renderer) {
        this.props = props;
        this.wrapper = wrapper;
        this.track = track;
        this.renderer = renderer;
        this.props = props;
        this.wrapper = wrapper;
        this.track = track;
        this.tickSizes = this.getTickSizes();
    }
    resizeTrack() {
        const orientation = this.props.vertical ? 'height' : 'width';
        const trackWidth = this.trackWidth();
        this.track.style[orientation] = `${trackWidth}px`;
    }
    resizeTicks(ticksContainer, ticks) {
        const dimension = this.props.vertical ? "height" : "width";
        [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);
        if (this.props.vertical) {
            this.adjustPadding(ticksContainer);
        }
    }
    resizeWrapper() {
        const dimension = this.props.vertical ? "height" : "width";
        const wrapperSize = this.elementSize(this.wrapper);
        const trackWidth = calculateTrackSize(wrapperSize, this.elementOffset(this.track));
        const fixedTrackWidth = calculateFixedTrackSize(this.props);
        const wrapperParentEl = this.wrapper.parentElement;
        if (trackWidth > fixedTrackWidth) {
            wrapperParentEl.style[dimension] = `${wrapperSize - (trackWidth - fixedTrackWidth)}px`;
        }
        else {
            wrapperParentEl.style[dimension] = `${wrapperSize + (fixedTrackWidth - trackWidth)}px`;
        }
    }
    trackWidth() {
        if (this.props.fixedTickWidth) {
            return calculateFixedTrackSize(this.props);
        }
        return calculateTrackSize(this.elementSize(this.wrapper), this.elementOffset(this.track), this.props.buttons);
    }
    getTickSizes() {
        const { min, max, smallStep } = this.props;
        const count = calculateTicksCount(min, max, smallStep);
        const trackSize = this.trackWidth();
        const distStep = trackSize / subtract(max, min);
        const result = [];
        let usedSpace = 0;
        let endPoint = 0;
        for (let i = 0; i < count; i++) {
            if (i === 0 || i === count - 1) {
                endPoint += (smallStep / 2) * distStep;
            }
            else {
                endPoint += smallStep * distStep;
            }
            // ensure that the sum of the tick sizes does not exceed the track width
            endPoint = +endPoint.toFixed(2) - 0.01;
            const size = Math.round(endPoint - usedSpace);
            result.push(size);
            usedSpace += size;
        }
        if (usedSpace >= trackSize) {
            result[result.length - 1] -= 1;
        }
        return result;
    }
    adjustPadding(ticksContainer) {
        const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);
        const trackWidth = this.trackWidth();
        const reminder = trackWidth - totalTickSize;
        if (reminder !== 0) {
            const padding = reminder + this.elementOffset(this.track);
            ticksContainer.style.paddingTop = `${padding}px`;
        }
    }
    elementOffset(element) {
        const { vertical } = this.props;
        const style = getComputedStyle(element);
        return parseInt(vertical ? style.bottom : style.left, 10);
    }
    elementSize(element) {
        const { vertical } = this.props;
        return vertical ? element.clientHeight : element.clientWidth;
    }
}

/**
 * @hidden
 */
class SliderModel extends SliderModelBase {
    positionHandle(dragHandle) {
        const { max, min, reverse, vertical } = this.props;
        const position = vertical ? 'bottom' : 'left';
        const trackWidth = this.trackWidth();
        const value = trimValue(max, min, this.props.value);
        this.handlePosition = calculateHandlePosition({
            min,
            max,
            reverse,
            value,
            trackWidth,
            handleWidth: dragHandle.offsetWidth
        });
        this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);
    }
    positionSelection(dragHandle, selection) {
        const { reverse, vertical } = this.props;
        const dimension = vertical ? 'height' : 'width';
        const handleWidth = Math.floor(dragHandle.offsetWidth / 2);
        let size = this.handlePosition + handleWidth;
        if (reverse) {
            size = this.trackWidth() - size;
        }
        this.renderer.setStyle(selection, dimension, `${size}px`);
    }
}

const UNTOUCHED = 'ng-untouched';
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
/**
 * @hidden
 */
function invokeElementMethod(element, name, ...args) {
    if (element && element.nativeElement) {
        return element.nativeElement[name].apply(element.nativeElement, args);
    }
}
/**
 * @hidden
 */
const isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);
/**
 * @hidden
 */
const containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};

/**
 * Represents the template for the labels of the Slider.
 * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside
 * the `<kendo-slider>` tag. The template context is passed to the `label` value.
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-slider [largeStep]="2">
 *           <ng-template kendoSliderLabelTemplate let-value="value">
 *             <b>{{value}}</b>
 *           </ng-template>
 *         </kendo-slider>
 *     `
 * })
 *
 * class AppComponent {
 * }
 *
 * ```
 */
class LabelTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
LabelTemplateDirective.ɵfac = function LabelTemplateDirective_Factory(t) { return new (t || LabelTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
LabelTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LabelTemplateDirective, selectors: [["", "kendoSliderLabelTemplate", ""]] });
/** @nocollapse */
LabelTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoSliderLabelTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class SliderBase {
    constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {
        this.localizationService = localizationService;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
         * for each tick is its Slider value. If you use a callback function, the function accepts an argument
         * that holds the value of the component and returns a string with the new title.
         */
        this.title = identity;
        /**
         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
         *
         * The available options are:
         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
         * * `both`&mdash; (Default) The tick marks are located on both sides of the track.
         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
         */
        this.tickPlacement = 'both';
        /**
         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
         * ([see example]({% slug orientation_slider %})).
         */
        this.vertical = false;
        /**
         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.min = 0;
        /**
         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.max = 10;
        /**
         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * Accepts positive values only. Can be an integer or a floating-point number.
         */
        this.smallStep = 1;
        /**
         * Specifies that every n<sup>th</sup> tick will be large and will have a label
         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
         * Accepts positive integer values only.
         */
        this.largeStep = null;
        /**
         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the component.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the component is blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.sliderClass = true;
        this.widgetClass = true;
        this.subscriptions = new Subscription();
        /**
         * @hidden
         */
        this.ifEnabled = (callback, event) => {
            if (!this.isDisabled) {
                callback.call(this, event);
            }
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get horizontalClass() {
        return !this.vertical;
    }
    get verticalClass() {
        return this.vertical;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngOnInit() {
        this.subscriptions.add(this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
            this.sizeComponent();
        }));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    get reverse() {
        return this.localizationService.rtl && !this.vertical;
    }
    get keyBinding() {
        const reverse = this.reverse;
        return {
            [Keys.ArrowLeft]: reverse ? increment : decrement,
            [Keys.ArrowRight]: reverse ? decrement : increment,
            [Keys.ArrowDown]: decrement,
            [Keys.ArrowUp]: increment,
            [Keys.PageUp]: incrementLarge,
            [Keys.PageDown]: decrementLarge,
            [Keys.Home]: ({ min }) => min,
            [Keys.End]: ({ max }) => max
        };
    }
    resetStyles(elements) {
        elements.forEach(el => {
            if (el) {
                if (this.vertical) {
                    this.renderer.removeStyle(el, 'width');
                    this.renderer.removeStyle(el, 'left');
                    this.renderer.removeStyle(el, 'right');
                }
                else {
                    this.renderer.removeStyle(el, 'height');
                    this.renderer.removeStyle(el, 'bottom');
                }
                this.renderer.removeStyle(el, 'padding-top');
            }
        });
    }
}
SliderBase.ɵfac = function SliderBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SliderBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SliderBase, contentQueries: function SliderBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LabelTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
    } }, viewQuery: function SliderBase_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(_c3, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sliderSelection = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticks = _t.first);
    } }, hostVars: 11, hostBindings: function SliderBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-slider", ctx.sliderClass)("k-widget", ctx.widgetClass)("k-slider-horizontal", ctx.horizontalClass)("k-slider-vertical", ctx.verticalClass)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { title: "title", tickPlacement: "tickPlacement", vertical: "vertical", min: "min", max: "max", smallStep: "smallStep", largeStep: "largeStep", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", fixedTickWidth: "fixedTickWidth" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" } });
SliderBase.propDecorators = {
    title: [{ type: Input }],
    tickPlacement: [{ type: Input }],
    vertical: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    smallStep: [{ type: Input }],
    largeStep: [{ type: Input }],
    fixedTickWidth: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tabindex: [{ type: Input }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    valueChange: [{ type: Output }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    horizontalClass: [{ type: HostBinding, args: ['class.k-slider-horizontal',] }],
    verticalClass: [{ type: HostBinding, args: ['class.k-slider-vertical',] }],
    sliderClass: [{ type: HostBinding, args: ['class.k-slider',] }],
    widgetClass: [{ type: HostBinding, args: ['class.k-widget',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    wrapper: [{ type: ViewChild, args: ['wrap', { static: true },] }],
    track: [{ type: ViewChild, args: ['track', { static: true },] }],
    sliderSelection: [{ type: ViewChild, args: ['sliderSelection', { static: true },] }],
    ticksContainer: [{ type: ViewChild, args: ['ticks', { read: ElementRef },] }],
    ticks: [{ type: ViewChild, args: ['ticks',] }],
    labelTemplate: [{ type: ContentChild, args: [LabelTemplateDirective,] }]
};


const FOCUSED = 'k-state-focused';
const PRESSED = 'k-pressed';
/**
 * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).
 */
class SliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines if the animation will be played on value change.
         * Regardless of this setting, no animation will be played during the initial rendering.
         */
        this.animate = true;
        /**
         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
         * When `showButtons` is set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * The current value of the Slider when it is initially displayed.
         * The component can use either NgModel or the `value` binding but not both of them at the same time.
         */
        this.value = this.min;
        /**
         * @hidden
         */
        this.handleFocus = () => {
            this.focused = true;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            const target = args.target;
            if (!this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {
                const value = eventValue(args, this.track.nativeElement, this.getProps());
                this.changeValue(value);
            }
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            const value = handler(options);
            this.changeValue(trimValue(max, min, value));
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.decreaseValue = () => {
            this.changeValue(decreaseValueToStep(this.value, this.getProps()));
        };
        this.increaseValue = () => {
            this.changeValue(increaseValueToStep(this.value, this.getProps()));
        };
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Focuses the Slider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        invokeElementMethod(this.wrapper, 'focus');
    }
    /**
     * Blurs the Slider.
     */
    blur() {
        invokeElementMethod(this.wrapper, 'blur');
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent(false);
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
            this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent(false));
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    get incrementMessage() {
        return this.incrementTitle || this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementMessage() {
        return this.decrementTitle || this.localizationService.get('decrement');
    }
    /**
     * @hidden
     */
    get dragHandleMessage() {
        return this.dragHandleTitle || this.localizationService.get('dragHandle');
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.focus();
        this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        this.dragging = false; //needed for animation
        this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.sizeComponent(this.animate);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.sizeComponent(this.animate);
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent(animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleEl = this.draghandle.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        if (!animate) {
            this.renderer.removeClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new SliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleEl);
        model.positionSelection(dragHandleEl, selectionEl);
        if (!animate) {
            this.hostElement.nativeElement.getBoundingClientRect();
            this.renderer.addClass(this.hostElement.nativeElement, 'k-slider-transitions');
        }
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(element, FOCUSED);
            }
            else {
                this.renderer.removeClass(element, FOCUSED);
            }
            this.isFocused = value;
        }
    }
    set dragging(value) {
        if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = this.draghandle.nativeElement;
            if (value) {
                this.renderer.addClass(sliderSelection, PRESSED);
                this.renderer.addClass(draghandle, PRESSED);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED);
                this.renderer.removeClass(draghandle, PRESSED);
            }
            this.isDragged = value;
        }
    }
    setValueChangeInterval(element, callback) {
        this.ngZone.runOutsideAngular(() => {
            const mousedown = fromEvent(element, 'mousedown');
            const mouseup = fromEvent(element, 'mouseup');
            const mouseout = fromEvent(element, 'mouseout');
            const subscription = mousedown.pipe(filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout))))).subscribe(() => {
                this.focus();
                callback();
            });
            this.subscriptions.add(subscription);
        });
    }
    getProps() {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValue(this.max, this.min, this.value),
            vertical: this.vertical
        };
    }
}
SliderComponent.ɵfac = function SliderComponent_Factory(t) { return new (t || SliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SliderComponent, selectors: [["kendo-slider"]], viewQuery: function SliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c4, true);
        ɵngcc0.ɵɵviewQuery(_c5, true);
        ɵngcc0.ɵɵviewQuery(_c6, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draghandle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.decreaseButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.increaseButton = _t.first);
    } }, inputs: { focusableId: "focusableId", animate: "animate", showButtons: "showButtons", value: "value", tabIndex: "tabIndex", dragHandleTitle: "dragHandleTitle", incrementTitle: "incrementTitle", decrementTitle: "decrementTitle" }, exportAs: ["kendoSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.slider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent) },
            { provide: KendoInput, useExisting: forwardRef(() => SliderComponent) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 14, vars: 26, consts: [["kendoSliderLocalizedMessages", "", 6, "increment", "decrement", "dragHandle"], [1, "k-slider-wrap", 3, "id", "kendoEventsOutsideAngular"], ["wrap", ""], ["class", "k-button k-button-decrease", 3, "title", 4, "ngIf"], ["class", "k-button k-button-increase", 3, "title", 4, "ngIf"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], ["track", ""], [1, "k-slider-selection"], ["sliderSelection", ""], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "title", "kendoPress", "kendoDrag", "kendoRelease"], ["draghandle", ""], [3, "resize"], [1, "k-button", "k-button-decrease", 3, "title"], ["decreaseButton", ""], [1, "k-icon"], [1, "k-button", "k-button-increase", 3, "title"], ["increaseButton", ""], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"], ["ticks", ""]], template: function SliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c13);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(4, SliderComponent_a_4_Template, 3, 6, "a", 3);
        ɵngcc0.ɵɵtemplate(5, SliderComponent_a_5_Template, 3, 6, "a", 4);
        ɵngcc0.ɵɵtemplate(6, SliderComponent_ul_6_Template, 2, 7, "ul", 5);
        ɵngcc0.ɵɵelementStart(7, "div", 6, 7);
        ɵngcc0.ɵɵelement(9, "div", 8, 9);
        ɵngcc0.ɵɵelementStart(11, "a", 10, 11);
        ɵngcc0.ɵɵlistener("kendoPress", function SliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); })("kendoDrag", function SliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); })("kendoRelease", function SliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", 12);
        ɵngcc0.ɵɵlistener("resize", function SliderComponent_Template_kendo_resize_sensor_resize_13_listener() { return ctx.sizeComponent(false); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("k-slider-buttons", ctx.showButtons)("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction4(21, _c14, ctx.handleFocus, ctx.handleBlur, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButtons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵproperty("title", ctx.dragHandleMessage);
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
    } }, directives: function () { return [LocalizedSliderMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf, ɵngcc2.DraggableDirective, ɵngcc2.ResizeSensorComponent, SliderTicksComponent]; }, encapsulation: 2 });
/** @nocollapse */
SliderComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: Injector },
    { type: Renderer2 },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
SliderComponent.propDecorators = {
    focusableId: [{ type: Input }],
    dragHandleTitle: [{ type: Input }],
    incrementTitle: [{ type: Input }],
    animate: [{ type: Input }],
    decrementTitle: [{ type: Input }],
    showButtons: [{ type: Input }],
    value: [{ type: Input }],
    tabIndex: [{ type: Input }],
    draghandle: [{ type: ViewChild, args: ['draghandle', { static: true },] }],
    decreaseButton: [{ type: ViewChild, args: ['decreaseButton',] }],
    increaseButton: [{ type: ViewChild, args: ['increaseButton',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => SliderComponent) },
                    { provide: KendoInput, useExisting: forwardRef(() => SliderComponent) }
                ],
                selector: 'kendo-slider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >
        <div class="k-slider-wrap" #wrap
            [id]="focusableId"
            [class.k-slider-buttons]="showButtons"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [attr.tabindex]="disabled ? undefined : tabIndex"
            [kendoEventsOutsideAngular]="{ focus: handleFocus, blur: handleBlur, click: onWrapClick, keydown: onKeyDown }"
            >
            <a
                #decreaseButton
                *ngIf="showButtons"
                class="k-button k-button-decrease"
                [title]="decrementMessage"
                [attr.aria-label]="decrementMessage"
            >
                <span class="k-icon"
                    [class.k-i-arrow-w]="!vertical"
                    [class.k-i-arrow-s]="vertical"
                >
                </span>
            </a>
            <a
                *ngIf="showButtons"
                #increaseButton
                class="k-button k-button-increase"
                [title]="incrementMessage"
                [attr.aria-label]="incrementMessage"
            >
                <span class="k-icon"
                    [class.k-i-arrow-e]="!vertical"
                    [class.k-i-arrow-n]="vertical"
                >
                </span>
            </a>
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
            >
            </ul>
        <div #track class="k-slider-track">
            <div #sliderSelection class="k-slider-selection">
            </div>
                <a #draghandle
                    role="slider"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="dragHandleMessage"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress, $event)"
                    (kendoDrag)="ifEnabled(onHandleDrag, $event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
            </div>
            <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { focusableId: [{
            type: Input
        }], animate: [{
            type: Input
        }], showButtons: [{
            type: Input
        }], value: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], dragHandleTitle: [{
            type: Input
        }], incrementTitle: [{
            type: Input
        }], decrementTitle: [{
            type: Input
        }], draghandle: [{
            type: ViewChild,
            args: ['draghandle', { static: true }]
        }], decreaseButton: [{
            type: ViewChild,
            args: ['decreaseButton']
        }], increaseButton: [{
            type: ViewChild,
            args: ['increaseButton']
        }] }); })();

/**
 * @hidden
 */
class RangeSliderModel extends SliderModelBase {
    positionHandle(dragHandle) {
        if (!dragHandle.id) {
            return;
        }
        const { max, min, reverse, vertical } = this.props;
        const position = vertical ? 'bottom' : 'left';
        const trackWidth = this.trackWidth();
        const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0]
            : trimValueRange(max, min, this.props.value)[1];
        if (isStartHandle(dragHandle)) {
            this.startHandlePosition = calculateHandlePosition({
                min,
                max,
                reverse,
                value,
                trackWidth,
                handleWidth: dragHandle.offsetWidth
            });
            this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);
        }
        else {
            this.endHandlePosition = calculateHandlePosition({
                min,
                max,
                reverse,
                value,
                trackWidth,
                handleWidth: dragHandle.offsetWidth
            });
            this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);
        }
    }
    positionSelection(dragHandle, selection) {
        const { reverse, vertical } = this.props;
        const dimension = vertical ? 'height' : 'width';
        const position = vertical ? 'bottom' : reverse ? 'right' : 'left';
        const handleWidth = Math.floor(dragHandle.offsetWidth / 2);
        const size = Math.abs(this.endHandlePosition - this.startHandlePosition);
        const currentSelectionPosition = vertical ? dragHandle.style.bottom : dragHandle.style.left;
        this.renderer.setStyle(selection, dimension, `${size}px`);
        this.renderer.setStyle(selection, position, reverse ? this.trackWidth() - parseFloat(currentSelectionPosition) - handleWidth + 'px'
            : parseFloat(currentSelectionPosition) + handleWidth + 'px');
    }
}

const PRESSED$1 = 'k-pressed';
/**
 * Represents the [Kendo UI RangeSlider component for Angular]({% slug overview_rangeslider %}).
 */
class RangeSliderComponent extends SliderBase {
    constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
        super(localization, injector, renderer, ngZone, changeDetector, hostElement);
        this.localization = localization;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.startHandleId = `k-start-handle-${guid()}`;
        /**
         * @hidden
         */
        this.endHandleId = `k-end-handle-${guid()}`;
        /**
         * @hidden
         */
        this.focusableId = this.startHandleId;
        this.handleZIndex = 0;
        this.activeHandle = 'startHandle';
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.onWrapClick = (args) => {
            if (!this.isDisabled) {
                this.value = this.value || [this.min, this.min];
                const trackValue = eventValue(args, this.track.nativeElement, this.getProps());
                let newRangeValue;
                const [startValue, endValue] = newRangeValue = this.value;
                if (trackValue <= startValue) {
                    newRangeValue = [trackValue, endValue];
                    this.activeHandle = 'startHandle';
                }
                else if (startValue < trackValue && trackValue < endValue) {
                    if (trackValue < (startValue + endValue) / 2) {
                        newRangeValue = [trackValue, endValue];
                        this.activeHandle = 'startHandle';
                    }
                    else {
                        newRangeValue = [startValue, trackValue];
                        this.activeHandle = 'endHandle';
                    }
                }
                else if (trackValue >= endValue) {
                    newRangeValue = [startValue, trackValue];
                    this.activeHandle = 'endHandle';
                }
                const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
                invokeElementMethod(activeHandle, 'focus');
                this.changeValue(newRangeValue);
            }
        };
        /**
         * @hidden
         */
        this.onKeyDown = (e) => {
            this.value = this.value || [this.min, this.min];
            const options = this.getProps();
            const { max, min } = options;
            const handler = this.keyBinding[e.keyCode];
            if (this.isDisabled || !handler) {
                return;
            }
            this.renderer.setStyle(e.target, 'zIndex', ++this.handleZIndex);
            const startHandleIsActive = isStartHandle(e.target);
            const value = handler(Object.assign({}, options, { value: startHandleIsActive ? this.value[0] : this.value[1] }));
            if (startHandleIsActive) {
                if (value > this.value[1]) {
                    this.value[1] = value;
                }
            }
            else {
                if (value < this.value[0]) {
                    this.value[0] = value;
                }
            }
            const trimmedValue = trimValue(max, min, value);
            const newValue = startHandleIsActive ? [trimmedValue, this.value[1]]
                : [this.value[0], trimmedValue];
            this.changeValue(newValue);
            e.preventDefault();
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    if (!this.focusChangedProgrammatically) {
                        this.onBlur.emit();
                    }
                });
            }
        };
    }
    /**
     * Focuses the RangeSlider.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *     <div>
     *         <button class="k-button" (click)="slider.focus()">Focus</button>
     *     </div>
     *     <kendo-rangeslider #slider></kendo-rangeslider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        this.focusChangedProgrammatically = true;
        invokeElementMethod(this.draghandleStart, 'focus');
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the RangeSlider.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const activeHandle = this.activeHandle === 'startHandle' ? this.draghandleStart : this.draghandleEnd;
        invokeElementMethod(activeHandle, 'blur');
        this.handleBlur();
        this.focusChangedProgrammatically = false;
    }
    ngOnInit() {
        if (!this.value) {
            this.value = [this.min, this.max];
        }
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (anyChanged(['value', 'fixedTickWidth', 'tickPlacement'], changes, true)) {
            if (changes.value && changes.value.currentValue) {
                validateValue(changes.value.currentValue);
            }
            this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this.sizeComponent();
            });
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.sizeComponent();
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(() => this.sizeComponent());
        }
        this.attachElementEventHandlers();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     */
    get valueText() {
        return this.value ? `${this.value[0]} - ${this.value[1]}` : '';
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        const target = args.originalEvent.target;
        this.draggedHandle = target;
        this.renderer.setStyle(target, 'zIndex', ++this.handleZIndex);
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        this.value = this.value || [this.min, this.min];
        const target = args.originalEvent.target;
        const lastCoords = this.draggedHandle.getBoundingClientRect();
        this.lastHandlePosition = { x: lastCoords.left, y: lastCoords.top };
        this.dragging = { value: true, target };
        const left = args.pageX < this.lastHandlePosition.x;
        const right = args.pageX > this.lastHandlePosition.x;
        const up = args.pageY > this.lastHandlePosition.y;
        const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);
        const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);
        const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);
        const activeStartHandle = isStartHandle(this.draggedHandle);
        const vertical = this.vertical;
        const horizontal = !vertical;
        const forward = (vertical && up) || (this.reverse ? horizontal && right : horizontal && left);
        // const forward = (this.reverse ? (!this.vertical && !left) : (!this.vertical && left)) || (this.vertical && up);
        if (this.value[0] === this.value[1]) {
            if (forward) {
                activeStartHandle ? moveStartHandle() : moveBothHandles();
            }
            else {
                activeStartHandle ? moveBothHandles() : moveEndHandle();
            }
        }
        else {
            activeStartHandle ? moveStartHandle() : moveEndHandle();
        }
    }
    /**
     * @hidden
     */
    onHandleRelease(args) {
        this.dragging = { value: false, target: args.originalEvent.target }; //needed for animation
        this.draggedHandle = undefined;
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        validateValue(value);
        this.value = value;
        this.sizeComponent();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    changeValue(value) {
        if (!this.value || !isSameRange(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                if (this.value) {
                    this.valueChange.emit(value);
                }
                this.sizeComponent();
            });
        }
    }
    /**
     * @hidden
     */
    sizeComponent() {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const track = this.track.nativeElement;
        const selectionEl = this.sliderSelection.nativeElement;
        const dragHandleStartEl = this.draghandleStart.nativeElement;
        const dragHandleEndEl = this.draghandleEnd.nativeElement;
        const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
        this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);
        const props = this.getProps();
        const model = new RangeSliderModel(props, wrapper, track, this.renderer);
        model.resizeTrack();
        if (this.ticks) { //for case when tickPlacement: none
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(element => element.nativeElement));
        }
        model.positionHandle(dragHandleStartEl);
        model.positionHandle(dragHandleEndEl);
        model.positionSelection(dragHandleStartEl, selectionEl);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    }
    /**
     * @hidden
     */
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    /**
     * @hidden
     * Used by the FloatingLabel to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            this.isFocused = value;
        }
    }
    set dragging(data) {
        if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {
            const sliderSelection = this.sliderSelection.nativeElement;
            const draghandle = data.target;
            if (data.value) {
                this.renderer.addClass(sliderSelection, PRESSED$1);
                this.renderer.addClass(draghandle, PRESSED$1);
            }
            else {
                this.renderer.removeClass(sliderSelection, PRESSED$1);
                this.renderer.removeClass(draghandle, PRESSED$1);
            }
            this.isDragged = data.value;
        }
    }
    getProps() {
        return {
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: trimValueRange(this.max, this.min, this.value),
            vertical: this.vertical,
            buttons: false
        };
    }
    attachElementEventHandlers() {
        const hostElement = this.hostElement.nativeElement;
        let tabbing = false;
        let cursorInsideWrapper = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        if (!this.focusChangedProgrammatically) {
                            this.onFocus.emit();
                        }
                        this.focused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
}
RangeSliderComponent.ɵfac = function RangeSliderComponent_Factory(t) { return new (t || RangeSliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
RangeSliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RangeSliderComponent, selectors: [["kendo-rangeslider"]], viewQuery: function RangeSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c15, true);
        ɵngcc0.ɵɵstaticViewQuery(_c16, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draghandleStart = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.draghandleEnd = _t.first);
    } }, inputs: { value: "value" }, exportAs: ["kendoRangeSlider"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
            { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent) },
            { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent) }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 14, vars: 33, consts: [["kendoSliderLocalizedMessages", "", 6, "dragHandleStart", "dragHandleEnd"], [1, "k-slider-wrap", 3, "kendoEventsOutsideAngular"], ["wrap", ""], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], ["track", ""], [1, "k-slider-selection"], ["sliderSelection", ""], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "id", "title", "kendoPress", "kendoDrag", "kendoRelease"], ["draghandleStart", ""], ["draghandleEnd", ""], [3, "resize"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"], ["ticks", ""]], template: function RangeSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c21);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(4, RangeSliderComponent_ul_4_Template, 2, 7, "ul", 3);
        ɵngcc0.ɵɵelementStart(5, "div", 4, 5);
        ɵngcc0.ɵɵelement(7, "div", 6, 7);
        ɵngcc0.ɵɵelementStart(9, "a", 8, 9);
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_9_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); })("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_9_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); })("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_9_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "a", 8, 10);
        ɵngcc0.ɵɵlistener("kendoPress", function RangeSliderComponent_Template_a_kendoPress_11_listener($event) { return ctx.ifEnabled(ctx.handleDragPress, $event); })("kendoDrag", function RangeSliderComponent_Template_a_kendoDrag_11_listener($event) { return ctx.ifEnabled(ctx.onHandleDrag, $event); })("kendoRelease", function RangeSliderComponent_Template_a_kendoRelease_11_listener($event) { return ctx.ifEnabled(ctx.onHandleRelease, $event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "kendo-resize-sensor", 11);
        ɵngcc0.ɵɵlistener("resize", function RangeSliderComponent_Template_kendo_resize_sensor_resize_13_listener() { return ctx.sizeComponent(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(30, _c22, ctx.onWrapClick, ctx.onKeyDown));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵproperty("id", ctx.startHandleId)("title", ctx.textFor("dragHandleStart"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[0] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵngcc0.ɵɵproperty("id", ctx.endHandleId)("title", ctx.textFor("dragHandleEnd"));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[1] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : undefined)("aria-readonly", ctx.readonly ? true : undefined)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
    } }, directives: function () { return [LocalizedRangeSliderMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf, ɵngcc2.DraggableDirective, ɵngcc2.ResizeSensorComponent, SliderTicksComponent]; }, encapsulation: 2 });
/** @nocollapse */
RangeSliderComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: Injector },
    { type: Renderer2 },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
RangeSliderComponent.propDecorators = {
    value: [{ type: Input }],
    draghandleStart: [{ type: ViewChild, args: ['draghandleStart', { static: true },] }],
    draghandleEnd: [{ type: ViewChild, args: ['draghandleEnd', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RangeSliderComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoRangeSlider',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.rangeslider' },
                    { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => RangeSliderComponent) },
                    { provide: KendoInput, useExisting: forwardRef(() => RangeSliderComponent) }
                ],
                selector: 'kendo-rangeslider',
                template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-dragHandleStart="kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider."
            dragHandleStart="Drag"
            i18n-dragHandleEnd="kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider."
            dragHandleEnd="Drag"
        >

        <div class="k-slider-wrap" #wrap
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
            >
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <a #draghandleStart
                    role="slider"
                    [id]="startHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[0] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleStart')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
                <a #draghandleEnd
                    role="slider"
                    [id]="endHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[1] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleEnd')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></a>
            </div>

            <kendo-resize-sensor (resize)="sizeComponent()"></kendo-resize-sensor>
        </div>
  `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { value: [{
            type: Input
        }], draghandleStart: [{
            type: ViewChild,
            args: ['draghandleStart', { static: true }]
        }], draghandleEnd: [{
            type: ViewChild,
            args: ['draghandleEnd', { static: true }]
        }] }); })();

const FOCUSED$1 = 'k-state-focused';
/**
 * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).
 */
class SwitchComponent {
    constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.localizationService = localizationService;
        this.injector = injector;
        this.changeDetector = changeDetector;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets the current value of the Switch when it is initially displayed.
         */
        this.checked = false;
        /**
         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        /**
         * @hidden
         */
        this.handleFocus = () => {
            this.focused = true;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
        this.keyDownHandler = this.keyDownHandler.bind(this);
        this.clickHandler = this.clickHandler.bind(this);
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get ieClass() {
        return browser && browser.msie;
    }
    get ariaDisabled() {
        return this.disabled ? true : undefined;
    }
    get ariaReadonly() {
        return this.readonly;
    }
    get hostClasses() {
        return true;
    }
    get switchOnClass() {
        return this.checked;
    }
    get switchOffClass() {
        return !this.checked;
    }
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get onLabelMessage() {
        return this.onLabel || this.localizationService.get('on');
    }
    /**
     * @hidden
     */
    get offLabelMessage() {
        return this.offLabel || this.localizationService.get('off');
    }
    get isEnabled() {
        return !this.disabled && !this.readonly;
    }
    ngOnInit() {
        if (this.hostElement) {
            const wrapper = this.hostElement.nativeElement;
            this.renderer.removeAttribute(wrapper, "tabindex");
        }
        this.localizationChangeSubscription = this.localizationService
            .changes
            .pipe(skip(1))
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.control = this.injector.get(NgControl, null);
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    /**
     * Focuses the Switch.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="switch.focus()">Focus</button>
     *  <kendo-switch #switch></kendo-switch>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.focus();
    }
    /**
     * Blurs the Switch.
     */
    blur() {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.blur();
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.changeDetector.markForCheck();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.checked = value === null ? false : value;
        this.changeDetector.markForCheck();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    keyDownHandler(e) {
        const keyCode = e.keyCode;
        if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {
            this.changeValue(!this.checked);
            e.preventDefault();
        }
    }
    /**
     * @hidden
     */
    clickHandler() {
        if (this.isEnabled) {
            this.changeValue(!this.checked);
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    changeValue(value) {
        if (this.checked !== value) {
            this.ngZone.run(() => {
                this.checked = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(element, FOCUSED$1);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$1);
            }
            this.isFocused = value;
        }
    }
}
SwitchComponent.ɵfac = function SwitchComponent_Factory(t) { return new (t || SwitchComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SwitchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwitchComponent, selectors: [["kendo-switch"]], viewQuery: function SwitchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c23, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);
    } }, hostVars: 15, hostBindings: function SwitchComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("aria-disabled", ctx.ariaDisabled)("aria-readonly", ctx.ariaReadonly);
        ɵngcc0.ɵɵclassProp("k-ie", ctx.ieClass)("k-widget", ctx.hostClasses)("k-switch", ctx.hostClasses)("k-switch-on", ctx.switchOnClass)("k-switch-off", ctx.switchOffClass)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { focusableId: "focusableId", checked: "checked", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", tabIndex: "tabIndex", onLabel: "onLabel", offLabel: "offLabel" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoSwitch"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.switch' },
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => SwitchComponent) /* tslint:disable-line */
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => SwitchComponent)
            }
        ])], decls: 9, vars: 13, consts: [["kendoSwitchLocalizedMessages", "", 6, "on", "off"], ["role", "switch", 1, "k-switch-container", 3, "id", "kendoEventsOutsideAngular"], ["wrapper", ""], [1, "k-switch-label-on"], [1, "k-switch-label-off"], [1, "k-switch-handle"]], template: function SwitchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c28);
        ɵngcc0.ɵɵelementStart(2, "span", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "span", 3);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span", 4);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(8, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction4(8, _c29, ctx.clickHandler, ctx.keyDownHandler, ctx.handleFocus, ctx.handleBlur));
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("tabindex", ctx.disabled ? undefined : ctx.tabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.onLabelMessage);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-hidden", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.offLabelMessage);
    } }, directives: function () { return [LocalizedSwitchMessagesDirective, ɵngcc2.EventsOutsideAngularDirective]; }, encapsulation: 2 });
/** @nocollapse */
SwitchComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: LocalizationService },
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: NgZone }
];
SwitchComponent.propDecorators = {
    focusableId: [{ type: Input }],
    onLabel: [{ type: Input }],
    offLabel: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    valueChange: [{ type: Output }],
    wrapper: [{ type: ViewChild, args: ['wrapper',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    ieClass: [{ type: HostBinding, args: ['class.k-ie',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    ariaReadonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-switch',] }],
    switchOnClass: [{ type: HostBinding, args: ['class.k-switch-on',] }],
    switchOffClass: [{ type: HostBinding, args: ['class.k-switch-off',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwitchComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoSwitch',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.switch' },
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => SwitchComponent) /* tslint:disable-line */
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => SwitchComponent)
                    }
                ],
                selector: 'kendo-switch',
                template: `
        <ng-container kendoSwitchLocalizedMessages
            i18n-on="kendo.switch.on|The **On** label of the Switch."
            on="ON"
            i18n-off="kendo.switch.off|The **Off** label of the Switch."
            off="OFF"
        >

        <span
            #wrapper
            class="k-switch-container"
            [id]="focusableId"
            role="switch"
            [attr.aria-checked]="checked"
            [attr.tabindex]="(disabled ? undefined : tabIndex)"
            [kendoEventsOutsideAngular]="{ click: clickHandler, keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }"
        >
            <span class="k-switch-label-on" [attr.aria-hidden]="true" >{{onLabelMessage}}</span>
            <span class="k-switch-label-off" [attr.aria-hidden]="true">{{offLabelMessage}}</span>
            <span class="k-switch-handle"></span>
        </span>
  `
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, { focusableId: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabIndex: [{
            type: Input
        }], ieClass: [{
            type: HostBinding,
            args: ['class.k-ie']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaReadonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-switch']
        }], switchOnClass: [{
            type: HostBinding,
            args: ['class.k-switch-on']
        }], switchOffClass: [{
            type: HostBinding,
            args: ['class.k-switch-off']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], onLabel: [{
            type: Input
        }], offLabel: [{
            type: Input
        }], wrapper: [{
            type: ViewChild,
            args: ['wrapper']
        }] }); })();

/**
 * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).
 * Provides floating labels to `textarea` elements.
 *
 * @example
 * ```ts-no-run
 * <textarea kendoTextArea></textarea>
 * ```
 */
class TextAreaDirective {
    constructor(renderer, element, zone, changeDetector, injector, rtl) {
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.injector = injector;
        this.elementClass = true;
        this.autofillClass = true;
        /**
         * Fires each time the textarea value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Specifies if the `textarea` element will resize its height automatically
         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).
         *
         * @default false
         */
        this.autoSize = false;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.direction = rtl ? 'rtl' : 'ltr';
    }
    get id() {
        return this.element.nativeElement.id;
    }
    set id(id) {
        this.renderer.setAttribute(this.element.nativeElement, 'id', id);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.elementValue = value;
        this.resize();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.setElementProperty('disabled', isDisabled);
    }
    ngOnInit() {
        const element = this.element.nativeElement;
        this.zone.runOutsideAngular(() => {
            this.listeners = [
                this.renderer.listen(element, 'focus', this.handleFocus.bind(this)),
                this.renderer.listen(element, 'blur', this.handleBlur.bind(this)),
                this.renderer.listen(element, 'animationstart', (e) => {
                    if (e.animationName === 'autoFillStart') {
                        this.autoFillStart.emit();
                    }
                    else if (e.animationName === 'autoFillEnd') {
                        this.autoFillEnd.emit();
                    }
                })
            ];
            if (isDocumentAvailable() && this.autoSize) {
                this.resizeSubscription = fromEvent(window, 'resize')
                    .pipe((debounceTime(50)))
                    .subscribe(() => this.resize());
            }
            this.inputSubscription = fromEvent(element, 'input')
                .subscribe(this.handleInput.bind(this));
        });
        this.control = this.injector.get(NgControl, null);
    }
    ngOnChanges(changes) {
        const element = this.element.nativeElement;
        if (changes.value) {
            this.elementValue = this.value;
        }
        if (changes.autoSize) {
            if (this.autoSize) {
                this.initialHeight = element.offsetHeight;
                this.renderer.setStyle(element, 'resize', 'none');
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = `${this.initialHeight}px`;
            }
        }
        this.resize();
    }
    ngOnDestroy() {
        this.listeners.forEach(listener => listener());
        if (this.inputSubscription) {
            this.inputSubscription.unsubscribe();
        }
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    get elementValue() {
        if (this.element) {
            return this.element.nativeElement.value;
        }
        return '';
    }
    set elementValue(value) {
        this.setElementProperty('value', (value === undefined || value === null) ? '' : value);
    }
    setElementProperty(name, value) {
        if (this.element) {
            this.renderer.setProperty(this.element.nativeElement, name, value);
        }
    }
    resize() {
        if (!this.autoSize) {
            return;
        }
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        element.style.height = `${this.initialHeight}px`;
        const scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = `${scrollHeight}px`;
        }
    }
    handleInput() {
        const value = this.elementValue;
        this.value = value;
        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
            this.zone.run(() => {
                this.ngChange(value);
                this.onValueChange.emit(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
        this.resize();
    }
    handleFocus() {
        if (hasObservers(this.onFocus)) {
            this.zone.run(() => {
                this.onFocus.emit();
            });
        }
    }
    handleBlur() {
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
            this.zone.run(() => {
                this.ngTouched();
                this.onBlur.emit();
                this.changeDetector.markForCheck();
            });
        }
    }
}
TextAreaDirective.ɵfac = function TextAreaDirective_Factory(t) { return new (t || TextAreaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
TextAreaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextAreaDirective, selectors: [["textarea", "kendoTextArea", ""]], hostVars: 5, hostBindings: function TextAreaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textarea", ctx.elementClass)("k-autofill", ctx.autofillClass);
    } }, inputs: { autoSize: "autoSize", value: "value" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextAreaDirective),
                multi: true
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => TextAreaDirective)
            }]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
TextAreaDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Injector },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }
];
TextAreaDirective.propDecorators = {
    elementClass: [{ type: HostBinding, args: ['class.k-textarea',] }],
    autofillClass: [{ type: HostBinding, args: ['class.k-autofill',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    valueChange: [{ type: Output }],
    autoSize: [{ type: Input }],
    value: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextAreaDirective, [{
        type: Directive,
        args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextAreaDirective),
                        multi: true
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => TextAreaDirective)
                    }],
                selector: 'textarea[kendoTextArea]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Injector }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { elementClass: [{
            type: HostBinding,
            args: ['class.k-textarea']
        }], autofillClass: [{
            type: HostBinding,
            args: ['class.k-autofill']
        }], valueChange: [{
            type: Output
        }], autoSize: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], value: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FloatingLabelInputAdapter {
    constructor(component, formControl) {
        this.component = component;
        const isObservableOrEventEmitter = (event) => event instanceof Observable || event instanceof EventEmitter;
        if (isObservableOrEventEmitter(component.onFocus)) {
            this.onFocus = component.onFocus;
        }
        if (isObservableOrEventEmitter(component.autoFillStart)) {
            this.autoFillStart = component.autoFillStart;
        }
        if (isObservableOrEventEmitter(component.autoFillEnd)) {
            this.autoFillEnd = component.autoFillEnd;
        }
        if (isObservableOrEventEmitter(component.onBlur)) {
            this.onBlur = component.onBlur;
        }
        if (formControl) {
            this.onValueChange = formControl.valueChanges;
        }
        else if (component.onValueChange) {
            this.onValueChange = component.onValueChange;
        }
    }
    get focusableId() {
        const component = this.component;
        if ('focusableId' in component) {
            return component.focusableId;
        }
        else if ('id' in component) {
            return component.id;
        }
        return "";
    }
    set focusableId(value) {
        const component = this.component;
        if ('focusableId' in component) {
            component.focusableId = value;
        }
        else if ('id' in component) {
            component.id = value;
        }
    }
}

const isFunction = (x) => Object.prototype.toString.call(x) === '[object Function]';
/**
 * @hidden
 */
class TextBoxContainerComponent {
    constructor(elementRef, renderer, changeDetectorRef, rtl) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.empty = true;
        /**
         * @hidden
         */
        this.invalid = false;
        this._subscriptions = [];
        this.autoFillStarted = false;
        this.direction = rtl ? 'rtl' : 'ltr';
        this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
    }
    get hostClasses() {
        return true;
    }
    get textareaElementClass() {
        return !!this.textarea;
    }
    get focusedClass() {
        return this.focused;
    }
    get invalidClass() {
        return this.invalid;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.formControl && !this.kendoInput) {
            if (isDevMode()) {
                throw new Error("The TextBoxContainer requires a Kendo Input component" +
                    " or a forms-bound component to function properly.");
            }
            return;
        }
        // add focus/blur/valueChange handlers
        const control = new FloatingLabelInputAdapter(this.kendoInput || this.formControl.valueAccessor, this.formControl);
        const setFocus = (isFocused) => () => {
            this.focused = isFocused;
            this.updateState();
        };
        this.subscribe(control, 'onFocus', setFocus(true));
        this.subscribe(control, 'onBlur', setFocus(false));
        this.subscribe(control, 'autoFillStart', () => {
            this.autoFillStarted = true;
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        });
        this.subscribe(control, 'autoFillEnd', () => {
            if (this.autoFillStarted) {
                this.autoFillStarted = false;
                if (this.empty) {
                    this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
                }
            }
        });
        const updateState = () => this.updateState();
        updateState();
        this.subscribe(control, 'onValueChange', updateState);
        // set label id for floating label
        if (this.id && control.focusableId) {
            // input wins
            this.id = control.focusableId;
        }
        else if (this.id) {
            control.focusableId = this.id;
        }
        else if (control.focusableId) {
            this.id = control.focusableId;
        }
        else {
            const id = "_" + guid();
            control.focusableId = id;
            this.id = id;
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._subscriptions.forEach(s => s.unsubscribe());
        this._subscriptions = [];
    }
    subscribe(control, eventName, handler) {
        if (control[eventName] instanceof EventEmitter) {
            const subscription = control[eventName].subscribe(handler);
            this._subscriptions.push(subscription);
        }
    }
    updateState() {
        const empty = value => {
            // zero is not an empty value (e.g., NumericTextBox)
            if (value === 0 || value === false) {
                return false;
            }
            // empty arrays are an empty value (e.g., MultiSelect)
            if (Array.isArray(value) && !value.length) {
                return true;
            }
            return !value;
        };
        const formControl = this.formControl;
        if (formControl) {
            const valueAccessor = formControl.valueAccessor;
            if (isFunction(valueAccessor.isEmpty)) {
                this.empty = valueAccessor.isEmpty();
            }
            else {
                this.empty = empty(formControl.value);
            }
            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);
        }
        else {
            this.empty = isFunction(this.kendoInput.isEmpty) ?
                this.kendoInput.isEmpty() : empty(this.kendoInput.value);
        }
        if (this.empty) {
            this.renderer.addClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'k-state-empty');
        }
        this.changeDetectorRef.markForCheck();
    }
}
TextBoxContainerComponent.ɵfac = function TextBoxContainerComponent_Factory(t) { return new (t || TextBoxContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
TextBoxContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TextBoxContainerComponent, selectors: [["kendo-textbox-container"]], contentQueries: function TextBoxContainerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, KendoInput, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextAreaDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textarea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControl = _t.first);
    } }, hostVars: 9, hostBindings: function TextBoxContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox-container", ctx.hostClasses)("k-textarea-wrapper", ctx.textareaElementClass)("k-state-focused", ctx.focusedClass)("k-state-invalid", ctx.invalidClass);
    } }, inputs: { id: "id", floatingLabel: "floatingLabel" }, ngContentSelectors: _c30, decls: 2, vars: 1, consts: [["class", "k-label", 3, "for", 4, "ngIf"], [1, "k-label", 3, "for"]], template: function TextBoxContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, TextBoxContainerComponent_label_1_Template, 2, 2, "label", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.floatingLabel);
    } }, directives: [ɵngcc3.NgIf], encapsulation: 2 });
/** @nocollapse */
TextBoxContainerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }
];
TextBoxContainerComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-textbox-container',] }],
    textareaElementClass: [{ type: HostBinding, args: ['class.k-textarea-wrapper',] }],
    focusedClass: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    invalidClass: [{ type: HostBinding, args: ['class.k-state-invalid',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    id: [{ type: Input }],
    floatingLabel: [{ type: Input }],
    kendoInput: [{ type: ContentChild, args: [KendoInput,] }],
    textarea: [{ type: ContentChild, args: [TextAreaDirective,] }],
    formControl: [{ type: ContentChild, args: [NgControl,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-textbox-container',
                template: `
        <ng-content></ng-content>
        <label *ngIf="floatingLabel" [for]="id" class="k-label">{{ floatingLabel }}</label>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-textbox-container']
        }], textareaElementClass: [{
            type: HostBinding,
            args: ['class.k-textarea-wrapper']
        }], focusedClass: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], invalidClass: [{
            type: HostBinding,
            args: ['class.k-state-invalid']
        }], id: [{
            type: Input
        }], floatingLabel: [{
            type: Input
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput]
        }], textarea: [{
            type: ContentChild,
            args: [TextAreaDirective]
        }], formControl: [{
            type: ContentChild,
            args: [NgControl]
        }] }); })();

/**
 * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.
 * Used to style the textbox of any `input` element.
 *
 * @example
 * ```ts-no-run
 * <input kendoTextBox />
 * <input kendoTextBox type="email" />
 * <input kendoTextBox type="password" />
 * ```
 */
class TextBoxDirective {
    constructor(renderer, inputElement, ngZone) {
        this.renderer = renderer;
        this.inputElement = inputElement;
        this.ngZone = ngZone;
        this.hostClass = true;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillStart = new EventEmitter();
        /**
         * @hidden
         */
        this.autoFillEnd = new EventEmitter();
        this.listeners = [];
    }
    /**
     * @hidden
     */
    set value(text) {
        if (!this.inputElement) {
            return;
        }
        this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;
        this.onValueChange.emit();
    }
    /**
     * @hidden
     */
    get value() {
        return this.inputElement.nativeElement.value;
    }
    get id() {
        return this.inputElement.nativeElement.id;
    }
    set id(id) {
        this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);
    }
    ngAfterViewInit() {
        const input = this.inputElement.nativeElement;
        this.listeners = [
            this.renderer.listen(input, 'focus', () => this.onFocus.emit()),
            this.renderer.listen(input, 'blur', () => this.onBlur.emit())
        ];
        this.ngZone.runOutsideAngular(() => {
            this.renderer.listen(input, 'animationstart', (e) => {
                if (e.animationName === 'autoFillStart') {
                    this.autoFillStart.emit();
                }
                else if (e.animationName === 'autoFillEnd') {
                    this.autoFillEnd.emit();
                }
            });
        });
    }
    ngOnDestroy() {
        this.listeners.forEach(listener => listener());
    }
}
TextBoxDirective.ɵfac = function TextBoxDirective_Factory(t) { return new (t || TextBoxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TextBoxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextBoxDirective, selectors: [["input", "kendoTextBox", ""]], hostVars: 2, hostBindings: function TextBoxDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClass);
    } }, inputs: { value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: KendoInput,
                useExisting: forwardRef(() => TextBoxDirective)
            }])] });
/** @nocollapse */
TextBoxDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone }
];
TextBoxDirective.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-textbox',] }],
    value: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoTextBox]',
                providers: [{
                        provide: KendoInput,
                        useExisting: forwardRef(() => TextBoxDirective)
                    }]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }], value: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
const createMaxValidator = (maxValue) => {
    return (c) => {
        if (!isPresent(maxValue) || !isPresent(c.value) || c.value <= maxValue) {
            return null;
        }
        return {
            maxError: {
                maxValue: maxValue,
                value: c.value
            }
        };
    };
};

/**
 * @hidden
 */
const createMinValidator = (minValue) => {
    return (c) => {
        if (!isPresent(minValue) || !isPresent(c.value) || c.value >= minValue) {
            return null;
        }
        return {
            minError: {
                minValue: minValue,
                value: c.value
            }
        };
    };
};

/**
 * @hidden
 */
const MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';
/**
 * @hidden
 */
const MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';
/**
 * @hidden
 */
const POINT = ".";
/**
 * @hidden
 */
const INITIAL_SPIN_DELAY = 500;
/**
 * @hidden
 */
const SPIN_DELAY = 50;
/**
 * @hidden
 */
const EXPONENT_REGEX = /[eE][\-+]?([0-9]+)/;

/**
 * @hidden
 */
const numericRegex = (options) => {
    const { autoCorrect, decimals, min } = options;
    let separator = options.separator;
    if (separator === POINT) {
        separator = '\\' + separator;
    }
    const signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';
    let numberPattern;
    if (decimals === 0) {
        numberPattern = '\\d*';
    }
    else {
        numberPattern = `(?:(?:\\d+(${separator}\\d*)?)|(?:${separator}\\d*))?`;
    }
    return new RegExp(`^${signPattern}${numberPattern}$`);
};
/**
 * @hidden
 */
const decimalPart = (value) => {
    return value >= 0 ? Math.floor(value) : Math.ceil(value);
};
/**
 * @hidden
 */
const noop = (_) => { }; // tslint:disable-line:no-empty
/**
 * @hidden
 */
const defined = (value) => {
    return typeof value !== 'undefined';
};
/**
 * @hidden
 */
const isNumber = (value) => {
    return !isNaN(value) && value !== null;
};
/**
 * @hidden
 */
function pad(value, digits) {
    const count = digits - String(value).length;
    let result = value;
    if (count > 0) {
        const padString = new Array(count + 1).join("0");
        result = parseFloat(value + padString);
    }
    return result;
}
/**
 * @hidden
 */
const getDeltaFromMouseWheel = (e) => {
    let delta = 0;
    if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
    }
    else if (e.detail) {
        delta = Math.round(-e.detail / 3);
    }
    return delta;
};
/**
 * @hidden
 */
const getCaretPosition = (element) => element.selectionStart;
/**
 * @hidden
 */
const extractSignificantNumericChars = (formattedString, separator) => {
    const significantCharacters = `${separator}0123456789-`;
    return formattedString.split('').reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);
};

/**
 * @hidden
 */
var ArrowDirection;
(function (ArrowDirection) {
    ArrowDirection[ArrowDirection["Down"] = -1] = "Down";
    ArrowDirection[ArrowDirection["None"] = 0] = "None";
    ArrowDirection[ArrowDirection["Up"] = 1] = "Up";
})(ArrowDirection || (ArrowDirection = {}));

const PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];
const PARSABLE_DEFAULTS = {
    decimals: null,
    max: null,
    min: null,
    step: 1
};
const FOCUSED$2 = 'k-state-focused';
const FORMATTED_VALUE = 'k-formatted-value';
/**
 * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).
 */
class NumericTextBoxComponent {
    constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {
        this.intl = intl;
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.injector = injector;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).
         */
        this.readonly = false;
        /**
         * Sets the title of the `input` element of the NumericTextBox.
         */
        this.title = '';
        /**
         * Specifies whether the value will be auto-corrected based on the minimum and maximum values
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.autoCorrect = false;
        /**
         * Specifies the number of decimals that the user can enter when the input is focused
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.decimals = null;
        /**
         * Specifies the value that is used to increment or decrement the component value
         * ([see example]({% slug predefinedsteps_numerictextbox %})).
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered
         * ([see example]({% slug spinbuttons_numerictextbox %})).
         */
        this.spinners = true;
        /**
         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.
         *
         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`
         * to `false`, the built-in Angular validators will be executed.
         */
        this.rangeValidation = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Determines whether the whole value will be selected when the NumericTextBox is clicked. Defaults to `true`.
         */
        this.selectOnFocus = true;
        /**
         * Specifies the value of the NumericTextBox
         * ([see example]({% slug formats_numerictextbox %})).
         */
        this.value = null;
        /**
         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.ArrowDirection = ArrowDirection;
        /**
         * @hidden
         */
        this.arrowDirection = ArrowDirection.None;
        this.inputValue = '';
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this._format = "n2";
        this.isPasted = false;
        this.mouseDown = false;
        this.ngChange = noop;
        this.ngTouched = noop;
        this.ngValidatorChange = noop;
        /**
         * @hidden
         */
        this.increasePress = (e) => {
            this.arrowPress(ArrowDirection.Up, e);
        };
        /**
         * @hidden
         */
        this.decreasePress = (e) => {
            this.arrowPress(ArrowDirection.Down, e);
        };
        /**
         * @hidden
         */
        this.releaseArrow = () => {
            clearTimeout(this.spinTimeout);
            if (this.arrowDirection !== ArrowDirection.None) {
                this.arrowDirection = ArrowDirection.None;
                this.changeDetector.detectChanges();
            }
        };
        /**
         * @hidden
         */
        this.handlePaste = () => {
            this.isPasted = true;
        };
        /**
         * @hidden
         */
        this.handleInput = () => {
            const input = this.numericInput.nativeElement;
            let { selectionStart, selectionEnd, value: inputValue } = input;
            if (this.pressedKey === Keys.NumpadDecimal) {
                inputValue = this.replaceNumpadDotValue();
            }
            if (this.isPasted) {
                inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));
            }
            if (!this.isValid(inputValue)) {
                input.value = this.inputValue;
                this.setSelection(selectionStart - 1, selectionEnd - 1);
                return;
            }
            const parsedValue = this.intl.parseNumber(inputValue);
            let value = this.restrictDecimals(parsedValue);
            if (this.autoCorrect) {
                const limited = this.limitInputValue(value);
                value = limited.value;
                selectionStart = limited.selectionStart;
                selectionEnd = limited.selectionEnd;
            }
            if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {
                this.setInputValue(value);
                this.setSelection(selectionStart, selectionEnd);
            }
            else {
                this.inputValue = inputValue;
            }
            if (this.isPasted) {
                input.value = this.inputValue;
            }
            this.updateValue(value);
            this.previousSelection = null;
            this.isPasted = false;
        };
        /**
         * @hidden
         */
        this.handleDragEnter = () => {
            if (!this.focused && !this.isDisabled) {
                this.setInputValue(this.value, true);
            }
        };
        /**
         * @hidden
         */
        this.handleMouseDown = () => {
            this.mouseDown = true;
        };
        /**
         * @hidden
         */
        this.handleFocus = () => {
            if (!this.focused) {
                this.focused = true;
                if (!this.isDisabled) {
                    const shouldSelectAll = this.selectOnFocus || !this.mouseDown;
                    this.ngZone.runOutsideAngular(() => {
                        setTimeout(() => {
                            if (shouldSelectAll) {
                                this.selectAll();
                            }
                            else {
                                this.selectCaret();
                            }
                        }, 0);
                    });
                }
            }
            this.mouseDown = false;
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            //blur is thrown before input when dragging the input text in IE
            if (this.inputValue !== this.elementValue) {
                this.handleInput();
            }
            this.setInputValue();
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.onBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleKeyDown = (e) => {
            if (this.isDisabled) {
                return;
            }
            let step;
            if (e.keyCode === Keys.ArrowDown) {
                step = -1;
            }
            else if (e.keyCode === Keys.ArrowUp) {
                step = 1;
            }
            if (step && this.step) {
                e.preventDefault();
                this.addStep(step);
            }
            const input = this.numericInput.nativeElement;
            this.previousSelection = {
                end: input.selectionEnd,
                start: input.selectionStart
            };
            this.pressedKey = e.keyCode;
        };
        /**
         * @hidden
         */
        this.handleWheel = (e) => {
            if (this.focused && !this.isDisabled) {
                e.preventDefault();
                const delta = getDeltaFromMouseWheel(e);
                this.addStep(delta);
            }
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Specifies the number format which is used when the NumericTextBox is not focused
     * ([see example]({% slug formats_numerictextbox %})).
     * If `format` is set to `null` or `undefined`, the default format will be used.
     */
    get format() {
        const format = this._format;
        return format !== null && format !== undefined ? format : 'n2';
    }
    set format(value) {
        this._format = value;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get widgetClasses() {
        return true;
    }
    ngOnInit() {
        this.subscriptions = this.localizationService
            .changes
            .subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {
            this.parseOptions(PARSABLE_OPTIONS.filter(option => changes[option]));
        }
        this.verifySettings();
        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {
            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;
            this.ngValidatorChange();
        }
        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {
            delete this.numericRegex;
        }
        if (anyChanged(['value', 'format'], changes, false)) {
            this.verifyValue(this.value);
            this.value = this.restrictModelValue(this.value);
            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {
                this.setInputValue();
            }
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        clearTimeout(this.spinTimeout);
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidateFn(control) || this.maxValidateFn(control);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.ngValidatorChange = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        let restrictedValue = this.restrictModelValue(value);
        this.value = restrictedValue;
        this.setInputValue();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Focuses the NumericTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="numerictextbox.focus()">Focus NumericTextBox</button>
     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        invokeElementMethod(this.numericInput, 'focus');
    }
    /**
     * Blurs the NumericTextBox.
     */
    blur() {
        invokeElementMethod(this.numericInput, 'blur');
    }
    /**
     * Notifies the `NumericTextBoxComponent` that the input value should be changed.
     * Can be used to update the input after setting the component properties directly.
     */
    notifyValueChange() {
        this.setInputValue();
    }
    /**
     * @hidden
     */
    get incrementTitle() {
        return this.localizationService.get('increment');
    }
    /**
     * @hidden
     */
    get decrementTitle() {
        return this.localizationService.get('decrement');
    }
    get decimalSeparator() {
        const numberSymbols = this.intl.numberSymbols();
        return numberSymbols.decimal;
    }
    get elementValue() {
        return this.numericInput.nativeElement.value;
    }
    set elementValue(value) {
        this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);
    }
    get focused() {
        return this.isFocused;
    }
    get hasDecimals() {
        return this.decimals !== null && this.decimals >= 0;
    }
    set focused(value) {
        if (this.isFocused !== value && this.numericWrap) {
            const wrap = this.numericWrap.nativeElement;
            const input = this.numericInput.nativeElement;
            if (value) {
                this.renderer.addClass(wrap, FOCUSED$2);
                if (!this.isDisabled) {
                    this.renderer.removeClass(input, FORMATTED_VALUE);
                }
            }
            else {
                this.renderer.removeClass(wrap, FOCUSED$2);
                this.renderer.addClass(input, FORMATTED_VALUE);
            }
            this.isFocused = value;
        }
    }
    get isDisabled() {
        return this.disabled || this.readonly;
    }
    arrowPress(direction, e) {
        e.preventDefault();
        if (this.isDisabled) {
            return;
        }
        if (!mobileOS) {
            this.focused = true;
            this.focus();
        }
        if (this.arrowDirection !== direction) {
            this.arrowDirection = direction;
            this.changeDetector.detectChanges();
        }
        if (this.step) {
            this.spin(direction, INITIAL_SPIN_DELAY);
        }
        else {
            this.setInputValue();
        }
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    replaceNumpadDotValue() {
        let value = this.inputValue || "";
        if (this.previousSelection) {
            const input = this.numericInput.nativeElement;
            const { selectionStart, selectionEnd } = input;
            const { start, end } = this.previousSelection;
            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);
            this.setSelection(selectionStart, selectionEnd);
        }
        return value;
    }
    isValid(value) {
        if (!this.numericRegex) {
            this.numericRegex = numericRegex({
                autoCorrect: this.autoCorrect,
                decimals: this.decimals,
                min: this.min,
                separator: this.decimalSeparator
            });
        }
        return this.numericRegex.test(value);
    }
    spin(step, timeout) {
        clearTimeout(this.spinTimeout);
        this.spinTimeout = window.setTimeout(() => {
            this.spin(step, SPIN_DELAY);
        }, timeout);
        this.addStep(step);
    }
    addStep(step) {
        let value = add(this.value || 0, this.step * step);
        value = this.limitValue(value);
        value = this.restrictDecimals(value);
        this.setInputValue(value);
        this.updateValue(value);
    }
    setSelection(start, end) {
        if (this.focused) {
            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);
        }
    }
    limitValue(value) {
        let result = value;
        if (!this.isInRange(value)) {
            if (isNumber(this.max) && value > this.max) {
                result = this.max;
            }
            if (isNumber(this.min) && value < this.min) {
                result = this.min;
            }
        }
        return result;
    }
    limitInputValue(value) {
        let { selectionStart, selectionEnd, value: enteredValue } = this.numericInput.nativeElement;
        let limitedValue = value;
        let selectToEnd = false;
        if (!this.isInRange(value)) {
            const lengthChange = enteredValue.length - String(this.inputValue).length;
            const { min, max } = this;
            const hasMax = isNumber(max);
            const hasMin = isNumber(min);
            let padLimit, replaceNext;
            let correctedValue = value;
            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {
                return {
                    selectionEnd: selectionEnd,
                    selectionStart: selectionStart,
                    value: null
                };
            }
            if (hasMax && value > max) {
                if (value > 0) {
                    replaceNext = true;
                }
                else {
                    padLimit = max;
                }
            }
            else if (hasMin && value < min) {
                if (value > 0) {
                    padLimit = min;
                }
                else {
                    replaceNext = true;
                }
            }
            if (padLimit) {
                const paddedValue = this.tryPadValue(value, padLimit);
                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {
                    correctedValue = paddedValue;
                    selectToEnd = true;
                }
            }
            else if (replaceNext) {
                if (this.inputValue && selectionStart !== enteredValue.length) {
                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +
                        enteredValue.substr(selectionStart + lengthChange));
                }
            }
            limitedValue = this.limitValue(correctedValue);
            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&
                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;
        }
        return {
            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,
            selectionStart: selectionStart,
            value: limitedValue
        };
    }
    tryPadValue(value, limit) {
        const limitLength = String(Math.floor(limit)).length;
        const zeroPadded = pad(value, limitLength);
        const zeroPaddedNext = pad(value, limitLength + 1);
        let result;
        if (this.isInRange(zeroPadded)) {
            result = zeroPadded;
        }
        else if (this.isInRange(zeroPaddedNext)) {
            result = zeroPaddedNext;
        }
        return result;
    }
    isInRange(value) {
        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));
    }
    restrictModelValue(value) {
        let result = this.restrictDecimals(value, true);
        if (this.autoCorrect && this.limitValue(result) !== result) {
            result = null;
        }
        return result;
    }
    restrictDecimals(value, round) {
        let result = value;
        if (value && this.hasDecimals) {
            const decimals = this.decimals;
            const stringValue = String(value);
            if (round || EXPONENT_REGEX.test(stringValue)) {
                result = toFixedPrecision(value, decimals);
            }
            else {
                const parts = stringValue.split(POINT);
                let fraction = parts[1];
                if (fraction && fraction.length > decimals) {
                    fraction = fraction.substr(0, decimals);
                    result = parseFloat(`${parts[0]}${POINT}${fraction}`);
                }
            }
        }
        return result;
    }
    formatInputValue(value) {
        let stringValue = String(value);
        const exponentMatch = EXPONENT_REGEX.exec(stringValue);
        if (exponentMatch) {
            stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));
        }
        return stringValue.replace(POINT, this.decimalSeparator);
    }
    formatValue(value, focused) {
        let formattedValue;
        if (value === null || !defined(value) || value === '') {
            formattedValue = '';
        }
        else if (focused && !this.readonly) {
            formattedValue = this.formatInputValue(value);
        }
        else {
            formattedValue = this.intl.formatNumber(value, this.format);
        }
        return formattedValue;
    }
    setInputValue(value = this.value, focused = this.focused) {
        const formattedValue = this.formatValue(value, focused);
        this.elementValue = formattedValue;
        this.inputValue = formattedValue;
    }
    verifySettings() {
        if (!isDevMode()) {
            return;
        }
        if (this.min !== null && this.max !== null && this.min > this.max) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
        }
    }
    verifyValue(value) {
        if (isDevMode() && value && typeof value !== 'number') {
            throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);
        }
    }
    parseOptions(options) {
        for (let idx = 0; idx < options.length; idx++) {
            const name = options[idx];
            const value = this[name];
            if (typeof value === 'string') {
                const parsed = parseFloat(value);
                const valid = !isNaN(parsed);
                if (isDevMode() && !valid && value !== '') {
                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +
                        `a number for the ${name} property and ${JSON.stringify(value)} was set.`);
                }
                this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];
            }
        }
    }
    intlChange() {
        delete this.numericRegex;
        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {
            this.setInputValue();
        }
    }
    hasTrailingZeros(inputValue) {
        if (this.hasDecimals && this.focused) {
            const fraction = inputValue.split(this.decimalSeparator)[1];
            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;
        }
    }
    selectAll() {
        this.setInputValue();
        this.setSelection(0, this.inputValue.length);
    }
    selectCaret() {
        const caretPosition = getCaretPosition(this.numericInput.nativeElement);
        const formattedValue = this.elementValue;
        const partialValue = formattedValue.substring(0, caretPosition);
        this.setInputValue();
        if (partialValue.length) {
            const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);
            const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);
            this.setSelection(adjustedSignificantChars, adjustedSignificantChars);
        }
        else {
            this.setSelection(0, 0);
        }
    }
    numberOfLeadingZeroes(formattedValue) {
        const separatorIndex = formattedValue.indexOf(this.decimalSeparator);
        const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);
        if (matchedLeadingZeroes) {
            const lengthOfMatch = matchedLeadingZeroes[0].length;
            const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;
            return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;
        }
        return 0;
    }
    adjustSignificantChars(formattedValue, significantChars) {
        const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);
        if (leadingZeroes > 0) {
            return Math.max(0, significantChars - leadingZeroes);
        }
        return significantChars;
    }
}
NumericTextBoxComponent.ɵfac = function NumericTextBoxComponent_Factory(t) { return new (t || NumericTextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NumericTextBoxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumericTextBoxComponent, selectors: [["kendo-numerictextbox"]], viewQuery: function NumericTextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c31, true);
        ɵngcc0.ɵɵviewQuery(_c32, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.numericWrap = _t.first);
    } }, hostVars: 5, hostBindings: function NumericTextBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.widgetClasses)("k-numerictextbox", ctx.widgetClasses);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", title: "title", autoCorrect: "autoCorrect", decimals: "decimals", step: "step", spinners: "spinners", rangeValidation: "rangeValidation", tabindex: "tabindex", selectOnFocus: "selectOnFocus", value: "value", format: "format", tabIndex: "tabIndex", max: "max", min: "min", placeholder: "placeholder" }, outputs: { valueChange: "valueChange", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoNumericTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
            { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent), multi: true },
            { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 25, consts: [["kendoNumericTextBoxLocalizedMessages", "", 6, "increment", "decrement"], [1, "k-numeric-wrap", 3, "kendoEventsOutsideAngular"], ["numericWrap", ""], ["role", "spinbutton", "autocomplete", "off", "autocorrect", "off", 1, "k-input", "k-formatted-value", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["numericInput", ""], ["class", "k-select", 3, "kendoEventsOutsideAngular", 4, "ngIf"], [1, "k-select", 3, "kendoEventsOutsideAngular"], [1, "k-link", "k-link-increase", 3, "kendoEventsOutsideAngular", "title"], [1, "k-icon", "k-i-arrow-n"], [1, "k-link", "k-link-decrease", 3, "kendoEventsOutsideAngular", "title"], [1, "k-icon", "k-i-arrow-s"]], template: function NumericTextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c37);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 1, 2);
        ɵngcc0.ɵɵelement(4, "input", 3, 4);
        ɵngcc0.ɵɵtemplate(6, NumericTextBoxComponent_span_6_Template, 5, 18, "span", 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("k-state-disabled", ctx.disabled);
        ɵngcc0.ɵɵproperty("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(14, _c40, ctx.handleWheel, ctx.handleWheel));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction7(17, _c41, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleFocus, ctx.handleBlur, ctx.handlePaste));
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("title", ctx.title)("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.spinners);
    } }, directives: function () { return [LocalizedNumericTextBoxMessagesDirective, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgIf]; }, encapsulation: 2 });
/** @nocollapse */
NumericTextBoxComponent.ctorParameters = () => [
    { type: IntlService },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: Injector },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NumericTextBoxComponent.propDecorators = {
    focusableId: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    title: [{ type: Input }],
    autoCorrect: [{ type: Input }],
    format: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    decimals: [{ type: Input }],
    placeholder: [{ type: Input }],
    step: [{ type: Input }],
    spinners: [{ type: Input }],
    rangeValidation: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input }],
    selectOnFocus: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    numericInput: [{ type: ViewChild, args: ['numericInput', { static: true },] }],
    numericWrap: [{ type: ViewChild, args: ['numericWrap',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-numerictextbox',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericTextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoNumericTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NumericTextBoxComponent), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => NumericTextBoxComponent), multi: true },
                    { provide: KendoInput, useExisting: forwardRef(() => NumericTextBoxComponent) }
                ],
                selector: 'kendo-numerictextbox',
                template: `
        <ng-container kendoNumericTextBoxLocalizedMessages
            i18n-increment="kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox"
            increment="Increase value"
            i18n-decrement="kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox"
            decrement="Decrease value"
        >
        </ng-container>
        <span
            class="k-numeric-wrap"
            [class.k-state-disabled]="disabled"
            [kendoEventsOutsideAngular]="{ mousewheel: handleWheel, DOMMouseScroll: handleWheel }"
            #numericWrap>
            <input
            role="spinbutton"
            class="k-input k-formatted-value"
            autocomplete="off"
            autocorrect="off"
            [id]="focusableId"
            [attr.aria-valuemin]="min"
            [attr.aria-valuemax]="max"
            [attr.aria-valuenow]="value"
            [attr.title]="title"
            [attr.placeholder]="placeholder"
            [tabindex]="tabIndex"
            [disabled]="disabled"
            [readonly]="readonly"
            [kendoEventsOutsideAngular]="{
                mousedown: handleMouseDown,
                dragenter: handleDragEnter,
                keydown: handleKeyDown,
                input: handleInput,
                focus: handleFocus,
                blur: handleBlur,
                paste: handlePaste
            }"
            #numericInput />
            <span class="k-select" *ngIf="spinners" [kendoEventsOutsideAngular]="{ mouseup: releaseArrow, mouseleave: releaseArrow }">
                <span
                    [kendoEventsOutsideAngular]="{ mousedown: increasePress }"
                    [attr.aria-label]="incrementTitle"
                    [title]="incrementTitle"
                    [class.k-state-active]="arrowDirection === ArrowDirection.Up"
                    class="k-link k-link-increase"
                >
                    <span class="k-icon k-i-arrow-n"></span>
                </span>
                <span
                    [kendoEventsOutsideAngular]="{ mousedown: decreasePress }"
                    [attr.aria-label]="decrementTitle"
                    [title]="decrementTitle"
                    [class.k-state-active]="arrowDirection === ArrowDirection.Down"
                    class="k-link k-link-decrease"
                >
                    <span class="k-icon k-i-arrow-s"></span>
                </span>
            </span>
        </span>
      `
            }]
    }], function () { return [{ type: ɵngcc4.IntlService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], title: [{
            type: Input
        }], autoCorrect: [{
            type: Input
        }], decimals: [{
            type: Input
        }], step: [{
            type: Input
        }], spinners: [{
            type: Input
        }], rangeValidation: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], value: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], format: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], widgetClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-numerictextbox']
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], numericInput: [{
            type: ViewChild,
            args: ['numericInput', { static: true }]
        }], numericWrap: [{
            type: ViewChild,
            args: ['numericWrap']
        }] }); })();

/**
 * @hidden
 */
class NumericTextBoxMessages extends ComponentMessages {
}
NumericTextBoxMessages.ɵfac = function NumericTextBoxMessages_Factory(t) { return ɵNumericTextBoxMessages_BaseFactory(t || NumericTextBoxMessages); };
NumericTextBoxMessages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NumericTextBoxMessages, inputs: { decrement: "decrement", increment: "increment" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NumericTextBoxMessages.propDecorators = {
    decrement: [{ type: Input }],
    increment: [{ type: Input }]
};
const ɵNumericTextBoxMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NumericTextBoxMessages);

/**
 * Custom component messages override default component messages.
 */
class NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
NumericTextBoxCustomMessagesComponent.ɵfac = function NumericTextBoxCustomMessagesComponent_Factory(t) { return new (t || NumericTextBoxCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
NumericTextBoxCustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumericTextBoxCustomMessagesComponent, selectors: [["kendo-numerictextbox-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NumericTextBoxMessages,
                useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NumericTextBoxCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
NumericTextBoxCustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericTextBoxCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NumericTextBoxMessages,
                        useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-numerictextbox-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * @hidden
 */
var ResultType;
(function (ResultType) {
    ResultType[ResultType["Literal"] = 0] = "Literal";
    ResultType[ResultType["Mask"] = 1] = "Mask";
    ResultType[ResultType["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
/**
 * @hidden
 */
class Result {
    constructor(value, rest, type = ResultType.Undefined) {
        this.value = value;
        this.rest = rest;
        this.type = type;
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    map(fn) {
        return new Result(fn(this.value), this.rest);
    }
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    chain(fn) {
        return fn(this.value, this.rest);
    }
    fold(s, _ /*we don't need it*/) {
        return s(this.value, this.rest);
    }
    concat(r) {
        return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));
    }
    toString() {
        return `Result({ value: '${this.value}', rest: ${this.rest} })`;
    }
}

/**
 * @hidden
 */
class Stream {
    constructor(input = [], control = []) {
        this.input = input;
        this.control = control;
        this.inputCursor = 0;
        this.controlCursor = 0;
    }
    eof() {
        return this.inputCursor >= this.input.length;
    }
    // Get the first value from the input.
    next() {
        return {
            char: this.input[this.inputCursor++],
            control: this.control[this.controlCursor++]
        };
    }
    peek() {
        return {
            char: this.input[this.inputCursor],
            control: this.control[this.controlCursor]
        };
    }
    eat_input() {
        this.inputCursor++;
    }
    eat_control() {
        this.controlCursor++;
    }
    eat() {
        this.inputCursor++;
        this.controlCursor++;
    }
}

const toArray = (value) => (value || '').split('');
const ESCAPE_CHARACTER = '\\';
/**
 * @hidden
 */
class Parser {
    constructor(parse) {
        this.parse = parse;
    }
    run(input, control = '') {
        if (input instanceof Stream) {
            return this.parse(input);
        }
        else {
            return this.parse(new Stream(toArray(input), toArray(control)));
        }
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    map(f) {
        return new Parser(stream => this.parse(stream).map(f));
    }
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    chain(f) {
        return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));
    }
    isLiteral(c) {
        return this.run(c).type === ResultType.Literal;
    }
}
/**
 * @hidden
 */
const mask = ({ prompt, promptPlaceholder }) => rule => new Parser(stream => {
    while (!stream.eof()) {
        const { char, control } = stream.peek();
        if (char === control && control === prompt) {
            stream.eat();
            return new Result(prompt, stream, ResultType.Mask);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream, ResultType.Mask);
        }
        if (char === promptPlaceholder) {
            stream.eat();
            return new Result(prompt, stream, ResultType.Mask);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result(prompt, stream, ResultType.Mask);
});
/**
 * @hidden
 */
const literal = _token => new Parser(stream => {
    //    let {char, control} = stream.peek();
    let char = stream.peek().char;
    if (char === _token) {
        stream.eat();
        return new Result(_token, stream, ResultType.Literal);
    }
    //    if (control === _token) {
    //        while (!stream.eof() && char !== _token) {
    //            stream.eat_input();
    //            char = stream.peek().char;
    //        }
    //    }
    //
    //    if (control !== undefined) {
    //        stream.eat();
    //    }
    return new Result(_token, stream, ResultType.Literal);
});
/**
 * @hidden
 */
const unmask = prompt => rule => new Parser(stream => {
    while (!stream.eof()) {
        const { char, control } = stream.peek();
        if (char === prompt && control === prompt) {
            stream.eat();
            return new Result(char, stream);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result('', stream);
});
/**
 * @hidden
 */
const unliteral = _token => new Parser(stream => {
    if (stream.eof()) {
        return new Result('', stream);
    }
    const { char } = stream.peek();
    if (char === _token) {
        stream.eat();
    }
    return new Result(_token, stream);
});
/**
 * @hidden
 */
const token = (rules, creator) => new Parser(stream => {
    let { char } = stream.next();
    const rule = rules[char];
    if (char === ESCAPE_CHARACTER) {
        char = stream.next().char;
        return new Result(creator.literal(char), stream);
    }
    if (!rule) {
        return new Result(creator.literal(char), stream);
    }
    return new Result(creator.mask(rule), stream);
});
/**
 * @hidden
 */
const rawMask = ({ prompt, promptPlaceholder }) => new Parser(stream => {
    let { char } = stream.next();
    if (char === prompt) {
        return new Result(promptPlaceholder, stream);
    }
    return new Result(char, stream);
});
/**
 * @hidden
 */
const rawLiteral = includeLiterals => new Parser(stream => {
    let { char } = stream.next();
    if (includeLiterals) {
        return new Result(char, stream);
    }
    return new Result('', stream);
});

/**
 * @hidden
 */
const always = value => new Parser(stream => new Result(value, stream));
/**
 * @hidden
 */
const append = (p1, p2) => p1.chain(vs => p2.map(v => vs.concat([v])));
/**
 * @hidden
 */
const sequence = list => list.reduce((acc, parser) => append(acc, parser), always([]));
/**
 * @hidden
 */
const greedy = parser => new Parser(stream => {
    let result = new Result([], stream);
    while (!stream.eof()) {
        result = result.concat(parser.run(stream));
    }
    return result;
});

/**
 * @hidden
 */
class MaskingService {
    constructor() {
        this.rules = {};
        this.prompt = "_";
        this.mask = "";
        this.promptPlaceholder = " ";
        this.includeLiterals = false;
        this.maskTokens = [];
        this.unmaskTokens = [];
        this.rawTokens = [];
        this.validationTokens = [];
    }
    update({ mask: mask$$1 = '', prompt = '', promptPlaceholder = ' ', rules = {}, includeLiterals = false }) {
        this.mask = mask$$1;
        this.prompt = prompt;
        this.promptPlaceholder = promptPlaceholder;
        this.rules = rules;
        this.includeLiterals = includeLiterals;
        this.tokenize();
    }
    validationValue(maskedValue = '') {
        let value = maskedValue;
        sequence(this.validationTokens)
            .run(maskedValue)
            .fold(unmasked => {
            value = unmasked.join('');
        });
        return value;
    }
    rawValue(maskedValue = '') {
        let value = maskedValue;
        if (!this.rawTokens.length) {
            return value;
        }
        sequence(this.rawTokens)
            .run(maskedValue)
            .fold(unmasked => {
            value = unmasked.join('');
        });
        return value;
    }
    /**
     * @hidden
     */
    maskRaw(rawValue = '') {
        let value = rawValue;
        if (!this.maskTokens.length) {
            return value;
        }
        sequence(this.maskTokens)
            .run(rawValue)
            .fold(masked => {
            value = masked.join('');
        });
        return value;
    }
    maskInput(input, control, splitPoint) {
        if (input.length < control.length) {
            return this.maskRemoved(input, control, splitPoint);
        }
        return this.maskInserted(input, control, splitPoint);
    }
    maskInRange(pasted, oldValue, start, end) {
        let value = '';
        let selection = end;
        const beforeChange = oldValue.split('').slice(0, start);
        const afterChange = oldValue.split('').slice(end);
        sequence(this.maskTokens.slice(start, end))
            .run(pasted)
            .fold(masked => {
            value = beforeChange
                .concat(masked)
                .concat(afterChange)
                .join('');
        });
        return {
            selection,
            value
        };
    }
    maskRemoved(input, control, splitPoint) {
        let value = '';
        let selection = splitPoint;
        const unchanged = input.split('').slice(splitPoint);
        const changed = input.split('').slice(0, splitPoint).join('');
        const take$$1 = this.maskTokens.length - (input.length - splitPoint);
        sequence(this.maskTokens.slice(0, take$$1))
            .run(changed, control)
            .fold(masked => {
            selection = this.adjustPosition(masked, selection);
            value = masked.concat(unchanged).join('');
        });
        return {
            selection,
            value
        };
    }
    adjustPosition(input, selection) {
        const caretChar = input[selection];
        const isLiteral = this.maskTokens[selection].isLiteral(caretChar);
        if (!isLiteral && caretChar !== this.prompt) {
            return selection + 1;
        }
        return selection;
    }
    maskInserted(input, control, splitPoint) {
        let value = '';
        let selection = splitPoint;
        const changed = input.slice(0, splitPoint);
        sequence(this.unmaskTokens)
            .run(changed, control)
            .chain(unmasked => {
            selection = unmasked.join('').length;
            const unchanged = control.slice(selection);
            return sequence(this.maskTokens)
                .run(unmasked.join('') + unchanged, control);
        })
            .fold(masked => {
            value = masked.join('');
        });
        return {
            selection,
            value
        };
    }
    get maskTokenCreator() {
        const { prompt, promptPlaceholder } = this;
        return {
            literal: rule => literal(rule),
            mask: rule => mask({ prompt, promptPlaceholder })(rule)
        };
    }
    get unmaskTokenCreator() {
        return {
            literal: rule => unliteral(rule),
            mask: rule => unmask(this.prompt)(rule)
        };
    }
    get rawTokenCreator() {
        const { prompt, promptPlaceholder, includeLiterals } = this;
        return {
            literal: _ => rawLiteral(includeLiterals),
            mask: _ => rawMask({ prompt, promptPlaceholder })
        };
    }
    get validationTokenCreator() {
        const { prompt } = this;
        return {
            literal: _ => rawLiteral(false),
            mask: _ => rawMask({ prompt, promptPlaceholder: '' })
        };
    }
    tokenize() {
        greedy(token(this.rules, this.maskTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.maskTokens = tokens;
        });
        greedy(token(this.rules, this.unmaskTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.unmaskTokens = tokens;
        });
        greedy(token(this.rules, this.rawTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.rawTokens = tokens;
        });
        greedy(token(this.rules, this.validationTokenCreator))
            .run(this.mask)
            .fold((tokens, _) => {
            this.validationTokens = tokens;
        });
    }
}
MaskingService.ɵfac = function MaskingService_Factory(t) { return new (t || MaskingService)(); };
MaskingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MaskingService, factory: MaskingService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MaskingService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const resolvedPromise = Promise.resolve(null);
const FOCUSED$3 = 'k-state-focused';
/**
 * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).
 *
 * @example
 * ```ts-no-run
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-maskedtextbox
 *          [mask]="mask"
 *          [value]="value">
 *      </kendo-maskedtextbox>
 *     `
 * })
 *
 * class AppComponent {
 *  public value: string = "9580128055807792";
 *  public mask: string = "0000-0000-0000-0000";
 * }
 * ```
 */
class MaskedTextBoxComponent {
    constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {
        this.service = service;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.injector = injector;
        this.changeDetector = changeDetector;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).
         */
        this.readonly = false;
        this.hostClasses = true;
        /**
         * Represents a prompt character for the masked value.
         * @default `_`
         */
        this.prompt = '_';
        /**
         * Indicates a character which represents an empty position in the raw value.
         * @default ' '
         */
        this.promptPlaceholder = ' ';
        /**
         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).
         * @default false
         */
        this.includeLiterals = false;
        /**
         * Specifies if the mask should be shown on focus for empty value.
         */
        this.maskOnFocus = false;
        /**
         * Determines whether the built-in mask validator is enforced when a form is validated
         * ([see example]({% slug validation_maskedtextbox %})).
         * @default true
         */
        this.maskValidation = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (focus)="handleFocus()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (blur)="handleBlur()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the value changes.
         */
        this.valueChange = new EventEmitter();
        this.focusClick = false;
        this.defaultRules = {
            "#": /[\d\s\+\-]/,
            "&": /[\S]/,
            "0": /[\d]/,
            "9": /[\d\s]/,
            "?": /[a-zA-Z\s]/,
            "A": /[a-zA-Z0-9]/,
            "C": /./,
            "L": /[a-zA-Z]/,
            "a": /[a-zA-Z0-9\s]/
        };
        this.isPasted = false;
        this.selection = [0, 0];
        /**
         * @hidden
         */
        this.handleFocus = () => {
            this.focused = true;
            if (this.maskOnFocus && this.emptyMask) {
                this.updateInput(this.service.maskRaw(this.value));
                this.ngZone.runOutsideAngular(() => {
                    setTimeout(() => { this.setSelection(0, 0); }, 0);
                });
            }
            if (hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleClick = () => {
            if (this.focused && !this.focusClick) {
                this.focusClick = true;
                const { selectionStart, selectionEnd } = this.input.nativeElement;
                if (selectionStart === selectionEnd) {
                    this.setFocusSelection();
                }
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = () => {
            this.changeDetector.markForCheck();
            this.focused = false;
            this.focusClick = false;
            if (this.maskOnFocus && this.emptyMask) {
                this.updateInput(this.maskedValue);
            }
            if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.onTouched();
                    this.onBlur.emit();
                });
            }
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        this.direction = rtl ? 'rtl' : 'ltr';
        this.updateService();
    }
    get hostDisabledClass() {
        return this.disabled;
    }
    /**
     * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).
     */
    get rules() {
        return this._rules || this.defaultRules;
    }
    set rules(value) {
        this._rules = Object.assign({}, this.defaultRules, value);
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    ngOnInit() {
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.
     */
    isEmpty() {
        if (this.input) {
            return !Boolean(this.input.nativeElement.value);
        }
    }
    /**
     * @hidden
     */
    handleDragDrop() {
        return false;
    }
    /**
     * Focuses the MaskedTextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="maskedinput.focus()">Focus the input</button>
     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.focus();
        this.setFocusSelection();
    }
    /**
     * Blurs the MaskedTextBox.
     */
    blur() {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.blur();
    }
    /**
     * @hidden
     */
    pasteHandler(e) {
        const { selectionStart, selectionEnd } = e.target;
        if (selectionEnd === selectionStart) {
            return;
        }
        this.isPasted = true;
        this.selection = [selectionStart, selectionEnd];
    }
    /**
     * @hidden
     */
    inputHandler(e) {
        const value = e.target.value;
        const [start, end] = this.selection;
        if (!this.mask) {
            this.updateValue(value);
            this.isPasted = false;
            return;
        }
        let result;
        if (this.isPasted) {
            this.isPasted = false;
            const rightPart = this.maskedValue.length - end;
            const to = value.length - rightPart;
            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);
        }
        else {
            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);
        }
        this.updateInput(result.value, result.selection);
        this.updateValue(result.value);
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.value) {
            this.value = this.normalizeValue();
        }
        if (!this.mask) {
            this.updateInput(this.value);
            return;
        }
        const next = this.extractChanges(changes);
        this.updateService(next);
        if (isChanged('value', changes)) {
            const maskedValue = this.service.maskRaw(this.value);
            if (maskedValue !== this.maskedValue) {
                this.updateInput(maskedValue);
            }
        }
        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {
            resolvedPromise.then(() => {
                this.updateValue(this.maskedValue);
            });
        }
        else {
            this.updateInput(this.service.maskRaw(this.value));
        }
    }
    /**
     * @hidden
     * Writes a new value to the element.
     */
    writeValue(value) {
        this.value = this.normalizeValue(value);
        this.updateInput(this.service.maskRaw(this.value));
    }
    /**
     * @hidden
     * Sets the function that will be called when a `change` event is triggered.
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @hidden
     * Sets the function that will be called when a `touch` event is triggered.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    validate(_) {
        if (this.maskValidation === false || !this.mask) {
            return null;
        }
        if (!this.service.validationValue(this.maskedValue)) {
            return null;
        }
        if (this.maskedValue.indexOf(this.prompt) !== -1) {
            return {
                patternError: {
                    mask: this.mask,
                    maskedValue: this.maskedValue,
                    value: this.value
                }
            };
        }
        return null;
    }
    /**
     * @hidden
     */
    updateValue(maskedValue) {
        if (this.mask && !this.service.validationValue(maskedValue)) {
            this.value = '';
        }
        else {
            this.value = this.service.rawValue(maskedValue);
        }
        this.onChange(this.value);
        this.valueChange.emit(this.value);
    }
    updateInput(maskedValue = '', selection) {
        this.maskedValue = maskedValue;
        const value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;
        this.renderer.setProperty(this.input.nativeElement, "value", value);
        if (selection !== undefined) {
            this.setSelection(selection, selection);
        }
    }
    extractChanges(changes) {
        return Object.keys(changes).filter(key => key !== 'rules').reduce((obj, key) => {
            obj[key] = changes[key].currentValue;
            return obj;
        }, {}); // tslint:disable-line:align
    }
    updateService(extra) {
        const config = Object.assign({
            includeLiterals: this.includeLiterals,
            mask: this.mask,
            prompt: this.prompt,
            promptPlaceholder: this.promptPlaceholder,
            rules: this.rules
        }, extra); // tslint:disable-line:align
        this.service.update(config);
    }
    setSelection(start = this.selection[0], end = this.selection[1]) {
        if (this.focused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    get emptyMask() {
        return this.service.maskRaw() === this.maskedValue;
    }
    setFocusSelection() {
        const selectionStart = this.input.nativeElement.selectionStart;
        const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;
        if (index >= 0 && index < selectionStart) {
            this.selection = [index, index];
            this.setSelection();
        }
    }
    get focused() {
        return this.isFocused;
    }
    set focused(value) {
        if (this.isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value) {
                this.renderer.addClass(element, FOCUSED$3);
            }
            else {
                this.renderer.removeClass(element, FOCUSED$3);
            }
            this.isFocused = value;
        }
    }
    normalizeValue(value = this.value) {
        const present = isPresent(value);
        if (present && typeof value !== 'string') {
            if (isDevMode()) {
                throw new Error('The MaskedTextBox component supports only string values.');
            }
            return String(value);
        }
        return present ? value : '';
    }
}
MaskedTextBoxComponent.ɵfac = function MaskedTextBoxComponent_Factory(t) { return new (t || MaskedTextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(MaskingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
MaskedTextBoxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MaskedTextBoxComponent, selectors: [["kendo-maskedtextbox"]], viewQuery: function MaskedTextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c42, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 7, hostBindings: function MaskedTextBoxComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("paste", function MaskedTextBoxComponent_paste_HostBindingHandler($event) { return ctx.pasteHandler($event); })("input", function MaskedTextBoxComponent_input_HostBindingHandler($event) { return ctx.inputHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-maskedtextbox", ctx.hostClasses)("k-state-disabled", ctx.hostDisabledClass);
    } }, inputs: { focusableId: "focusableId", disabled: "disabled", readonly: "readonly", prompt: "prompt", promptPlaceholder: "promptPlaceholder", includeLiterals: "includeLiterals", maskOnFocus: "maskOnFocus", maskValidation: "maskValidation", tabindex: "tabindex", rules: "rules", tabIndex: "tabIndex", value: "value", title: "title", mask: "mask" }, outputs: { onFocus: "focus", onBlur: "blur", valueChange: "valueChange" }, exportAs: ["kendoMaskedTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            MaskingService,
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MaskedTextBoxComponent) /* tslint:disable-line */
            },
            {
                multi: true,
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => MaskedTextBoxComponent) /* tslint:disable-line */
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => MaskedTextBoxComponent)
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 12, consts: [["type", "text", "autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-textbox", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["input", ""]], template: function MaskedTextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "input", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction5(6, _c43, ctx.handleFocus, ctx.handleBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));
        ɵngcc0.ɵɵattribute("title", ctx.title);
    } }, directives: [ɵngcc2.EventsOutsideAngularDirective], encapsulation: 2 });
/** @nocollapse */
MaskedTextBoxComponent.ctorParameters = () => [
    { type: MaskingService },
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone },
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }
];
MaskedTextBoxComponent.propDecorators = {
    focusableId: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    title: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-maskedtextbox',] }],
    hostDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    mask: [{ type: Input }],
    value: [{ type: Input }],
    rules: [{ type: Input }],
    prompt: [{ type: Input }],
    promptPlaceholder: [{ type: Input }],
    includeLiterals: [{ type: Input }],
    maskOnFocus: [{ type: Input }],
    maskValidation: [{ type: Input }],
    tabindex: [{ type: Input }],
    tabIndex: [{ type: Input }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    valueChange: [{ type: Output }],
    input: [{ type: ViewChild, args: ['input', { static: true },] }],
    pasteHandler: [{ type: HostListener, args: ['paste', ['$event'],] }],
    inputHandler: [{ type: HostListener, args: ['input', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MaskedTextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoMaskedTextBox',
                providers: [
                    MaskingService,
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MaskedTextBoxComponent) /* tslint:disable-line */
                    },
                    {
                        multi: true,
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => MaskedTextBoxComponent) /* tslint:disable-line */
                    },
                    {
                        provide: KendoInput,
                        useExisting: forwardRef(() => MaskedTextBoxComponent)
                    }
                ],
                selector: 'kendo-maskedtextbox',
                template: `
        <input type="text"
            #input
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            class="k-textbox"
            [id]="focusableId"
            [tabindex]="tabIndex"
            [attr.title]="title"
            [disabled]="disabled"
            [readonly]="readonly"
            [kendoEventsOutsideAngular]="{
                focus: handleFocus,
                blur: handleBlur,
                click: handleClick,
                dragstart: handleDragDrop,
                drop: handleDragDrop
            }"
        />
    `
            }]
    }], function () { return [{ type: MaskingService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { focusableId: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-maskedtextbox']
        }], prompt: [{
            type: Input
        }], promptPlaceholder: [{
            type: Input
        }], includeLiterals: [{
            type: Input
        }], maskOnFocus: [{
            type: Input
        }], maskValidation: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], valueChange: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostDisabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], rules: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], pasteHandler: [{
            type: HostListener,
            args: ['paste', ['$event']]
        }], inputHandler: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], value: [{
            type: Input
        }], title: [{
            type: Input
        }], mask: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }] }); })();

/* tslint:disable:component-selector */
/**
 * @hidden
 */
class SliderTick {
    constructor(value) {
        this.value = value;
        this.classes = {
            'k-tick': true
        };
    }
}
/**
 * @hidden
 */
class SliderTicksComponent {
    constructor(rtl) {
        this.rtl = rtl;
        this.wrapperClasses = 'k-reset k-slider-items';
        this.ticks = [];
    }
    ngOnChanges(_) {
        this.createTicks();
    }
    createTicks() {
        const count = calculateTicksCount(this.min, this.max, this.step);
        const largeStep = this.largeStep;
        const tickValueProps = {
            max: this.max,
            min: this.min,
            smallStep: this.step
        };
        let result = [];
        for (let i = 0; i < count; i++) {
            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));
            if (largeStep && i % largeStep === 0) {
                result[i].large = true;
                result[i].classes['k-tick-large'] = true;
            }
        }
        if (this.rtl || this.vertical) {
            result = result.reverse();
        }
        if (result.length > 0) {
            Object.assign(result[0].classes, this.endTickClasses(true));
            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));
        }
        this.ticks = result;
    }
    endTickClasses(first) {
        return {
            'k-first': (first && !this.vertical) || (!first && this.vertical),
            'k-last': (!first && !this.vertical) || (first && this.vertical)
        };
    }
}
SliderTicksComponent.ɵfac = function SliderTicksComponent_Factory(t) { return new (t || SliderTicksComponent)(ɵngcc0.ɵɵdirectiveInject(RTL, 8)); };
SliderTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SliderTicksComponent, selectors: [["", "kendoSliderTicks", ""]], viewQuery: function SliderTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c44, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tickElements = _t);
    } }, hostVars: 2, hostBindings: function SliderTicksComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.wrapperClasses);
    } }, inputs: { tickTitle: "tickTitle", vertical: "vertical", step: "step", largeStep: "largeStep", min: "min", max: "max", labelTemplate: "labelTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c45, decls: 3, vars: 1, consts: [["role", "presentation", 3, "ngClass", "title", 4, "ngFor", "ngForOf"], ["defaultLabel", ""], ["role", "presentation", 3, "ngClass", "title"], ["tickElement", ""], [3, "ngSwitch"], ["class", "k-label", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [1, "k-label"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function SliderTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SliderTicksComponent_li_0_Template, 5, 5, "li", 0);
        ɵngcc0.ɵɵtemplate(1, SliderTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc3.NgForOf, ɵngcc3.NgClass, ɵngcc3.NgSwitch, ɵngcc3.NgSwitchCase, ɵngcc3.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
SliderTicksComponent.ctorParameters = () => [
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }
];
SliderTicksComponent.propDecorators = {
    wrapperClasses: [{ type: HostBinding, args: ['class',] }],
    tickTitle: [{ type: Input }],
    vertical: [{ type: Input }],
    step: [{ type: Input }],
    largeStep: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    labelTemplate: [{ type: Input }],
    tickElements: [{ type: ViewChildren, args: ['tickElement',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderTicksComponent, [{
        type: Component,
        args: [{
                selector: '[kendoSliderTicks]',
                template: `
    <li #tickElement *ngFor="let tick of ticks;"
        [ngClass]="tick.classes"
        title="{{ tickTitle(tick.value) }}"
        role="presentation"
     >
         <ng-container [ngSwitch]="tick.large">
            <span class="k-label" *ngSwitchCase="true">
                <ng-container [ngTemplateOutlet]="labelTemplate || defaultLabel" [ngTemplateOutletContext]="tick">
                </ng-container>
            </span>
            <ng-container *ngSwitchCase="false">&nbsp;</ng-container>
         </ng-container>
     </li>

     <ng-template #defaultLabel let-value="value">
        {{ tickTitle(value) }}
     </ng-template>
  `
            }]
    }], function () { return [{ type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [RTL]
            }] }]; }, { wrapperClasses: [{
            type: HostBinding,
            args: ['class']
        }], tickTitle: [{
            type: Input
        }], vertical: [{
            type: Input
        }], step: [{
            type: Input
        }], largeStep: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], labelTemplate: [{
            type: Input
        }], tickElements: [{
            type: ViewChildren,
            args: ['tickElement']
        }] }); })();

/**
 * @hidden
 */
class SlidersCommonModule {
}
SlidersCommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SlidersCommonModule });
SlidersCommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SlidersCommonModule_Factory(t) { return new (t || SlidersCommonModule)(); }, imports: [[CommonModule, DraggableModule, EventsModule, ResizeSensorModule],
        DraggableModule,
        EventsModule,
        ResizeSensorModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SlidersCommonModule, { declarations: function () { return [SliderTicksComponent,
        LabelTemplateDirective]; }, imports: function () { return [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]; }, exports: function () { return [LabelTemplateDirective,
        SliderTicksComponent,
        DraggableModule,
        EventsModule,
        ResizeSensorModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SlidersCommonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SliderTicksComponent,
                    LabelTemplateDirective
                ],
                exports: [
                    LabelTemplateDirective,
                    SliderTicksComponent,
                    DraggableModule,
                    EventsModule,
                    ResizeSensorModule
                ],
                imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class SliderMessages extends ComponentMessages {
}
SliderMessages.ɵfac = function SliderMessages_Factory(t) { return ɵSliderMessages_BaseFactory(t || SliderMessages); };
SliderMessages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SliderMessages, inputs: { decrement: "decrement", increment: "increment", dragHandle: "dragHandle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
SliderMessages.propDecorators = {
    decrement: [{ type: Input }],
    increment: [{ type: Input }],
    dragHandle: [{ type: Input }]
};
const ɵSliderMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(SliderMessages);

/**
 * @hidden
 */
class LocalizedSliderMessagesDirective extends SliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedSliderMessagesDirective.ɵfac = function LocalizedSliderMessagesDirective_Factory(t) { return new (t || LocalizedSliderMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedSliderMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedSliderMessagesDirective, selectors: [["", "kendoSliderLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SliderMessages,
                useExisting: forwardRef(() => LocalizedSliderMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedSliderMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedSliderMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: SliderMessages,
                        useExisting: forwardRef(() => LocalizedSliderMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSliderLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Custom component messages override default component messages.
 */
class SliderCustomMessagesComponent extends SliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
SliderCustomMessagesComponent.ɵfac = function SliderCustomMessagesComponent_Factory(t) { return new (t || SliderCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
SliderCustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SliderCustomMessagesComponent, selectors: [["kendo-slider-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SliderMessages,
                useExisting: forwardRef(() => SliderCustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SliderCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
SliderCustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: SliderMessages,
                        useExisting: forwardRef(() => SliderCustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-slider-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Slider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { SliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class SliderModule {
}
SliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SliderModule });
SliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SliderModule_Factory(t) { return new (t || SliderModule)(); }, imports: [[CommonModule, SlidersCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SliderModule, { declarations: function () { return [SliderComponent,
        SliderCustomMessagesComponent,
        LocalizedSliderMessagesDirective]; }, imports: function () { return [CommonModule,
        SlidersCommonModule]; }, exports: function () { return [SliderComponent,
        SliderCustomMessagesComponent,
        LabelTemplateDirective,
        LocalizedSliderMessagesDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SliderComponent,
                    SliderCustomMessagesComponent,
                    LocalizedSliderMessagesDirective
                ],
                exports: [
                    SliderComponent,
                    SliderCustomMessagesComponent,
                    LabelTemplateDirective,
                    LocalizedSliderMessagesDirective
                ],
                imports: [CommonModule, SlidersCommonModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class RangeSliderMessages extends ComponentMessages {
}
RangeSliderMessages.ɵfac = function RangeSliderMessages_Factory(t) { return ɵRangeSliderMessages_BaseFactory(t || RangeSliderMessages); };
RangeSliderMessages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RangeSliderMessages, inputs: { dragHandleStart: "dragHandleStart", dragHandleEnd: "dragHandleEnd" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
RangeSliderMessages.propDecorators = {
    dragHandleStart: [{ type: Input }],
    dragHandleEnd: [{ type: Input }]
};
const ɵRangeSliderMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(RangeSliderMessages);

/**
 * @hidden
 */
class LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedRangeSliderMessagesDirective.ɵfac = function LocalizedRangeSliderMessagesDirective_Factory(t) { return new (t || LocalizedRangeSliderMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedRangeSliderMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedRangeSliderMessagesDirective, selectors: [["", "kendoSliderLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RangeSliderMessages,
                useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedRangeSliderMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedRangeSliderMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: RangeSliderMessages,
                        useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSliderLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Custom component messages override default component messages.
 */
class RangeSliderCustomMessagesComponent extends RangeSliderMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
RangeSliderCustomMessagesComponent.ɵfac = function RangeSliderCustomMessagesComponent_Factory(t) { return new (t || RangeSliderCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
RangeSliderCustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RangeSliderCustomMessagesComponent, selectors: [["kendo-rangeslider-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RangeSliderMessages,
                useExisting: forwardRef(() => RangeSliderCustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RangeSliderCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
RangeSliderCustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RangeSliderCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: RangeSliderMessages,
                        useExisting: forwardRef(() => RangeSliderCustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-rangeslider-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the RangeSlider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { RangeSliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, RangeSliderModule], // import RangeSlider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class RangeSliderModule {
}
RangeSliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RangeSliderModule });
RangeSliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RangeSliderModule_Factory(t) { return new (t || RangeSliderModule)(); }, imports: [[CommonModule, SlidersCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RangeSliderModule, { declarations: function () { return [RangeSliderComponent,
        RangeSliderCustomMessagesComponent,
        LocalizedRangeSliderMessagesDirective]; }, imports: function () { return [CommonModule,
        SlidersCommonModule]; }, exports: function () { return [RangeSliderComponent,
        RangeSliderCustomMessagesComponent,
        LocalizedRangeSliderMessagesDirective,
        LabelTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RangeSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    RangeSliderComponent,
                    RangeSliderCustomMessagesComponent,
                    LocalizedRangeSliderMessagesDirective
                ],
                exports: [
                    RangeSliderComponent,
                    RangeSliderCustomMessagesComponent,
                    LocalizedRangeSliderMessagesDirective,
                    LabelTemplateDirective
                ],
                imports: [CommonModule, SlidersCommonModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = function Messages_Factory(t) { return ɵMessages_BaseFactory(t || Messages); };
Messages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { on: "on", off: "off" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
Messages.propDecorators = {
    on: [{ type: Input }],
    off: [{ type: Input }]
};
const ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages);

/**
 * @hidden
 */
class LocalizedSwitchMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedSwitchMessagesDirective.ɵfac = function LocalizedSwitchMessagesDirective_Factory(t) { return new (t || LocalizedSwitchMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedSwitchMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedSwitchMessagesDirective, selectors: [["", "kendoSwitchLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedSwitchMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedSwitchMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedSwitchMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedSwitchMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoSwitchLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Custom component messages override default component messages.
 */
class SwitchCustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
SwitchCustomMessagesComponent.ɵfac = function SwitchCustomMessagesComponent_Factory(t) { return new (t || SwitchCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
SwitchCustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwitchCustomMessagesComponent, selectors: [["kendo-switch-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => SwitchCustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SwitchCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
SwitchCustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwitchCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => SwitchCustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-switch-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Switch component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Switch module
 * import { SwitchModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, SwitchModule], // import Switch module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class SwitchModule {
}
SwitchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SwitchModule });
SwitchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SwitchModule_Factory(t) { return new (t || SwitchModule)(); }, imports: [[CommonModule, EventsModule, ResizeSensorModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SwitchModule, { declarations: function () { return [SwitchComponent,
        SwitchCustomMessagesComponent,
        LocalizedSwitchMessagesDirective]; }, imports: function () { return [CommonModule, EventsModule, ResizeSensorModule]; }, exports: function () { return [SwitchComponent,
        SwitchCustomMessagesComponent,
        LocalizedSwitchMessagesDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwitchModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SwitchComponent,
                    SwitchCustomMessagesComponent,
                    LocalizedSwitchMessagesDirective
                ],
                exports: [
                    SwitchComponent,
                    SwitchCustomMessagesComponent,
                    LocalizedSwitchMessagesDirective
                ],
                imports: [CommonModule, EventsModule, ResizeSensorModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedNumericTextBoxMessagesDirective.ɵfac = function LocalizedNumericTextBoxMessagesDirective_Factory(t) { return new (t || LocalizedNumericTextBoxMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedNumericTextBoxMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedNumericTextBoxMessagesDirective, selectors: [["", "kendoNumericTextBoxLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NumericTextBoxMessages,
                useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedNumericTextBoxMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedNumericTextBoxMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: NumericTextBoxMessages,
                        useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoNumericTextBoxLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the NumericTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the NumericTextBox module
 * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class NumericTextBoxModule {
}
NumericTextBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NumericTextBoxModule });
NumericTextBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NumericTextBoxModule_Factory(t) { return new (t || NumericTextBoxModule)(); }, imports: [[CommonModule, EventsModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NumericTextBoxModule, { declarations: function () { return [LocalizedNumericTextBoxMessagesDirective,
        NumericTextBoxComponent,
        NumericTextBoxCustomMessagesComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [NumericTextBoxComponent,
        NumericTextBoxCustomMessagesComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericTextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    LocalizedNumericTextBoxMessagesDirective,
                    NumericTextBoxComponent,
                    NumericTextBoxCustomMessagesComponent
                ],
                exports: [
                    NumericTextBoxComponent,
                    NumericTextBoxCustomMessagesComponent
                ],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the MaskedTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the MaskedTextBox module
 * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class MaskedTextBoxModule {
}
MaskedTextBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MaskedTextBoxModule });
MaskedTextBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MaskedTextBoxModule_Factory(t) { return new (t || MaskedTextBoxModule)(); }, imports: [[CommonModule, EventsModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MaskedTextBoxModule, { declarations: function () { return [MaskedTextBoxComponent]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [MaskedTextBoxComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MaskedTextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [MaskedTextBoxComponent],
                exports: [MaskedTextBoxComponent],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();

/**
 * Specifies the adornments in the suffix container ([see examples]({% slug adornments_textbox %}#toc-suffixadornments)).
 *  @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxSuffixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
class TextBoxSuffixTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TextBoxSuffixTemplateDirective.ɵfac = function TextBoxSuffixTemplateDirective_Factory(t) { return new (t || TextBoxSuffixTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
TextBoxSuffixTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextBoxSuffixTemplateDirective, selectors: [["", "kendoTextBoxSuffixTemplate", ""]] });
/** @nocollapse */
TextBoxSuffixTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxSuffixTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTextBoxSuffixTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Specifies the adornments in the prefix container ([see examples]({% slug adornments_textbox %}#toc-prefixadornments)).
 * @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxPrefixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
class TextBoxPrefixTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TextBoxPrefixTemplateDirective.ɵfac = function TextBoxPrefixTemplateDirective_Factory(t) { return new (t || TextBoxPrefixTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
TextBoxPrefixTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextBoxPrefixTemplateDirective, selectors: [["", "kendoTextBoxPrefixTemplate", ""]] });
/** @nocollapse */
TextBoxPrefixTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxPrefixTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTextBoxPrefixTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

class TextBoxComponent {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * Sets the `title` attribute of the `input` element of the TextBox.
         */
        this.title = '';
        /**
         * Sets the disabled state of the component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         *
         * @default false
         */
        this.readonly = false;
        /**
         * Specifies the `tabindex` of the TextBox.
         *
         * @default 0
         */
        this.tabindex = 0;
        /**
         * Provides a value for the TextBox.
         */
        this.value = null;
        /**
         * Determines whether the whole value will be selected when the TextBox is clicked. Defaults to `false`.
         *
         * @default false
         */
        this.selectOnFocus = false;
        /**
         * Specifies when the Success icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * `boolean`&mdash;The Success icon is displayed, if the condition given by the developer is met.
         *
         * `initial`&mdash;The Success icon will be displayed when the component state is neither `invalid` nor `touched` or `dirty`.
         *
         * @default false
         */
        this.showSuccessIcon = false;
        /**
         * Specifies when the Error icon will be shown ([see example]({% slug validation_textbox %})).
         *
         * The possible values are:
         *
         * * `initial`&mdash;The Error icon will be displayed when the component state is
         * `invalid` and `touched` or `dirty`.
         * * `boolean`&mdash;The Error icon is displayed, if the condition given by the developer is met.
         *
         * @default false
         */
        this.showErrorIcon = false;
        /**
         * Specifies whether a Clear button will be rendered.
         *
         * @default false
         */
        this.clearButton = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_textbox %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.inputFocus = new EventEmitter();
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.inputBlur = new EventEmitter();
        /**
         * Fires each time the user focuses the TextBox component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (focus)="handleFocus()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is isFocused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextBox component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts-no-run
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textbox (blur)="handleBlur()"></kendo-textbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        this.hostClass = true;
        this._isFocused = false;
        this.focusChangedProgrammatically = false;
        /**
         * @hidden
         */
        this.handleInputFocus = () => {
            if (!this.disabled) {
                if (this.selectOnFocus && this.value) {
                    this.ngZone.run(() => {
                        setTimeout(() => { this.selectAll(); });
                    });
                }
                if (hasObservers(this.onFocus)) {
                    if (!this.isFocused) {
                        this.ngZone.run(() => {
                            this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(this.inputFocus)) {
                    if (!this.focusChangedProgrammatically || (this.focusChangedProgrammatically && this.clearButtonClicked)) {
                        this.ngZone.run(() => {
                            this.inputFocus.emit();
                        });
                    }
                }
                this.ngZone.run(() => {
                    this.isFocused = true;
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInputBlur = () => {
            this.changeDetector.markForCheck();
            if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                    this.inputBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleInput = (ev) => {
            let incomingValue = ev.target.value;
            this.updateValue(incomingValue);
        };
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get disabledClass() {
        return this.disabled;
    }
    get isFocused() {
        return this.disabled ? false : this._isFocused;
    }
    set isFocused(isFocused) {
        this._isFocused = isFocused;
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
        this.checkClearButton();
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    ngAfterViewInit() {
        const hostElement = this.hostElement.nativeElement;
        let cursorInsideWrapper = false;
        let tabbing = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        this.onFocus.emit();
                        this.isFocused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);
                    if (!closestTextbox) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper && !this.clearButtonClicked) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
    ngOnChanges(changes) {
        if (changes.disabled || changes.readonly) {
            this.checkClearButton();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * Focuses the TextBox.
     *
     * @example
     * ```ts-no-run
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="input.focus()">Focus the input</button>
     *  <kendo-textbox #input></kendo-textbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the TextBox.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    /**
     * @hidden
     */
    clearTitle() {
        return this.localizationService.get('clear');
    }
    /**
     * @hidden
     */
    checkClearButton() {
        this.showClearButton =
            !this.disabled &&
                !this.readonly &&
                this.clearButton &&
                !!this.value;
    }
    /**
     * @hidden
     */
    clearValue(ev) {
        if (ev) {
            ev.preventDefault();
        }
        this.clearButtonClicked = true;
        this.input.nativeElement.value = '';
        this.input.nativeElement.focus();
        this.updateValue(null);
        this.checkClearButton();
        this.clearButtonClicked = false;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.checkClearButton();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    showErrorsInitial() {
        if (!this.control) {
            return false;
        }
        const { invalid, dirty, touched } = this.control;
        return invalid && (dirty || touched);
    }
    /**
     * @hidden
     */
    showSuccessInitial() {
        if (!this.control) {
            return false;
        }
        const { valid, dirty, touched } = this.control;
        return valid && (dirty || touched);
    }
    /**
     * @hidden
     */
    get successIconClasses() {
        return this.successIcon
            ? `k-text-success ${this.successIcon}`
            : `k-text-success k-icon k-i-check-outline`;
    }
    /**
     * @hidden
     */
    get errorIconClasses() {
        return this.errorIcon
            ? `k-text-error ${this.errorIcon}`
            : `k-text-error k-icon k-i-warning`;
    }
    /**
     * @hidden
     */
    get clearButtonClasses() {
        return this.clearButtonIcon
            ? this.clearButtonIcon
            : `k-icon k-i-close-circle`;
    }
    /**
     * @hidden
     */
    get hasErrors() {
        return this.showErrorIcon === 'initial'
            ? this.showErrorsInitial()
            : this.showErrorIcon;
    }
    /**
     * @hidden
     */
    get isSuccessful() {
        return this.showSuccessIcon === 'initial'
            ? this.showSuccessInitial()
            : this.showSuccessIcon;
    }
    setSelection(start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    selectAll() {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.checkClearButton();
                this.changeDetector.markForCheck();
            });
        }
    }
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
}
TextBoxComponent.ɵfac = function TextBoxComponent_Factory(t) { return new (t || TextBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TextBoxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TextBoxComponent, selectors: [["kendo-textbox"]], contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
    } }, viewQuery: function TextBoxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c42, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 7, hostBindings: function TextBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-textbox", ctx.hostClass)("k-state-focused", ctx.isFocused)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { title: "title", disabled: "disabled", readonly: "readonly", tabindex: "tabindex", value: "value", selectOnFocus: "selectOnFocus", showSuccessIcon: "showSuccessIcon", showErrorIcon: "showErrorIcon", clearButton: "clearButton", tabIndex: "tabIndex", successIcon: "successIcon", errorIcon: "errorIcon", clearButtonIcon: "clearButtonIcon", placeholder: "placeholder" }, outputs: { valueChange: "valueChange", inputFocus: "inputFocus", inputBlur: "inputBlur", onFocus: "focus", onBlur: "blur" }, exportAs: ["kendoTextBox"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextBoxComponent),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent) }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 11, vars: 16, consts: [["kendoTextBoxLocalizedMessages", "", 6, "clear"], [1, "k-input-prefix"], [4, "ngIf"], [1, "k-input", 3, "disabled", "readonly", "value", "kendoEventsOutsideAngular"], ["input", ""], [1, "k-input-suffix"], [3, "ngClass", 4, "ngIf"], ["role", "button", "class", "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "ngClass"], ["role", "button", 1, "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space"]], template: function TextBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c48);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 1);
        ɵngcc0.ɵɵtemplate(3, TextBoxComponent_3_Template, 1, 1, undefined, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "input", 3, 4);
        ɵngcc0.ɵɵelementStart(6, "span", 5);
        ɵngcc0.ɵɵtemplate(7, TextBoxComponent_span_7_Template, 1, 1, "span", 6);
        ɵngcc0.ɵɵtemplate(8, TextBoxComponent_span_8_Template, 1, 1, "span", 6);
        ɵngcc0.ɵɵtemplate(9, TextBoxComponent_span_9_Template, 2, 4, "span", 7);
        ɵngcc0.ɵɵtemplate(10, TextBoxComponent_10_Template, 1, 1, undefined, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.value)("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction3(12, _c49, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵngcc0.ɵɵattribute("tabindex", ctx.disabled ? undefined : ctx.tabindex)("placeholder", ctx.placeholder)("title", ctx.title);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSuccessful);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClearButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.suffixTemplate);
    } }, directives: function () { return [LocalizedTextBoxMessagesDirective, ɵngcc3.NgIf, ɵngcc2.EventsOutsideAngularDirective, ɵngcc3.NgTemplateOutlet, ɵngcc3.NgClass]; }, encapsulation: 2 });
/** @nocollapse */
TextBoxComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: Injector },
    { type: ElementRef }
];
TextBoxComponent.propDecorators = {
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tabindex: [{ type: Input }],
    value: [{ type: Input }],
    selectOnFocus: [{ type: Input }],
    showSuccessIcon: [{ type: Input }],
    showErrorIcon: [{ type: Input }],
    clearButton: [{ type: Input }],
    successIcon: [{ type: Input }],
    errorIcon: [{ type: Input }],
    clearButtonIcon: [{ type: Input }],
    tabIndex: [{ type: Input }],
    placeholder: [{ type: Input }],
    valueChange: [{ type: Output }],
    inputFocus: [{ type: Output }],
    inputBlur: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    input: [{ type: ViewChild, args: ['input', { static: true },] }],
    suffixTemplate: [{ type: ContentChild, args: [TextBoxSuffixTemplateDirective,] }],
    prefixTemplate: [{ type: ContentChild, args: [TextBoxPrefixTemplateDirective,] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    hostClass: [{ type: HostBinding, args: ['class.k-textbox',] }],
    isFocused: [{ type: HostBinding, args: ['class.k-state-focused',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoTextBox',
                providers: [
                    LocalizationService,
                    { provide: L10N_PREFIX, useValue: 'kendo.textbox' },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TextBoxComponent),
                        multi: true
                    },
                    { provide: KendoInput, useExisting: forwardRef(() => TextBoxComponent) }
                ],
                selector: 'kendo-textbox',
                template: `
        <ng-container kendoTextBoxLocalizedMessages
            i18n-clear="kendo.textbox.clear|The title for the **Clear** button in the TextBox."
            clear="Clear">
        </ng-container>
        <span class="k-input-prefix">
            <ng-template
                *ngIf="prefixTemplate"
                [ngTemplateOutlet]="prefixTemplate?.templateRef">
            </ng-template>
        </span>
        <input
            class="k-input"
            #input
            [disabled]="disabled"
            [readonly]="readonly"
            [attr.tabindex]="disabled ? undefined : tabindex"
            [value]="value"
            [attr.placeholder]="placeholder"
            [attr.title]="title"
            [kendoEventsOutsideAngular]="{
                focus: handleInputFocus,
                blur: handleInputBlur,
                input: handleInput}"/>
        <span class="k-input-suffix">
            <span *ngIf="hasErrors" [ngClass]="errorIconClasses"></span>
            <span *ngIf="isSuccessful" [ngClass]="successIconClasses"></span>
            <span
                role="button"
                class="k-clear-value"
                *ngIf="showClearButton"
                (click)="clearValue()"
                (mousedown)="$event.preventDefault()"
                [tabindex]="tabIndex"
                [attr.aria-label]="clearTitle()"
                [title]="clearTitle()"
                (keydown.enter)="clearValue($event)"
                (keydown.space)="clearValue($event)"
                >
                <span [ngClass]="clearButtonClasses"></span>
            </span>
            <ng-template
                *ngIf="suffixTemplate"
                [ngTemplateOutlet]="suffixTemplate?.templateRef">
            </ng-template>
        </span>
    `
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef }]; }, { title: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], value: [{
            type: Input
        }], selectOnFocus: [{
            type: Input
        }], showSuccessIcon: [{
            type: Input
        }], showErrorIcon: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], inputFocus: [{
            type: Output
        }], inputBlur: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-textbox']
        }], isFocused: [{
            type: HostBinding,
            args: ['class.k-state-focused']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], tabIndex: [{
            type: Input
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], successIcon: [{
            type: Input
        }], errorIcon: [{
            type: Input
        }], clearButtonIcon: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], suffixTemplate: [{
            type: ContentChild,
            args: [TextBoxSuffixTemplateDirective]
        }], prefixTemplate: [{
            type: ContentChild,
            args: [TextBoxPrefixTemplateDirective]
        }] }); })();

/**
 * Specifies a separator in the content of the TextBox ([see examples]({% slug adornments_textbox %}#toc-separator)).
 * @example
 * ```ts-no-run
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-textbox>
 *    <ng-template kendoTextBoxSuffixTemplate>
 *        <button kendoButton look="clear" icon="image"></button>
 *        <kendo-textbox-separator></kendo-textbox-separator>
 *    </ng-template>
 *  </kendo-textbox>
 * `
 * })
 * class AppComponent {}
 * ```
 */
class TextBoxSeparatorComponent {
    constructor() {
        this.hostClass = true;
    }
}
TextBoxSeparatorComponent.ɵfac = function TextBoxSeparatorComponent_Factory(t) { return new (t || TextBoxSeparatorComponent)(); };
TextBoxSeparatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TextBoxSeparatorComponent, selectors: [["kendo-textbox-separator"]], hostVars: 2, hostBindings: function TextBoxSeparatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-textbox-separator", ctx.hostClass);
    } }, decls: 0, vars: 0, template: function TextBoxSeparatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
TextBoxSeparatorComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-textbox-separator',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxSeparatorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-textbox-separator',
                template: ``
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-textbox-separator']
        }] }); })();

/**
 * @hidden
 */
class TextBoxMessages extends ComponentMessages {
}
TextBoxMessages.ɵfac = function TextBoxMessages_Factory(t) { return ɵTextBoxMessages_BaseFactory(t || TextBoxMessages); };
TextBoxMessages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextBoxMessages, inputs: { clear: "clear" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
TextBoxMessages.propDecorators = {
    clear: [{ type: Input }]
};
const ɵTextBoxMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TextBoxMessages);

/**
 * Custom component messages override default component messages.
 */
class TextBoxCustomMessagesComponent extends TextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
TextBoxCustomMessagesComponent.ɵfac = function TextBoxCustomMessagesComponent_Factory(t) { return new (t || TextBoxCustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
TextBoxCustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TextBoxCustomMessagesComponent, selectors: [["kendo-textbox-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TextBoxMessages,
                useExisting: forwardRef(() => TextBoxCustomMessagesComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TextBoxCustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
TextBoxCustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxCustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: TextBoxMessages,
                        useExisting: forwardRef(() => TextBoxCustomMessagesComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-textbox-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * @hidden
 */
class LocalizedTextBoxMessagesDirective extends TextBoxMessages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedTextBoxMessagesDirective.ɵfac = function LocalizedTextBoxMessagesDirective_Factory(t) { return new (t || LocalizedTextBoxMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
LocalizedTextBoxMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedTextBoxMessagesDirective, selectors: [["", "kendoTextBoxLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: TextBoxMessages,
                useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedTextBoxMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedTextBoxMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: TextBoxMessages,
                        useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: '[kendoTextBoxLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TextBox module
 * import { TextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TextBoxModule], // import TextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class TextBoxModule {
}
TextBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TextBoxModule });
TextBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TextBoxModule_Factory(t) { return new (t || TextBoxModule)(); }, imports: [[CommonModule, EventsModule],
        EventsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextBoxModule, { declarations: function () { return [TextBoxDirective,
        TextAreaDirective,
        TextBoxContainerComponent,
        TextBoxComponent,
        TextBoxSeparatorComponent,
        TextBoxSuffixTemplateDirective,
        TextBoxPrefixTemplateDirective,
        TextBoxCustomMessagesComponent,
        LocalizedTextBoxMessagesDirective]; }, imports: function () { return [CommonModule, EventsModule]; }, exports: function () { return [TextBoxDirective,
        TextAreaDirective,
        TextBoxContainerComponent,
        TextBoxComponent,
        TextBoxSeparatorComponent,
        TextBoxSuffixTemplateDirective,
        TextBoxPrefixTemplateDirective,
        EventsModule,
        TextBoxCustomMessagesComponent,
        LocalizedTextBoxMessagesDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TextBoxDirective,
                    TextAreaDirective,
                    TextBoxContainerComponent,
                    TextBoxComponent,
                    TextBoxSeparatorComponent,
                    TextBoxSuffixTemplateDirective,
                    TextBoxPrefixTemplateDirective,
                    TextBoxCustomMessagesComponent,
                    LocalizedTextBoxMessagesDirective
                ],
                exports: [
                    TextBoxDirective,
                    TextAreaDirective,
                    TextBoxContainerComponent,
                    TextBoxComponent,
                    TextBoxSeparatorComponent,
                    TextBoxSuffixTemplateDirective,
                    TextBoxPrefixTemplateDirective,
                    EventsModule,
                    TextBoxCustomMessagesComponent,
                    LocalizedTextBoxMessagesDirective
                ],
                imports: [CommonModule, EventsModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns - `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Fires each time the left side of the ColorPicker wrapper is clicked.
 * The event is triggered regardless of whether a ColorPicker icon is set or not.
 *
 * Provides information about the current active color and gives the option to prevent the opening of the popup.
 *
 * @example
 *
 * ```ts-no-run
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-colorpicker
 *           [icon]="'edit-tools'"
 *           [value]="'#900'"
 *           (activeColorClick)="handleActiveColorClick($event)"
 *       >
 *       </kendo-colorpicker>
 *   `
 * })
 * class AppComponent {
 *     public handleActiveColorClick(event: ActiveColorClickEvent): void {
 *         event.preventOpen();
 *
 *         console.log('Open prevented:', event.isOpenPrevented());
 *         console.log('Current color:', event.color);
 *     }
 *  }
 * ```
 */
class ActiveColorClickEvent {
    /**
     * @hidden
     * @param color Represents the current value of the ColorPicker.
     */
    constructor(color) {
        this.color = color;
        this.openPrevented = false;
    }
    /**
     * Prevents the opening of the popup.
     */
    preventOpen() {
        this.openPrevented = true;
    }
    /**
     * Returns `true` if the popup opening is prevented by any of its subscribers.
     *
     * @returns - Returns `true` if the open action was prevented. Otherwise, returns `false`.
     */
    isOpenPrevented() {
        return this.openPrevented;
    }
}

/**
 * @hidden
 *
 * Returns the hex or rgba string representation of the color.
 */
const parseColor$1 = (value, format, safe = true) => {
    const allowedFormats = ['hex', 'rgba', 'name'];
    if (allowedFormats.indexOf(format) === -1) {
        throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);
    }
    if (!isPresent(value)) {
        return;
    }
    if (format === 'name') {
        return nameFormat(value, safe);
    }
    const parsedColor = parseColor(value.trim(), safe);
    if (!isPresent(parsedColor)) {
        return;
    }
    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();
};
/**
 * @hidden
 *
 * Returns an HSV object representation of the color string.
 */
const getHSV = (value, safe = true) => {
    const parsed = parseColor(value, safe);
    if (!isPresent(parsed)) {
        return {};
    }
    return parsed.toHSV();
};
/**
 * @hidden
 *
 * Returns an RGBA object representation of the color string.
 */
const getRGBA = (value, safe = true) => {
    const parsed = parseColor(value, safe);
    if (!isPresent(parsed)) {
        return {};
    }
    return parsed.toBytes();
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
const getColorFromHSV = (hsva) => {
    const hue = fitIntoBounds(hsva.h, 0, 359.9);
    const saturation = fitIntoBounds(hsva.s, 0, 1);
    const value = fitIntoBounds(hsva.v, 0, 1);
    const alpha = fitIntoBounds(hsva.a, 0, 1);
    return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color based on the `hue`, assuming the `value`, `saturation` and `alpha` have value of `1`.
 */
const getColorFromHue = (hue) => {
    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });
};
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
const getColorFromRGBA = (rgba) => {
    const red = fitIntoBounds(rgba.r, 0, 255);
    const green = fitIntoBounds(rgba.g, 0, 255);
    const blue = fitIntoBounds(rgba.b, 0, 255);
    const alpha = fitIntoBounds(rgba.a, 0, 1);
    return Color.fromBytes(red, green, blue, alpha).toCssRgba();
};
/**
 *
 * @hidden
 */
function nameFormat(value, safe) {
    value = value.toLowerCase().trim();
    if (isPresent(namedColors[value])) {
        return value;
    }
    if (parseColor(value, safe)) {
        value = parseColor(value, safe).toHex();
    }
    const key = Object.keys(namedColors).find(key => namedColors[key] === value);
    if (!key && !safe) {
        throw new Error(`The provided color ${value} is not supported for 'format="name"' property.To display ${value} color, the component 'format' property shoud be set to 'hex' or 'rgba' `);
    }
    return key;
}

// tslint:disable:max-line-length
/**
 * @hidden
 */
const PALETTEPRESETS = {
    basic: {
        colors: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7',
        columns: 10
    },
    office: {
        colors: 'ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623',
        columns: 10
    },
    apex: {
        colors: 'ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366',
        columns: 10
    },
    austin: {
        colors: 'ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200',
        columns: 10
    },
    clarity: {
        colors: 'ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e',
        columns: 10
    },
    slipstream: {
        colors: 'ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908',
        columns: 10
    },
    metro: {
        colors: 'ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f',
        columns: 10
    },
    flow: {
        colors: 'ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321',
        columns: 10
    },
    hardcover: {
        colors: 'ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243',
        columns: 10
    },
    trek: {
        colors: 'ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14',
        columns: 10
    },
    verve: {
        colors: 'ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f',
        columns: 10
    },
    monochrome: {
        colors: '000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff',
        columns: 12
    },
    accessible: {
        colors: 'black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple',
        columns: 10
    }
};

const DEFAULT_PRESET = 'office';
const DEFAULT_ACCESSIBLE_PRESET = 'accessible';
let serial = 0;
/**
 * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).
 * Designed to replace the `<input type="color">` HTML5 tag which is not widely supported in browsers.
 */
class ColorPickerComponent {
    constructor(popupService, localizationService) {
        this.popupService = popupService;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.focusableId = `k-colorpicker-${serial++}`;
        /**
         * Sets what view the ColorPicker will render in the popup.
         */
        this.view = 'gradient';
        /**
         * Sets the read-only state of the ColorPicker.
         */
        this.readonly = false;
        /**
         * Sets the disabled state of the ColorPicker.
         */
        this.disabled = false;
        /**
         * Specifies the output format of the ColorPicker.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.
         *
         * The supported values are:
         * * `rgba` (default)
         * * `hex`
         * * [`name`](https://www.w3.org/wiki/CSS/Properties/color/keywords)
         */
        this.format = 'rgba';
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time ColorPicker is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the ColorPicker is blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the left side of the ColorPicker wrapper is clicked.
         * The event is triggered regardless of whether a ColorPicker icon is set or not.
         *
         * The [`ActiveColorClickEvent`]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
         */
        this.activeColorClick = new EventEmitter();
        this._tabindex = 0;
        this._popupSettings = { animate: true };
        this._paletteSettings = {};
        this._gradientSettings = { opacity: true, clearButton: false };
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Configures the popup of the ColorPicker.
     */
    set popupSettings(value) {
        this._popupSettings = Object.assign(this._popupSettings, value);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Configures the palette that is displayed in the ColorPicker popup.
     */
    set paletteSettings(value) {
        this._paletteSettings = Object.assign(this._paletteSettings, value);
    }
    get paletteSettings() {
        return this._paletteSettings;
    }
    /**
     * Configures the gradient that is displayed in the ColorPicker popup.
     */
    set gradientSettings(value) {
        this._gradientSettings = Object.assign(this._gradientSettings, value);
    }
    get gradientSettings() {
        return this._gradientSettings;
    }
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorPicker popup is open.
     */
    get isOpen() {
        return isPresent(this.popupRef);
    }
    /**
     * @hidden
     */
    get iconStyles() {
        if (this.iconClass) {
            return this.iconClass;
        }
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
    }
    ngOnInit() {
        const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
        const settingsPalette = this._paletteSettings.palette;
        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?
            PALETTEPRESETS[settingsPalette].columns :
            undefined;
        this._paletteSettings = {
            palette: settingsPalette || defaultPreset,
            tileSize: this._paletteSettings.tileSize || 24,
            columns: this._paletteSettings.columns || presetColumns || 10
        };
    }
    ngOnChanges(changes) {
        if (changes.format && changes.format.currentValue === 'name') {
            this.view = 'palette';
        }
        if (this.view === 'gradient' && this.gradientSettings.opacity) {
            this.format = 'rgba';
            this.value = parseColor$1(this.value, this.format);
        }
    }
    ngOnDestroy() {
        this.closePopup();
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    handleWrapperClick() {
        this.toggleWithEvents(!this.isOpen);
        this.focus();
    }
    /**
     * @hidden
     */
    handleActiveColorClick() {
        this.focus();
        const event = new ActiveColorClickEvent(this.value);
        this.activeColorClick.emit(event);
        if (!event.isOpenPrevented() || this.isOpen) {
            this.handleWrapperClick();
        }
    }
    /**
     * Focuses the wrapper of the ColorPicker.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.wrapper.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleWrapperFocus() {
        if (isPresent(this.palette)) {
            this.palette.nativeElement.focus();
        }
        if (this.isFocused) {
            return;
        }
        this.isFocused = true;
        this.onFocus.emit();
    }
    /**
     * Blurs the ColorPicker.
     */
    blur() {
        this.wrapper.nativeElement.blur();
    }
    /**
     * @hidden
     */
    handleWrapperBlur() {
        if (this.isOpen) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
    }
    /**
     * Clears the color value of the ColorPicker.
     */
    reset() {
        if (!isPresent(this.value)) {
            return;
        }
        this._value = undefined;
        this.notifyNgChanged(undefined);
    }
    /**
     * Toggles the popup of the ColorPicker.
     * Does not trigger the `open` and `close` events of the component.
     *
     * @param open An optional parameter. Specifies whether the popup will be opened or closed.
     */
    toggle(open) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.closePopup();
        open = isPresent(open) ? open : !this.isOpen;
        if (open) {
            this.openPopup();
        }
    }
    /**
     * @hidden
     */
    handleValueChange(color, closePopup) {
        const parsedColor = parseColor$1(color, this.format);
        const valueChange = parsedColor !== this.value;
        if (closePopup) {
            this.toggleWithEvents(false);
            this.focus();
        }
        if (valueChange) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
        }
    }
    /**
     * @hidden
     */
    handlePopupBlur(event) {
        const focusInPopupElement = this.popupRef.popupElement.contains(event.relatedTarget);
        const wrapperClicked = event.relatedTarget === this.wrapper.nativeElement;
        if (!this.isFocused || wrapperClicked || focusInPopupElement) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
        this.toggleWithEvents(false);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    handleWrapperKeyDown(event) {
        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {
            event.preventDefault();
            this.toggleWithEvents(true);
        }
    }
    /**
     * @hidden
     */
    handlePopupKeyDown(keyCode) {
        if (keyCode === Keys.Tab || keyCode === Keys.Escape) {
            this.toggleWithEvents(false);
            this.wrapper.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    toggleWithEvents(open) {
        const sameState = this.isOpen === open;
        if (this.disabled || this.readonly || sameState) {
            return;
        }
        const eventArgs = new PreventableEvent();
        open ? this.open.emit(eventArgs) : this.close.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.toggle(open);
        }
    }
    openPopup() {
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.popupSettings.appendTo,
            popupAlign: popupPosition,
            anchorAlign: anchorPosition,
            popupClass: 'k-colorpicker-popup',
            content: this.popupTemplate,
            positionMode: 'absolute'
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.toggleWithEvents(false);
            if (!this.isOpen) {
                this.wrapper.nativeElement.focus({
                    preventScroll: true
                });
            }
        });
    }
    closePopup() {
        if (!this.isOpen) {
            return;
        }
        this.popupRef.close();
        this.popupRef = null;
        this.palette = null;
    }
}
ColorPickerComponent.ɵfac = function ColorPickerComponent_Factory(t) { return new (t || ColorPickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ColorPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorPickerComponent, selectors: [["kendo-colorpicker"]], viewQuery: function ColorPickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c50, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c51, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c23, true);
        ɵngcc0.ɵɵviewQuery(_c52, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.palette = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
    } }, hostVars: 5, hostBindings: function ColorPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-colorpicker", ctx.hostClasses);
    } }, inputs: { focusableId: "focusableId", view: "view", readonly: "readonly", disabled: "disabled", format: "format", value: "value", popupSettings: "popupSettings", paletteSettings: "paletteSettings", gradientSettings: "gradientSettings", tabindex: "tabindex", icon: "icon", iconClass: "iconClass" }, outputs: { valueChange: "valueChange", open: "open", close: "close", onFocus: "focus", onBlur: "blur", activeColorClick: "activeColorClick" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPickerComponent)
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPickerComponent)
            },
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpicker'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 9, consts: [["role", "listbox", 3, "ngClass", "id", "focus", "blur", "mousedown", "keydown"], ["wrapper", ""], ["class", "k-selected-color", 3, "background-color", "click", 4, "ngIf"], ["class", "k-tool-icon", 3, "ngClass", "click", 4, "ngIf"], [1, "k-select", 3, "click"], [1, "k-icon", "k-i-arrow-s"], ["popupTemplate", ""], ["container", ""], [1, "k-selected-color", 3, "click"], ["class", "k-icon k-i-line", 4, "ngIf"], [1, "k-icon", "k-i-line"], [1, "k-tool-icon", 3, "ngClass", "click"], [1, "k-selected-color"], ["kendoFocusOnDomReady", "", 3, "value", "format", "opacity", "clearButton", "focusout", "valueChange", "keydown", 4, "ngIf"], ["kendoFocusOnDomReady", "", 3, "palette", "columns", "tileSize", "format", "value", "blur", "cellSelection", "mousedown", "keydown", 4, "ngIf"], ["kendoFocusOnDomReady", "", 3, "value", "format", "opacity", "clearButton", "focusout", "valueChange", "keydown"], ["kendoFocusOnDomReady", "", 3, "palette", "columns", "tileSize", "format", "value", "blur", "cellSelection", "mousedown", "keydown"], ["palette", ""]], template: function ColorPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0, 1);
        ɵngcc0.ɵɵlistener("focus", function ColorPickerComponent_Template_span_focus_0_listener() { return ctx.handleWrapperFocus(); })("blur", function ColorPickerComponent_Template_span_blur_0_listener() { return ctx.handleWrapperBlur(); })("mousedown", function ColorPickerComponent_Template_span_mousedown_0_listener($event) { return $event.preventDefault(); })("keydown", function ColorPickerComponent_Template_span_keydown_0_listener($event) { return ctx.handleWrapperKeyDown($event); });
        ɵngcc0.ɵɵtemplate(2, ColorPickerComponent_span_2_Template, 2, 3, "span", 2);
        ɵngcc0.ɵɵtemplate(3, ColorPickerComponent_span_3_Template, 2, 3, "span", 3);
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵlistener("click", function ColorPickerComponent_Template_span_click_4_listener() { return ctx.handleWrapperClick(); });
        ɵngcc0.ɵɵelement(5, "span", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ColorPickerComponent_ng_template_6_Template, 2, 2, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainer(8, null, 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(6, _c53, ctx.disabled, ctx.isFocused))("id", ctx.focusableId);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.isOpen)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.iconStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconStyles);
    } }, directives: function () { return [ɵngcc3.NgClass, ɵngcc3.NgIf, ColorGradientComponent,
        FocusOnDomReadyDirective,
        ColorPaletteComponent]; }, encapsulation: 2 });
/** @nocollapse */
ColorPickerComponent.ctorParameters = () => [
    { type: PopupService },
    { type: LocalizationService }
];
ColorPickerComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-colorpicker',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    focusableId: [{ type: Input }],
    view: [{ type: Input }],
    readonly: [{ type: Input }],
    disabled: [{ type: Input }],
    format: [{ type: Input }],
    value: [{ type: Input }],
    popupSettings: [{ type: Input }],
    paletteSettings: [{ type: Input }],
    gradientSettings: [{ type: Input }],
    icon: [{ type: Input }],
    iconClass: [{ type: Input }],
    tabindex: [{ type: Input }],
    valueChange: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    onFocus: [{ type: Output, args: ['focus',] }],
    onBlur: [{ type: Output, args: ['blur',] }],
    activeColorClick: [{ type: Output }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    wrapper: [{ type: ViewChild, args: ['wrapper',] }],
    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
    palette: [{ type: ViewChild, args: ['palette', { read: ElementRef },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorPickerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorpicker',
                providers: [{
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPickerComponent)
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPickerComponent)
                    },
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpicker'
                    }
                ],
                template: `
        <span
            #wrapper
            [ngClass]="{
                'k-picker-wrap': true,
                'k-state-disabled': this.disabled,
                'k-state-focused': this.isFocused
            }"
            role="listbox"
            [attr.aria-expanded]="isOpen"
            [id]="focusableId"
            [attr.tabindex]="tabindex"
            (focus)="handleWrapperFocus()"
            (blur)="handleWrapperBlur()"
            (mousedown)="$event.preventDefault()"
            (keydown)="handleWrapperKeyDown($event)"
        >
            <span *ngIf="!iconStyles" class="k-selected-color" [style.background-color]="value" (click)="handleActiveColorClick()">
                <span class="k-icon k-i-line" *ngIf="!value"></span>
            </span>
            <span *ngIf="iconStyles" class="k-tool-icon" [ngClass]="iconStyles" (click)="handleActiveColorClick()">
                <span class="k-selected-color" [style.background-color]="value"></span>
            </span>
            <span class="k-select" (click)="handleWrapperClick()">
                <span class="k-icon k-i-arrow-s"></span>
            </span>
        </span>
        <ng-template #popupTemplate>
            <kendo-colorgradient
                *ngIf="view === 'gradient' || view === 'combo'"
                kendoFocusOnDomReady
                [value]="value"
                [format]="format"
                [opacity]="gradientSettings.opacity"
                [clearButton]="gradientSettings.clearButton"
                (focusout)="handlePopupBlur($event)"
                (valueChange)="handleValueChange($event, false)"
                (keydown)="handlePopupKeyDown($event.keyCode)"
            >
            </kendo-colorgradient>
            <kendo-colorpalette
                #palette
                *ngIf="view === 'palette' || view === 'combo'"
                kendoFocusOnDomReady
                [palette]="paletteSettings.palette"
                [columns]="paletteSettings.columns"
                [tileSize]="paletteSettings.tileSize"
                [format]="format"
                [value]="value"
                (blur)="handlePopupBlur($event)"
                (cellSelection)="handleValueChange($event, true)"
                (mousedown)="$event.preventDefault()"
                (keydown)="handlePopupKeyDown($event.keyCode)"
            >
            </kendo-colorpalette>
        </ng-template>
        <ng-container #container></ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc5.PopupService }, { type: ɵngcc1.LocalizationService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-colorpicker']
        }], focusableId: [{
            type: Input
        }], view: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabled: [{
            type: Input
        }], format: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], activeColorClick: [{
            type: Output
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], value: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], paletteSettings: [{
            type: Input
        }], gradientSettings: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], palette: [{
            type: ViewChild,
            args: ['palette', { read: ElementRef }]
        }], icon: [{
            type: Input
        }], iconClass: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef }]
        }], wrapper: [{
            type: ViewChild,
            args: ['wrapper']
        }], popupTemplate: [{
            type: ViewChild,
            args: ['popupTemplate']
        }] }); })();

/**
 * @hidden
 */
class ColorPaletteService {
    constructor() {
        this.colorRows = [];
    }
    setColorMatrix(palette, columns) {
        this.colorRows = [];
        if (!(isPresent(palette) && palette.length)) {
            return;
        }
        columns = columns || palette.length;
        for (let start = 0; start < palette.length; start += columns) {
            const row = palette.slice(start, columns + start);
            this.colorRows.push(row);
        }
    }
    getCellCoordsFor(color) {
        if (!isPresent(color)) {
            return;
        }
        for (let row = 0; row < this.colorRows.length; row++) {
            for (let col = 0; col < this.colorRows[row].length; col++) {
                if (this.colorRows[row][col] === color) {
                    return { row, col };
                }
            }
        }
    }
    getColorAt(cellCoords) {
        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {
            return;
        }
        return this.colorRows[cellCoords.row][cellCoords.col];
    }
    getNextCell(current, horizontalStep, verticalStep) {
        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {
            return { row: 0, col: 0 };
        }
        const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
        const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
        return { row, col };
    }
    clampIndex(index, max) {
        const minArrayIndex = 0;
        if (index < minArrayIndex) {
            return minArrayIndex;
        }
        if (index > max) {
            return max;
        }
        return index;
    }
}
ColorPaletteService.ɵfac = function ColorPaletteService_Factory(t) { return new (t || ColorPaletteService)(); };
ColorPaletteService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColorPaletteService, factory: ColorPaletteService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorPaletteService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const DEFAULT_TILE_SIZE = 24;
const DEFAULT_COLUMNS_COUNT = 10;
const DEFAULT_PRESET$1 = 'office';
const DEFAULT_ACCESSIBLE_PRESET$1 = 'accessible';
let serial$1 = 0;
/**
 * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.
 * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
class ColorPaletteComponent {
    constructor(service, localizationService) {
        this.service = service;
        /**
         * @hidden
         */
        this.id = `k-colorpalette-${serial$1++}`;
        /**
         * Specifies the output format of the ColorPaletteComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `hex`
         * * `rgba`
         * * `name`
         */
        this.format = 'hex';
        /**
         * Specifies the size of a color cell.
         *
         * The possible values are:
         * * (Default) `tileSize = 24`
         * * `{ width: number, height: number }`
         */
        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };
        /**
         * Fires each time the color selection is changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user selects a cell with the mouse or presses `Enter`.
         *
         * @hidden
         */
        this.cellSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.hostClasses = true;
        this._tabindex = 0;
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get paletteId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the number of columns that will be displayed.
     * Defaults to `10`.
     */
    set columns(value) {
        const minColumnsCount = 1;
        this._columns = value > minColumnsCount ? value : minColumnsCount;
    }
    get columns() {
        return this._columns;
    }
    /**
     * The color palette that will be displayed.
     *
     * The supported values are:
     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).
     * * A string with comma-separated colors.
     * * A string array.
     */
    set palette(value) {
        if (!isPresent(value)) {
            value = DEFAULT_PRESET$1;
        }
        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {
            this.columns = this.columns || PALETTEPRESETS[value].columns;
            value = PALETTEPRESETS[value].colors;
        }
        const colors = (typeof value === 'string') ? value.split(',') : value;
        this._palette = colors.map(color => parseColor$1(color, this.format, false));
    }
    get palette() {
        return this._palette;
    }
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * @hidden
     */
    get tileLayout() {
        if (typeof this.tileSize !== 'number') {
            return this.tileSize;
        }
        return { width: this.tileSize, height: this.tileSize };
    }
    /**
     * @hidden
     */
    get colorRows() {
        return this.service.colorRows;
    }
    /**
     * @hidden
     */
    get hostTabindex() { return this.tabindex; }
    /**
     * @hidden
     */
    get disabledClass() { return this.disabled; }
    ngOnInit() {
        if (this.colorRows.length === 0) {
            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
            this.palette = this.palette || defaultPreset;
            this.setRows();
            this.focusedCell = this.service.getCellCoordsFor(this.value);
        }
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.palette || changes.columns) {
            this.setRows();
        }
        if (changes.palette || changes.value || changes.columns) {
            this.focusedCell = this.service.getCellCoordsFor(this.value);
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        const isRTL = this.direction === 'rtl';
        switch (event.keyCode) {
            case Keys.ArrowDown:
                this.handleCellNavigation(0, 1);
                break;
            case Keys.ArrowUp:
                this.handleCellNavigation(0, -1);
                break;
            case Keys.ArrowRight:
                this.handleCellNavigation(isRTL ? -1 : 1, 0);
                break;
            case Keys.ArrowLeft:
                this.handleCellNavigation(isRTL ? 1 : -1, 0);
                break;
            case Keys.Enter:
                this.handleEnter();
                break;
            default: return;
        }
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleHostBlur() {
        this.notifyNgTouched();
    }
    /**
     * @hidden
     */
    handleCellSelection(value, focusedCell) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = focusedCell;
        const parsedColor = parseColor$1(value, this.format, false);
        this.cellSelection.emit(parsedColor);
        if (this.value !== parsedColor) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
        }
        if (this.selection !== parsedColor) {
            this.selection = parsedColor;
            this.selectionChange.emit(parsedColor);
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.focusedCell = this.service.getCellCoordsFor(this.value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Clears the color value of the ColorPalette.
     */
    reset() {
        this.focusedCell = null;
        if (isPresent(this.value)) {
            this._value = undefined;
            this.notifyNgChanged(undefined);
        }
    }
    setRows() {
        if (!isPresent(this.palette)) {
            return;
        }
        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
        this.service.setColorMatrix(this.palette, this.columns);
    }
    handleCellNavigation(horizontalStep, verticalStep) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
        const selection = this.service.getColorAt(this.focusedCell);
        if (this.selection !== selection) {
            this.selection = selection;
            this.selectionChange.emit(selection);
        }
    }
    handleEnter() {
        if (!isPresent(this.focusedCell)) {
            return;
        }
        const selectedColor = this.service.getColorAt(this.focusedCell);
        this.handleCellSelection(selectedColor, this.focusedCell);
    }
}
ColorPaletteComponent.ɵfac = function ColorPaletteComponent_Factory(t) { return new (t || ColorPaletteComponent)(ɵngcc0.ɵɵdirectiveInject(ColorPaletteService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ColorPaletteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorPaletteComponent, selectors: [["kendo-colorpalette"]], hostVars: 9, hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ColorPaletteComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); })("blur", function ColorPaletteComponent_blur_HostBindingHandler() { return ctx.handleHostBlur(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("id", ctx.paletteId)("tabindex", ctx.hostTabindex);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-colorpalette", ctx.hostClasses)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { id: "id", format: "format", tileSize: "tileSize", value: "value", columns: "columns", palette: "palette", tabindex: "tabindex", disabled: "disabled", readonly: "readonly" }, outputs: { selectionChange: "selectionChange", valueChange: "valueChange", cellSelection: "cellSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPaletteComponent) // tslint:disable-line:no-forward-ref
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPaletteComponent)
            },
            ColorPaletteService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpalette'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 1, consts: [["role", "grid"], ["role", "presentation", 1, "k-palette", "k-reset"], ["role", "row", 4, "ngFor", "ngForOf"], ["role", "row"], ["class", "k-item", 3, "k-state-selected", "ngStyle", "click", 4, "ngFor", "ngForOf"], [1, "k-item", 3, "ngStyle", "click"]], template: function ColorPaletteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "table", 1);
        ɵngcc0.ɵɵelementStart(2, "tbody");
        ɵngcc0.ɵɵtemplate(3, ColorPaletteComponent_tr_3_Template, 2, 1, "tr", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.colorRows);
    } }, directives: [ɵngcc3.NgForOf, ɵngcc3.NgStyle], encapsulation: 2 });
/** @nocollapse */
ColorPaletteComponent.ctorParameters = () => [
    { type: ColorPaletteService },
    { type: LocalizationService }
];
ColorPaletteComponent.propDecorators = {
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    paletteId: [{ type: HostBinding, args: ['attr.id',] }],
    id: [{ type: Input }],
    format: [{ type: Input }],
    value: [{ type: Input }],
    columns: [{ type: Input }],
    palette: [{ type: Input }],
    tabindex: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    tileSize: [{ type: Input }],
    selectionChange: [{ type: Output }],
    valueChange: [{ type: Output }],
    cellSelection: [{ type: Output }],
    hostTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-colorpalette',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    handleHostBlur: [{ type: HostListener, args: ['blur',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorPaletteComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorpalette',
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorPaletteComponent) // tslint:disable-line:no-forward-ref
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorPaletteComponent)
                    },
                    ColorPaletteService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorpalette'
                    }
                ],
                template: `
        <div role="grid">
            <table class="k-palette k-reset" role="presentation">
                <tbody>
                    <tr role="row" *ngFor="let row of colorRows; let rowIndex = index">
                        <td *ngFor="let color of row; let colIndex = index"
                            [class.k-state-selected]="focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                            class="k-item"
                            [attr.value]="color"
                            (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                            [ngStyle]="{
                                backgroundColor: color,
                                width: tileLayout.width + 'px',
                                height: tileLayout.height + 'px',
                                minWidth: tileLayout.width + 'px'
                            }">
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `
            }]
    }], function () { return [{ type: ColorPaletteService }, { type: ɵngcc1.LocalizationService }]; }, { id: [{
            type: Input
        }], format: [{
            type: Input
        }], tileSize: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], cellSelection: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-colorpalette']
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], paletteId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], columns: [{
            type: Input
        }], palette: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], handleKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], handleHostBlur: [{
            type: HostListener,
            args: ['blur']
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }] }); })();

const DEFAULT_OUTPUT_FORMAT = 'rgba';
const DEFAULT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';
let serial$2 = 0;
/**
 * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.
 * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
class ColorGradientComponent {
    constructor(host, ngZone, renderer, cdr, localizationService) {
        this.host = host;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.id = `k-colorgradient-${serial$2++}`;
        /**
         * Defines whether the alpha slider will be displayed.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorGradient.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorGradient.
         */
        this.readonly = false;
        /**
         * Specifies whether the ColorGradient should display a 'Clear color' button.
         */
        this.clearButton = false;
        /**
         * Fires each time the user selects a new color.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.backgroundColor = DEFAULT_BACKGROUND_COLOR;
        /**
         * @hidden
         *
         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
         * updated on moving the drag handle or the sliders.
         */
        this.hsva = {};
        /**
         * Specifies the output format of the ColorGradientComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `rgba`
         * * `hex`
         */
        this.format = DEFAULT_OUTPUT_FORMAT;
        this._tabindex = 0;
        this.listeners = [];
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    get disabledClass() {
        return this.disabled;
    }
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get gradientId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor$1(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorGradient or any of its content is focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
    }
    /**
     * @hidden
     */
    get alphaSliderValue() {
        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run
        if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {
            return;
        }
        return this.hsva.a * 100;
    }
    get gradientRect() {
        return this.gradientWrapper.nativeElement.getBoundingClientRect();
    }
    ngAfterViewInit() {
        this.updateUI();
        this.cdr.detectChanges();
        this.addEventListeners();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes) && !this.isFocused) {
            this.updateUI();
        }
    }
    ngOnDestroy() {
        this.listeners.forEach(removeListener => removeListener());
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    reset() {
        this.handleValueChange(undefined);
        this.updateUI();
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {
            return;
        }
        this.focus();
        args.originalEvent.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.changePosition(args);
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
    }
    /**
     * @hidden
     */
    changePosition(position) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.ngZone.run(() => this.moveDragHandle(position));
    }
    /**
     * @hidden
     */
    handleHueSliderChange(hue) {
        this.handleValueChange(getColorFromHSV(this.hsva));
        this.backgroundColor = getColorFromHue(hue);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    /**
     * @hidden
     */
    handleAlphaSliderChange(alpha) {
        this.hsva.a = alpha / 100;
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    handleInputsValueChange(color) {
        const parsed = parseColor$1(color, this.format);
        if (this.value !== parsed) {
            this.handleValueChange(parsed);
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        if (isPresent(this.gradientWrapper)) {
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    moveDragHandle(position) {
        const deltaX = position.clientX - this.gradientRect.left;
        const deltaY = position.clientY - this.gradientRect.top;
        const top = fitIntoBounds(deltaY, 0, this.gradientRect.height);
        const left = fitIntoBounds(deltaX, 0, this.gradientRect.width);
        this.setDragHandleElementPosition(top, left);
        this.hsva.s = left / this.gradientRect.width;
        this.hsva.v = 1 - top / this.gradientRect.height;
        this.handleValueChange(getColorFromHSV(this.hsva));
        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva, { a: 1 })));
    }
    updateUI() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };
        const top = (1 - this.hsva.v) * this.gradientRect.height;
        const left = this.hsva.s * this.gradientRect.width;
        this.setDragHandleElementPosition(top, left);
        this.backgroundColor = getColorFromHue(this.hsva.h);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
    }
    setDragHandleElementPosition(top, left) {
        const dragHandle = this.dragHandle.nativeElement;
        this.renderer.setStyle(dragHandle, 'top', `${top}px`);
        this.renderer.setStyle(dragHandle, 'left', `${left}px`);
    }
    setAlphaSliderBackground(backgroundColor) {
        if (!isPresent(this.alphaSlider)) {
            return;
        }
        const sliderTrack = this.alphaSlider.track.nativeElement;
        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);
    }
    addEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {
                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
                    this.ngZone.run(() => this.notifyNgTouched());
                }
            });
            this.listeners.push(focusOutListener);
        });
    }
}
ColorGradientComponent.ɵfac = function ColorGradientComponent_Factory(t) { return new (t || ColorGradientComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
ColorGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorGradientComponent, selectors: [["kendo-colorgradient"]], viewQuery: function ColorGradientComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c55, true);
        ɵngcc0.ɵɵviewQuery(_c56, true);
        ɵngcc0.ɵɵviewQuery(_c57, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.alphaSlider = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradientWrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragHandle = _t.first);
    } }, hostVars: 9, hostBindings: function ColorGradientComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction)("tabindex", ctx.hostTabindex)("id", ctx.gradientId);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-flatcolorpicker", ctx.hostClasses)("k-state-disabled", ctx.disabledClass);
    } }, inputs: { id: "id", opacity: "opacity", disabled: "disabled", readonly: "readonly", clearButton: "clearButton", format: "format", value: "value", tabindex: "tabindex" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorGradientComponent)
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorGradientComponent)
            },
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorgradient'
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 11, vars: 21, consts: [[1, "k-hbox", "k-hsv-wrap"], [1, "k-hsv-rectangle"], ["kendoDraggable", "", 1, "k-hsv-gradient", 3, "click", "kendoPress", "kendoDrag", "kendoRelease"], ["gradientWrapper", ""], [1, "k-draghandle"], ["dragHandle", ""], ["class", "k-clear-color k-button k-bare k-button-icon", 3, "click", 4, "ngIf"], [1, "k-hue-slider", 3, "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"], ["class", "k-alpha-slider", 3, "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange", 4, "ngIf"], [3, "opacity", "value", "disabled", "readonly", "valueChange"], [1, "k-clear-color", "k-button", "k-bare", "k-button-icon", 3, "click"], [1, "k-icon", "k-i-reset-color"], [1, "k-alpha-slider", 3, "disabled", "readonly", "showButtons", "tickPlacement", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange"], ["alphaSlider", ""]], template: function ColorGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵlistener("click", function ColorGradientComponent_Template_div_click_2_listener($event) { return ctx.changePosition($event); })("kendoPress", function ColorGradientComponent_Template_div_kendoPress_2_listener($event) { return ctx.handleDragPress($event); })("kendoDrag", function ColorGradientComponent_Template_div_kendoDrag_2_listener($event) { return ctx.onHandleDrag($event); })("kendoRelease", function ColorGradientComponent_Template_div_kendoRelease_2_listener() { return ctx.onHandleRelease(); });
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div");
        ɵngcc0.ɵɵtemplate(7, ColorGradientComponent_span_7_Template, 2, 0, "span", 6);
        ɵngcc0.ɵɵelementStart(8, "kendo-slider", 7);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_8_listener($event) { return ctx.hsva.h = $event; })("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_8_listener($event) { return ctx.handleHueSliderChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, ColorGradientComponent_kendo_slider_9_Template, 2, 10, "kendo-slider", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "kendo-colorinput", 9);
        ɵngcc0.ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_colorinput_valueChange_10_listener($event) { return ctx.handleInputsValueChange($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.backgroundColor);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵclassMapInterpolate1("k-hbox k-sliders-wrap ", ctx.clearButton ? "k-sliders-wrap-clearable" : "", "");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.clearButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx.readonly)("showButtons", false)("tickPlacement", "none")("vertical", true)("min", 0)("max", 360)("smallStep", 5)("largeStep", 10)("value", ctx.hsva.h);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.opacity && ctx.format === "rgba");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("opacity", ctx.opacity)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly);
    } }, directives: function () { return [ɵngcc2.DraggableDirective, ɵngcc3.NgIf, SliderComponent,
        ColorInputComponent]; }, encapsulation: 2 });
/** @nocollapse */
ColorGradientComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: LocalizationService }
];
ColorGradientComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-flatcolorpicker',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
    hostTabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    gradientId: [{ type: HostBinding, args: ['attr.id',] }],
    id: [{ type: Input }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    opacity: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    clearButton: [{ type: Input }],
    value: [{ type: Input }],
    tabindex: [{ type: Input }],
    valueChange: [{ type: Output }],
    format: [{ type: Input }],
    alphaSlider: [{ type: ViewChild, args: ['alphaSlider',] }],
    gradientWrapper: [{ type: ViewChild, args: ['gradientWrapper',] }],
    dragHandle: [{ type: ViewChild, args: ['dragHandle',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorGradientComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorgradient',
                providers: [{
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorGradientComponent)
                    }, {
                        provide: KendoInput,
                        useExisting: forwardRef(() => ColorGradientComponent)
                    },
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.colorgradient'
                    }
                ],
                template: `
        <div class="k-hbox k-hsv-wrap">
            <div class="k-hsv-rectangle" [style.background-color]="backgroundColor">
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()">
                    <div
                        #dragHandle
                        class="k-draghandle"
                    >
                    </div>
                </div>
            </div>
            <div class="k-hbox k-sliders-wrap {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}">
                <span class="k-clear-color k-button k-bare k-button-icon" *ngIf="clearButton" (click)="reset()">
                    <span class="k-icon k-i-reset-color"></span>
                </span>
                <kendo-slider
                    class="k-hue-slider"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="360"
                    [smallStep]="5"
                    [largeStep]="10"
                    [(value)]="hsva.h"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity && format === 'rgba'"
                    #alphaSlider
                    class="k-alpha-slider"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput
            [opacity]="opacity"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
        >
        </kendo-colorinput>
`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.LocalizationService }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-flatcolorpicker']
        }], id: [{
            type: Input
        }], opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], clearButton: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], format: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-state-disabled']
        }], hostTabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], gradientId: [{
            type: HostBinding,
            args: ['attr.id']
        }], value: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], alphaSlider: [{
            type: ViewChild,
            args: ['alphaSlider']
        }], gradientWrapper: [{
            type: ViewChild,
            args: ['gradientWrapper']
        }], dragHandle: [{
            type: ViewChild,
            args: ['dragHandle']
        }] }); })();

/**
 * @hidden
 */
class ColorInputComponent {
    constructor(host) {
        this.host = host;
        /**
         * Sets whether the alpha slider will be shown.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorInput.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorInput.
         */
        this.readonly = false;
        /**
         * Emits a parsed rgba string color.
         */
        this.valueChange = new EventEmitter();
        this.colorInputClass = true;
        /**
         * The rgba inputs values.
         */
        this.rgba = {};
    }
    /**
     * Indicates whether any of the inputs are focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        const activeElement = document.activeElement;
        return this.host.nativeElement.contains(activeElement);
    }
    /**
     * Indicates whether any of the rgba inputs have value.
     */
    get rgbaInputValid() {
        return Object.keys(this.rgba).every(key => isPresent(this.rgba[key]));
    }
    ngOnChanges(changes) {
        if (isPresent(changes.value) && !this.isFocused) {
            this.hex = parseColor$1(this.value, 'hex');
            this.rgba = getRGBA(this.value);
            this.rgba.a = parseColor$1(this.value, 'rgba') ? this.rgba.a : 1;
        }
    }
    handleRgbaValueChange() {
        const color = getColorFromRGBA(this.rgba);
        if (!this.rgbaInputValid || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(this.value);
        this.hex = parseColor$1(color, 'hex');
        this.valueChange.emit(color);
    }
    handleHexValueChange(hex) {
        this.hex = hex;
        const color = parseColor$1(hex, 'rgba');
        if (!isPresent(color) || color === this.value) {
            return;
        }
        this.value = color;
        this.rgba = getRGBA(color);
        this.valueChange.emit(color);
    }
    handleRgbaInputBlur() {
        if (!this.rgbaInputValid) {
            this.rgba = getRGBA(this.value);
        }
    }
    handleHexInputBlur() {
        this.hex = parseColor$1(this.value, 'hex');
    }
}
ColorInputComponent.ɵfac = function ColorInputComponent_Factory(t) { return new (t || ColorInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ColorInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorInputComponent, selectors: [["kendo-colorinput"]], hostVars: 2, hostBindings: function ColorInputComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-colorinputs", ctx.colorInputClass);
    } }, inputs: { opacity: "opacity", disabled: "disabled", readonly: "readonly", value: "value" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 17, vars: 32, consts: [[1, "k-hbox", "k-gradient-values"], ["placeholder", "no color", 1, "k-textbox", "k-hex-value", 3, "disabled", "readonly", "value", "blur", "input"], ["hexInput", ""], ["placeholder", "R", 3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals", "valueChange", "blur"], ["placeholder", "G", 3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals", "valueChange", "blur"], ["placeholder", "B", 3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals", "valueChange", "blur"], ["placeholder", "A", 3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "step", "format", "decimals", "valueChange", "blur", 4, "ngIf"], [1, "k-hex-value"], [4, "ngIf"], ["placeholder", "A", 3, "disabled", "readonly", "min", "max", "value", "autoCorrect", "spinners", "step", "format", "decimals", "valueChange", "blur"]], template: function ColorInputComponent_Template(rf, ctx) { if (rf & 1) {
        const _r7 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
        ɵngcc0.ɵɵlistener("blur", function ColorInputComponent_Template_input_blur_1_listener() { return ctx.handleHexInputBlur(); })("input", function ColorInputComponent_Template_input_input_1_listener() { ɵngcc0.ɵɵrestoreView(_r7); const _r0 = ɵngcc0.ɵɵreference(2); return ctx.handleHexValueChange(_r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "kendo-numerictextbox", 3);
        ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_Template_kendo_numerictextbox_valueChange_3_listener($event) { return ctx.rgba.r = $event; })("blur", function ColorInputComponent_Template_kendo_numerictextbox_blur_3_listener() { return ctx.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_Template_kendo_numerictextbox_valueChange_3_listener() { return ctx.handleRgbaValueChange(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "kendo-numerictextbox", 4);
        ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_Template_kendo_numerictextbox_valueChange_4_listener($event) { return ctx.rgba.g = $event; })("blur", function ColorInputComponent_Template_kendo_numerictextbox_blur_4_listener() { return ctx.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_Template_kendo_numerictextbox_valueChange_4_listener() { return ctx.handleRgbaValueChange(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "kendo-numerictextbox", 5);
        ɵngcc0.ɵɵlistener("valueChange", function ColorInputComponent_Template_kendo_numerictextbox_valueChange_5_listener($event) { return ctx.rgba.b = $event; })("blur", function ColorInputComponent_Template_kendo_numerictextbox_blur_5_listener() { return ctx.handleRgbaInputBlur(); })("valueChange", function ColorInputComponent_Template_kendo_numerictextbox_valueChange_5_listener() { return ctx.handleRgbaValueChange(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, ColorInputComponent_kendo_numerictextbox_6_Template, 1, 10, "kendo-numerictextbox", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 0);
        ɵngcc0.ɵɵelementStart(8, "div", 7);
        ɵngcc0.ɵɵtext(9, "hex");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div");
        ɵngcc0.ɵɵtext(11, "r");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div");
        ɵngcc0.ɵɵtext(13, "g");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "div");
        ɵngcc0.ɵɵtext(15, "b");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(16, ColorInputComponent_div_16_Template, 2, 0, "div", 8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.hex || "");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx.readonly)("min", 0)("max", 255)("value", ctx.rgba.r)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx.readonly)("min", 0)("max", 255)("value", ctx.rgba.g)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx.readonly)("min", 0)("max", 255)("value", ctx.rgba.b)("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.opacity);
        ɵngcc0.ɵɵadvance(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.opacity);
    } }, directives: [NumericTextBoxComponent, ɵngcc3.NgIf], encapsulation: 2 });
/** @nocollapse */
ColorInputComponent.ctorParameters = () => [
    { type: ElementRef }
];
ColorInputComponent.propDecorators = {
    value: [{ type: Input }],
    opacity: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    valueChange: [{ type: Output }],
    colorInputClass: [{ type: HostBinding, args: ['class.k-colorinputs',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-colorinput',
                template: `
        <div class="k-hbox k-gradient-values">
            <input
                #hexInput
                class="k-textbox k-hex-value"
                [disabled]="disabled"
                [readonly]="readonly"
                [value]="hex || ''"
                placeholder="no color"
                (blur)="handleHexInputBlur()"
                (input)="handleHexValueChange(hexInput.value)"
            />
            <kendo-numerictextbox
                [disabled]="disabled"
                [readonly]="readonly"
                [min]="0"
                [max]="255"
                placeholder="R"
                [(value)]="rgba.r"
                [autoCorrect]="true"
                [spinners]="false"
                [format]="'n'"
                [decimals]="0"
                (blur)="handleRgbaInputBlur()"
                (valueChange)="handleRgbaValueChange()"
            >
            </kendo-numerictextbox>
            <kendo-numerictextbox
                [disabled]="disabled"
                [readonly]="readonly"
                [min]="0"
                [max]="255"
                placeholder="G"
                [(value)]="rgba.g"
                [autoCorrect]="true"
                [spinners]="false"
                [format]="'n'"
                [decimals]="0"
                (blur)="handleRgbaInputBlur()"
                (valueChange)="handleRgbaValueChange()"
            >
            </kendo-numerictextbox>
            <kendo-numerictextbox
                [disabled]="disabled"
                [readonly]="readonly"
                [min]="0"
                [max]="255"
                placeholder="B"
                [(value)]="rgba.b"
                [autoCorrect]="true"
                [spinners]="false"
                [format]="'n'"
                [decimals]="0"
                (blur)="handleRgbaInputBlur()"
                (valueChange)="handleRgbaValueChange()"
            >
            </kendo-numerictextbox>
            <kendo-numerictextbox
                *ngIf="opacity"
                [disabled]="disabled"
                [readonly]="readonly"
                [min]="0"
                [max]="1"
                placeholder="A"
                [(value)]="rgba.a"
                [autoCorrect]="true"
                [spinners]="false"
                [step]="0.01"
                [format]="'n2'"
                [decimals]="2"
                (blur)="handleRgbaInputBlur()"
                (valueChange)="handleRgbaValueChange()"
            >
            </kendo-numerictextbox>
        </div>
        <div class="k-hbox k-gradient-values">
            <div class="k-hex-value">hex</div>
            <div>r</div>
            <div>g</div>
            <div>b</div>
            <div *ngIf="opacity">a</div>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { opacity: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], colorInputClass: [{
            type: HostBinding,
            args: ['class.k-colorinputs']
        }], value: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FocusOnDomReadyDirective {
    constructor(host, ngZone) {
        this.host = host;
        this.ngZone = ngZone;
    }
    ngAfterContentInit() {
        this.focusOnNextTick();
    }
    focusOnNextTick() {
        this.ngZone.runOutsideAngular(() => setTimeout(() => this.host.nativeElement.focus()));
    }
}
FocusOnDomReadyDirective.ɵfac = function FocusOnDomReadyDirective_Factory(t) { return new (t || FocusOnDomReadyDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
FocusOnDomReadyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FocusOnDomReadyDirective, selectors: [["", "kendoFocusOnDomReady", ""]] });
/** @nocollapse */
FocusOnDomReadyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusOnDomReadyDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFocusOnDomReady]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();

const PUBLIC_DIRECTIVES = [
    ColorPickerComponent,
    ColorPaletteComponent,
    ColorGradientComponent
];
const INTERNAL_DIRECTIVES = [
    ColorInputComponent,
    FocusOnDomReadyDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the ColorPicker.
 */
class ColorPickerModule {
}
ColorPickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ColorPickerModule });
ColorPickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ColorPickerModule_Factory(t) { return new (t || ColorPickerModule)(); }, imports: [[
            SliderModule,
            NumericTextBoxModule,
            CommonModule,
            PopupModule,
            DraggableModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ColorPickerModule, { declarations: function () { return [ColorPickerComponent,
        ColorPaletteComponent,
        ColorGradientComponent,
        ColorInputComponent,
        FocusOnDomReadyDirective]; }, imports: function () { return [SliderModule,
        NumericTextBoxModule,
        CommonModule,
        PopupModule,
        DraggableModule]; }, exports: function () { return [ColorPickerComponent,
        ColorPaletteComponent,
        ColorGradientComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorPickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    PUBLIC_DIRECTIVES,
                    INTERNAL_DIRECTIVES
                ],
                exports: [PUBLIC_DIRECTIVES],
                imports: [
                    SliderModule,
                    NumericTextBoxModule,
                    CommonModule,
                    PopupModule,
                    DraggableModule
                ]
            }]
    }], null, null); })();

/**
 * Represents the directive that renders the [Kendo UI CheckBox]({% slug overview_checkbox %}) input component.
 * The directive is placed on input type="checkbox" elements.
 *
 * @example
 * ```ts-no-run
 * <input type="checkbox" kendoCheckBox />
 * ```
 */
class CheckBoxDirective {
    constructor() {
        this.kendoClass = true;
    }
}
CheckBoxDirective.ɵfac = function CheckBoxDirective_Factory(t) { return new (t || CheckBoxDirective)(); };
CheckBoxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CheckBoxDirective, selectors: [["input", "kendoCheckBox", ""]], hostVars: 2, hostBindings: function CheckBoxDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-checkbox", ctx.kendoClass);
    } } });
CheckBoxDirective.propDecorators = {
    kendoClass: [{ type: HostBinding, args: ['class.k-checkbox',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoCheckBox]'
            }]
    }], function () { return []; }, { kendoClass: [{
            type: HostBinding,
            args: ['class.k-checkbox']
        }] }); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the CheckBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the CheckBox module
 * import { CheckBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, CheckBoxModule], // import CheckBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class CheckBoxModule {
}
CheckBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CheckBoxModule });
CheckBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CheckBoxModule_Factory(t) { return new (t || CheckBoxModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CheckBoxModule, { declarations: function () { return [CheckBoxDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CheckBoxDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [CheckBoxDirective],
                exports: [CheckBoxDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Represents the directive that renders the [Kendo UI RadioButton]({% slug overview_checkbox %}) input component.
 * The directive is placed on input type="radio" elements.
 *
 * @example
 * ```ts-no-run
 * <input type="radio" kendoRadioButton />
 * ```
 */
class RadioButtonDirective {
    constructor() {
        this.kendoClass = true;
    }
}
RadioButtonDirective.ɵfac = function RadioButtonDirective_Factory(t) { return new (t || RadioButtonDirective)(); };
RadioButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RadioButtonDirective, selectors: [["input", "kendoRadioButton", ""]], hostVars: 2, hostBindings: function RadioButtonDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-radio", ctx.kendoClass);
    } } });
RadioButtonDirective.propDecorators = {
    kendoClass: [{ type: HostBinding, args: ['class.k-radio',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RadioButtonDirective, [{
        type: Directive,
        args: [{
                selector: 'input[kendoRadioButton]'
            }]
    }], function () { return []; }, { kendoClass: [{
            type: HostBinding,
            args: ['class.k-radio']
        }] }); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the RadioButton directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the RadioButton module
 * import { RadioButtonModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, RadioButtonModule], // import RadioButton module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class RadioButtonModule {
}
RadioButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RadioButtonModule });
RadioButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RadioButtonModule_Factory(t) { return new (t || RadioButtonModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RadioButtonModule, { declarations: function () { return [RadioButtonDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [RadioButtonDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RadioButtonModule, [{
        type: NgModule,
        args: [{
                declarations: [RadioButtonDirective],
                exports: [RadioButtonDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();

let serial$3 = 0;
/**
 * Represents an error message that will be shown underneath
 * a Kendo control or native HTML form-bound component after a validation.
 */
class ErrorComponent {
    constructor() {
        this.hostClass = true;
        /**
         * Specifies the alignment of the Error message.
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.align = 'start';
        /**
         * @hidden
         */
        this.id = `kendo-error-${serial$3++}`;
        this.roleAttribute = 'alert';
    }
    get startClass() {
        return this.align === 'start';
    }
    get endClass() {
        return this.align === 'end';
    }
    get idAttribute() {
        return this.id;
    }
}
ErrorComponent.ɵfac = function ErrorComponent_Factory(t) { return new (t || ErrorComponent)(); };
ErrorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ErrorComponent, selectors: [["kendo-formerror"]], hostVars: 8, hostBindings: function ErrorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.roleAttribute)("id", ctx.idAttribute);
        ɵngcc0.ɵɵclassProp("k-form-error", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
    } }, inputs: { align: "align" }, ngContentSelectors: _c30, decls: 1, vars: 0, template: function ErrorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
ErrorComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-form-error',] }],
    align: [{ type: Input }],
    roleAttribute: [{ type: HostBinding, args: ['attr.role',] }],
    startClass: [{ type: HostBinding, args: ['class.k-text-start',] }],
    endClass: [{ type: HostBinding, args: ['class.k-text-end',] }],
    idAttribute: [{ type: HostBinding, args: ['attr.id',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ErrorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formerror',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-form-error']
        }], align: [{
            type: Input
        }], roleAttribute: [{
            type: HostBinding,
            args: ['attr.role']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-text-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-text-end']
        }], idAttribute: [{
            type: HostBinding,
            args: ['attr.id']
        }] }); })();

let serial$4 = 0;
/**
 * Represents a hint message that will be shown underneath a form-bound component.
 */
class HintComponent {
    constructor() {
        /**
         * Specifies the alignment of the Hint message.
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.align = 'start';
        /**
         * @hidden
         */
        this.id = `kendo-hint-${serial$4++}`;
        this.hostClass = true;
    }
    get startClass() {
        return this.align === 'start';
    }
    get endClass() {
        return this.align === 'end';
    }
    get idAttribute() {
        return this.id;
    }
}
HintComponent.ɵfac = function HintComponent_Factory(t) { return new (t || HintComponent)(); };
HintComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HintComponent, selectors: [["kendo-formhint"]], hostVars: 7, hostBindings: function HintComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.idAttribute);
        ɵngcc0.ɵɵclassProp("k-form-hint", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
    } }, inputs: { align: "align" }, ngContentSelectors: _c30, decls: 1, vars: 0, template: function HintComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
HintComponent.propDecorators = {
    align: [{ type: Input }],
    hostClass: [{ type: HostBinding, args: ['class.k-form-hint',] }],
    startClass: [{ type: HostBinding, args: ['class.k-text-start',] }],
    endClass: [{ type: HostBinding, args: ['class.k-text-end',] }],
    idAttribute: [{ type: HostBinding, args: ['attr.id',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HintComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formhint',
                template: `
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { align: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-form-hint']
        }], startClass: [{
            type: HostBinding,
            args: ['class.k-text-start']
        }], endClass: [{
            type: HostBinding,
            args: ['class.k-text-end']
        }], idAttribute: [{
            type: HostBinding,
            args: ['attr.id']
        }] }); })();

/**
 * Specifies a container for form-bound controls (Kendo controls or native HTML controls).
 * Applies styling and behavior rules.
 */
class FormFieldComponent {
    constructor(renderer, localizationService) {
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.hostClass = true;
        /**
         *
         * Specifies when the Hint messages will be shown.
         *
         * The possible values are:
         *
         * * (Default) `initial`&mdash;Allows displaying hints when the form-bound component state is
         * `valid` or `untouched` and `pristine`.
         * * `always`&mdash;Allows full control over the visibility of the hints.
         *
         */
        this.showHints = 'initial';
        /**
         * Specifies the layout orientation of the form field.
         *
         * * The possible values are:
         *
         * * (Default) `vertical`
         * * `horizontal`
         */
        this.orientation = 'vertical';
        /**
         * Specifies when the Error messages will be shown.
         *
         * The possible values are:
         *
         * * (Default) `initial`&mdash;Allows displaying errors when the form-bound component state is
         * `invalid` and `touched` or `dirty`.
         * * `always`&mdash;Allows full control over the visibility of the errors.
         *
         */
        this.showErrors = 'initial';
        this.subscriptions = new Subscription();
        this.rtl = false;
        this.subscriptions.add(this.localizationService.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        }));
    }
    get errorClass() {
        if (!this.control) {
            return false;
        }
        return this.control.invalid && (this.control.touched || this.control.dirty);
    }
    get disabledClass() {
        if (!this.control) {
            return false;
        }
        // radiobutton group
        if (this.isRadioControl(this.control)) {
            return false;
        }
        return this.disabledControl() ||
            this.disabledElement() ||
            this.disabledKendoInput();
    }
    set formControls(formControls) {
        this.validateFormControl(formControls);
        this.control = formControls.first;
    }
    /**
     * @hidden
     */
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    /**
     * @hidden
     */
    get hasHints() {
        return this.showHints === 'always' ? true : this.showHintsInitial();
    }
    /**
     * @hidden
     */
    get hasErrors() {
        return this.showErrors === 'always' ? true : this.showErrorsInitial();
    }
    ngAfterViewInit() {
        this.setDescription();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    disabledKendoInput() {
        return this.kendoInput && this.kendoInput.disabled;
    }
    disabledControl() {
        return this.control.disabled;
    }
    disabledElement() {
        const elements = this.controlElementRefs.toArray();
        return elements.every(e => e.nativeElement.hasAttribute('disabled'));
    }
    validateFormControl(formControls) {
        if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {
            throw new Error('The `kendo-formfield` component should contain ' +
                'only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)' +
                'or an ngModel(https://angular.io/api/forms/NgModel) binding.');
        }
    }
    isControlGroup(formControls) {
        if (!formControls.length) {
            return false;
        }
        const name = formControls.first.name;
        return formControls.toArray().every(c => c.name === name && (this.isRadioControl(c)));
    }
    isRadioControl(control) {
        return control.valueAccessor instanceof RadioControlValueAccessor;
    }
    updateDescription() {
        const controls = this.findControlElements();
        if (!controls) {
            return;
        }
        controls.forEach((control) => {
            const ariaIds = this.generateDescriptionIds(control);
            this.renderer.setAttribute(control, 'aria-describedby', ariaIds);
        });
    }
    findControlElements() {
        if (!this.controlElementRefs) {
            return;
        }
        // if the control is KendoInput and has focusableId - dropdowns, dateinputs
        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
            return [document.getElementById(this.kendoInput.focusableId)];
        }
        return this.controlElementRefs.map(el => el.nativeElement);
    }
    generateDescriptionIds(control) {
        const ids = new Set();
        if (control.hasAttribute('aria-describedby')) {
            const attributes = control.getAttribute('aria-describedby').split(' ');
            attributes.forEach((attr) => {
                if (attr.includes('kendo-hint-') || attr.includes('kendo-error-')) {
                    return;
                }
                ids.add(attr);
            });
        }
        this.hintChildren.forEach((hint) => {
            ids.add(hint.id);
        });
        this.errorChildren.forEach((error) => {
            ids.add(error.id);
        });
        return Array.from(ids).join(' ');
    }
    showHintsInitial() {
        if (!this.control) {
            return true;
        }
        const { valid, untouched, pristine } = this.control;
        return valid || (untouched && pristine);
    }
    showErrorsInitial() {
        if (!this.control) {
            return false;
        }
        const { invalid, dirty, touched } = this.control;
        return invalid && (dirty || touched);
    }
    setDescription() {
        this.updateDescription();
        this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));
        this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));
    }
}
FormFieldComponent.ɵfac = function FormFieldComponent_Factory(t) { return new (t || FormFieldComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
FormFieldComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FormFieldComponent, selectors: [["kendo-formfield"]], contentQueries: function FormFieldComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, KendoInput, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NgControl, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, NgControl, true, ElementRef);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ErrorComponent, true);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, HintComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.controlElementRefs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.errorChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hintChildren = _t);
    } }, hostVars: 7, hostBindings: function FormFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.direction);
        ɵngcc0.ɵɵclassProp("k-form-field", ctx.hostClass)("k-form-field-error", ctx.errorClass)("k-form-field-disabled", ctx.disabledClass);
    } }, inputs: { showHints: "showHints", orientation: "orientation", showErrors: "showErrors" }, features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.formfield'
            }
        ])], ngContentSelectors: _c59, decls: 5, vars: 4, consts: [[4, "ngIf"]], template: function FormFieldComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c58);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵtemplate(3, FormFieldComponent_3_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵtemplate(4, FormFieldComponent_4_Template, 1, 0, undefined, 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("k-form-field-wrap", ctx.horizontal);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasHints);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasErrors);
    } }, directives: [ɵngcc3.NgIf], encapsulation: 2 });
/** @nocollapse */
FormFieldComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: LocalizationService }
];
FormFieldComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-form-field',] }],
    direction: [{ type: HostBinding, args: ['attr.dir',] }],
    errorClass: [{ type: HostBinding, args: ['class.k-form-field-error',] }],
    disabledClass: [{ type: HostBinding, args: ['class.k-form-field-disabled',] }],
    formControls: [{ type: ContentChildren, args: [NgControl, { descendants: true, static: true },] }],
    controlElementRefs: [{ type: ContentChildren, args: [NgControl, { read: ElementRef, descendants: true, static: true },] }],
    kendoInput: [{ type: ContentChild, args: [KendoInput, { static: true },] }],
    errorChildren: [{ type: ContentChildren, args: [ErrorComponent, { descendants: true, static: true },] }],
    hintChildren: [{ type: ContentChildren, args: [HintComponent, { descendants: true, static: true },] }],
    showHints: [{ type: Input }],
    orientation: [{ type: Input }],
    showErrors: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FormFieldComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-formfield',
                template: `
        <ng-content select="label, kendo-label"></ng-content>
        <div [class.k-form-field-wrap]="horizontal">
            <ng-content></ng-content>
            <ng-content select="kendo-formhint" *ngIf="hasHints"></ng-content>
            <ng-content select="kendo-formerror" *ngIf="hasErrors"></ng-content>
        </div>
    `,
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.formfield'
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-form-field']
        }], showHints: [{
            type: Input
        }], orientation: [{
            type: Input
        }], showErrors: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['attr.dir']
        }], errorClass: [{
            type: HostBinding,
            args: ['class.k-form-field-error']
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.k-form-field-disabled']
        }], formControls: [{
            type: ContentChildren,
            args: [NgControl, { descendants: true, static: true }]
        }], controlElementRefs: [{
            type: ContentChildren,
            args: [NgControl, { read: ElementRef, descendants: true, static: true }]
        }], kendoInput: [{
            type: ContentChild,
            args: [KendoInput, { static: true }]
        }], errorChildren: [{
            type: ContentChildren,
            args: [ErrorComponent, { descendants: true, static: true }]
        }], hintChildren: [{
            type: ContentChildren,
            args: [HintComponent, { descendants: true, static: true }]
        }] }); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the FormField, Error and Hint components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the FormField module
 * import { FormFieldModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, FormFieldModule], // import FormField module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class FormFieldModule {
}
FormFieldModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FormFieldModule });
FormFieldModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FormFieldModule_Factory(t) { return new (t || FormFieldModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormFieldModule, { declarations: function () { return [HintComponent,
        ErrorComponent,
        FormFieldComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [HintComponent,
        ErrorComponent,
        FormFieldComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FormFieldModule, [{
        type: NgModule,
        args: [{
                declarations: [HintComponent, ErrorComponent, FormFieldComponent],
                exports: [HintComponent, ErrorComponent, FormFieldComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Inputs components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { InputsModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class InputsModule {
}
InputsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: InputsModule });
InputsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function InputsModule_Factory(t) { return new (t || InputsModule)(); }, imports: [[CommonModule],
        TextBoxModule,
        SliderModule,
        RangeSliderModule,
        SwitchModule,
        NumericTextBoxModule,
        MaskedTextBoxModule,
        ColorPickerModule,
        CheckBoxModule,
        RadioButtonModule,
        FormFieldModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InputsModule, { imports: function () { return [CommonModule]; }, exports: function () { return [TextBoxModule,
        SliderModule,
        RangeSliderModule,
        SwitchModule,
        NumericTextBoxModule,
        MaskedTextBoxModule,
        ColorPickerModule,
        CheckBoxModule,
        RadioButtonModule,
        FormFieldModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InputsModule, [{
        type: NgModule,
        args: [{
                exports: [TextBoxModule, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, ColorPickerModule, CheckBoxModule, RadioButtonModule, FormFieldModule],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CheckBoxModule, ColorInputComponent, FocusOnDomReadyDirective, ColorPaletteService, MaskingService, NumericTextBoxMessages, RadioButtonModule, RangeSliderCustomMessagesComponent, RangeSliderMessages, SliderCustomMessagesComponent, SliderMessages, SliderBase, SlidersCommonModule, SwitchCustomMessagesComponent, Messages, TextBoxCustomMessagesComponent, LocalizedTextBoxMessagesDirective, TextBoxMessages, TextBoxPrefixTemplateDirective, TextBoxSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxComponent, SliderComponent, RangeSliderComponent, LabelTemplateDirective, SwitchComponent, TextBoxContainerComponent, TextBoxDirective, TextAreaDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderTicksComponent, SliderModule, RangeSliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxModule, ColorPickerComponent, ColorPaletteComponent, ColorGradientComponent, ColorPickerModule, ActiveColorClickEvent, CheckBoxDirective, RadioButtonDirective, HintComponent, ErrorComponent, FormFieldComponent, FormFieldModule, LocalizedNumericTextBoxMessagesDirective, LocalizedSliderMessagesDirective, LocalizedRangeSliderMessagesDirective, LocalizedSwitchMessagesDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0SUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1ZBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VPQTBGRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NE9BbUZFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MklBeUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztpREFhRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztvQkFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnS0F3RUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29NQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7aUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt1S0FZRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O29GQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lGQTZDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7MElBd0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFnQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhNQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtpRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQVdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OytKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFnQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tOQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7MkZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztvS0FZRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O29GQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBZ0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4SUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO3FFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0RBV0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29GQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7K0pBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFlRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tEQVdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBY0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4SkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhKQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a01BK0RFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O29IQU1FO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzSkFBQztBQUNEO0FBQ0E7QUFDQTttRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2dLQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBNEJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dURBNkVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQTJDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FEQW9GRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRkF3RkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0SUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztvR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBZ0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBS0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztXQUtFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzZCQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7NkJBUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dEQW9CRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBpc0Rldk1vZGUsIERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYsIE9wdGlvbmFsLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIEhvc3RCaW5kaW5nLCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIENvbnRlbnRDaGlsZCwgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3RvciwgUmVuZGVyZXIyLCBOZ1pvbmUsIENoYW5nZURldGVjdG9yUmVmLCBJbmplY3QsIEluamVjdGFibGUsIEhvc3RMaXN0ZW5lciwgVmlld0NoaWxkcmVuLCBOZ01vZHVsZSwgVmlld0NvbnRhaW5lclJlZiwgQ29udGVudENoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SLCBOR19WQUxJREFUT1JTLCBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBmcm9tRXZlbnQsIGludGVydmFsLCBtZXJnZSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZSwgZmlsdGVyLCBjb25jYXRNYXAsIHN0YXJ0V2l0aCwgdGFrZVVudGlsLCBza2lwLCBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCwgUlRMLCBDb21wb25lbnRNZXNzYWdlcyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgS2V5cywgZ3VpZCwgaGFzT2JzZXJ2ZXJzLCBhbnlDaGFuZ2VkLCBpc0RvY3VtZW50QXZhaWxhYmxlLCBLZW5kb0lucHV0LCBpc0NoYW5nZWQsIERyYWdnYWJsZU1vZHVsZSwgRXZlbnRzTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgYnJvd3NlciwgbW9iaWxlT1MgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tY29tbW9uJztcbmltcG9ydCB7IEludGxTZXJ2aWNlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW50bCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUG9wdXBTZXJ2aWNlLCBQb3B1cE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbmltcG9ydCB7IENvbG9yLCBwYXJzZUNvbG9yLCBuYW1lZENvbG9ycyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1kcmF3aW5nJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIEZhbHN5IHZhbHVlcyBsaWtlICcnLCAwLCBmYWxzZSwgTmFOLCBldGMuIGFyZSByZWdhcmRlZCBhcyBwcmVzZW50LlxuICovXG5jb25zdCBpc1ByZXNlbnQgPSAodmFsdWUpID0+IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgYXJlU2FtZSA9ICh2YWx1ZTEsIHZhbHVlMikgPT4gdmFsdWUxID09PSB2YWx1ZTIgfHwgKHZhbHVlMSA9PT0gbnVsbCAmJiB2YWx1ZTIgPT09IHVuZGVmaW5lZCkgfHwgKHZhbHVlMSA9PT0gdW5kZWZpbmVkICYmIHZhbHVlMiA9PT0gbnVsbCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVxdWlyZXNab25lT25CbHVyID0gKG5nQ29udHJvbCkgPT4gbmdDb250cm9sICYmXG4gICAgKCFuZ0NvbnRyb2wudG91Y2hlZCB8fCAobmdDb250cm9sLmNvbnRyb2wgJiYgbmdDb250cm9sLmNvbnRyb2wudXBkYXRlT24gPT09ICdibHVyJykpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogRml0cyB0aGUgY29udGVuZGVyIG51bWJlciBpbnRvIHRoZSBzcGVjaWZpZWQgYm91bmRzLiBJZiB0aGUgbnVtYmVyIGlzIE5hTiBvciBudWxsLCB0aGUgbWluIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBjb250ZW5kZXIgUmVwcmVzZW50cyB0aGUgbnVtYmVyIHlvdSB3YW50IHRvIGZpdCBpbnRvIHNwZWNpZmllZCBib3VuZHMuXG4gKiBAcGFyYW0gbWluIFRoZSBpbmNsdXNpdmUgbG93ZXIgYm91bmQgbnVtYmVyLlxuICogQHBhcmFtIG1heCBUaGUgaW5jbHVzaXZlIHVwcGVyIGJvdW5kIG51bWJlci5cbiAqL1xuY29uc3QgZml0SW50b0JvdW5kcyA9IChjb250ZW5kZXIsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKCFpc1ByZXNlbnQoY29udGVuZGVyKSB8fCBpc05hTihjb250ZW5kZXIpKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIHJldHVybiBjb250ZW5kZXIgPD0gbWluID8gbWluIDogY29udGVuZGVyID49IG1heCA/IG1heCA6IGNvbnRlbmRlcjtcbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBNQVhfUFJFQ0lTSU9OID0gMjA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbGltaXRQcmVjaXNpb24gPSAocHJlY2lzaW9uKSA9PiBNYXRoLm1pbihwcmVjaXNpb24sIE1BWF9QUkVDSVNJT04pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZyYWN0aW9uTGVuZ3RoID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIChTdHJpbmcodmFsdWUpLnNwbGl0KCcuJylbMV0gfHwgXCJcIikubGVuZ3RoO1xufTtcbmNvbnN0IG1heEZyYWN0aW9uTGVuZ3RoID0gKHZhbHVlMSwgdmFsdWUyKSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGZyYWN0aW9uTGVuZ3RoKHZhbHVlMSksIGZyYWN0aW9uTGVuZ3RoKHZhbHVlMikpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b0ZpeGVkUHJlY2lzaW9uID0gKHZhbHVlLCBwcmVjaXNpb24pID0+IHtcbiAgICBjb25zdCBtYXhQcmVjaXNpb24gPSBsaW1pdFByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQobWF4UHJlY2lzaW9uKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGFkZCA9ICh2YWx1ZTEsIHZhbHVlMikgPT4ge1xuICAgIGNvbnN0IG1heFByZWNpc2lvbiA9IG1heEZyYWN0aW9uTGVuZ3RoKHZhbHVlMSwgdmFsdWUyKTtcbiAgICByZXR1cm4gdG9GaXhlZFByZWNpc2lvbih2YWx1ZTEgKyB2YWx1ZTIsIG1heFByZWNpc2lvbik7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHN1YnRyYWN0ID0gKHZhbHVlMSwgdmFsdWUyKSA9PiB7XG4gICAgcmV0dXJuIGFkZCh2YWx1ZTEsIC12YWx1ZTIpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBtdWx0aXBseSA9ICh2YWx1ZTEsIHZhbHVlMikgPT4ge1xuICAgIGNvbnN0IG1heFByZWNpc2lvbiA9IGZyYWN0aW9uTGVuZ3RoKHZhbHVlMSkgKyBmcmFjdGlvbkxlbmd0aCh2YWx1ZTIpO1xuICAgIHJldHVybiB0b0ZpeGVkUHJlY2lzaW9uKHZhbHVlMSAqIHZhbHVlMiwgbWF4UHJlY2lzaW9uKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGl2aWRlID0gKGRpdmlkZW5kLCBkaXZpc29yKSA9PiB7XG4gICAgaWYgKGRpdmlzb3IgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgcG93ZXIgPSBtYXhGcmFjdGlvbkxlbmd0aChkaXZpZGVuZCwgZGl2aXNvcik7XG4gICAgY29uc3QgY29ycmVjdGlvblZhbHVlID0gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgICByZXR1cm4gKChjb3JyZWN0aW9uVmFsdWUgKiBkaXZpZGVuZCkgLyAoY29ycmVjdGlvblZhbHVlICogZGl2aXNvcikpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZW1haW5kZXIgPSAoZGl2aWRlbmQsIGRpdmlzb3IpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMoc3VidHJhY3QoZGl2aWRlbmQsIG11bHRpcGx5KGRpdmlzb3IsIE1hdGguZmxvb3IoZGl2aWRlKGRpdmlkZW5kLCBkaXZpc29yKSkpKSk7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY2FsY3VsYXRlRml4ZWRUcmFja1NpemUgPSAoeyBtYXgsIG1pbiwgc21hbGxTdGVwLCBmaXhlZFRpY2tXaWR0aCB9KSA9PiAoKG1heCAtIG1pbikgLyBzbWFsbFN0ZXApICogZml4ZWRUaWNrV2lkdGg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY2FsY3VsYXRlVHJhY2tTaXplID0gKHdyYXBwZXJXaWR0aCwgb2Zmc2V0LCBzaG93QnV0dG9ucyA9IHRydWUpID0+IHtcbiAgICBjb25zdCBCVVRUT05TX0NPVU5UID0gMjtcbiAgICBjb25zdCB0cmFja09mZnNldCA9IHNob3dCdXR0b25zID8gcGFyc2VGbG9hdChvZmZzZXQpICogQlVUVE9OU19DT1VOVCA6IDA7XG4gICAgY29uc3QgdHJhY2tXaWR0aCA9IHdyYXBwZXJXaWR0aCAtIHRyYWNrT2Zmc2V0O1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRyYWNrV2lkdGgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjYWxjdWxhdGVUaWNrc0NvdW50ID0gKG1pbiA9IDAsIG1heCA9IDAsIHNtYWxsU3RlcCA9IDEpID0+IHtcbiAgICBpZiAoc21hbGxTdGVwIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBzbWFsbFN0ZXAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBjb25zdCBhZGp1c3RlZFJhbmdlID0gTWF0aC5hYnMoc3VidHJhY3QobWF4LCBtaW4pKTtcbiAgICBjb25zdCBhZGp1c3RlZFJhdGlvID0gTWF0aC5mbG9vcihkaXZpZGUoYWRqdXN0ZWRSYW5nZSwgc21hbGxTdGVwKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYWRkKGFkanVzdGVkUmF0aW8sIDEpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVZhbHVlRnJvbVRpY2sgPSAoaW5kZXgsIHsgbWF4LCBtaW4sIHNtYWxsU3RlcCwgcmV2ZXJzZSwgdmVydGljYWwgfSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYWRkKG1pbiwgbXVsdGlwbHkoaW5kZXgsIHNtYWxsU3RlcCkpO1xuICAgIHJldHVybiB2ZXJ0aWNhbCB8fCByZXZlcnNlID8gTWF0aC5hYnMoc3VidHJhY3QodmFsdWUsIG1heCkpIDogdmFsdWU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZUhhbmRsZVBvc2l0aW9uID0gKHsgaGFuZGxlV2lkdGgsIHRyYWNrV2lkdGgsIG1pbiwgbWF4LCByZXZlcnNlLCB2YWx1ZSB9KSA9PiB7XG4gICAgY29uc3QgaGFsZkhhbmRsZVdpZHRoID0gTWF0aC5mbG9vcihoYW5kbGVXaWR0aCAvIDIpO1xuICAgIGNvbnN0IHN0ZXAgPSB0cmFja1dpZHRoIC8gTWF0aC5hYnMobWF4IC0gbWluKTtcbiAgICBsZXQgcG9zID0gaXNQcmVzZW50KHZhbHVlKSA/IHN0ZXAgKiAodmFsdWUgLSBtaW4pIDogbWluO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHBvcyA9IHRyYWNrV2lkdGggLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKHBvcyAtIGhhbGZIYW5kbGVXaWR0aCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlY3JlYXNlVmFsdWVUb1N0ZXAgPSAodmFsdWUsIHsgbWF4LCBtaW4sIHNtYWxsU3RlcCwgbGFyZ2VTdGVwIH0sIGxhcmdlID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBzdGVwID0gbGFyZ2UgJiYgbGFyZ2VTdGVwID8gbXVsdGlwbHkoc21hbGxTdGVwLCBsYXJnZVN0ZXApIDogc21hbGxTdGVwO1xuICAgIGNvbnN0IHN0ZXBWYWx1ZSA9IHN1YnRyYWN0KHZhbHVlLCBtaW4pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3Qgc3RlcFJlbWFpbmRlciA9IHJlbWFpbmRlcihzdGVwVmFsdWUsIHN0ZXApO1xuICAgIGlmIChzdGVwUmVtYWluZGVyID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHN1YnRyYWN0KHN0ZXBWYWx1ZSwgc3RlcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdWJ0cmFjdChzdGVwVmFsdWUsIHN0ZXBSZW1haW5kZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbGltaXRWYWx1ZShhZGQocmVzdWx0LCBtaW4pLCBtaW4sIG1heCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGluY3JlYXNlVmFsdWVUb1N0ZXAgPSAodmFsdWUsIHsgbWF4LCBtaW4sIHNtYWxsU3RlcCwgbGFyZ2VTdGVwIH0sIGxhcmdlID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBzdGVwID0gbGFyZ2UgJiYgbGFyZ2VTdGVwID8gbXVsdGlwbHkoc21hbGxTdGVwLCBsYXJnZVN0ZXApIDogc21hbGxTdGVwO1xuICAgIGNvbnN0IHN0ZXBWYWx1ZSA9IHN1YnRyYWN0KHZhbHVlLCBtaW4pO1xuICAgIGNvbnN0IHN0ZXBSZW1haW5kZXIgPSByZW1haW5kZXIoc3RlcFZhbHVlLCBzdGVwKTtcbiAgICBjb25zdCByZXN1bHQgPSBhZGQoc3VidHJhY3Qoc3RlcFZhbHVlLCBzdGVwUmVtYWluZGVyKSwgc3RlcCk7XG4gICAgcmV0dXJuIGxpbWl0VmFsdWUoYWRkKHJlc3VsdCwgbWluKSwgbWluLCBtYXgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1N0YXJ0SGFuZGxlID0gKGRyYWdIYW5kbGUpID0+IGRyYWdIYW5kbGUuaWQuaW5kZXhPZignay1zdGFydC1oYW5kbGUnKSA+IC0xO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNuYXBWYWx1ZSA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgc21hbGxTdGVwLCBtaW4sIG1heCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBsaW1pdGVkID0gbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xuICAgIGlmICh2YWx1ZSAhPT0gbGltaXRlZCkge1xuICAgICAgICByZXR1cm4gbGltaXRlZDtcbiAgICB9XG4gICAgY29uc3QgbGVmdCA9IGRlY3JlYXNlVmFsdWVUb1N0ZXAodmFsdWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJpZ2h0ID0gaW5jcmVhc2VWYWx1ZVRvU3RlcCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKCh2YWx1ZSAtIG1pbikgJSBzbWFsbFN0ZXAgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAocmlnaHQgLSB2YWx1ZSA8PSAocmlnaHQgLSBsZWZ0KSAvIDIpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdHJpbVZhbHVlID0gKG1heCwgbWluLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0cmltVmFsdWVSYW5nZSA9IChtYXgsIG1pbiwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPyBbdHJpbVZhbHVlKG1heCwgbWluLCB2YWx1ZVswXSksIHRyaW1WYWx1ZShtYXgsIG1pbiwgdmFsdWVbMV0pXSA6IFttaW4sIG1pbl07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1NhbWVSYW5nZSA9ICh2YWx1ZTEsIHZhbHVlMikgPT4gYXJlU2FtZSh2YWx1ZTFbMF0sIHZhbHVlMlswXSkgJiYgYXJlU2FtZSh2YWx1ZTFbMV0sIHZhbHVlMlsxXSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZWxlbWVudE9mZnNldCA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogYm94LmxlZnQgKyAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KSAtIChkb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdCB8fCAwKSxcbiAgICAgICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSAtIChkb2N1bWVudEVsZW1lbnQuY2xpZW50VG9wIHx8IDApXG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbGltaXRWYWx1ZSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGV2ZW50VmFsdWUgPSAoZXZlbnRBcmdzLCBzY2FsZUVsZW1lbnQsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IG1pbiwgbWF4LCB2ZXJ0aWNhbCwgcnRsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrT2Zmc2V0ID0gZWxlbWVudE9mZnNldChzY2FsZUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldCA9IHZlcnRpY2FsID8gZXZlbnRBcmdzLnBhZ2VZIC0gdHJhY2tPZmZzZXQudG9wIDogZXZlbnRBcmdzLnBhZ2VYIC0gdHJhY2tPZmZzZXQubGVmdDtcbiAgICBjb25zdCBzY2FsZSA9IChtYXggLSBtaW4pIC8gKHZlcnRpY2FsID8gc2NhbGVFbGVtZW50LmNsaWVudEhlaWdodCA6IHNjYWxlRWxlbWVudC5jbGllbnRXaWR0aCk7XG4gICAgY29uc3Qgb2Zmc2V0VmFsdWUgPSBvZmZzZXQgKiBzY2FsZTtcbiAgICBsZXQgdmFsdWUgPSBydGwgfHwgdmVydGljYWwgPyBtYXggLSBvZmZzZXRWYWx1ZSA6IG1pbiArIG9mZnNldFZhbHVlO1xuICAgIGNvbnN0IHN0ZXBGcmFjdGlvbkxlbmd0aCA9IGZyYWN0aW9uTGVuZ3RoKG9wdGlvbnMuc21hbGxTdGVwKTtcbiAgICB2YWx1ZSA9IHRvRml4ZWRQcmVjaXNpb24odmFsdWUsIHN0ZXBGcmFjdGlvbkxlbmd0aCArIDEpO1xuICAgIHJldHVybiBzbmFwVmFsdWUodmFsdWUsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0J1dHRvbiA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2stYnV0dG9uLWluY3JlYXNlJykgPj0gMCB8fCBlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKCdrLWJ1dHRvbi1kZWNyZWFzZScpID49IDA7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGluY3JlbWVudCA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGluY3JlYXNlVmFsdWVUb1N0ZXAob3B0aW9ucy52YWx1ZSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlY3JlbWVudCA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGRlY3JlYXNlVmFsdWVUb1N0ZXAob3B0aW9ucy52YWx1ZSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGluY3JlbWVudExhcmdlID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gaW5jcmVhc2VWYWx1ZVRvU3RlcChvcHRpb25zLnZhbHVlLCBvcHRpb25zLCB0cnVlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGVjcmVtZW50TGFyZ2UgPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBkZWNyZWFzZVZhbHVlVG9TdGVwKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMsIHRydWUpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB2YWxpZGF0ZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKGlzRGV2TW9kZSAmJiB2YWx1ZSAmJiB2YWx1ZVswXSA+IHZhbHVlWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW1JhbmdlU2xpZGVyXSBUaGUgc3RhcnQgdmFsdWUgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIGVuZCB2YWx1ZS4nKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2xpZGVyTW9kZWxCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgd3JhcHBlciwgdHJhY2ssIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLnRpY2tTaXplcyA9IHRoaXMuZ2V0VGlja1NpemVzKCk7XG4gICAgfVxuICAgIHJlc2l6ZVRyYWNrKCkge1xuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMucHJvcHMudmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrV2lkdGgoKTtcbiAgICAgICAgdGhpcy50cmFjay5zdHlsZVtvcmllbnRhdGlvbl0gPSBgJHt0cmFja1dpZHRofXB4YDtcbiAgICB9XG4gICAgcmVzaXplVGlja3ModGlja3NDb250YWluZXIsIHRpY2tzKSB7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMucHJvcHMudmVydGljYWwgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgICAgICBbLi4udGlja3NdLm1hcCgodGljaywgaW5kZXgpID0+IHRpY2suc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMudGlja1NpemVzW2luZGV4XX1weGApO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RQYWRkaW5nKHRpY2tzQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemVXcmFwcGVyKCkge1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLnByb3BzLnZlcnRpY2FsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICAgICAgY29uc3Qgd3JhcHBlclNpemUgPSB0aGlzLmVsZW1lbnRTaXplKHRoaXMud3JhcHBlcik7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSBjYWxjdWxhdGVUcmFja1NpemUod3JhcHBlclNpemUsIHRoaXMuZWxlbWVudE9mZnNldCh0aGlzLnRyYWNrKSk7XG4gICAgICAgIGNvbnN0IGZpeGVkVHJhY2tXaWR0aCA9IGNhbGN1bGF0ZUZpeGVkVHJhY2tTaXplKHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCB3cmFwcGVyUGFyZW50RWwgPSB0aGlzLndyYXBwZXIucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHRyYWNrV2lkdGggPiBmaXhlZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICAgIHdyYXBwZXJQYXJlbnRFbC5zdHlsZVtkaW1lbnNpb25dID0gYCR7d3JhcHBlclNpemUgLSAodHJhY2tXaWR0aCAtIGZpeGVkVHJhY2tXaWR0aCl9cHhgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlclBhcmVudEVsLnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt3cmFwcGVyU2l6ZSArIChmaXhlZFRyYWNrV2lkdGggLSB0cmFja1dpZHRoKX1weGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2tXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZml4ZWRUaWNrV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVGaXhlZFRyYWNrU2l6ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsY3VsYXRlVHJhY2tTaXplKHRoaXMuZWxlbWVudFNpemUodGhpcy53cmFwcGVyKSwgdGhpcy5lbGVtZW50T2Zmc2V0KHRoaXMudHJhY2spLCB0aGlzLnByb3BzLmJ1dHRvbnMpO1xuICAgIH1cbiAgICBnZXRUaWNrU2l6ZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXgsIHNtYWxsU3RlcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY291bnQgPSBjYWxjdWxhdGVUaWNrc0NvdW50KG1pbiwgbWF4LCBzbWFsbFN0ZXApO1xuICAgICAgICBjb25zdCB0cmFja1NpemUgPSB0aGlzLnRyYWNrV2lkdGgoKTtcbiAgICAgICAgY29uc3QgZGlzdFN0ZXAgPSB0cmFja1NpemUgLyBzdWJ0cmFjdChtYXgsIG1pbik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgdXNlZFNwYWNlID0gMDtcbiAgICAgICAgbGV0IGVuZFBvaW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBjb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICBlbmRQb2ludCArPSAoc21hbGxTdGVwIC8gMikgKiBkaXN0U3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZFBvaW50ICs9IHNtYWxsU3RlcCAqIGRpc3RTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHN1bSBvZiB0aGUgdGljayBzaXplcyBkb2VzIG5vdCBleGNlZWQgdGhlIHRyYWNrIHdpZHRoXG4gICAgICAgICAgICBlbmRQb2ludCA9ICtlbmRQb2ludC50b0ZpeGVkKDIpIC0gMC4wMTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLnJvdW5kKGVuZFBvaW50IC0gdXNlZFNwYWNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNpemUpO1xuICAgICAgICAgICAgdXNlZFNwYWNlICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZWRTcGFjZSA+PSB0cmFja1NpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhZGp1c3RQYWRkaW5nKHRpY2tzQ29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsVGlja1NpemUgPSB0aGlzLnRpY2tTaXplcy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYgKyBjdXJyLCAwKTtcbiAgICAgICAgY29uc3QgdHJhY2tXaWR0aCA9IHRoaXMudHJhY2tXaWR0aCgpO1xuICAgICAgICBjb25zdCByZW1pbmRlciA9IHRyYWNrV2lkdGggLSB0b3RhbFRpY2tTaXplO1xuICAgICAgICBpZiAocmVtaW5kZXIgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSByZW1pbmRlciArIHRoaXMuZWxlbWVudE9mZnNldCh0aGlzLnRyYWNrKTtcbiAgICAgICAgICAgIHRpY2tzQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3AgPSBgJHtwYWRkaW5nfXB4YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyB2ZXJ0aWNhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmVydGljYWwgPyBzdHlsZS5ib3R0b20gOiBzdHlsZS5sZWZ0LCAxMCk7XG4gICAgfVxuICAgIGVsZW1lbnRTaXplKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyB2ZXJ0aWNhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIHZlcnRpY2FsID8gZWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNsaWRlck1vZGVsIGV4dGVuZHMgU2xpZGVyTW9kZWxCYXNlIHtcbiAgICBwb3NpdGlvbkhhbmRsZShkcmFnSGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4LCBtaW4sIHJldmVyc2UsIHZlcnRpY2FsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHZlcnRpY2FsID8gJ2JvdHRvbScgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrV2lkdGgoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0cmltVmFsdWUobWF4LCBtaW4sIHRoaXMucHJvcHMudmFsdWUpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvc2l0aW9uID0gY2FsY3VsYXRlSGFuZGxlUG9zaXRpb24oe1xuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgcmV2ZXJzZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdHJhY2tXaWR0aCxcbiAgICAgICAgICAgIGhhbmRsZVdpZHRoOiBkcmFnSGFuZGxlLm9mZnNldFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRyYWdIYW5kbGUsIHBvc2l0aW9uLCBgJHt0aGlzLmhhbmRsZVBvc2l0aW9ufXB4YCk7XG4gICAgfVxuICAgIHBvc2l0aW9uU2VsZWN0aW9uKGRyYWdIYW5kbGUsIHNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCB7IHJldmVyc2UsIHZlcnRpY2FsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB2ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgaGFuZGxlV2lkdGggPSBNYXRoLmZsb29yKGRyYWdIYW5kbGUub2Zmc2V0V2lkdGggLyAyKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLmhhbmRsZVBvc2l0aW9uICsgaGFuZGxlV2lkdGg7XG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy50cmFja1dpZHRoKCkgLSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoc2VsZWN0aW9uLCBkaW1lbnNpb24sIGAke3NpemV9cHhgKTtcbiAgICB9XG59XG5cbmNvbnN0IFVOVE9VQ0hFRCA9ICduZy11bnRvdWNoZWQnO1xuY29uc3QgdG9DbGFzc0xpc3QgPSAoY2xhc3NOYW1lcykgPT4gU3RyaW5nKGNsYXNzTmFtZXMpLnRyaW0oKS5zcGxpdCgnICcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0NsYXNzID0gKGVsZW1lbnQsIGNsYXNzTmFtZSkgPT4gQm9vbGVhbih0b0NsYXNzTGlzdChlbGVtZW50LmNsYXNzTmFtZSkuZmluZCgobmFtZSkgPT4gbmFtZSA9PT0gY2xhc3NOYW1lKSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaW52b2tlRWxlbWVudE1ldGhvZChlbGVtZW50LCBuYW1lLCAuLi5hcmdzKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnRbbmFtZV0uYXBwbHkoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBhcmdzKTtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNVbnRvdWNoZWQgPSAoZWxlbWVudCkgPT4gZWxlbWVudCAmJiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQgJiYgaGFzQ2xhc3MoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBVTlRPVUNIRUQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNvbnRhaW5zRm9jdXMgPSAoaG9zdEVsZW1lbnQsIGNvbnRlbmRlcikgPT4gaG9zdEVsZW1lbnQgJiYgY29udGVuZGVyICYmIChob3N0RWxlbWVudCA9PT0gY29udGVuZGVyIHx8IGhvc3RFbGVtZW50LmNvbnRhaW5zKGNvbnRlbmRlcikpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBsYWJlbHMgb2YgdGhlIFNsaWRlci5cbiAqIFRvIGRlZmluZSB0aGUgbGFiZWxzIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvU2xpZGVyTGFiZWxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZVxuICogdGhlIGA8a2VuZG8tc2xpZGVyPmAgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBwYXNzZWQgdG8gdGhlIGBsYWJlbGAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLXNsaWRlciBbbGFyZ2VTdGVwXT1cIjJcIj5cbiAqICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9TbGlkZXJMYWJlbFRlbXBsYXRlIGxldC12YWx1ZT1cInZhbHVlXCI+XG4gKiAgICAgICAgICAgICA8Yj57e3ZhbHVlfX08L2I+XG4gKiAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgPC9rZW5kby1zbGlkZXI+XG4gKiAgICAgYFxuICogfSlcbiAqXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICpcbiAqIGBgYFxuICovXG5jbGFzcyBMYWJlbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU2xpZGVyTGFiZWxUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxhYmVsVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNsaWRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvblNlcnZpY2UsIGluamVjdG9yLCByZW5kZXJlciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHRpdGxlIG9mIHRoZSB0aWNrcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRpY2tzX3NsaWRlciAlfSN0b2MtdGl0bGVzKSkuIFRoZSBkZWZhdWx0IHRpdGxlXG4gICAgICAgICAqIGZvciBlYWNoIHRpY2sgaXMgaXRzIFNsaWRlciB2YWx1ZS4gSWYgeW91IHVzZSBhIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gYWNjZXB0cyBhbiBhcmd1bWVudFxuICAgICAgICAgKiB0aGF0IGhvbGRzIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50IGFuZCByZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhlIG5ldyB0aXRsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSBpZGVudGl0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbm90ZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIG1hcmtzIGluIHRoZSBTbGlkZXIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aWNrc19zbGlkZXIgJX0jdG9jLXBsYWNlbWVudCkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAgICAgKiAqIGBiZWZvcmVgJm1kYXNoO1RoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIHRvIHRoZSB0b3Agc2lkZSBvZiB0aGUgaG9yaXpvbnRhbCB0cmFjayBvciB0byB0aGUgbGVmdCBzaWRlIG9mIGEgdmVydGljYWwgdHJhY2suXG4gICAgICAgICAqICogYGFmdGVyYCZtZGFzaDtUaGUgdGljayBtYXJrcyBhcmUgbG9jYXRlZCB0byB0aGUgYm90dG9tIHNpZGUgb2YgdGhlIGhvcml6b250YWwgdHJhY2sgb3IgdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHZlcnRpY2FsIHRyYWNrLlxuICAgICAgICAgKiAqIGBib3RoYCZtZGFzaDsgKERlZmF1bHQpIFRoZSB0aWNrIG1hcmtzIGFyZSBsb2NhdGVkIG9uIGJvdGggc2lkZXMgb2YgdGhlIHRyYWNrLlxuICAgICAgICAgKiAqIGBub25lYCZtZGFzaDtUaGUgdGljayBtYXJrcyBhcmUgbm90IHZpc2libGUuIFRoZSBhY3R1YWwgZWxlbWVudHMgYXJlIG5vdCBhZGRlZCB0byB0aGUgRE9NIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpY2tQbGFjZW1lbnQgPSAnYm90aCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdmVydGljYWxgIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgU2xpZGVyIGNoYW5nZXMgZnJvbSBob3Jpem9udGFsIHRvIHZlcnRpY2FsXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3JpZW50YXRpb25fc2xpZGVyICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgU2xpZGVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcHJlZGVmaW5lZHN0ZXBzX3NsaWRlciAlfSN0b2Mtc21hbGwtc3RlcHMpKS5cbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZSBhY2NlcHRzIGJvdGggaW50ZWdlcnMgYW5kIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgU2xpZGVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcHJlZGVmaW5lZHN0ZXBzX3NsaWRlciAlfSN0b2Mtc21hbGwtc3RlcHMpKS5cbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZSBhY2NlcHRzIGJvdGggaW50ZWdlcnMgYW5kIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heCA9IDEwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0ZXAgdmFsdWUgb2YgdGhlIFNsaWRlciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWRlZmluZWRzdGVwc19zbGlkZXIgJX0jdG9jLXNtYWxsLXN0ZXBzKSkuXG4gICAgICAgICAqIEFjY2VwdHMgcG9zaXRpdmUgdmFsdWVzIG9ubHkuIENhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zbWFsbFN0ZXAgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgZXZlcnkgbjxzdXA+dGg8L3N1cD4gdGljayB3aWxsIGJlIGxhcmdlIGFuZCB3aWxsIGhhdmUgYSBsYWJlbFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHByZWRlZmluZWRzdGVwc19zbGlkZXIgJX0jdG9jLWxhcmdlLXN0ZXBzKSkuXG4gICAgICAgICAqIEFjY2VwdHMgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZXMgb25seS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFyZ2VTdGVwID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgU2xpZGVyIGlzIGRpc2FibGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRzdGF0ZV9zbGlkZXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgU2xpZGVyIGlzIGluIGl0cyByZWFkLW9ubHkgc3RhdGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9zbGlkZXIgJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBTbGlkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGNvbXBvbmVudCBpcyBibHVycmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLndpZGdldENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZkVuYWJsZWQgPSAoY2FsbGJhY2ssIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvblNlcnZpY2UucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgZ2V0IGhvcml6b250YWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnZlcnRpY2FsO1xuICAgIH1cbiAgICBnZXQgdmVydGljYWxDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWw7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBzdGF0dXMgb2YgdGhlIGNvbXBvbmVudCBjaGFuZ2VzIHRvIG9yIGZyb20gYGRpc2FibGVkYC5cbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHZhbHVlLCBpdCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBhcHByb3ByaWF0ZSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmxvY2FsaXphdGlvblNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgICAgICB0aGlzLnNpemVDb21wb25lbnQoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LCBcInRhYmluZGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIEZsb2F0aW5nTGFiZWwgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcmV2ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5ydGwgJiYgIXRoaXMudmVydGljYWw7XG4gICAgfVxuICAgIGdldCBrZXlCaW5kaW5nKCkge1xuICAgICAgICBjb25zdCByZXZlcnNlID0gdGhpcy5yZXZlcnNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0tleXMuQXJyb3dMZWZ0XTogcmV2ZXJzZSA/IGluY3JlbWVudCA6IGRlY3JlbWVudCxcbiAgICAgICAgICAgIFtLZXlzLkFycm93UmlnaHRdOiByZXZlcnNlID8gZGVjcmVtZW50IDogaW5jcmVtZW50LFxuICAgICAgICAgICAgW0tleXMuQXJyb3dEb3duXTogZGVjcmVtZW50LFxuICAgICAgICAgICAgW0tleXMuQXJyb3dVcF06IGluY3JlbWVudCxcbiAgICAgICAgICAgIFtLZXlzLlBhZ2VVcF06IGluY3JlbWVudExhcmdlLFxuICAgICAgICAgICAgW0tleXMuUGFnZURvd25dOiBkZWNyZW1lbnRMYXJnZSxcbiAgICAgICAgICAgIFtLZXlzLkhvbWVdOiAoeyBtaW4gfSkgPT4gbWluLFxuICAgICAgICAgICAgW0tleXMuRW5kXTogKHsgbWF4IH0pID0+IG1heFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXNldFN0eWxlcyhlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUoZWwsICd3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKGVsLCAnbGVmdCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKGVsLCAncmlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUoZWwsICdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZShlbCwgJ2JvdHRvbScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKGVsLCAncGFkZGluZy10b3AnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuU2xpZGVyQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGlja1BsYWNlbWVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmVydGljYWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzbWFsbFN0ZXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxhcmdlU3RlcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZml4ZWRUaWNrV2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZWFkb25seTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiaW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIHZhbHVlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBob3Jpem9udGFsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc2xpZGVyLWhvcml6b250YWwnLF0gfV0sXG4gICAgdmVydGljYWxDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zbGlkZXItdmVydGljYWwnLF0gfV0sXG4gICAgc2xpZGVyQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc2xpZGVyJyxdIH1dLFxuICAgIHdpZGdldENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9XSxcbiAgICBkaXNhYmxlZENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWRpc2FibGVkJyxdIH1dLFxuICAgIHdyYXBwZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd3cmFwJywgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIHRyYWNrOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndHJhY2snLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgc2xpZGVyU2VsZWN0aW9uOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnc2xpZGVyU2VsZWN0aW9uJywgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIHRpY2tzQ29udGFpbmVyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGlja3MnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSxdIH1dLFxuICAgIHRpY2tzOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGlja3MnLF0gfV0sXG4gICAgbGFiZWxUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dXG59O1xuXG5jb25zdCBGT0NVU0VEID0gJ2stc3RhdGUtZm9jdXNlZCc7XG5jb25zdCBQUkVTU0VEID0gJ2stcHJlc3NlZCc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBTbGlkZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3NsaWRlciAlfSkuXG4gKi9cbmNsYXNzIFNsaWRlckNvbXBvbmVudCBleHRlbmRzIFNsaWRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgaW5qZWN0b3IsIHJlbmRlcmVyLCBuZ1pvbmUsIGNoYW5nZURldGVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIGluamVjdG9yLCByZW5kZXJlciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgcGxheWVkIG9uIHZhbHVlIGNoYW5nZS5cbiAgICAgICAgICogUmVnYXJkbGVzcyBvZiB0aGlzIHNldHRpbmcsIG5vIGFuaW1hdGlvbiB3aWxsIGJlIHBsYXllZCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgdGhlIGFycm93IHNpZGUgYnV0dG9ucyBvZiB0aGUgU2xpZGVyIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2lkZWJ1dHRvbnNfc2xpZGVyICV9I3RvYy1oaWRkZW4tc3RhdGUpKS5cbiAgICAgICAgICogV2hlbiBgc2hvd0J1dHRvbnNgIGlzIHNldCB0byBgZmFsc2VgLCB0aGUgYnV0dG9ucyBhcmUgbm90IGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd0J1dHRvbnMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIFNsaWRlciB3aGVuIGl0IGlzIGluaXRpYWxseSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQgY2FuIHVzZSBlaXRoZXIgTmdNb2RlbCBvciB0aGUgYHZhbHVlYCBiaW5kaW5nIGJ1dCBub3QgYm90aCBvZiB0aGVtIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5taW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25CbHVyKSB8fCByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdUb3VjaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25XcmFwQ2xpY2sgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXJncy50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCAmJiAhKGlzQnV0dG9uKHRhcmdldCkgfHwgaXNCdXR0b24odGFyZ2V0LnBhcmVudE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uS2V5RG93biA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgY29uc3QgeyBtYXgsIG1pbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmtleUJpbmRpbmdbZS5rZXlDb2RlXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQgfHwgIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhhbmRsZXIob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKHRyaW1WYWx1ZShtYXgsIG1pbiwgdmFsdWUpKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmRlY3JlYXNlVmFsdWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKGRlY3JlYXNlVmFsdWVUb1N0ZXAodGhpcy52YWx1ZSwgdGhpcy5nZXRQcm9wcygpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5jcmVhc2VWYWx1ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoaW5jcmVhc2VWYWx1ZVRvU3RlcCh0aGlzLnZhbHVlLCB0aGlzLmdldFByb3BzKCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YWJJbmRleCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIFNsaWRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJzbGlkZXIuZm9jdXMoKVwiPkZvY3VzPC9idXR0b24+XG4gICAgICogIDxrZW5kby1zbGlkZXIgI3NsaWRlcj48L2tlbmRvLXNsaWRlcj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy53cmFwcGVyLCAnZm9jdXMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmx1cnMgdGhlIFNsaWRlci5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMud3JhcHBlciwgJ2JsdXInKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChbJ3ZhbHVlJywgJ2ZpeGVkVGlja1dpZHRoJywgJ3RpY2tQbGFjZW1lbnQnXSwgY2hhbmdlcywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVDb21wb25lbnQoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dCdXR0b25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlQ2hhbmdlSW50ZXJ2YWwodGhpcy5pbmNyZWFzZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCAoKSA9PiB0aGlzLmluY3JlYXNlVmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlQ2hhbmdlSW50ZXJ2YWwodGhpcy5kZWNyZWFzZUJ1dHRvbi5uYXRpdmVFbGVtZW50LCAoKSA9PiB0aGlzLmRlY3JlYXNlVmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMudGlja3MpIHtcbiAgICAgICAgICAgIHRoaXMudGlja3MudGlja0VsZW1lbnRzXG4gICAgICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2l6ZUNvbXBvbmVudChmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbmNyZW1lbnRNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnRUaXRsZSB8fCB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdpbmNyZW1lbnQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkZWNyZW1lbnRNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNyZW1lbnRUaXRsZSB8fCB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdkZWNyZW1lbnQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkcmFnSGFuZGxlTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0hhbmRsZVRpdGxlIHx8IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2RyYWdIYW5kbGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZURyYWdQcmVzcyhhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIGFyZ3Mub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLXNsaWRlci10cmFuc2l0aW9ucycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVEcmFnKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVSZWxlYXNlKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7IC8vbmVlZGVkIGZvciBhbmltYXRpb25cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLXNsaWRlci10cmFuc2l0aW9ucycpO1xuICAgIH1cbiAgICAvL25nTW9kZWwgYmluZGluZ1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWFyZVNhbWUodGhpcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZUNvbXBvbmVudCh0aGlzLmFuaW1hdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNpemVDb21wb25lbnQoYW5pbWF0ZSkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVsID0gdGhpcy5zbGlkZXJTZWxlY3Rpb24ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZUVsID0gdGhpcy5kcmFnaGFuZGxlLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyA/IHRoaXMudGlja3NDb250YWluZXIubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdrLXNsaWRlci10cmFuc2l0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRTdHlsZXMoW3RyYWNrLCBzZWxlY3Rpb25FbCwgZHJhZ0hhbmRsZUVsLCB0aWNrcywgdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50XSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IG5ldyBTbGlkZXJNb2RlbChwcm9wcywgd3JhcHBlciwgdHJhY2ssIHRoaXMucmVuZGVyZXIpO1xuICAgICAgICBtb2RlbC5yZXNpemVUcmFjaygpO1xuICAgICAgICBpZiAodGhpcy50aWNrcykgeyAvL2ZvciBjYXNlIHdoZW4gdGlja1BsYWNlbWVudDogbm9uZVxuICAgICAgICAgICAgbW9kZWwucmVzaXplVGlja3ModGhpcy50aWNrc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB0aGlzLnRpY2tzLnRpY2tFbGVtZW50cy5tYXAoZWxlbWVudCA9PiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5wb3NpdGlvbkhhbmRsZShkcmFnSGFuZGxlRWwpO1xuICAgICAgICBtb2RlbC5wb3NpdGlvblNlbGVjdGlvbihkcmFnSGFuZGxlRWwsIHNlbGVjdGlvbkVsKTtcbiAgICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2stc2xpZGVyLXRyYW5zaXRpb25zJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZml4ZWRUaWNrV2lkdGgpIHtcbiAgICAgICAgICAgIG1vZGVsLnJlc2l6ZVdyYXBwZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgZm9jdXNlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgIT09IHZhbHVlICYmIHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnQsIEZPQ1VTRUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCBGT0NVU0VEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IGRyYWdnaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dlZCAhPT0gdmFsdWUgJiYgdGhpcy5zbGlkZXJTZWxlY3Rpb24gJiYgdGhpcy5kcmFnaGFuZGxlKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZXJTZWxlY3Rpb24gPSB0aGlzLnNsaWRlclNlbGVjdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHJhZ2hhbmRsZSA9IHRoaXMuZHJhZ2hhbmRsZS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhzbGlkZXJTZWxlY3Rpb24sIFBSRVNTRUQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZHJhZ2hhbmRsZSwgUFJFU1NFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHNsaWRlclNlbGVjdGlvbiwgUFJFU1NFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhkcmFnaGFuZGxlLCBQUkVTU0VEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VmFsdWVDaGFuZ2VJbnRlcnZhbChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZWRvd24gPSBmcm9tRXZlbnQoZWxlbWVudCwgJ21vdXNlZG93bicpO1xuICAgICAgICAgICAgY29uc3QgbW91c2V1cCA9IGZyb21FdmVudChlbGVtZW50LCAnbW91c2V1cCcpO1xuICAgICAgICAgICAgY29uc3QgbW91c2VvdXQgPSBmcm9tRXZlbnQoZWxlbWVudCwgJ21vdXNlb3V0Jyk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBtb3VzZWRvd24ucGlwZShmaWx0ZXIoKGUpID0+IGUuYnV0dG9uID09PSAwICYmICF0aGlzLmlzRGlzYWJsZWQpLCBjb25jYXRNYXAoKCkgPT4gaW50ZXJ2YWwoMTUwKS5waXBlKHN0YXJ0V2l0aCgtMSksIHRha2VVbnRpbChtZXJnZShtb3VzZXVwLCBtb3VzZW91dCkpKSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFByb3BzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnV0dG9uczogdGhpcy5zaG93QnV0dG9ucyxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgICAgZml4ZWRUaWNrV2lkdGg6IHRoaXMuZml4ZWRUaWNrV2lkdGgsXG4gICAgICAgICAgICBsYXJnZVN0ZXA6IHRoaXMubGFyZ2VTdGVwLFxuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICByZWFkb25seTogdGhpcy5yZWFkb25seSxcbiAgICAgICAgICAgIHJldmVyc2U6IHRoaXMucmV2ZXJzZSxcbiAgICAgICAgICAgIHJ0bDogdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCxcbiAgICAgICAgICAgIHNtYWxsU3RlcDogdGhpcy5zbWFsbFN0ZXAsXG4gICAgICAgICAgICB2YWx1ZTogdHJpbVZhbHVlKHRoaXMubWF4LCB0aGlzLm1pbiwgdGhpcy52YWx1ZSksXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdGhpcy52ZXJ0aWNhbFxuICAgICAgICB9O1xuICAgIH1cbn1cblNsaWRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9TbGlkZXInLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLnNsaWRlcicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBtdWx0aTogdHJ1ZSwgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNsaWRlckNvbXBvbmVudCkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBLZW5kb0lucHV0LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTbGlkZXJDb21wb25lbnQpIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc2xpZGVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvU2xpZGVyTG9jYWxpemVkTWVzc2FnZXNcbiAgICAgICAgICAgIGkxOG4taW5jcmVtZW50PVwia2VuZG8uc2xpZGVyLmluY3JlbWVudHxUaGUgdGl0bGUgb2YgdGhlICoqSW5jcmVhc2UqKiBidXR0b24gb2YgdGhlIFNsaWRlci5cIlxuICAgICAgICAgICAgaW5jcmVtZW50PVwiaW5jcmVtZW50XCJcbiAgICAgICAgICAgIGkxOG4tZGVjcmVtZW50PVwia2VuZG8uc2xpZGVyLmRlY3JlbWVudHxUaGUgdGl0bGUgb2YgdGhlICoqRGVjcmVhc2UqKiBidXR0b24gb2YgdGhlIFNsaWRlci5cIlxuICAgICAgICAgICAgZGVjcmVtZW50PVwiZGVjcmVtZW50XCJcbiAgICAgICAgICAgIGkxOG4tZHJhZ0hhbmRsZT1cImtlbmRvLnNsaWRlci5kcmFnSGFuZGxlfFRoZSB0aXRsZSBvZiB0aGUgZHJhZyBoYW5kbGUgb2YgdGhlIFNsaWRlci5cIlxuICAgICAgICAgICAgZHJhZ0hhbmRsZT1cIkRyYWdcIlxuICAgICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXNsaWRlci13cmFwXCIgI3dyYXBcbiAgICAgICAgICAgIFtpZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItYnV0dG9uc109XCJzaG93QnV0dG9uc1wiXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItdG9wbGVmdF09XCJ0aWNrUGxhY2VtZW50ID09PSAnYmVmb3JlJ1wiXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItYm90dG9tcmlnaHRdPVwidGlja1BsYWNlbWVudCA9PT0gJ2FmdGVyJ1wiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRhYkluZGV4XCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cInsgZm9jdXM6IGhhbmRsZUZvY3VzLCBibHVyOiBoYW5kbGVCbHVyLCBjbGljazogb25XcmFwQ2xpY2ssIGtleWRvd246IG9uS2V5RG93biB9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgI2RlY3JlYXNlQnV0dG9uXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzaG93QnV0dG9uc1wiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWJ1dHRvbi1kZWNyZWFzZVwiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cImRlY3JlbWVudE1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiZGVjcmVtZW50TWVzc2FnZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb25cIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LXddPVwiIXZlcnRpY2FsXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstaS1hcnJvdy1zXT1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAqbmdJZj1cInNob3dCdXR0b25zXCJcbiAgICAgICAgICAgICAgICAjaW5jcmVhc2VCdXR0b25cbiAgICAgICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLWluY3JlYXNlXCJcbiAgICAgICAgICAgICAgICBbdGl0bGVdPVwiaW5jcmVtZW50TWVzc2FnZVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpbmNyZW1lbnRNZXNzYWdlXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvblwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWktYXJyb3ctZV09XCIhdmVydGljYWxcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWFycm93LW5dPVwidmVydGljYWxcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8dWwga2VuZG9TbGlkZXJUaWNrc1xuICAgICAgICAgICAgICAgICN0aWNrc1xuICAgICAgICAgICAgICAgICpuZ0lmPVwidGlja1BsYWNlbWVudCAhPT0gJ25vbmUnXCJcbiAgICAgICAgICAgICAgICBbdGlja1RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICAgICAgICBbdmVydGljYWxdPVwidmVydGljYWxcIlxuICAgICAgICAgICAgICAgIFtzdGVwXT1cInNtYWxsU3RlcFwiXG4gICAgICAgICAgICAgICAgW2xhcmdlU3RlcF09XCJsYXJnZVN0ZXBcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgW2xhYmVsVGVtcGxhdGVdPVwibGFiZWxUZW1wbGF0ZT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPGRpdiAjdHJhY2sgY2xhc3M9XCJrLXNsaWRlci10cmFja1wiPlxuICAgICAgICAgICAgPGRpdiAjc2xpZGVyU2VsZWN0aW9uIGNsYXNzPVwiay1zbGlkZXItc2VsZWN0aW9uXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8YSAjZHJhZ2hhbmRsZVxuICAgICAgICAgICAgICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtcmVhZG9ubHldPVwicmVhZG9ubHkgPyB0cnVlIDogdW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1vcmllbnRhdGlvbl09XCJ2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCdcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUudG91Y2gtYWN0aW9uXT1cImlzRGlzYWJsZWQgPyAnJyA6ICdub25lJ1wiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kcmFnaGFuZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cImRyYWdIYW5kbGVNZXNzYWdlXCJcbiAgICAgICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgICAgKGtlbmRvUHJlc3MpPVwiaWZFbmFibGVkKGhhbmRsZURyYWdQcmVzcywgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb0RyYWcpPVwiaWZFbmFibGVkKG9uSGFuZGxlRHJhZywgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb1JlbGVhc2UpPVwiaWZFbmFibGVkKG9uSGFuZGxlUmVsZWFzZSwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgPjwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJzaXplQ29tcG9uZW50KGZhbHNlKVwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICAgICAgPC9kaXY+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU2xpZGVyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuU2xpZGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZvY3VzYWJsZUlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkcmFnSGFuZGxlVGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluY3JlbWVudFRpdGxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmltYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkZWNyZW1lbnRUaXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd0J1dHRvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZHJhZ2hhbmRsZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2RyYWdoYW5kbGUnLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgZGVjcmVhc2VCdXR0b246IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydkZWNyZWFzZUJ1dHRvbicsXSB9XSxcbiAgICBpbmNyZWFzZUJ1dHRvbjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2luY3JlYXNlQnV0dG9uJyxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmFuZ2VTbGlkZXJNb2RlbCBleHRlbmRzIFNsaWRlck1vZGVsQmFzZSB7XG4gICAgcG9zaXRpb25IYW5kbGUoZHJhZ0hhbmRsZSkge1xuICAgICAgICBpZiAoIWRyYWdIYW5kbGUuaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1heCwgbWluLCByZXZlcnNlLCB2ZXJ0aWNhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2ZXJ0aWNhbCA/ICdib3R0b20nIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCB0cmFja1dpZHRoID0gdGhpcy50cmFja1dpZHRoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTdGFydEhhbmRsZShkcmFnSGFuZGxlKSA/IHRyaW1WYWx1ZVJhbmdlKG1heCwgbWluLCB0aGlzLnByb3BzLnZhbHVlKVswXVxuICAgICAgICAgICAgOiB0cmltVmFsdWVSYW5nZShtYXgsIG1pbiwgdGhpcy5wcm9wcy52YWx1ZSlbMV07XG4gICAgICAgIGlmIChpc1N0YXJ0SGFuZGxlKGRyYWdIYW5kbGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SGFuZGxlUG9zaXRpb24gPSBjYWxjdWxhdGVIYW5kbGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgICAgICByZXZlcnNlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHRyYWNrV2lkdGgsXG4gICAgICAgICAgICAgICAgaGFuZGxlV2lkdGg6IGRyYWdIYW5kbGUub2Zmc2V0V2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkcmFnSGFuZGxlLCBwb3NpdGlvbiwgYCR7dGhpcy5zdGFydEhhbmRsZVBvc2l0aW9ufXB4YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuZEhhbmRsZVBvc2l0aW9uID0gY2FsY3VsYXRlSGFuZGxlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgcmV2ZXJzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0cmFja1dpZHRoLFxuICAgICAgICAgICAgICAgIGhhbmRsZVdpZHRoOiBkcmFnSGFuZGxlLm9mZnNldFdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZHJhZ0hhbmRsZSwgcG9zaXRpb24sIGAke3RoaXMuZW5kSGFuZGxlUG9zaXRpb259cHhgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvblNlbGVjdGlvbihkcmFnSGFuZGxlLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyByZXZlcnNlLCB2ZXJ0aWNhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdmVydGljYWwgPyAnYm90dG9tJyA6IHJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBoYW5kbGVXaWR0aCA9IE1hdGguZmxvb3IoZHJhZ0hhbmRsZS5vZmZzZXRXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5hYnModGhpcy5lbmRIYW5kbGVQb3NpdGlvbiAtIHRoaXMuc3RhcnRIYW5kbGVQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb25Qb3NpdGlvbiA9IHZlcnRpY2FsID8gZHJhZ0hhbmRsZS5zdHlsZS5ib3R0b20gOiBkcmFnSGFuZGxlLnN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoc2VsZWN0aW9uLCBkaW1lbnNpb24sIGAke3NpemV9cHhgKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShzZWxlY3Rpb24sIHBvc2l0aW9uLCByZXZlcnNlID8gdGhpcy50cmFja1dpZHRoKCkgLSBwYXJzZUZsb2F0KGN1cnJlbnRTZWxlY3Rpb25Qb3NpdGlvbikgLSBoYW5kbGVXaWR0aCArICdweCdcbiAgICAgICAgICAgIDogcGFyc2VGbG9hdChjdXJyZW50U2VsZWN0aW9uUG9zaXRpb24pICsgaGFuZGxlV2lkdGggKyAncHgnKTtcbiAgICB9XG59XG5cbmNvbnN0IFBSRVNTRUQkMSA9ICdrLXByZXNzZWQnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgUmFuZ2VTbGlkZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3Jhbmdlc2xpZGVyICV9KS5cbiAqL1xuY2xhc3MgUmFuZ2VTbGlkZXJDb21wb25lbnQgZXh0ZW5kcyBTbGlkZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGluamVjdG9yLCByZW5kZXJlciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uLCBpbmplY3RvciwgcmVuZGVyZXIsIG5nWm9uZSwgY2hhbmdlRGV0ZWN0b3IsIGhvc3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0SGFuZGxlSWQgPSBgay1zdGFydC1oYW5kbGUtJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kSGFuZGxlSWQgPSBgay1lbmQtaGFuZGxlLSR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gdGhpcy5zdGFydEhhbmRsZUlkO1xuICAgICAgICB0aGlzLmhhbmRsZVpJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gJ3N0YXJ0SGFuZGxlJztcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uV3JhcENsaWNrID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUgfHwgW3RoaXMubWluLCB0aGlzLm1pbl07XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tWYWx1ZSA9IGV2ZW50VmFsdWUoYXJncywgdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LCB0aGlzLmdldFByb3BzKCkpO1xuICAgICAgICAgICAgICAgIGxldCBuZXdSYW5nZVZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydFZhbHVlLCBlbmRWYWx1ZV0gPSBuZXdSYW5nZVZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tWYWx1ZSA8PSBzdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlVmFsdWUgPSBbdHJhY2tWYWx1ZSwgZW5kVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9ICdzdGFydEhhbmRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0VmFsdWUgPCB0cmFja1ZhbHVlICYmIHRyYWNrVmFsdWUgPCBlbmRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tWYWx1ZSA8IChzdGFydFZhbHVlICsgZW5kVmFsdWUpIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VWYWx1ZSA9IFt0cmFja1ZhbHVlLCBlbmRWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9ICdzdGFydEhhbmRsZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZVZhbHVlID0gW3N0YXJ0VmFsdWUsIHRyYWNrVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVIYW5kbGUgPSAnZW5kSGFuZGxlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFja1ZhbHVlID49IGVuZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlVmFsdWUgPSBbc3RhcnRWYWx1ZSwgdHJhY2tWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gJ2VuZEhhbmRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUhhbmRsZSA9IHRoaXMuYWN0aXZlSGFuZGxlID09PSAnc3RhcnRIYW5kbGUnID8gdGhpcy5kcmFnaGFuZGxlU3RhcnQgOiB0aGlzLmRyYWdoYW5kbGVFbmQ7XG4gICAgICAgICAgICAgICAgaW52b2tlRWxlbWVudE1ldGhvZChhY3RpdmVIYW5kbGUsICdmb2N1cycpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUobmV3UmFuZ2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uS2V5RG93biA9IChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSB8fCBbdGhpcy5taW4sIHRoaXMubWluXTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBjb25zdCB7IG1heCwgbWluIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMua2V5QmluZGluZ1tlLmtleUNvZGVdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCB8fCAhaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZS50YXJnZXQsICd6SW5kZXgnLCArK3RoaXMuaGFuZGxlWkluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SGFuZGxlSXNBY3RpdmUgPSBpc1N0YXJ0SGFuZGxlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGFuZGxlcihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHZhbHVlOiBzdGFydEhhbmRsZUlzQWN0aXZlID8gdGhpcy52YWx1ZVswXSA6IHRoaXMudmFsdWVbMV0gfSkpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0SGFuZGxlSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiB0aGlzLnZhbHVlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCB0aGlzLnZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVmFsdWUgPSB0cmltVmFsdWUobWF4LCBtaW4sIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gc3RhcnRIYW5kbGVJc0FjdGl2ZSA/IFt0cmltbWVkVmFsdWUsIHRoaXMudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgOiBbdGhpcy52YWx1ZVswXSwgdHJpbW1lZFZhbHVlXTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5uZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1RvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBSYW5nZVNsaWRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICAgICA8ZGl2PlxuICAgICAqICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cInNsaWRlci5mb2N1cygpXCI+Rm9jdXM8L2J1dHRvbj5cbiAgICAgKiAgICAgPC9kaXY+XG4gICAgICogICAgIDxrZW5kby1yYW5nZXNsaWRlciAjc2xpZGVyPjwva2VuZG8tcmFuZ2VzbGlkZXI+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSB0cnVlO1xuICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuZHJhZ2hhbmRsZVN0YXJ0LCAnZm9jdXMnKTtcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBSYW5nZVNsaWRlci5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBhY3RpdmVIYW5kbGUgPSB0aGlzLmFjdGl2ZUhhbmRsZSA9PT0gJ3N0YXJ0SGFuZGxlJyA/IHRoaXMuZHJhZ2hhbmRsZVN0YXJ0IDogdGhpcy5kcmFnaGFuZGxlRW5kO1xuICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKGFjdGl2ZUhhbmRsZSwgJ2JsdXInKTtcbiAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW3RoaXMubWluLCB0aGlzLm1heF07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoYW55Q2hhbmdlZChbJ3ZhbHVlJywgJ2ZpeGVkVGlja1dpZHRoJywgJ3RpY2tQbGFjZW1lbnQnXSwgY2hhbmdlcywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLnZhbHVlICYmIGNoYW5nZXMudmFsdWUuY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVWYWx1ZShjaGFuZ2VzLnZhbHVlLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgICAgIGlmICh0aGlzLnRpY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tzLnRpY2tFbGVtZW50c1xuICAgICAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNpemVDb21wb25lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRhY2hFbGVtZW50RXZlbnRIYW5kbGVycygpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0ZXh0Rm9yKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IGAke3RoaXMudmFsdWVbMF19IC0gJHt0aGlzLnZhbHVlWzFdfWAgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZURyYWdQcmVzcyhhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIGFyZ3Mub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGFyZ3Mub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgIHRoaXMuZHJhZ2dlZEhhbmRsZSA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0YXJnZXQsICd6SW5kZXgnLCArK3RoaXMuaGFuZGxlWkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uSGFuZGxlRHJhZyhhcmdzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlIHx8IFt0aGlzLm1pbiwgdGhpcy5taW5dO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcmdzLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBsYXN0Q29vcmRzID0gdGhpcy5kcmFnZ2VkSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmxhc3RIYW5kbGVQb3NpdGlvbiA9IHsgeDogbGFzdENvb3Jkcy5sZWZ0LCB5OiBsYXN0Q29vcmRzLnRvcCB9O1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0geyB2YWx1ZTogdHJ1ZSwgdGFyZ2V0IH07XG4gICAgICAgIGNvbnN0IGxlZnQgPSBhcmdzLnBhZ2VYIDwgdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBhcmdzLnBhZ2VYID4gdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgdXAgPSBhcmdzLnBhZ2VZID4gdGhpcy5sYXN0SGFuZGxlUG9zaXRpb24ueTtcbiAgICAgICAgY29uc3QgbW92ZVN0YXJ0SGFuZGxlID0gKCkgPT4gdGhpcy5jaGFuZ2VWYWx1ZShbZXZlbnRWYWx1ZShhcmdzLCB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZ2V0UHJvcHMoKSksIHRoaXMudmFsdWVbMV1dKTtcbiAgICAgICAgY29uc3QgbW92ZUVuZEhhbmRsZSA9ICgpID0+IHRoaXMuY2hhbmdlVmFsdWUoW3RoaXMudmFsdWVbMF0sIGV2ZW50VmFsdWUoYXJncywgdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LCB0aGlzLmdldFByb3BzKCkpXSk7XG4gICAgICAgIGNvbnN0IG1vdmVCb3RoSGFuZGxlcyA9ICgpID0+IHRoaXMuY2hhbmdlVmFsdWUoW2V2ZW50VmFsdWUoYXJncywgdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LCB0aGlzLmdldFByb3BzKCkpLCBldmVudFZhbHVlKGFyZ3MsIHRoaXMudHJhY2submF0aXZlRWxlbWVudCwgdGhpcy5nZXRQcm9wcygpKV0pO1xuICAgICAgICBjb25zdCBhY3RpdmVTdGFydEhhbmRsZSA9IGlzU3RhcnRIYW5kbGUodGhpcy5kcmFnZ2VkSGFuZGxlKTtcbiAgICAgICAgY29uc3QgdmVydGljYWwgPSB0aGlzLnZlcnRpY2FsO1xuICAgICAgICBjb25zdCBob3Jpem9udGFsID0gIXZlcnRpY2FsO1xuICAgICAgICBjb25zdCBmb3J3YXJkID0gKHZlcnRpY2FsICYmIHVwKSB8fCAodGhpcy5yZXZlcnNlID8gaG9yaXpvbnRhbCAmJiByaWdodCA6IGhvcml6b250YWwgJiYgbGVmdCk7XG4gICAgICAgIC8vIGNvbnN0IGZvcndhcmQgPSAodGhpcy5yZXZlcnNlID8gKCF0aGlzLnZlcnRpY2FsICYmICFsZWZ0KSA6ICghdGhpcy52ZXJ0aWNhbCAmJiBsZWZ0KSkgfHwgKHRoaXMudmVydGljYWwgJiYgdXApO1xuICAgICAgICBpZiAodGhpcy52YWx1ZVswXSA9PT0gdGhpcy52YWx1ZVsxXSkge1xuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdGFydEhhbmRsZSA/IG1vdmVTdGFydEhhbmRsZSgpIDogbW92ZUJvdGhIYW5kbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdGFydEhhbmRsZSA/IG1vdmVCb3RoSGFuZGxlcygpIDogbW92ZUVuZEhhbmRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU3RhcnRIYW5kbGUgPyBtb3ZlU3RhcnRIYW5kbGUoKSA6IG1vdmVFbmRIYW5kbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVSZWxlYXNlKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHsgdmFsdWU6IGZhbHNlLCB0YXJnZXQ6IGFyZ3Mub3JpZ2luYWxFdmVudC50YXJnZXQgfTsgLy9uZWVkZWQgZm9yIGFuaW1hdGlvblxuICAgICAgICB0aGlzLmRyYWdnZWRIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vbmdNb2RlbCBiaW5kaW5nXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIWlzU2FtZVJhbmdlKHRoaXMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2l6ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbCA9IHRoaXMuc2xpZGVyU2VsZWN0aW9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGVTdGFydEVsID0gdGhpcy5kcmFnaGFuZGxlU3RhcnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZUVuZEVsID0gdGhpcy5kcmFnaGFuZGxlRW5kLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyA/IHRoaXMudGlja3NDb250YWluZXIubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXRTdHlsZXMoW3RyYWNrLCBzZWxlY3Rpb25FbCwgZHJhZ0hhbmRsZVN0YXJ0RWwsIGRyYWdIYW5kbGVFbmRFbCwgdGlja3MsIHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudF0pO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBuZXcgUmFuZ2VTbGlkZXJNb2RlbChwcm9wcywgd3JhcHBlciwgdHJhY2ssIHRoaXMucmVuZGVyZXIpO1xuICAgICAgICBtb2RlbC5yZXNpemVUcmFjaygpO1xuICAgICAgICBpZiAodGhpcy50aWNrcykgeyAvL2ZvciBjYXNlIHdoZW4gdGlja1BsYWNlbWVudDogbm9uZVxuICAgICAgICAgICAgbW9kZWwucmVzaXplVGlja3ModGhpcy50aWNrc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB0aGlzLnRpY2tzLnRpY2tFbGVtZW50cy5tYXAoZWxlbWVudCA9PiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5wb3NpdGlvbkhhbmRsZShkcmFnSGFuZGxlU3RhcnRFbCk7XG4gICAgICAgIG1vZGVsLnBvc2l0aW9uSGFuZGxlKGRyYWdIYW5kbGVFbmRFbCk7XG4gICAgICAgIG1vZGVsLnBvc2l0aW9uU2VsZWN0aW9uKGRyYWdIYW5kbGVTdGFydEVsLCBzZWxlY3Rpb25FbCk7XG4gICAgICAgIGlmICh0aGlzLmZpeGVkVGlja1dpZHRoKSB7XG4gICAgICAgICAgICBtb2RlbC5yZXNpemVXcmFwcGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc0Rpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgRmxvYXRpbmdMYWJlbCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCBmb2N1c2VkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9jdXNlZCAhPT0gdmFsdWUgJiYgdGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgZHJhZ2dpbmcoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnZWQgIT09IGRhdGEudmFsdWUgJiYgdGhpcy5zbGlkZXJTZWxlY3Rpb24gJiYgdGhpcy5kcmFnaGFuZGxlU3RhcnQgJiYgdGhpcy5kcmFnaGFuZGxlRW5kKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZXJTZWxlY3Rpb24gPSB0aGlzLnNsaWRlclNlbGVjdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHJhZ2hhbmRsZSA9IGRhdGEudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHNsaWRlclNlbGVjdGlvbiwgUFJFU1NFRCQxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGRyYWdoYW5kbGUsIFBSRVNTRUQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHNsaWRlclNlbGVjdGlvbiwgUFJFU1NFRCQxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGRyYWdoYW5kbGUsIFBSRVNTRUQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dlZCA9IGRhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgICAgIGZpeGVkVGlja1dpZHRoOiB0aGlzLmZpeGVkVGlja1dpZHRoLFxuICAgICAgICAgICAgbGFyZ2VTdGVwOiB0aGlzLmxhcmdlU3RlcCxcbiAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgcmVhZG9ubHk6IHRoaXMucmVhZG9ubHksXG4gICAgICAgICAgICByZXZlcnNlOiB0aGlzLnJldmVyc2UsXG4gICAgICAgICAgICBydGw6IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5ydGwsXG4gICAgICAgICAgICBzbWFsbFN0ZXA6IHRoaXMuc21hbGxTdGVwLFxuICAgICAgICAgICAgdmFsdWU6IHRyaW1WYWx1ZVJhbmdlKHRoaXMubWF4LCB0aGlzLm1pbiwgdGhpcy52YWx1ZSksXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdGhpcy52ZXJ0aWNhbCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGN1cnNvckluc2lkZVdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9jdXNJbiBhbmQgZm9jdXNPdXQgYXJlIHJlbGF0aXZlIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c291dCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWJiaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMuZHJhZ2hhbmRsZVN0YXJ0Lm5hdGl2ZUVsZW1lbnQgJiYgYXJncy5yZWxhdGVkVGFyZ2V0ICE9PSB0aGlzLmRyYWdoYW5kbGVFbmQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCbHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3JJbnNpZGVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnNvckluc2lkZVdyYXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3Vyc29ySW5zaWRlV3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ2tleWRvd24nLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuUmFuZ2VTbGlkZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvUmFuZ2VTbGlkZXInLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLnJhbmdlc2xpZGVyJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG11bHRpOiB0cnVlLCBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFuZ2VTbGlkZXJDb21wb25lbnQpIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogS2VuZG9JbnB1dCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFuZ2VTbGlkZXJDb21wb25lbnQpIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmFuZ2VzbGlkZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIga2VuZG9TbGlkZXJMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1kcmFnSGFuZGxlU3RhcnQ9XCJrZW5kby5yYW5nZXNsaWRlci5kcmFnSGFuZGxlU3RhcnR8VGhlIHRpdGxlIG9mIHRoZSAqKlN0YXJ0KiogZHJhZyBoYW5kbGUgb2YgdGhlIFNsaWRlci5cIlxuICAgICAgICAgICAgZHJhZ0hhbmRsZVN0YXJ0PVwiRHJhZ1wiXG4gICAgICAgICAgICBpMThuLWRyYWdIYW5kbGVFbmQ9XCJrZW5kby5yYW5nZXNsaWRlci5kcmFnSGFuZGxlRW5kfFRoZSB0aXRsZSBvZiB0aGUgKipFbmQqKiBkcmFnIGhhbmRsZSBvZiB0aGUgU2xpZGVyLlwiXG4gICAgICAgICAgICBkcmFnSGFuZGxlRW5kPVwiRHJhZ1wiXG4gICAgICAgID5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1zbGlkZXItd3JhcFwiICN3cmFwXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItdG9wbGVmdF09XCJ0aWNrUGxhY2VtZW50ID09PSAnYmVmb3JlJ1wiXG4gICAgICAgICAgICBbY2xhc3Muay1zbGlkZXItYm90dG9tcmlnaHRdPVwidGlja1BsYWNlbWVudCA9PT0gJ2FmdGVyJ1wiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7IGNsaWNrOiBvbldyYXBDbGljaywga2V5ZG93bjogb25LZXlEb3duIH1cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPHVsIGtlbmRvU2xpZGVyVGlja3NcbiAgICAgICAgICAgICAgICAjdGlja3NcbiAgICAgICAgICAgICAgICAqbmdJZj1cInRpY2tQbGFjZW1lbnQgIT09ICdub25lJ1wiXG4gICAgICAgICAgICAgICAgW3RpY2tUaXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgICAgICBbc3RlcF09XCJzbWFsbFN0ZXBcIlxuICAgICAgICAgICAgICAgIFtsYXJnZVN0ZXBdPVwibGFyZ2VTdGVwXCJcbiAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgIFtsYWJlbFRlbXBsYXRlXT1cImxhYmVsVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8ZGl2ICN0cmFjayBjbGFzcz1cImstc2xpZGVyLXRyYWNrXCI+XG4gICAgICAgICAgICAgICAgPGRpdiAjc2xpZGVyU2VsZWN0aW9uIGNsYXNzPVwiay1zbGlkZXItc2VsZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGEgI2RyYWdoYW5kbGVTdGFydFxuICAgICAgICAgICAgICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2lkXT1cInN0YXJ0SGFuZGxlSWRcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRhYmluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWUgPyB2YWx1ZVswXSA6IG51bGxcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVldGV4dF09XCJ2YWx1ZVRleHRcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtcmVhZG9ubHldPVwicmVhZG9ubHkgPyB0cnVlIDogdW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1vcmllbnRhdGlvbl09XCJ2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCdcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUudG91Y2gtYWN0aW9uXT1cImlzRGlzYWJsZWQgPyAnJyA6ICdub25lJ1wiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kcmFnaGFuZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cInRleHRGb3IoJ2RyYWdIYW5kbGVTdGFydCcpXCJcbiAgICAgICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICAgICAgKGtlbmRvUHJlc3MpPVwiaWZFbmFibGVkKGhhbmRsZURyYWdQcmVzcyAsJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb0RyYWcpPVwiaWZFbmFibGVkKG9uSGFuZGxlRHJhZyAsJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb1JlbGVhc2UpPVwiaWZFbmFibGVkKG9uSGFuZGxlUmVsZWFzZSwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgPjwvYT5cbiAgICAgICAgICAgICAgICA8YSAjZHJhZ2hhbmRsZUVuZFxuICAgICAgICAgICAgICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2lkXT1cImVuZEhhbmRsZUlkXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiZGlzYWJsZWQgPyB1bmRlZmluZWQgOiB0YWJpbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVtaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cInZhbHVlID8gdmFsdWVbMV0gOiBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZXRleHRdPVwidmFsdWVUZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZCA/IHRydWUgOiB1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRvbmx5ID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtb3JpZW50YXRpb25dPVwidmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnXCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLnRvdWNoLWFjdGlvbl09XCJpc0Rpc2FibGVkID8gJycgOiAnbm9uZSdcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstZHJhZ2hhbmRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJ0ZXh0Rm9yKCdkcmFnSGFuZGxlRW5kJylcIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgICAoa2VuZG9QcmVzcyk9XCJpZkVuYWJsZWQoaGFuZGxlRHJhZ1ByZXNzICwkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKGtlbmRvRHJhZyk9XCJpZkVuYWJsZWQob25IYW5kbGVEcmFnICwkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKGtlbmRvUmVsZWFzZSk9XCJpZkVuYWJsZWQob25IYW5kbGVSZWxlYXNlLCAkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICA+PC9hPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yIChyZXNpemUpPVwic2l6ZUNvbXBvbmVudCgpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8L2Rpdj5cbiAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5SYW5nZVNsaWRlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEluamVjdG9yIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcblJhbmdlU2xpZGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkcmFnaGFuZGxlU3RhcnQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydkcmFnaGFuZGxlU3RhcnQnLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgZHJhZ2hhbmRsZUVuZDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2RyYWdoYW5kbGVFbmQnLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV1cbn07XG5cbmNvbnN0IEZPQ1VTRUQkMSA9ICdrLXN0YXRlLWZvY3VzZWQnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgU3dpdGNoIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19zd2l0Y2ggJX0pLlxuICovXG5jbGFzcyBTd2l0Y2hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBob3N0RWxlbWVudCwgbG9jYWxpemF0aW9uU2VydmljZSwgaW5qZWN0b3IsIGNoYW5nZURldGVjdG9yLCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgU3dpdGNoIHdoZW4gaXQgaXMgaW5pdGlhbGx5IGRpc3BsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBTd2l0Y2ggaXMgZGlzYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZF9zd2l0Y2ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgU3dpdGNoIGlzIGluIGl0cyByZWFkLW9ubHkgc3RhdGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9zd2l0Y2ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBTd2l0Y2guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25Gb2N1cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uQmx1cikgfHwgcmVxdWlyZXNab25lT25CbHVyKHRoaXMuY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbG9jYWxpemF0aW9uU2VydmljZS5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLmtleURvd25IYW5kbGVyID0gdGhpcy5rZXlEb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsaWNrSGFuZGxlciA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICBnZXQgaWVDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIGJyb3dzZXIgJiYgYnJvd3Nlci5tc2llO1xuICAgIH1cbiAgICBnZXQgYXJpYURpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IHRydWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBhcmlhUmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgc3dpdGNoT25DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZDtcbiAgICB9XG4gICAgZ2V0IHN3aXRjaE9mZkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hlY2tlZDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG9uTGFiZWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkxhYmVsIHx8IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ29uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgb2ZmTGFiZWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZMYWJlbCB8fCB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UuZ2V0KCdvZmYnKTtcbiAgICB9XG4gICAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkICYmICF0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh3cmFwcGVyLCBcInRhYmluZGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlXG4gICAgICAgICAgICAuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoc2tpcCgxKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgU3dpdGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cInN3aXRjaC5mb2N1cygpXCI+Rm9jdXM8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLXN3aXRjaCAjc3dpdGNoPjwva2VuZG8tc3dpdGNoPlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgU3dpdGNoLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gdmFsdWUgPT09IG51bGwgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm5nVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAga2V5RG93bkhhbmRsZXIoZSkge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQgJiYgKGtleUNvZGUgPT09IEtleXMuU3BhY2UgfHwga2V5Q29kZSA9PT0gS2V5cy5FbnRlcikpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoIXRoaXMuY2hlY2tlZCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKCF0aGlzLmNoZWNrZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hhbmdlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IGZvY3VzZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkICE9PSB2YWx1ZSAmJiB0aGlzLmhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCBGT0NVU0VEJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCBGT0NVU0VEJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblN3aXRjaENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9Td2l0Y2gnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLnN3aXRjaCcgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFN3aXRjaENvbXBvbmVudCkgLyogdHNsaW50OmRpc2FibGUtbGluZSAqL1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU3dpdGNoQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXN3aXRjaCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1N3aXRjaExvY2FsaXplZE1lc3NhZ2VzXG4gICAgICAgICAgICBpMThuLW9uPVwia2VuZG8uc3dpdGNoLm9ufFRoZSAqKk9uKiogbGFiZWwgb2YgdGhlIFN3aXRjaC5cIlxuICAgICAgICAgICAgb249XCJPTlwiXG4gICAgICAgICAgICBpMThuLW9mZj1cImtlbmRvLnN3aXRjaC5vZmZ8VGhlICoqT2ZmKiogbGFiZWwgb2YgdGhlIFN3aXRjaC5cIlxuICAgICAgICAgICAgb2ZmPVwiT0ZGXCJcbiAgICAgICAgPlxuXG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICAjd3JhcHBlclxuICAgICAgICAgICAgY2xhc3M9XCJrLXN3aXRjaC1jb250YWluZXJcIlxuICAgICAgICAgICAgW2lkXT1cImZvY3VzYWJsZUlkXCJcbiAgICAgICAgICAgIHJvbGU9XCJzd2l0Y2hcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cImNoZWNrZWRcIlxuICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiKGRpc2FibGVkID8gdW5kZWZpbmVkIDogdGFiSW5kZXgpXCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cInsgY2xpY2s6IGNsaWNrSGFuZGxlciwga2V5ZG93bjoga2V5RG93bkhhbmRsZXIsIGZvY3VzOiBoYW5kbGVGb2N1cywgYmx1cjogaGFuZGxlQmx1ciB9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXN3aXRjaC1sYWJlbC1vblwiIFthdHRyLmFyaWEtaGlkZGVuXT1cInRydWVcIiA+e3tvbkxhYmVsTWVzc2FnZX19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLXN3aXRjaC1sYWJlbC1vZmZcIiBbYXR0ci5hcmlhLWhpZGRlbl09XCJ0cnVlXCI+e3tvZmZMYWJlbE1lc3NhZ2V9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zd2l0Y2gtaGFuZGxlXCI+PC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU3dpdGNoQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuU3dpdGNoQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZvY3VzYWJsZUlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvbkxhYmVsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvZmZMYWJlbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hlY2tlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlYWRvbmx5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJpbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIHZhbHVlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgd3JhcHBlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3dyYXBwZXInLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBpZUNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWllJyxdIH1dLFxuICAgIGFyaWFEaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWRpc2FibGVkJyxdIH1dLFxuICAgIGFyaWFSZWFkb25seTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXJlYWRvbmx5JyxdIH1dLFxuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3dpdGNoJyxdIH1dLFxuICAgIHN3aXRjaE9uQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3dpdGNoLW9uJyxdIH1dLFxuICAgIHN3aXRjaE9mZkNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN3aXRjaC1vZmYnLF0gfV0sXG4gICAgZGlzYWJsZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgVGV4dEFyZWEgZGlyZWN0aXZlIGZvciB0aGUgSW5wdXRzIGNvbXBvbmVudHMgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfdGV4dGFyZWEgJX0pLlxuICogUHJvdmlkZXMgZmxvYXRpbmcgbGFiZWxzIHRvIGB0ZXh0YXJlYWAgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogPHRleHRhcmVhIGtlbmRvVGV4dEFyZWE+PC90ZXh0YXJlYT5cbiAqIGBgYFxuICovXG5jbGFzcyBUZXh0QXJlYURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGVsZW1lbnQsIHpvbmUsIGNoYW5nZURldGVjdG9yLCBpbmplY3RvciwgcnRsKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvZmlsbENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdGV4dGFyZWEgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGB0ZXh0YXJlYWAgZWxlbWVudCB3aWxsIHJlc2l6ZSBpdHMgaGVpZ2h0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld190ZXh0YXJlYSAlfSN0b2MtYXV0by1yZXNpemluZykpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvU2l6ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9GaWxsU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9GaWxsRW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5uZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaWQ7XG4gICAgfVxuICAgIHNldCBpZChpZCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lkJywgaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm5nVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudFByb3BlcnR5KCdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnYmx1cicsIHRoaXMuaGFuZGxlQmx1ci5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnYW5pbWF0aW9uc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5hbmltYXRpb25OYW1lID09PSAnYXV0b0ZpbGxTdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b0ZpbGxTdGFydC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5hbmltYXRpb25OYW1lID09PSAnYXV0b0ZpbGxFbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9GaWxsRW5kLmVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiB0aGlzLmF1dG9TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJylcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUoKGRlYm91bmNlVGltZSg1MCkpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN1YnNjcmlwdGlvbiA9IGZyb21FdmVudChlbGVtZW50LCAnaW5wdXQnKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5oYW5kbGVJbnB1dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoY2hhbmdlcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLmF1dG9TaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ3Jlc2l6ZScsICdub25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdvdmVyZmxvdy15JywgJ2F1dG8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdyZXNpemUnLCAnYm90aCcpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5pbml0aWFsSGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgc2V0IGVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRQcm9wZXJ0eSgndmFsdWUnLCAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkgPyAnJyA6IHZhbHVlKTtcbiAgICB9XG4gICAgc2V0RWxlbWVudFByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRvU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbGVtZW50LCAnb3ZlcmZsb3cteScsICdoaWRkZW4nKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmluaXRpYWxIZWlnaHR9cHhgO1xuICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgaWYgKHNjcm9sbEhlaWdodCA+IHRoaXMuaW5pdGlhbEhlaWdodCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUlucHV0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZWxlbWVudFZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2wgfHwgaGFzT2JzZXJ2ZXJzKHRoaXMub25WYWx1ZUNoYW5nZSkgfHwgaGFzT2JzZXJ2ZXJzKHRoaXMudmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG4gICAgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nVG91Y2hlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5UZXh0QXJlYURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEFyZWFEaXJlY3RpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogS2VuZG9JbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRleHRBcmVhRGlyZWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3RleHRhcmVhW2tlbmRvVGV4dEFyZWFdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UZXh0QXJlYURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICB7IHR5cGU6IEJvb2xlYW4sIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbUlRMLF0gfV0gfVxuXTtcblRleHRBcmVhRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGVsZW1lbnRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay10ZXh0YXJlYScsXSB9XSxcbiAgICBhdXRvZmlsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWF1dG9maWxsJyxdIH1dLFxuICAgIGRpcmVjdGlvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5kaXInLF0gfV0sXG4gICAgdmFsdWVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBhdXRvU2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmxvYXRpbmdMYWJlbElucHV0QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBmb3JtQ29udHJvbCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgY29uc3QgaXNPYnNlcnZhYmxlT3JFdmVudEVtaXR0ZXIgPSAoZXZlbnQpID0+IGV2ZW50IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSB8fCBldmVudCBpbnN0YW5jZW9mIEV2ZW50RW1pdHRlcjtcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5vbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhpcy5vbkZvY3VzID0gY29tcG9uZW50Lm9uRm9jdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5hdXRvRmlsbFN0YXJ0KSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ID0gY29tcG9uZW50LmF1dG9GaWxsU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5hdXRvRmlsbEVuZCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0ZpbGxFbmQgPSBjb21wb25lbnQuYXV0b0ZpbGxFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9yRXZlbnRFbWl0dGVyKGNvbXBvbmVudC5vbkJsdXIpKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmx1ciA9IGNvbXBvbmVudC5vbkJsdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UgPSBmb3JtQ29udHJvbC52YWx1ZUNoYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm9uVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSA9IGNvbXBvbmVudC5vblZhbHVlQ2hhbmdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmb2N1c2FibGVJZCgpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGlmICgnZm9jdXNhYmxlSWQnIGluIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5mb2N1c2FibGVJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnaWQnIGluIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgc2V0IGZvY3VzYWJsZUlkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBpZiAoJ2ZvY3VzYWJsZUlkJyBpbiBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5mb2N1c2FibGVJZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdpZCcgaW4gY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQuaWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgaXNGdW5jdGlvbiA9ICh4KSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVGV4dEJveENvbnRhaW5lckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgcmVuZGVyZXIsIGNoYW5nZURldGVjdG9yUmVmLCBydGwpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1wdHkgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHRleHRhcmVhRWxlbWVudENsYXNzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnRleHRhcmVhO1xuICAgIH1cbiAgICBnZXQgZm9jdXNlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2VkO1xuICAgIH1cbiAgICBnZXQgaW52YWxpZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybUNvbnRyb2wgJiYgIXRoaXMua2VuZG9JbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFRleHRCb3hDb250YWluZXIgcmVxdWlyZXMgYSBLZW5kbyBJbnB1dCBjb21wb25lbnRcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIG9yIGEgZm9ybXMtYm91bmQgY29tcG9uZW50IHRvIGZ1bmN0aW9uIHByb3Blcmx5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgZm9jdXMvYmx1ci92YWx1ZUNoYW5nZSBoYW5kbGVyc1xuICAgICAgICBjb25zdCBjb250cm9sID0gbmV3IEZsb2F0aW5nTGFiZWxJbnB1dEFkYXB0ZXIodGhpcy5rZW5kb0lucHV0IHx8IHRoaXMuZm9ybUNvbnRyb2wudmFsdWVBY2Nlc3NvciwgdGhpcy5mb3JtQ29udHJvbCk7XG4gICAgICAgIGNvbnN0IHNldEZvY3VzID0gKGlzRm9jdXNlZCkgPT4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gaXNGb2N1c2VkO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YnNjcmliZShjb250cm9sLCAnb25Gb2N1cycsIHNldEZvY3VzKHRydWUpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoY29udHJvbCwgJ29uQmx1cicsIHNldEZvY3VzKGZhbHNlKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGNvbnRyb2wsICdhdXRvRmlsbFN0YXJ0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdXRvRmlsbFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZW1wdHknKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGNvbnRyb2wsICdhdXRvRmlsbEVuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9GaWxsU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b0ZpbGxTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2stc3RhdGUtZW1wdHknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cGRhdGVTdGF0ZSA9ICgpID0+IHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoY29udHJvbCwgJ29uVmFsdWVDaGFuZ2UnLCB1cGRhdGVTdGF0ZSk7XG4gICAgICAgIC8vIHNldCBsYWJlbCBpZCBmb3IgZmxvYXRpbmcgbGFiZWxcbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgY29udHJvbC5mb2N1c2FibGVJZCkge1xuICAgICAgICAgICAgLy8gaW5wdXQgd2luc1xuICAgICAgICAgICAgdGhpcy5pZCA9IGNvbnRyb2wuZm9jdXNhYmxlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgY29udHJvbC5mb2N1c2FibGVJZCA9IHRoaXMuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udHJvbC5mb2N1c2FibGVJZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGNvbnRyb2wuZm9jdXNhYmxlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IFwiX1wiICsgZ3VpZCgpO1xuICAgICAgICAgICAgY29udHJvbC5mb2N1c2FibGVJZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY29udHJvbCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChjb250cm9sW2V2ZW50TmFtZV0gaW5zdGFuY2VvZiBFdmVudEVtaXR0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNvbnRyb2xbZXZlbnROYW1lXS5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZW1wdHkgPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAvLyB6ZXJvIGlzIG5vdCBhbiBlbXB0eSB2YWx1ZSAoZS5nLiwgTnVtZXJpY1RleHRCb3gpXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDAgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1wdHkgYXJyYXlzIGFyZSBhbiBlbXB0eSB2YWx1ZSAoZS5nLiwgTXVsdGlTZWxlY3QpXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZm9ybUNvbnRyb2wgPSB0aGlzLmZvcm1Db250cm9sO1xuICAgICAgICBpZiAoZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQWNjZXNzb3IgPSBmb3JtQ29udHJvbC52YWx1ZUFjY2Vzc29yO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWVBY2Nlc3Nvci5pc0VtcHR5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkgPSB2YWx1ZUFjY2Vzc29yLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkgPSBlbXB0eShmb3JtQ29udHJvbC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludmFsaWQgPSBmb3JtQ29udHJvbC5pbnZhbGlkICYmIChmb3JtQ29udHJvbC50b3VjaGVkIHx8IGZvcm1Db250cm9sLmRpcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1wdHkgPSBpc0Z1bmN0aW9uKHRoaXMua2VuZG9JbnB1dC5pc0VtcHR5KSA/XG4gICAgICAgICAgICAgICAgdGhpcy5rZW5kb0lucHV0LmlzRW1wdHkoKSA6IGVtcHR5KHRoaXMua2VuZG9JbnB1dC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdrLXN0YXRlLWVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnay1zdGF0ZS1lbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuVGV4dEJveENvbnRhaW5lckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGV4dGJveC1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPGxhYmVsICpuZ0lmPVwiZmxvYXRpbmdMYWJlbFwiIFtmb3JdPVwiaWRcIiBjbGFzcz1cImstbGFiZWxcIj57eyBmbG9hdGluZ0xhYmVsIH19PC9sYWJlbD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRleHRCb3hDb250YWluZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBCb29sZWFuLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1JUTCxdIH1dIH1cbl07XG5UZXh0Qm94Q29udGFpbmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRleHRib3gtY29udGFpbmVyJyxdIH1dLFxuICAgIHRleHRhcmVhRWxlbWVudENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRleHRhcmVhLXdyYXBwZXInLF0gfV0sXG4gICAgZm9jdXNlZENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWZvY3VzZWQnLF0gfV0sXG4gICAgaW52YWxpZENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWludmFsaWQnLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBpZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmxvYXRpbmdMYWJlbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAga2VuZG9JbnB1dDogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbS2VuZG9JbnB1dCxdIH1dLFxuICAgIHRleHRhcmVhOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtUZXh0QXJlYURpcmVjdGl2ZSxdIH1dLFxuICAgIGZvcm1Db250cm9sOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtOZ0NvbnRyb2wsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgVGV4dEJveCBkaXJlY3RpdmVdKHslIHNsdWcgb3ZlcnZpZXdfdGV4dGJveCAlfSkgZm9yIHRoZSBJbnB1dHMgY29tcG9uZW50cyBmb3IgQW5ndWxhci5cbiAqIFVzZWQgdG8gc3R5bGUgdGhlIHRleHRib3ggb2YgYW55IGBpbnB1dGAgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiA8aW5wdXQga2VuZG9UZXh0Qm94IC8+XG4gKiA8aW5wdXQga2VuZG9UZXh0Qm94IHR5cGU9XCJlbWFpbFwiIC8+XG4gKiA8aW5wdXQga2VuZG9UZXh0Qm94IHR5cGU9XCJwYXNzd29yZFwiIC8+XG4gKiBgYGBcbiAqL1xuY2xhc3MgVGV4dEJveERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGlucHV0RWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQgPSBpbnB1dEVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0ZpbGxTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0ZpbGxFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudC52YWx1ZSA9ICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gbnVsbCkgPyAnJyA6IHRleHQ7XG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZS5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LmlkO1xuICAgIH1cbiAgICBzZXQgaWQoaWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lkJywgaWQpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihpbnB1dCwgJ2ZvY3VzJywgKCkgPT4gdGhpcy5vbkZvY3VzLmVtaXQoKSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbihpbnB1dCwgJ2JsdXInLCAoKSA9PiB0aGlzLm9uQmx1ci5lbWl0KCkpXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKGlucHV0LCAnYW5pbWF0aW9uc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLmFuaW1hdGlvbk5hbWUgPT09ICdhdXRvRmlsbFN0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9GaWxsU3RhcnQuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmFuaW1hdGlvbk5hbWUgPT09ICdhdXRvRmlsbEVuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvRmlsbEVuZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgICB9XG59XG5UZXh0Qm94RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFtrZW5kb1RleHRCb3hdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEJveERpcmVjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVGV4dEJveERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5UZXh0Qm94RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay10ZXh0Ym94JyxdIH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNyZWF0ZU1heFZhbGlkYXRvciA9IChtYXhWYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoYykgPT4ge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChtYXhWYWx1ZSkgfHwgIWlzUHJlc2VudChjLnZhbHVlKSB8fCBjLnZhbHVlIDw9IG1heFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4RXJyb3I6IHtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZTogbWF4VmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGMudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNyZWF0ZU1pblZhbGlkYXRvciA9IChtaW5WYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoYykgPT4ge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChtaW5WYWx1ZSkgfHwgIWlzUHJlc2VudChjLnZhbHVlKSB8fCBjLnZhbHVlID49IG1pblZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluRXJyb3I6IHtcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZTogbWluVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGMudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE1JTl9ET0NfTElOSyA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9pbnB1dHMvYXBpL051bWVyaWNUZXh0Qm94Q29tcG9uZW50LyN0b2MtbWluJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBNQVhfRE9DX0xJTksgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvaW5wdXRzL2FwaS9OdW1lcmljVGV4dEJveENvbXBvbmVudC8jdG9jLW1heCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUE9JTlQgPSBcIi5cIjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBJTklUSUFMX1NQSU5fREVMQVkgPSA1MDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU1BJTl9ERUxBWSA9IDUwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEVYUE9ORU5UX1JFR0VYID0gL1tlRV1bXFwtK10/KFswLTldKykvO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbnVtZXJpY1JlZ2V4ID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGF1dG9Db3JyZWN0LCBkZWNpbWFscywgbWluIH0gPSBvcHRpb25zO1xuICAgIGxldCBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvcjtcbiAgICBpZiAoc2VwYXJhdG9yID09PSBQT0lOVCkge1xuICAgICAgICBzZXBhcmF0b3IgPSAnXFxcXCcgKyBzZXBhcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25QYXR0ZXJuID0gYXV0b0NvcnJlY3QgJiYgbWluICE9PSBudWxsICYmIG1pbiA+PSAwID8gJycgOiAnLT8nO1xuICAgIGxldCBudW1iZXJQYXR0ZXJuO1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICBudW1iZXJQYXR0ZXJuID0gJ1xcXFxkKic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBudW1iZXJQYXR0ZXJuID0gYCg/Oig/OlxcXFxkKygke3NlcGFyYXRvcn1cXFxcZCopPyl8KD86JHtzZXBhcmF0b3J9XFxcXGQqKSk/YDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3NpZ25QYXR0ZXJufSR7bnVtYmVyUGF0dGVybn0kYCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlY2ltYWxQYXJ0ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgPyBNYXRoLmZsb29yKHZhbHVlKSA6IE1hdGguY2VpbCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vb3AgPSAoXykgPT4geyB9OyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWVtcHR5XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHZhbHVlICE9PSBudWxsO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBwYWQodmFsdWUsIGRpZ2l0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlnaXRzIC0gU3RyaW5nKHZhbHVlKS5sZW5ndGg7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFkU3RyaW5nID0gbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihcIjBcIik7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQodmFsdWUgKyBwYWRTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERlbHRhRnJvbU1vdXNlV2hlZWwgPSAoZSkgPT4ge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgaWYgKGUud2hlZWxEZWx0YSkge1xuICAgICAgICBkZWx0YSA9IGUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgICAgZGVsdGEgPSBkZWx0YSA+IDAgPyBNYXRoLmNlaWwoZGVsdGEpIDogTWF0aC5mbG9vcihkZWx0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUuZGV0YWlsKSB7XG4gICAgICAgIGRlbHRhID0gTWF0aC5yb3VuZCgtZS5kZXRhaWwgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBnZXRDYXJldFBvc2l0aW9uID0gKGVsZW1lbnQpID0+IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXh0cmFjdFNpZ25pZmljYW50TnVtZXJpY0NoYXJzID0gKGZvcm1hdHRlZFN0cmluZywgc2VwYXJhdG9yKSA9PiB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRDaGFyYWN0ZXJzID0gYCR7c2VwYXJhdG9yfTAxMjM0NTY3ODktYDtcbiAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nLnNwbGl0KCcnKS5yZWR1Y2UoKGFjYywgY3VycikgPT4gc2lnbmlmaWNhbnRDaGFyYWN0ZXJzLmluY2x1ZGVzKGN1cnIpID8gKythY2MgOiBhY2MsIDApO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBBcnJvd0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoQXJyb3dEaXJlY3Rpb24pIHtcbiAgICBBcnJvd0RpcmVjdGlvbltBcnJvd0RpcmVjdGlvbltcIkRvd25cIl0gPSAtMV0gPSBcIkRvd25cIjtcbiAgICBBcnJvd0RpcmVjdGlvbltBcnJvd0RpcmVjdGlvbltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIEFycm93RGlyZWN0aW9uW0Fycm93RGlyZWN0aW9uW1wiVXBcIl0gPSAxXSA9IFwiVXBcIjtcbn0pKEFycm93RGlyZWN0aW9uIHx8IChBcnJvd0RpcmVjdGlvbiA9IHt9KSk7XG5cbmNvbnN0IFBBUlNBQkxFX09QVElPTlMgPSBbJ21pbicsICdtYXgnLCAnc3RlcCcsICdkZWNpbWFscyddO1xuY29uc3QgUEFSU0FCTEVfREVGQVVMVFMgPSB7XG4gICAgZGVjaW1hbHM6IG51bGwsXG4gICAgbWF4OiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBzdGVwOiAxXG59O1xuY29uc3QgRk9DVVNFRCQyID0gJ2stc3RhdGUtZm9jdXNlZCc7XG5jb25zdCBGT1JNQVRURURfVkFMVUUgPSAnay1mb3JtYXR0ZWQtdmFsdWUnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgTnVtZXJpY1RleHRCb3ggY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X251bWVyaWN0ZXh0Ym94ICV9KS5cbiAqL1xuY2xhc3MgTnVtZXJpY1RleHRCb3hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGludGwsIHJlbmRlcmVyLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBpbmplY3Rvciwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay0ke2d1aWQoKX1gO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBOdW1lcmljVGV4dEJveCBpcyBkaXNhYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX251bWVyaWN0ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIE51bWVyaWNUZXh0Qm94IGlzIGluIGl0cyByZWFkLW9ubHkgc3RhdGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZWFkb25seV9udW1lcmljdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdGl0bGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCBvZiB0aGUgTnVtZXJpY1RleHRCb3guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgdmFsdWUgd2lsbCBiZSBhdXRvLWNvcnJlY3RlZCBiYXNlZCBvbiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXNcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVjaXNpb25fbnVtZXJpY3RleHRib3ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0NvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRoYXQgdGhlIHVzZXIgY2FuIGVudGVyIHdoZW4gdGhlIGlucHV0IGlzIGZvY3VzZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwcmVjaXNpb25fbnVtZXJpY3RleHRib3ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVjaW1hbHMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSB0aGF0IGlzIHVzZWQgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCB0aGUgY29tcG9uZW50IHZhbHVlXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcHJlZGVmaW5lZHN0ZXBzX251bWVyaWN0ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXAgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlICoqVXAqKiBhbmQgKipEb3duKiogc3BpbiBidXR0b25zIHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzcGluYnV0dG9uc19udW1lcmljdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGlubmVycyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbmltdW0gb3IgbWF4aW11bSB2YWxpZGF0b3JzIGFyZSBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyB2YWxpZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVGhlIDQuMi4wIEFuZ3VsYXIgdmVyc2lvbiBpbnRyb2R1Y2VzIHRoZSBgbWluYCBhbmQgYG1heGAgdmFsaWRhdGlvbiBkaXJlY3RpdmVzLiBBcyBhIHJlc3VsdCwgZXZlbiBpZiB5b3Ugc2V0IGByYW5nZVZhbGlkYXRpb25gXG4gICAgICAgICAqIHRvIGBmYWxzZWAsIHRoZSBidWlsdC1pbiBBbmd1bGFyIHZhbGlkYXRvcnMgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFuZ2VWYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgd2hvbGUgdmFsdWUgd2lsbCBiZSBzZWxlY3RlZCB3aGVuIHRoZSBOdW1lcmljVGV4dEJveCBpcyBjbGlja2VkLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdE9uRm9jdXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgTnVtZXJpY1RleHRCb3hcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmb3JtYXRzX251bWVyaWN0ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IHZhbHVlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfbnVtZXJpY3RleHRib3ggJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBgaW5wdXRgIGVsZW1lbnQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19udW1lcmljdGV4dGJveCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZWxlbWVudCBnZXRzIGJsdXJyZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19udW1lcmljdGV4dGJveCAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuQXJyb3dEaXJlY3Rpb24gPSBBcnJvd0RpcmVjdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJyb3dEaXJlY3Rpb24gPSBBcnJvd0RpcmVjdGlvbi5Ob25lO1xuICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5taW5WYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5tYXhWYWxpZGF0ZUZuID0gbm9vcDtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gXCJuMlwiO1xuICAgICAgICB0aGlzLmlzUGFzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmdDaGFuZ2UgPSBub29wO1xuICAgICAgICB0aGlzLm5nVG91Y2hlZCA9IG5vb3A7XG4gICAgICAgIHRoaXMubmdWYWxpZGF0b3JDaGFuZ2UgPSBub29wO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNyZWFzZVByZXNzID0gKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dQcmVzcyhBcnJvd0RpcmVjdGlvbi5VcCwgZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlY3JlYXNlUHJlc3MgPSAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXNzKEFycm93RGlyZWN0aW9uLkRvd24sIGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWxlYXNlQXJyb3cgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zcGluVGltZW91dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJvd0RpcmVjdGlvbiAhPT0gQXJyb3dEaXJlY3Rpb24uTm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dEaXJlY3Rpb24gPSBBcnJvd0RpcmVjdGlvbi5Ob25lO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVQYXN0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNQYXN0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVJbnB1dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5udW1lcmljSW5wdXQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGxldCB7IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQsIHZhbHVlOiBpbnB1dFZhbHVlIH0gPSBpbnB1dDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXNzZWRLZXkgPT09IEtleXMuTnVtcGFkRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB0aGlzLnJlcGxhY2VOdW1wYWREb3RWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gdGhpcy5mb3JtYXRJbnB1dFZhbHVlKHRoaXMuaW50bC5wYXJzZU51bWJlcihpbnB1dFZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZChpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0IC0gMSwgc2VsZWN0aW9uRW5kIC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSB0aGlzLmludGwucGFyc2VOdW1iZXIoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnJlc3RyaWN0RGVjaW1hbHMocGFyc2VkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0NvcnJlY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW1pdGVkID0gdGhpcy5saW1pdElucHV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGltaXRlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9IGxpbWl0ZWQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kID0gbGltaXRlZC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT09IHZhbHVlIHx8IHRoaXMuaGFzVHJhaWxpbmdaZXJvcyhpbnB1dFZhbHVlKSB8fCAhdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Bhc3RlZCkge1xuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNQYXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VudGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvY3VzZWQgJiYgIXRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSh0aGlzLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTZWxlY3RBbGwgPSB0aGlzLnNlbGVjdE9uRm9jdXMgfHwgIXRoaXMubW91c2VEb3duO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2VsZWN0QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdENhcmV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25Gb2N1cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy9ibHVyIGlzIHRocm93biBiZWZvcmUgaW5wdXQgd2hlbiBkcmFnZ2luZyB0aGUgaW5wdXQgdGV4dCBpbiBJRVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRWYWx1ZSAhPT0gdGhpcy5lbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUlucHV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1RvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RlcDtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duKSB7XG4gICAgICAgICAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09PSBLZXlzLkFycm93VXApIHtcbiAgICAgICAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwICYmIHRoaXMuc3RlcCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMubnVtZXJpY0lucHV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZEtleSA9IGUua2V5Q29kZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlV2hlZWwgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXNlZCAmJiAhdGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZ2V0RGVsdGFGcm9tTW91c2VXaGVlbChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN0ZXAoZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvblNlcnZpY2UucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgZm9ybWF0IHdoaWNoIGlzIHVzZWQgd2hlbiB0aGUgTnVtZXJpY1RleHRCb3ggaXMgbm90IGZvY3VzZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZvcm1hdHNfbnVtZXJpY3RleHRib3ggJX0pKS5cbiAgICAgKiBJZiBgZm9ybWF0YCBpcyBzZXQgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCBmb3JtYXQgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX2Zvcm1hdDtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCAhPT0gbnVsbCAmJiBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6ICduMic7XG4gICAgfVxuICAgIHNldCBmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICBnZXQgd2lkZ2V0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBpZiAodGhpcy5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LCBcInRhYmluZGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nQ29udHJvbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFBBUlNBQkxFX09QVElPTlMsIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZU9wdGlvbnMoUEFSU0FCTEVfT1BUSU9OUy5maWx0ZXIob3B0aW9uID0+IGNoYW5nZXNbb3B0aW9uXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyaWZ5U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWydtaW4nLCAnbWF4JywgJ3JhbmdlVmFsaWRhdGlvbiddLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsaWRhdGVGbiA9IHRoaXMucmFuZ2VWYWxpZGF0aW9uID8gY3JlYXRlTWluVmFsaWRhdG9yKHRoaXMubWluKSA6IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm1heFZhbGlkYXRlRm4gPSB0aGlzLnJhbmdlVmFsaWRhdGlvbiA/IGNyZWF0ZU1heFZhbGlkYXRvcih0aGlzLm1heCkgOiBub29wO1xuICAgICAgICAgICAgdGhpcy5uZ1ZhbGlkYXRvckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFsnYXV0b0NvcnJlY3QnLCAnZGVjaW1hbHMnLCAnbWluJ10sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5udW1lcmljUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZWQoWyd2YWx1ZScsICdmb3JtYXQnXSwgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeVZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMucmVzdHJpY3RNb2RlbFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvY3VzZWQgfHwgKHRoaXMuaW50bC5wYXJzZU51bWJlcih0aGlzLmVsZW1lbnRWYWx1ZSkgIT09IHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zcGluVGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShjb250cm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblZhbGlkYXRlRm4oY29udHJvbCkgfHwgdGhpcy5tYXhWYWxpZGF0ZUZuKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5nVmFsaWRhdG9yQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpO1xuICAgICAgICBsZXQgcmVzdHJpY3RlZFZhbHVlID0gdGhpcy5yZXN0cmljdE1vZGVsVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gcmVzdHJpY3RlZFZhbHVlO1xuICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5uZ1RvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBzdGF0dXMgb2YgdGhlIGNvbXBvbmVudCBjaGFuZ2VzIHRvIG9yIGZyb20gYGRpc2FibGVkYC5cbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHZhbHVlLCBpdCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBhcHByb3ByaWF0ZSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBOdW1lcmljVGV4dEJveC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8YnV0dG9uIChjbGljayk9XCJudW1lcmljdGV4dGJveC5mb2N1cygpXCI+Rm9jdXMgTnVtZXJpY1RleHRCb3g8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94ICNudW1lcmljdGV4dGJveD48L2tlbmRvLW51bWVyaWN0ZXh0Ym94PlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLm51bWVyaWNJbnB1dCwgJ2ZvY3VzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBOdW1lcmljVGV4dEJveC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMubnVtZXJpY0lucHV0LCAnYmx1cicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgYE51bWVyaWNUZXh0Qm94Q29tcG9uZW50YCB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBzaG91bGQgYmUgY2hhbmdlZC5cbiAgICAgKiBDYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIGlucHV0IGFmdGVyIHNldHRpbmcgdGhlIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIG5vdGlmeVZhbHVlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpbmNyZW1lbnRUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5nZXQoJ2luY3JlbWVudCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRlY3JlbWVudFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnZGVjcmVtZW50Jyk7XG4gICAgfVxuICAgIGdldCBkZWNpbWFsU2VwYXJhdG9yKCkge1xuICAgICAgICBjb25zdCBudW1iZXJTeW1ib2xzID0gdGhpcy5pbnRsLm51bWJlclN5bWJvbHMoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlclN5bWJvbHMuZGVjaW1hbDtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtZXJpY0lucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIHNldCBlbGVtZW50VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLm51bWVyaWNJbnB1dC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBmb2N1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZvY3VzZWQ7XG4gICAgfVxuICAgIGdldCBoYXNEZWNpbWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjaW1hbHMgIT09IG51bGwgJiYgdGhpcy5kZWNpbWFscyA+PSAwO1xuICAgIH1cbiAgICBzZXQgZm9jdXNlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgIT09IHZhbHVlICYmIHRoaXMubnVtZXJpY1dyYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXAgPSB0aGlzLm51bWVyaWNXcmFwLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMubnVtZXJpY0lucHV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHdyYXAsIEZPQ1VTRUQkMik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhpbnB1dCwgRk9STUFUVEVEX1ZBTFVFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHdyYXAsIEZPQ1VTRUQkMik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhpbnB1dCwgRk9STUFUVEVEX1ZBTFVFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHk7XG4gICAgfVxuICAgIGFycm93UHJlc3MoZGlyZWN0aW9uLCBlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9iaWxlT1MpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXJyb3dEaXJlY3Rpb24gIT09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hcnJvd0RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuc3BpbihkaXJlY3Rpb24sIElOSVRJQUxfU1BJTl9ERUxBWSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldElucHV0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWFyZVNhbWUodGhpcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlTnVtcGFkRG90VmFsdWUoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuaW5wdXRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91c1NlbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLm51bWVyaWNJbnB1dC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kIH0gPSBpbnB1dDtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5wcmV2aW91c1NlbGVjdGlvbjtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdGhpcy5kZWNpbWFsU2VwYXJhdG9yICsgdmFsdWUuc3Vic3RyaW5nKGVuZCk7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlzVmFsaWQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm51bWVyaWNSZWdleCkge1xuICAgICAgICAgICAgdGhpcy5udW1lcmljUmVnZXggPSBudW1lcmljUmVnZXgoe1xuICAgICAgICAgICAgICAgIGF1dG9Db3JyZWN0OiB0aGlzLmF1dG9Db3JyZWN0LFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0aGlzLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiB0aGlzLmRlY2ltYWxTZXBhcmF0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm51bWVyaWNSZWdleC50ZXN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3BpbihzdGVwLCB0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNwaW5UaW1lb3V0KTtcbiAgICAgICAgdGhpcy5zcGluVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3BpbihzdGVwLCBTUElOX0RFTEFZKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICB9XG4gICAgYWRkU3RlcChzdGVwKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFkZCh0aGlzLnZhbHVlIHx8IDAsIHRoaXMuc3RlcCAqIHN0ZXApO1xuICAgICAgICB2YWx1ZSA9IHRoaXMubGltaXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5yZXN0cmljdERlY2ltYWxzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRJbnB1dFZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIGludm9rZUVsZW1lbnRNZXRob2QodGhpcy5udW1lcmljSW5wdXQsICdzZXRTZWxlY3Rpb25SYW5nZScsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbWl0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuaXNJblJhbmdlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHRoaXMubWF4KSAmJiB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIodGhpcy5taW4pICYmIHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaW1pdElucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IHsgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCwgdmFsdWU6IGVudGVyZWRWYWx1ZSB9ID0gdGhpcy5udW1lcmljSW5wdXQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IGxpbWl0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBsZXQgc2VsZWN0VG9FbmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5SYW5nZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aENoYW5nZSA9IGVudGVyZWRWYWx1ZS5sZW5ndGggLSBTdHJpbmcodGhpcy5pbnB1dFZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaGFzTWF4ID0gaXNOdW1iZXIobWF4KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc01pbiA9IGlzTnVtYmVyKG1pbik7XG4gICAgICAgICAgICBsZXQgcGFkTGltaXQsIHJlcGxhY2VOZXh0O1xuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5pbnB1dFZhbHVlLnN1YnN0cigxKSA9PT0gZW50ZXJlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc01heCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZU5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkTGltaXQgPSBtYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzTWluICYmIHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYWRMaW1pdCA9IG1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFkTGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWRWYWx1ZSA9IHRoaXMudHJ5UGFkVmFsdWUodmFsdWUsIHBhZExpbWl0KTtcbiAgICAgICAgICAgICAgICBpZiAocGFkZGVkVmFsdWUgJiYgZGVjaW1hbFBhcnQodmFsdWUpICE9PSBkZWNpbWFsUGFydChwYWRMaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkVmFsdWUgPSBwYWRkZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0VG9FbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRWYWx1ZSAmJiBzZWxlY3Rpb25TdGFydCAhPT0gZW50ZXJlZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRWYWx1ZSA9IHBhcnNlRmxvYXQoZW50ZXJlZFZhbHVlLnN1YnN0cigwLCBzZWxlY3Rpb25TdGFydCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJlZFZhbHVlLnN1YnN0cihzZWxlY3Rpb25TdGFydCArIGxlbmd0aENoYW5nZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0ZWRWYWx1ZSA9IHRoaXMubGltaXRWYWx1ZShjb3JyZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzZWxlY3RUb0VuZCA9IChzZWxlY3RUb0VuZCB8fCBsaW1pdGVkVmFsdWUgIT09IGNvcnJlY3RlZFZhbHVlKSAmJiB0aGlzLnByZXZpb3VzU2VsZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgKHRoaXMucHJldmlvdXNTZWxlY3Rpb24uZW5kIC0gdGhpcy5wcmV2aW91c1NlbGVjdGlvbi5zdGFydCArIGxlbmd0aENoYW5nZSkgPiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdFRvRW5kID8gU3RyaW5nKGxpbWl0ZWRWYWx1ZSkubGVuZ3RoIDogc2VsZWN0aW9uRW5kLFxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgdmFsdWU6IGxpbWl0ZWRWYWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cnlQYWRWYWx1ZSh2YWx1ZSwgbGltaXQpIHtcbiAgICAgICAgY29uc3QgbGltaXRMZW5ndGggPSBTdHJpbmcoTWF0aC5mbG9vcihsaW1pdCkpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgemVyb1BhZGRlZCA9IHBhZCh2YWx1ZSwgbGltaXRMZW5ndGgpO1xuICAgICAgICBjb25zdCB6ZXJvUGFkZGVkTmV4dCA9IHBhZCh2YWx1ZSwgbGltaXRMZW5ndGggKyAxKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlKHplcm9QYWRkZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB6ZXJvUGFkZGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNJblJhbmdlKHplcm9QYWRkZWROZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gemVyb1BhZGRlZE5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaXNJblJhbmdlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhaXNOdW1iZXIodmFsdWUpIHx8ICgoIWlzTnVtYmVyKHRoaXMubWluKSB8fCB0aGlzLm1pbiA8PSB2YWx1ZSkgJiYgKCFpc051bWJlcih0aGlzLm1heCkgfHwgdmFsdWUgPD0gdGhpcy5tYXgpKTtcbiAgICB9XG4gICAgcmVzdHJpY3RNb2RlbFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlc3RyaWN0RGVjaW1hbHModmFsdWUsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5hdXRvQ29ycmVjdCAmJiB0aGlzLmxpbWl0VmFsdWUocmVzdWx0KSAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3RyaWN0RGVjaW1hbHModmFsdWUsIHJvdW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuaGFzRGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdGhpcy5kZWNpbWFscztcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyb3VuZCB8fCBFWFBPTkVOVF9SRUdFWC50ZXN0KHN0cmluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvRml4ZWRQcmVjaXNpb24odmFsdWUsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3RyaW5nVmFsdWUuc3BsaXQoUE9JTlQpO1xuICAgICAgICAgICAgICAgIGxldCBmcmFjdGlvbiA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGlmIChmcmFjdGlvbiAmJiBmcmFjdGlvbi5sZW5ndGggPiBkZWNpbWFscykge1xuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnN1YnN0cigwLCBkZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoYCR7cGFydHNbMF19JHtQT0lOVH0ke2ZyYWN0aW9ufWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3JtYXRJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBzdHJpbmdWYWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4cG9uZW50TWF0Y2ggPSBFWFBPTkVOVF9SRUdFWC5leGVjKHN0cmluZ1ZhbHVlKTtcbiAgICAgICAgaWYgKGV4cG9uZW50TWF0Y2gpIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gdmFsdWUudG9GaXhlZChsaW1pdFByZWNpc2lvbihwYXJzZUludChleHBvbmVudE1hdGNoWzFdLCAxMCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUucmVwbGFjZShQT0lOVCwgdGhpcy5kZWNpbWFsU2VwYXJhdG9yKTtcbiAgICB9XG4gICAgZm9ybWF0VmFsdWUodmFsdWUsIGZvY3VzZWQpIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgIWRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb2N1c2VkICYmICF0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0SW5wdXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuaW50bC5mb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuICAgIHNldElucHV0VmFsdWUodmFsdWUgPSB0aGlzLnZhbHVlLCBmb2N1c2VkID0gdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gdGhpcy5mb3JtYXRWYWx1ZSh2YWx1ZSwgZm9jdXNlZCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgIH1cbiAgICB2ZXJpZnlTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbiAhPT0gbnVsbCAmJiB0aGlzLm1heCAhPT0gbnVsbCAmJiB0aGlzLm1pbiA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtYXggdmFsdWUgc2hvdWxkIGJlIGJpZ2dlciB0aGFuIHRoZSBtaW4uIFNlZSAke01JTl9ET0NfTElOS30gYW5kICR7TUFYX0RPQ19MSU5LfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgTnVtZXJpY1RleHRCb3ggY29tcG9uZW50IHJlcXVpcmVzIHZhbHVlIG9mIHR5cGUgTnVtYmVyIGFuZCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gd2FzIHNldC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBvcHRpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zW2lkeF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gIWlzTmFOKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmICF2YWxpZCAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgTnVtZXJpY1RleHRCb3ggY29tcG9uZW50IHJlcXVpcmVzIHZhbHVlIG9mIHR5cGUgTnVtYmVyIG9yIGEgU3RyaW5nIHJlcHJlc2VudGluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhIG51bWJlciBmb3IgdGhlICR7bmFtZX0gcHJvcGVydHkgYW5kICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSB3YXMgc2V0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gdmFsaWQgPyBwYXJzZWQgOiBQQVJTQUJMRV9ERUZBVUxUU1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5udW1lcmljUmVnZXg7XG4gICAgICAgIGlmICh0aGlzLm51bWVyaWNJbnB1dCAmJiAoIXRoaXMuZm9jdXNlZCB8fCAhdGhpcy5pc1ZhbGlkKHRoaXMuZWxlbWVudFZhbHVlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc1RyYWlsaW5nWmVyb3MoaW5wdXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNEZWNpbWFscyAmJiB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uID0gaW5wdXRWYWx1ZS5zcGxpdCh0aGlzLmRlY2ltYWxTZXBhcmF0b3IpWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWN0aW9uICYmIGZyYWN0aW9uLmxlbmd0aCA+IHRoaXMuZGVjaW1hbHMgJiYgZnJhY3Rpb24ubGFzdEluZGV4T2YoJzAnKSA9PT0gZnJhY3Rpb24ubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RBbGwoKSB7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbigwLCB0aGlzLmlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICB9XG4gICAgc2VsZWN0Q2FyZXQoKSB7XG4gICAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBnZXRDYXJldFBvc2l0aW9uKHRoaXMubnVtZXJpY0lucHV0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZWxlbWVudFZhbHVlO1xuICAgICAgICBjb25zdCBwYXJ0aWFsVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZS5zdWJzdHJpbmcoMCwgY2FyZXRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICBpZiAocGFydGlhbFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmlmaWNhbnRDaGFyc0luRm9ybWF0dGVkVmFsdWUgPSBleHRyYWN0U2lnbmlmaWNhbnROdW1lcmljQ2hhcnMocGFydGlhbFZhbHVlLCB0aGlzLmRlY2ltYWxTZXBhcmF0b3IpO1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWRTaWduaWZpY2FudENoYXJzID0gdGhpcy5hZGp1c3RTaWduaWZpY2FudENoYXJzKGZvcm1hdHRlZFZhbHVlLCBzaWduaWZpY2FudENoYXJzSW5Gb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihhZGp1c3RlZFNpZ25pZmljYW50Q2hhcnMsIGFkanVzdGVkU2lnbmlmaWNhbnRDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbigwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBudW1iZXJPZkxlYWRpbmdaZXJvZXMoZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBmb3JtYXR0ZWRWYWx1ZS5pbmRleE9mKHRoaXMuZGVjaW1hbFNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRMZWFkaW5nWmVyb2VzID0gZm9ybWF0dGVkVmFsdWUubWF0Y2goL15bXjEtOV0qPygwKykvKTtcbiAgICAgICAgaWYgKG1hdGNoZWRMZWFkaW5nWmVyb2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhPZk1hdGNoID0gbWF0Y2hlZExlYWRpbmdaZXJvZXNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoT2ZMZWFkaW5nWmVyb2VzTWF0Y2ggPSBtYXRjaGVkTGVhZGluZ1plcm9lc1sxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoT2ZNYXRjaCA9PT0gc2VwYXJhdG9ySW5kZXggPyBsZW5ndGhPZkxlYWRpbmdaZXJvZXNNYXRjaCAtIDEgOiBsZW5ndGhPZkxlYWRpbmdaZXJvZXNNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgYWRqdXN0U2lnbmlmaWNhbnRDaGFycyhmb3JtYXR0ZWRWYWx1ZSwgc2lnbmlmaWNhbnRDaGFycykge1xuICAgICAgICBjb25zdCBsZWFkaW5nWmVyb2VzID0gdGhpcy5udW1iZXJPZkxlYWRpbmdaZXJvZXMoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICBpZiAobGVhZGluZ1plcm9lcyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBzaWduaWZpY2FudENoYXJzIC0gbGVhZGluZ1plcm9lcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25pZmljYW50Q2hhcnM7XG4gICAgfVxufVxuTnVtZXJpY1RleHRCb3hDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvTnVtZXJpY1RleHRCb3gnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLm51bWVyaWN0ZXh0Ym94JyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOdW1lcmljVGV4dEJveENvbXBvbmVudCksIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtZXJpY1RleHRCb3hDb21wb25lbnQpLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE51bWVyaWNUZXh0Qm94Q29tcG9uZW50KSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLW51bWVyaWN0ZXh0Ym94JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvTnVtZXJpY1RleHRCb3hMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1pbmNyZW1lbnQ9XCJrZW5kby5udW1lcmljdGV4dGJveC5pbmNyZW1lbnR8VGhlIHRpdGxlIGZvciB0aGUgKipJbmNyZW1lbnQqKiBidXR0b24gaW4gdGhlIE51bWVyaWNUZXh0Qm94XCJcbiAgICAgICAgICAgIGluY3JlbWVudD1cIkluY3JlYXNlIHZhbHVlXCJcbiAgICAgICAgICAgIGkxOG4tZGVjcmVtZW50PVwia2VuZG8ubnVtZXJpY3RleHRib3guZGVjcmVtZW50fFRoZSB0aXRsZSBmb3IgdGhlICoqRGVjcmVtZW50KiogYnV0dG9uIGluIHRoZSBOdW1lcmljVGV4dEJveFwiXG4gICAgICAgICAgICBkZWNyZW1lbnQ9XCJEZWNyZWFzZSB2YWx1ZVwiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICBjbGFzcz1cImstbnVtZXJpYy13cmFwXCJcbiAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXT1cInsgbW91c2V3aGVlbDogaGFuZGxlV2hlZWwsIERPTU1vdXNlU2Nyb2xsOiBoYW5kbGVXaGVlbCB9XCJcbiAgICAgICAgICAgICNudW1lcmljV3JhcD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgcm9sZT1cInNwaW5idXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWlucHV0IGstZm9ybWF0dGVkLXZhbHVlXCJcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICBhdXRvY29ycmVjdD1cIm9mZlwiXG4gICAgICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1pbl09XCJtaW5cIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duOiBoYW5kbGVNb3VzZURvd24sXG4gICAgICAgICAgICAgICAgZHJhZ2VudGVyOiBoYW5kbGVEcmFnRW50ZXIsXG4gICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgICAgICBpbnB1dDogaGFuZGxlSW5wdXQsXG4gICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgIGJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICAgICAgICAgICAgcGFzdGU6IGhhbmRsZVBhc3RlXG4gICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICNudW1lcmljSW5wdXQgLz5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zZWxlY3RcIiAqbmdJZj1cInNwaW5uZXJzXCIgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwieyBtb3VzZXVwOiByZWxlYXNlQXJyb3csIG1vdXNlbGVhdmU6IHJlbGVhc2VBcnJvdyB9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgW2tlbmRvRXZlbnRzT3V0c2lkZUFuZ3VsYXJdPVwieyBtb3VzZWRvd246IGluY3JlYXNlUHJlc3MgfVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaW5jcmVtZW50VGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwiaW5jcmVtZW50VGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1zdGF0ZS1hY3RpdmVdPVwiYXJyb3dEaXJlY3Rpb24gPT09IEFycm93RGlyZWN0aW9uLlVwXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWxpbmsgay1saW5rLWluY3JlYXNlXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1hcnJvdy1uXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7IG1vdXNlZG93bjogZGVjcmVhc2VQcmVzcyB9XCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJkZWNyZW1lbnRUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJkZWNyZW1lbnRUaXRsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLWFjdGl2ZV09XCJhcnJvd0RpcmVjdGlvbiA9PT0gQXJyb3dEaXJlY3Rpb24uRG93blwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1saW5rIGstbGluay1kZWNyZWFzZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWktYXJyb3ctc1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTnVtZXJpY1RleHRCb3hDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJbnRsU2VydmljZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuTnVtZXJpY1RleHRCb3hDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZm9jdXNhYmxlSWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZWFkb25seTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGF1dG9Db3JyZWN0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkZWNpbWFsczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0ZXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNwaW5uZXJzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByYW5nZVZhbGlkYXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0T25Gb2N1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgb25Gb2N1czogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2ZvY3VzJyxdIH1dLFxuICAgIG9uQmx1cjogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2JsdXInLF0gfV0sXG4gICAgbnVtZXJpY0lucHV0OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnbnVtZXJpY0lucHV0JywgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIG51bWVyaWNXcmFwOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnbnVtZXJpY1dyYXAnLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICB3aWRnZXRDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstbnVtZXJpY3RleHRib3gnLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOdW1lcmljVGV4dEJveE1lc3NhZ2VzIGV4dGVuZHMgQ29tcG9uZW50TWVzc2FnZXMge1xufVxuTnVtZXJpY1RleHRCb3hNZXNzYWdlcy5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkZWNyZW1lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluY3JlbWVudDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQ3VzdG9tIGNvbXBvbmVudCBtZXNzYWdlcyBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudCBtZXNzYWdlcy5cbiAqL1xuY2xhc3MgTnVtZXJpY1RleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIE51bWVyaWNUZXh0Qm94TWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5OdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE51bWVyaWNUZXh0Qm94TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tbnVtZXJpY3RleHRib3gtbWVzc2FnZXMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5OdW1lcmljVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIFJlc3VsdFR5cGU7XG4oZnVuY3Rpb24gKFJlc3VsdFR5cGUpIHtcbiAgICBSZXN1bHRUeXBlW1Jlc3VsdFR5cGVbXCJMaXRlcmFsXCJdID0gMF0gPSBcIkxpdGVyYWxcIjtcbiAgICBSZXN1bHRUeXBlW1Jlc3VsdFR5cGVbXCJNYXNrXCJdID0gMV0gPSBcIk1hc2tcIjtcbiAgICBSZXN1bHRUeXBlW1Jlc3VsdFR5cGVbXCJVbmRlZmluZWRcIl0gPSAyXSA9IFwiVW5kZWZpbmVkXCI7XG59KShSZXN1bHRUeXBlIHx8IChSZXN1bHRUeXBlID0ge30pKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZXN0LCB0eXBlID0gUmVzdWx0VHlwZS5VbmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvL21hcCA6OiBGdW5jdG9yIGYgPT4gZiBhIH4+IChhIC0+IGIpIC0+IGYgYlxuICAgIG1hcChmbikge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChmbih0aGlzLnZhbHVlKSwgdGhpcy5yZXN0KTtcbiAgICB9XG4gICAgLy9jaGFpbiA6OiBDaGFpbiBtID0+IG0gYSB+PiAoYSAtPiBtIGIpIC0+IG0gYlxuICAgIGNoYWluKGZuKSB7XG4gICAgICAgIHJldHVybiBmbih0aGlzLnZhbHVlLCB0aGlzLnJlc3QpO1xuICAgIH1cbiAgICBmb2xkKHMsIF8gLyp3ZSBkb24ndCBuZWVkIGl0Ki8pIHtcbiAgICAgICAgcmV0dXJuIHModGhpcy52YWx1ZSwgdGhpcy5yZXN0KTtcbiAgICB9XG4gICAgY29uY2F0KHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKCh2cywgXykgPT4gci5jaGFpbigodiwgX18pID0+IHZzLmNvbmNhdChbdl0pKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFJlc3VsdCh7IHZhbHVlOiAnJHt0aGlzLnZhbHVlfScsIHJlc3Q6ICR7dGhpcy5yZXN0fSB9KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCA9IFtdLCBjb250cm9sID0gW10pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgICB0aGlzLmlucHV0Q3Vyc29yID0gMDtcbiAgICAgICAgdGhpcy5jb250cm9sQ3Vyc29yID0gMDtcbiAgICB9XG4gICAgZW9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEN1cnNvciA+PSB0aGlzLmlucHV0Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBpbnB1dC5cbiAgICBuZXh0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhcjogdGhpcy5pbnB1dFt0aGlzLmlucHV0Q3Vyc29yKytdLFxuICAgICAgICAgICAgY29udHJvbDogdGhpcy5jb250cm9sW3RoaXMuY29udHJvbEN1cnNvcisrXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhcjogdGhpcy5pbnB1dFt0aGlzLmlucHV0Q3Vyc29yXSxcbiAgICAgICAgICAgIGNvbnRyb2w6IHRoaXMuY29udHJvbFt0aGlzLmNvbnRyb2xDdXJzb3JdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVhdF9pbnB1dCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEN1cnNvcisrO1xuICAgIH1cbiAgICBlYXRfY29udHJvbCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sQ3Vyc29yKys7XG4gICAgfVxuICAgIGVhdCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEN1cnNvcisrO1xuICAgICAgICB0aGlzLmNvbnRyb2xDdXJzb3IrKztcbiAgICB9XG59XG5cbmNvbnN0IHRvQXJyYXkgPSAodmFsdWUpID0+ICh2YWx1ZSB8fCAnJykuc3BsaXQoJycpO1xuY29uc3QgRVNDQVBFX0NIQVJBQ1RFUiA9ICdcXFxcJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlKSB7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICB9XG4gICAgcnVuKGlucHV0LCBjb250cm9sID0gJycpIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShuZXcgU3RyZWFtKHRvQXJyYXkoaW5wdXQpLCB0b0FycmF5KGNvbnRyb2wpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9tYXAgOjogRnVuY3RvciBmID0+IGYgYSB+PiAoYSAtPiBiKSAtPiBmIGJcbiAgICBtYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzdHJlYW0gPT4gdGhpcy5wYXJzZShzdHJlYW0pLm1hcChmKSk7XG4gICAgfVxuICAgIC8vY2hhaW4gOjogQ2hhaW4gbSA9PiBtIGEgfj4gKGEgLT4gbSBiKSAtPiBtIGJcbiAgICBjaGFpbihmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB0aGlzLnBhcnNlKHN0cmVhbSkuY2hhaW4oKHYsIHMpID0+IGYodikucnVuKHMpKSk7XG4gICAgfVxuICAgIGlzTGl0ZXJhbChjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bihjKS50eXBlID09PSBSZXN1bHRUeXBlLkxpdGVyYWw7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1hc2sgPSAoeyBwcm9tcHQsIHByb21wdFBsYWNlaG9sZGVyIH0pID0+IHJ1bGUgPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIHdoaWxlICghc3RyZWFtLmVvZigpKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhciwgY29udHJvbCB9ID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09IGNvbnRyb2wgJiYgY29udHJvbCA9PT0gcHJvbXB0KSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChwcm9tcHQsIHN0cmVhbSwgUmVzdWx0VHlwZS5NYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChjaGFyLCBzdHJlYW0sIFJlc3VsdFR5cGUuTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IHByb21wdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChwcm9tcHQsIHN0cmVhbSwgUmVzdWx0VHlwZS5NYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZWF0X2lucHV0KCk7XG4gICAgfVxuICAgIHN0cmVhbS5lYXQoKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdChwcm9tcHQsIHN0cmVhbSwgUmVzdWx0VHlwZS5NYXNrKTtcbn0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxpdGVyYWwgPSBfdG9rZW4gPT4gbmV3IFBhcnNlcihzdHJlYW0gPT4ge1xuICAgIC8vICAgIGxldCB7Y2hhciwgY29udHJvbH0gPSBzdHJlYW0ucGVlaygpO1xuICAgIGxldCBjaGFyID0gc3RyZWFtLnBlZWsoKS5jaGFyO1xuICAgIGlmIChjaGFyID09PSBfdG9rZW4pIHtcbiAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfdG9rZW4sIHN0cmVhbSwgUmVzdWx0VHlwZS5MaXRlcmFsKTtcbiAgICB9XG4gICAgLy8gICAgaWYgKGNvbnRyb2wgPT09IF90b2tlbikge1xuICAgIC8vICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2YoKSAmJiBjaGFyICE9PSBfdG9rZW4pIHtcbiAgICAvLyAgICAgICAgICAgIHN0cmVhbS5lYXRfaW5wdXQoKTtcbiAgICAvLyAgICAgICAgICAgIGNoYXIgPSBzdHJlYW0ucGVlaygpLmNoYXI7XG4gICAgLy8gICAgICAgIH1cbiAgICAvLyAgICB9XG4gICAgLy9cbiAgICAvLyAgICBpZiAoY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgIHN0cmVhbS5lYXQoKTtcbiAgICAvLyAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoX3Rva2VuLCBzdHJlYW0sIFJlc3VsdFR5cGUuTGl0ZXJhbCk7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB1bm1hc2sgPSBwcm9tcHQgPT4gcnVsZSA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9mKCkpIHtcbiAgICAgICAgY29uc3QgeyBjaGFyLCBjb250cm9sIH0gPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICBpZiAoY2hhciA9PT0gcHJvbXB0ICYmIGNvbnRyb2wgPT09IHByb21wdCkge1xuICAgICAgICAgICAgc3RyZWFtLmVhdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoY2hhciwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChjaGFyLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5lYXRfaW5wdXQoKTtcbiAgICB9XG4gICAgc3RyZWFtLmVhdCgpO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KCcnLCBzdHJlYW0pO1xufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdW5saXRlcmFsID0gX3Rva2VuID0+IG5ldyBQYXJzZXIoc3RyZWFtID0+IHtcbiAgICBpZiAoc3RyZWFtLmVvZigpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KCcnLCBzdHJlYW0pO1xuICAgIH1cbiAgICBjb25zdCB7IGNoYXIgfSA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKGNoYXIgPT09IF90b2tlbikge1xuICAgICAgICBzdHJlYW0uZWF0KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzdWx0KF90b2tlbiwgc3RyZWFtKTtcbn0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRva2VuID0gKHJ1bGVzLCBjcmVhdG9yKSA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB7XG4gICAgbGV0IHsgY2hhciB9ID0gc3RyZWFtLm5leHQoKTtcbiAgICBjb25zdCBydWxlID0gcnVsZXNbY2hhcl07XG4gICAgaWYgKGNoYXIgPT09IEVTQ0FQRV9DSEFSQUNURVIpIHtcbiAgICAgICAgY2hhciA9IHN0cmVhbS5uZXh0KCkuY2hhcjtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoY3JlYXRvci5saXRlcmFsKGNoYXIpLCBzdHJlYW0pO1xuICAgIH1cbiAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoY3JlYXRvci5saXRlcmFsKGNoYXIpLCBzdHJlYW0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc3VsdChjcmVhdG9yLm1hc2socnVsZSksIHN0cmVhbSk7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByYXdNYXNrID0gKHsgcHJvbXB0LCBwcm9tcHRQbGFjZWhvbGRlciB9KSA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB7XG4gICAgbGV0IHsgY2hhciB9ID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2hhciA9PT0gcHJvbXB0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHByb21wdFBsYWNlaG9sZGVyLCBzdHJlYW0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlc3VsdChjaGFyLCBzdHJlYW0pO1xufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmF3TGl0ZXJhbCA9IGluY2x1ZGVMaXRlcmFscyA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB7XG4gICAgbGV0IHsgY2hhciB9ID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoaW5jbHVkZUxpdGVyYWxzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0KGNoYXIsIHN0cmVhbSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzdWx0KCcnLCBzdHJlYW0pO1xufSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhbHdheXMgPSB2YWx1ZSA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiBuZXcgUmVzdWx0KHZhbHVlLCBzdHJlYW0pKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhcHBlbmQgPSAocDEsIHAyKSA9PiBwMS5jaGFpbih2cyA9PiBwMi5tYXAodiA9PiB2cy5jb25jYXQoW3ZdKSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNlcXVlbmNlID0gbGlzdCA9PiBsaXN0LnJlZHVjZSgoYWNjLCBwYXJzZXIpID0+IGFwcGVuZChhY2MsIHBhcnNlciksIGFsd2F5cyhbXSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdyZWVkeSA9IHBhcnNlciA9PiBuZXcgUGFyc2VyKHN0cmVhbSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBSZXN1bHQoW10sIHN0cmVhbSk7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9mKCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChwYXJzZXIucnVuKHN0cmVhbSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNYXNraW5nU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5wcm9tcHQgPSBcIl9cIjtcbiAgICAgICAgdGhpcy5tYXNrID0gXCJcIjtcbiAgICAgICAgdGhpcy5wcm9tcHRQbGFjZWhvbGRlciA9IFwiIFwiO1xuICAgICAgICB0aGlzLmluY2x1ZGVMaXRlcmFscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hc2tUb2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy51bm1hc2tUb2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5yYXdUb2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uVG9rZW5zID0gW107XG4gICAgfVxuICAgIHVwZGF0ZSh7IG1hc2s6IG1hc2skJDEgPSAnJywgcHJvbXB0ID0gJycsIHByb21wdFBsYWNlaG9sZGVyID0gJyAnLCBydWxlcyA9IHt9LCBpbmNsdWRlTGl0ZXJhbHMgPSBmYWxzZSB9KSB7XG4gICAgICAgIHRoaXMubWFzayA9IG1hc2skJDE7XG4gICAgICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICAgICAgICB0aGlzLnByb21wdFBsYWNlaG9sZGVyID0gcHJvbXB0UGxhY2Vob2xkZXI7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlTGl0ZXJhbHMgPSBpbmNsdWRlTGl0ZXJhbHM7XG4gICAgICAgIHRoaXMudG9rZW5pemUoKTtcbiAgICB9XG4gICAgdmFsaWRhdGlvblZhbHVlKG1hc2tlZFZhbHVlID0gJycpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFza2VkVmFsdWU7XG4gICAgICAgIHNlcXVlbmNlKHRoaXMudmFsaWRhdGlvblRva2VucylcbiAgICAgICAgICAgIC5ydW4obWFza2VkVmFsdWUpXG4gICAgICAgICAgICAuZm9sZCh1bm1hc2tlZCA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVubWFza2VkLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByYXdWYWx1ZShtYXNrZWRWYWx1ZSA9ICcnKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hc2tlZFZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMucmF3VG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNlcXVlbmNlKHRoaXMucmF3VG9rZW5zKVxuICAgICAgICAgICAgLnJ1bihtYXNrZWRWYWx1ZSlcbiAgICAgICAgICAgIC5mb2xkKHVubWFza2VkID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5tYXNrZWQuam9pbignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBtYXNrUmF3KHJhd1ZhbHVlID0gJycpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5tYXNrVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNlcXVlbmNlKHRoaXMubWFza1Rva2VucylcbiAgICAgICAgICAgIC5ydW4ocmF3VmFsdWUpXG4gICAgICAgICAgICAuZm9sZChtYXNrZWQgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXNrZWQuam9pbignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIG1hc2tJbnB1dChpbnB1dCwgY29udHJvbCwgc3BsaXRQb2ludCkge1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDwgY29udHJvbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hc2tSZW1vdmVkKGlucHV0LCBjb250cm9sLCBzcGxpdFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXNrSW5zZXJ0ZWQoaW5wdXQsIGNvbnRyb2wsIHNwbGl0UG9pbnQpO1xuICAgIH1cbiAgICBtYXNrSW5SYW5nZShwYXN0ZWQsIG9sZFZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZW5kO1xuICAgICAgICBjb25zdCBiZWZvcmVDaGFuZ2UgPSBvbGRWYWx1ZS5zcGxpdCgnJykuc2xpY2UoMCwgc3RhcnQpO1xuICAgICAgICBjb25zdCBhZnRlckNoYW5nZSA9IG9sZFZhbHVlLnNwbGl0KCcnKS5zbGljZShlbmQpO1xuICAgICAgICBzZXF1ZW5jZSh0aGlzLm1hc2tUb2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gICAgICAgICAgICAucnVuKHBhc3RlZClcbiAgICAgICAgICAgIC5mb2xkKG1hc2tlZCA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJlZm9yZUNoYW5nZVxuICAgICAgICAgICAgICAgIC5jb25jYXQobWFza2VkKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoYWZ0ZXJDaGFuZ2UpXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1hc2tSZW1vdmVkKGlucHV0LCBjb250cm9sLCBzcGxpdFBvaW50KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gc3BsaXRQb2ludDtcbiAgICAgICAgY29uc3QgdW5jaGFuZ2VkID0gaW5wdXQuc3BsaXQoJycpLnNsaWNlKHNwbGl0UG9pbnQpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gaW5wdXQuc3BsaXQoJycpLnNsaWNlKDAsIHNwbGl0UG9pbnQpLmpvaW4oJycpO1xuICAgICAgICBjb25zdCB0YWtlJCQxID0gdGhpcy5tYXNrVG9rZW5zLmxlbmd0aCAtIChpbnB1dC5sZW5ndGggLSBzcGxpdFBvaW50KTtcbiAgICAgICAgc2VxdWVuY2UodGhpcy5tYXNrVG9rZW5zLnNsaWNlKDAsIHRha2UkJDEpKVxuICAgICAgICAgICAgLnJ1bihjaGFuZ2VkLCBjb250cm9sKVxuICAgICAgICAgICAgLmZvbGQobWFza2VkID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHRoaXMuYWRqdXN0UG9zaXRpb24obWFza2VkLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFsdWUgPSBtYXNrZWQuY29uY2F0KHVuY2hhbmdlZCkuam9pbignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRqdXN0UG9zaXRpb24oaW5wdXQsIHNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBjYXJldENoYXIgPSBpbnB1dFtzZWxlY3Rpb25dO1xuICAgICAgICBjb25zdCBpc0xpdGVyYWwgPSB0aGlzLm1hc2tUb2tlbnNbc2VsZWN0aW9uXS5pc0xpdGVyYWwoY2FyZXRDaGFyKTtcbiAgICAgICAgaWYgKCFpc0xpdGVyYWwgJiYgY2FyZXRDaGFyICE9PSB0aGlzLnByb21wdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9XG4gICAgbWFza0luc2VydGVkKGlucHV0LCBjb250cm9sLCBzcGxpdFBvaW50KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gc3BsaXRQb2ludDtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IGlucHV0LnNsaWNlKDAsIHNwbGl0UG9pbnQpO1xuICAgICAgICBzZXF1ZW5jZSh0aGlzLnVubWFza1Rva2VucylcbiAgICAgICAgICAgIC5ydW4oY2hhbmdlZCwgY29udHJvbClcbiAgICAgICAgICAgIC5jaGFpbih1bm1hc2tlZCA9PiB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB1bm1hc2tlZC5qb2luKCcnKS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB1bmNoYW5nZWQgPSBjb250cm9sLnNsaWNlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gc2VxdWVuY2UodGhpcy5tYXNrVG9rZW5zKVxuICAgICAgICAgICAgICAgIC5ydW4odW5tYXNrZWQuam9pbignJykgKyB1bmNoYW5nZWQsIGNvbnRyb2wpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvbGQobWFza2VkID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gbWFza2VkLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBtYXNrVG9rZW5DcmVhdG9yKCkge1xuICAgICAgICBjb25zdCB7IHByb21wdCwgcHJvbXB0UGxhY2Vob2xkZXIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBydWxlID0+IGxpdGVyYWwocnVsZSksXG4gICAgICAgICAgICBtYXNrOiBydWxlID0+IG1hc2soeyBwcm9tcHQsIHByb21wdFBsYWNlaG9sZGVyIH0pKHJ1bGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCB1bm1hc2tUb2tlbkNyZWF0b3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBydWxlID0+IHVubGl0ZXJhbChydWxlKSxcbiAgICAgICAgICAgIG1hc2s6IHJ1bGUgPT4gdW5tYXNrKHRoaXMucHJvbXB0KShydWxlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgcmF3VG9rZW5DcmVhdG9yKCkge1xuICAgICAgICBjb25zdCB7IHByb21wdCwgcHJvbXB0UGxhY2Vob2xkZXIsIGluY2x1ZGVMaXRlcmFscyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IF8gPT4gcmF3TGl0ZXJhbChpbmNsdWRlTGl0ZXJhbHMpLFxuICAgICAgICAgICAgbWFzazogXyA9PiByYXdNYXNrKHsgcHJvbXB0LCBwcm9tcHRQbGFjZWhvbGRlciB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgdmFsaWRhdGlvblRva2VuQ3JlYXRvcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9tcHQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBfID0+IHJhd0xpdGVyYWwoZmFsc2UpLFxuICAgICAgICAgICAgbWFzazogXyA9PiByYXdNYXNrKHsgcHJvbXB0LCBwcm9tcHRQbGFjZWhvbGRlcjogJycgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9rZW5pemUoKSB7XG4gICAgICAgIGdyZWVkeSh0b2tlbih0aGlzLnJ1bGVzLCB0aGlzLm1hc2tUb2tlbkNyZWF0b3IpKVxuICAgICAgICAgICAgLnJ1bih0aGlzLm1hc2spXG4gICAgICAgICAgICAuZm9sZCgodG9rZW5zLCBfKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hc2tUb2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIH0pO1xuICAgICAgICBncmVlZHkodG9rZW4odGhpcy5ydWxlcywgdGhpcy51bm1hc2tUb2tlbkNyZWF0b3IpKVxuICAgICAgICAgICAgLnJ1bih0aGlzLm1hc2spXG4gICAgICAgICAgICAuZm9sZCgodG9rZW5zLCBfKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVubWFza1Rva2VucyA9IHRva2VucztcbiAgICAgICAgfSk7XG4gICAgICAgIGdyZWVkeSh0b2tlbih0aGlzLnJ1bGVzLCB0aGlzLnJhd1Rva2VuQ3JlYXRvcikpXG4gICAgICAgICAgICAucnVuKHRoaXMubWFzaylcbiAgICAgICAgICAgIC5mb2xkKCh0b2tlbnMsIF8pID0+IHtcbiAgICAgICAgICAgIHRoaXMucmF3VG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JlZWR5KHRva2VuKHRoaXMucnVsZXMsIHRoaXMudmFsaWRhdGlvblRva2VuQ3JlYXRvcikpXG4gICAgICAgICAgICAucnVuKHRoaXMubWFzaylcbiAgICAgICAgICAgIC5mb2xkKCh0b2tlbnMsIF8pID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvblRva2VucyA9IHRva2VucztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuTWFza2luZ1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbmNvbnN0IEZPQ1VTRUQkMyA9ICdrLXN0YXRlLWZvY3VzZWQnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgTWFza2VkVGV4dEJveCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfbWFza2VkdGV4dGJveCAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGtlbmRvLW1hc2tlZHRleHRib3hcbiAqICAgICAgICAgIFttYXNrXT1cIm1hc2tcIlxuICogICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCI+XG4gKiAgICAgIDwva2VuZG8tbWFza2VkdGV4dGJveD5cbiAqICAgICBgXG4gKiB9KVxuICpcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgcHVibGljIHZhbHVlOiBzdHJpbmcgPSBcIjk1ODAxMjgwNTU4MDc3OTJcIjtcbiAqICBwdWJsaWMgbWFzazogc3RyaW5nID0gXCIwMDAwLTAwMDAtMDAwMC0wMDAwXCI7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgTWFza2VkVGV4dEJveENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgcmVuZGVyZXIsIGhvc3RFbGVtZW50LCBuZ1pvbmUsIGluamVjdG9yLCBjaGFuZ2VEZXRlY3RvciwgcnRsKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzYWJsZUlkID0gYGstJHtndWlkKCl9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgTWFza2VkVGV4dEJveCBpcyBkaXNhYmxlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRpc2FibGVkX21hc2tlZHRleHRib3ggJX0pKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgTWFza2VkVGV4dEJveCBpcyBpbiBpdHMgcmVhZC1vbmx5IHN0YXRlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfbWFza2VkdGV4dGJveCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgYSBwcm9tcHQgY2hhcmFjdGVyIGZvciB0aGUgbWFza2VkIHZhbHVlLlxuICAgICAgICAgKiBAZGVmYXVsdCBgX2BcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvbXB0ID0gJ18nO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGEgY2hhcmFjdGVyIHdoaWNoIHJlcHJlc2VudHMgYW4gZW1wdHkgcG9zaXRpb24gaW4gdGhlIHJhdyB2YWx1ZS5cbiAgICAgICAgICogQGRlZmF1bHQgJyAnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb21wdFBsYWNlaG9sZGVyID0gJyAnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW5jbHVkZSBsaXRlcmFscyBpbiB0aGUgcmF3IHZhbHVlICAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHZhbHVlX21hc2tlZHRleHRib3ggJX0pKS5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5jbHVkZUxpdGVyYWxzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIG1hc2sgc2hvdWxkIGJlIHNob3duIG9uIGZvY3VzIGZvciBlbXB0eSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFza09uRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gbWFzayB2YWxpZGF0b3IgaXMgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgdmFsaWRhdGVkXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmFsaWRhdGlvbl9tYXNrZWR0ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFza1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBbYHRhYmluZGV4YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFiaW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkZvY3VzYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHMtbm8tcnVuXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLW1hc2tlZHRleHRib3g+XG4gICAgICAgICAqIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICBwdWJsaWMgaGFuZGxlRm9jdXMoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgZm9jdXNlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7IC8vdHNsaW50OmRpc2FibGUtbGluZTpuby1vdXRwdXQtcmVuYW1lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHMtbm8tcnVuXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggKGJsdXIpPVwiaGFuZGxlQmx1cigpXCI+PC9rZW5kby1tYXNrZWR0ZXh0Ym94PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUJsdXIoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgaXMgYmx1cnJlZFwiKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTsgLy90c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW91dHB1dC1yZW5hbWVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZm9jdXNDbGljayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRSdWxlcyA9IHtcbiAgICAgICAgICAgIFwiI1wiOiAvW1xcZFxcc1xcK1xcLV0vLFxuICAgICAgICAgICAgXCImXCI6IC9bXFxTXS8sXG4gICAgICAgICAgICBcIjBcIjogL1tcXGRdLyxcbiAgICAgICAgICAgIFwiOVwiOiAvW1xcZFxcc10vLFxuICAgICAgICAgICAgXCI/XCI6IC9bYS16QS1aXFxzXS8sXG4gICAgICAgICAgICBcIkFcIjogL1thLXpBLVowLTldLyxcbiAgICAgICAgICAgIFwiQ1wiOiAvLi8sXG4gICAgICAgICAgICBcIkxcIjogL1thLXpBLVpdLyxcbiAgICAgICAgICAgIFwiYVwiOiAvW2EtekEtWjAtOVxcc10vXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNQYXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc2tPbkZvY3VzICYmIHRoaXMuZW1wdHlNYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dCh0aGlzLnNlcnZpY2UubWFza1Jhdyh0aGlzLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5zZXRTZWxlY3Rpb24oMCwgMCk7IH0sIDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLm9uRm9jdXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1c2VkICYmICF0aGlzLmZvY3VzQ2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCB9ID0gdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUJsdXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc2tPbkZvY3VzICYmIHRoaXMuZW1wdHlNYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dCh0aGlzLm1hc2tlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpIHx8IHJlcXVpcmVzWm9uZU9uQmx1cih0aGlzLmNvbnRyb2wpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlKCk7XG4gICAgfVxuICAgIGdldCBob3N0RGlzYWJsZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgdGhlIFJlZ0V4cC1iYXNlZCBtYXNrIHZhbGlkYXRpb24gYXJyYXkgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBtYXNrc19tYXNrZWR0ZXh0Ym94ICV9KSkuXG4gICAgICovXG4gICAgZ2V0IHJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXMgfHwgdGhpcy5kZWZhdWx0UnVsZXM7XG4gICAgfVxuICAgIHNldCBydWxlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ydWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFJ1bGVzLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdGFiSW5kZXgodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy50YWJpbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgXCJ0YWJpbmRleFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmluamVjdG9yLmdldChOZ0NvbnRyb2wsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXNlZCBieSB0aGUgVGV4dEJveENvbnRhaW5lciB0byBkZXRlcm1pbmUgaWYgdGhlIE1hc2tlZFRleHRCb3ggaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAhQm9vbGVhbih0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVEcmFnRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBNYXNrZWRUZXh0Qm94LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cIm1hc2tlZGlucHV0LmZvY3VzKClcIj5Gb2N1cyB0aGUgaW5wdXQ8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLW1hc2tlZHRleHRib3ggI21hc2tlZGlucHV0Pjwva2VuZG8tbWFza2VkdGV4dGJveD5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLnNldEZvY3VzU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBNYXNrZWRUZXh0Qm94LlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwYXN0ZUhhbmRsZXIoZSkge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgfSA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoc2VsZWN0aW9uRW5kID09PSBzZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGlucHV0SGFuZGxlcihlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoIXRoaXMubWFzaykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmlzUGFzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMuaXNQYXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQYXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0UGFydCA9IHRoaXMubWFza2VkVmFsdWUubGVuZ3RoIC0gZW5kO1xuICAgICAgICAgICAgY29uc3QgdG8gPSB2YWx1ZS5sZW5ndGggLSByaWdodFBhcnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNlcnZpY2UubWFza0luUmFuZ2UodmFsdWUuc2xpY2Uoc3RhcnQsIHRvKSwgdGhpcy5tYXNrZWRWYWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNlcnZpY2UubWFza0lucHV0KHZhbHVlLCB0aGlzLm1hc2tlZFZhbHVlLCBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dChyZXN1bHQudmFsdWUsIHJlc3VsdC5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHJlc3VsdC52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5ub3JtYWxpemVWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tYXNrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmV4dHJhY3RDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlcnZpY2UobmV4dCk7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ3ZhbHVlJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hc2tlZFZhbHVlID0gdGhpcy5zZXJ2aWNlLm1hc2tSYXcodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAobWFza2VkVmFsdWUgIT09IHRoaXMubWFza2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KG1hc2tlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbnlDaGFuZ2VkKFsncHJvbXB0UGxhY2Vob2xkZXInLCAnaW5jbHVkZUxpdGVyYWxzJ10sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLm1hc2tlZFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dCh0aGlzLnNlcnZpY2UubWFza1Jhdyh0aGlzLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFdyaXRlcyBhIG5ldyB2YWx1ZSB0byB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dCh0aGlzLnNlcnZpY2UubWFza1Jhdyh0aGlzLnZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBgdG91Y2hgIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShfKSB7XG4gICAgICAgIGlmICh0aGlzLm1hc2tWYWxpZGF0aW9uID09PSBmYWxzZSB8fCAhdGhpcy5tYXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VydmljZS52YWxpZGF0aW9uVmFsdWUodGhpcy5tYXNrZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hc2tlZFZhbHVlLmluZGV4T2YodGhpcy5wcm9tcHQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFzazogdGhpcy5tYXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZTogdGhpcy5tYXNrZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWUobWFza2VkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFzayAmJiAhdGhpcy5zZXJ2aWNlLnZhbGlkYXRpb25WYWx1ZShtYXNrZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNlcnZpY2UucmF3VmFsdWUobWFza2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgdXBkYXRlSW5wdXQobWFza2VkVmFsdWUgPSAnJywgc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubWFza2VkVmFsdWUgPSBtYXNrZWRWYWx1ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm1hc2tPbkZvY3VzICYmICF0aGlzLmZvY3VzZWQgJiYgdGhpcy5lbXB0eU1hc2sgPyAnJyA6IG1hc2tlZFZhbHVlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJhY3RDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNoYW5nZXMpLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAncnVsZXMnKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGNoYW5nZXNba2V5XS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbiAgICB9XG4gICAgdXBkYXRlU2VydmljZShleHRyYSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGluY2x1ZGVMaXRlcmFsczogdGhpcy5pbmNsdWRlTGl0ZXJhbHMsXG4gICAgICAgICAgICBtYXNrOiB0aGlzLm1hc2ssXG4gICAgICAgICAgICBwcm9tcHQ6IHRoaXMucHJvbXB0LFxuICAgICAgICAgICAgcHJvbXB0UGxhY2Vob2xkZXI6IHRoaXMucHJvbXB0UGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBydWxlczogdGhpcy5ydWxlc1xuICAgICAgICB9LCBleHRyYSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbiAgICAgICAgdGhpcy5zZXJ2aWNlLnVwZGF0ZShjb25maWcpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc3RhcnQgPSB0aGlzLnNlbGVjdGlvblswXSwgZW5kID0gdGhpcy5zZWxlY3Rpb25bMV0pIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNlZCkge1xuICAgICAgICAgICAgaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLmlucHV0LCAnc2V0U2VsZWN0aW9uUmFuZ2UnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZW1wdHlNYXNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm1hc2tSYXcoKSA9PT0gdGhpcy5tYXNrZWRWYWx1ZTtcbiAgICB9XG4gICAgc2V0Rm9jdXNTZWxlY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubWFza2VkVmFsdWUgPyB0aGlzLm1hc2tlZFZhbHVlLmluZGV4T2YodGhpcy5wcm9tcHQpIDogMDtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBbaW5kZXgsIGluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgc2V0IGZvY3VzZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkICE9PSB2YWx1ZSAmJiB0aGlzLmhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCBGT0NVU0VEJDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCBGT0NVU0VEJDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub3JtYWxpemVWYWx1ZSh2YWx1ZSA9IHRoaXMudmFsdWUpIHtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IGlzUHJlc2VudCh2YWx1ZSk7XG4gICAgICAgIGlmIChwcmVzZW50ICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIE1hc2tlZFRleHRCb3ggY29tcG9uZW50IHN1cHBvcnRzIG9ubHkgc3RyaW5nIHZhbHVlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVzZW50ID8gdmFsdWUgOiAnJztcbiAgICB9XG59XG5NYXNrZWRUZXh0Qm94Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb01hc2tlZFRleHRCb3gnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBNYXNraW5nU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hc2tlZFRleHRCb3hDb21wb25lbnQpIC8qIHRzbGludDpkaXNhYmxlLWxpbmUgKi9cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWFza2VkVGV4dEJveENvbXBvbmVudCkgLyogdHNsaW50OmRpc2FibGUtbGluZSAqL1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWFza2VkVGV4dEJveENvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1tYXNrZWR0ZXh0Ym94JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgI2lucHV0XG4gICAgICAgICAgICBhdXRvY29tcGxldGU9XCJvZmZcIlxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q9XCJvZmZcIlxuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU9XCJvZmZcIlxuICAgICAgICAgICAgc3BlbGxjaGVjaz1cImZhbHNlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay10ZXh0Ym94XCJcbiAgICAgICAgICAgIFtpZF09XCJmb2N1c2FibGVJZFwiXG4gICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgIGJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICAgICAgICAgICAgY2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgICAgICAgICAgICAgIGRyYWdzdGFydDogaGFuZGxlRHJhZ0Ryb3AsXG4gICAgICAgICAgICAgICAgZHJvcDogaGFuZGxlRHJhZ0Ryb3BcbiAgICAgICAgICAgIH1cIlxuICAgICAgICAvPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWFza2VkVGV4dEJveENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE1hc2tpbmdTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBCb29sZWFuLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1JUTCxdIH1dIH1cbl07XG5NYXNrZWRUZXh0Qm94Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZvY3VzYWJsZUlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRpdGxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXJlY3Rpb246IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH1dLFxuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstbWFza2VkdGV4dGJveCcsXSB9XSxcbiAgICBob3N0RGlzYWJsZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcsXSB9XSxcbiAgICBtYXNrOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcnVsZXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb21wdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcHJvbXB0UGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluY2x1ZGVMaXRlcmFsczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWFza09uRm9jdXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1hc2tWYWxpZGF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWJpbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9uRm9jdXM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydmb2N1cycsXSB9XSxcbiAgICBvbkJsdXI6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydibHVyJyxdIH1dLFxuICAgIHZhbHVlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaW5wdXQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpbnB1dCcsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcbiAgICBwYXN0ZUhhbmRsZXI6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydwYXN0ZScsIFsnJGV2ZW50J10sXSB9XSxcbiAgICBpbnB1dEhhbmRsZXI6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydpbnB1dCcsIFsnJGV2ZW50J10sXSB9XVxufTtcblxuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2xpZGVyVGljayB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB7XG4gICAgICAgICAgICAnay10aWNrJzogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTbGlkZXJUaWNrc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocnRsKSB7XG4gICAgICAgIHRoaXMucnRsID0gcnRsO1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzc2VzID0gJ2stcmVzZXQgay1zbGlkZXItaXRlbXMnO1xuICAgICAgICB0aGlzLnRpY2tzID0gW107XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKF8pIHtcbiAgICAgICAgdGhpcy5jcmVhdGVUaWNrcygpO1xuICAgIH1cbiAgICBjcmVhdGVUaWNrcygpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBjYWxjdWxhdGVUaWNrc0NvdW50KHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5zdGVwKTtcbiAgICAgICAgY29uc3QgbGFyZ2VTdGVwID0gdGhpcy5sYXJnZVN0ZXA7XG4gICAgICAgIGNvbnN0IHRpY2tWYWx1ZVByb3BzID0ge1xuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICBzbWFsbFN0ZXA6IHRoaXMuc3RlcFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFNsaWRlclRpY2soY2FsY3VsYXRlVmFsdWVGcm9tVGljayhpLCB0aWNrVmFsdWVQcm9wcykpKTtcbiAgICAgICAgICAgIGlmIChsYXJnZVN0ZXAgJiYgaSAlIGxhcmdlU3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5sYXJnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLmNsYXNzZXNbJ2stdGljay1sYXJnZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydGwgfHwgdGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0WzBdLmNsYXNzZXMsIHRoaXMuZW5kVGlja0NsYXNzZXModHJ1ZSkpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLmNsYXNzZXMsIHRoaXMuZW5kVGlja0NsYXNzZXMoZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpY2tzID0gcmVzdWx0O1xuICAgIH1cbiAgICBlbmRUaWNrQ2xhc3NlcyhmaXJzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2stZmlyc3QnOiAoZmlyc3QgJiYgIXRoaXMudmVydGljYWwpIHx8ICghZmlyc3QgJiYgdGhpcy52ZXJ0aWNhbCksXG4gICAgICAgICAgICAnay1sYXN0JzogKCFmaXJzdCAmJiAhdGhpcy52ZXJ0aWNhbCkgfHwgKGZpcnN0ICYmIHRoaXMudmVydGljYWwpXG4gICAgICAgIH07XG4gICAgfVxufVxuU2xpZGVyVGlja3NDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1NsaWRlclRpY2tzXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bGkgI3RpY2tFbGVtZW50ICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzO1wiXG4gICAgICAgIFtuZ0NsYXNzXT1cInRpY2suY2xhc3Nlc1wiXG4gICAgICAgIHRpdGxlPVwie3sgdGlja1RpdGxlKHRpY2sudmFsdWUpIH19XCJcbiAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgID5cbiAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cInRpY2subGFyZ2VcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1sYWJlbFwiICpuZ1N3aXRjaENhc2U9XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJsYWJlbFRlbXBsYXRlIHx8IGRlZmF1bHRMYWJlbFwiIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ0aWNrXCI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJmYWxzZVwiPiZuYnNwOzwvbmctY29udGFpbmVyPlxuICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgIDwvbGk+XG5cbiAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0TGFiZWwgbGV0LXZhbHVlPVwidmFsdWVcIj5cbiAgICAgICAge3sgdGlja1RpdGxlKHZhbHVlKSB9fVxuICAgICA8L25nLXRlbXBsYXRlPlxuICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNsaWRlclRpY2tzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQm9vbGVhbiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtSVEwsXSB9XSB9XG5dO1xuU2xpZGVyVGlja3NDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgd3JhcHBlckNsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIHRpY2tUaXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmVydGljYWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0ZXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxhcmdlU3RlcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxhYmVsVGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRpY2tFbGVtZW50czogW3sgdHlwZTogVmlld0NoaWxkcmVuLCBhcmdzOiBbJ3RpY2tFbGVtZW50JyxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2xpZGVyc0NvbW1vbk1vZHVsZSB7XG59XG5TbGlkZXJzQ29tbW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgU2xpZGVyVGlja3NDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIExhYmVsVGVtcGxhdGVEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgU2xpZGVyVGlja3NDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIERyYWdnYWJsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRzTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBSZXNpemVTZW5zb3JNb2R1bGVcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIERyYWdnYWJsZU1vZHVsZSwgRXZlbnRzTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTbGlkZXJNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cblNsaWRlck1lc3NhZ2VzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRlY3JlbWVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW5jcmVtZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkcmFnSGFuZGxlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgU2xpZGVyTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59XG5Mb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBTbGlkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlKSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvU2xpZGVyTG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Mb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzLlxuICovXG5jbGFzcyBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIFNsaWRlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogU2xpZGVyTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTbGlkZXJDdXN0b21NZXNzYWdlc0NvbXBvbmVudCkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXNsaWRlci1tZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSlcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBTbGlkZXIgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIElucHV0cyBtb2R1bGVcbiAqIGltcG9ydCB7IFNsaWRlck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqIGltcG9ydCB7IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBTbGlkZXJNb2R1bGVdLCAvLyBpbXBvcnQgU2xpZGVyIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgU2xpZGVyTW9kdWxlIHtcbn1cblNsaWRlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIFNsaWRlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIExhYmVsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXplZFNsaWRlck1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBTbGlkZXJzQ29tbW9uTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmFuZ2VTbGlkZXJNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cblJhbmdlU2xpZGVyTWVzc2FnZXMucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZHJhZ0hhbmRsZVN0YXJ0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkcmFnSGFuZGxlRW5kOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExvY2FsaXplZFJhbmdlU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBSYW5nZVNsaWRlck1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufVxuTG9jYWxpemVkUmFuZ2VTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBSYW5nZVNsaWRlck1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkUmFuZ2VTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1NsaWRlckxvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTG9jYWxpemVkUmFuZ2VTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzLlxuICovXG5jbGFzcyBSYW5nZVNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgUmFuZ2VTbGlkZXJNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUmFuZ2VTbGlkZXJNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1yYW5nZXNsaWRlci1tZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFJhbmdlU2xpZGVyIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBJbnB1dHMgbW9kdWxlXG4gKiBpbXBvcnQgeyBSYW5nZVNsaWRlck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqIGltcG9ydCB7IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBSYW5nZVNsaWRlck1vZHVsZV0sIC8vIGltcG9ydCBSYW5nZVNsaWRlciBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIFJhbmdlU2xpZGVyTW9kdWxlIHtcbn1cblJhbmdlU2xpZGVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgUmFuZ2VTbGlkZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXplZFJhbmdlU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgUmFuZ2VTbGlkZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXplZFJhbmdlU2xpZGVyTWVzc2FnZXNEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIExhYmVsVGVtcGxhdGVEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFNsaWRlcnNDb21tb25Nb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbk1lc3NhZ2VzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvZmY6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmUgZXh0ZW5kcyBNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn1cbkxvY2FsaXplZFN3aXRjaE1lc3NhZ2VzRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmUpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9Td2l0Y2hMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxvY2FsaXplZFN3aXRjaE1lc3NhZ2VzRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMuXG4gKi9cbmNsYXNzIFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50IGV4dGVuZHMgTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5Td2l0Y2hDdXN0b21NZXNzYWdlc0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50KSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3dpdGNoLW1lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU3dpdGNoQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFN3aXRjaCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgU3dpdGNoIG1vZHVsZVxuICogaW1wb3J0IHsgU3dpdGNoTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW5wdXRzJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgU3dpdGNoTW9kdWxlXSwgLy8gaW1wb3J0IFN3aXRjaCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIFN3aXRjaE1vZHVsZSB7XG59XG5Td2l0Y2hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBTd2l0Y2hDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBTd2l0Y2hDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIFN3aXRjaEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6ZWRTd2l0Y2hNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRXZlbnRzTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMb2NhbGl6ZWROdW1lcmljVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgTnVtZXJpY1RleHRCb3hNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbn1cbkxvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTnVtZXJpY1RleHRCb3hNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZE51bWVyaWNUZXh0Qm94TWVzc2FnZXNEaXJlY3RpdmUpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9OdW1lcmljVGV4dEJveExvY2FsaXplZE1lc3NhZ2VzXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTG9jYWxpemVkTnVtZXJpY1RleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgTnVtZXJpY1RleHRCb3ggY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIE51bWVyaWNUZXh0Qm94IG1vZHVsZVxuICogaW1wb3J0IHsgTnVtZXJpY1RleHRCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBOdW1lcmljVGV4dEJveE1vZHVsZV0sIC8vIGltcG9ydCBOdW1lcmljVGV4dEJveCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIE51bWVyaWNUZXh0Qm94TW9kdWxlIHtcbn1cbk51bWVyaWNUZXh0Qm94TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemVkTnVtZXJpY1RleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgTnVtZXJpY1RleHRCb3hDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE51bWVyaWNUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTnVtZXJpY1RleHRCb3hDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE51bWVyaWNUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnRcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEV2ZW50c01vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgTWFza2VkVGV4dEJveCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgTWFza2VkVGV4dEJveCBtb2R1bGVcbiAqIGltcG9ydCB7IE1hc2tlZFRleHRCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBNYXNrZWRUZXh0Qm94TW9kdWxlXSwgLy8gaW1wb3J0IE1hc2tlZFRleHRCb3ggbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBNYXNrZWRUZXh0Qm94TW9kdWxlIHtcbn1cbk1hc2tlZFRleHRCb3hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hc2tlZFRleHRCb3hDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYXNrZWRUZXh0Qm94Q29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBFdmVudHNNb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhZG9ybm1lbnRzIGluIHRoZSBzdWZmaXggY29udGFpbmVyIChbc2VlIGV4YW1wbGVzXSh7JSBzbHVnIGFkb3JubWVudHNfdGV4dGJveCAlfSN0b2Mtc3VmZml4YWRvcm5tZW50cykpLlxuICogIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLXRleHRib3g+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9UZXh0Qm94U3VmZml4VGVtcGxhdGU+XG4gKiAgICAgICAgPGJ1dHRvbiBrZW5kb0J1dHRvbiBsb29rPVwiY2xlYXJcIiBpY29uPVwiaW1hZ2VcIj48L2J1dHRvbj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby10ZXh0Ym94PlxuICogYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICogYGBgXG4gKi9cbmNsYXNzIFRleHRCb3hTdWZmaXhUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cblRleHRCb3hTdWZmaXhUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVGV4dEJveFN1ZmZpeFRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhZG9ybm1lbnRzIGluIHRoZSBwcmVmaXggY29udGFpbmVyIChbc2VlIGV4YW1wbGVzXSh7JSBzbHVnIGFkb3JubWVudHNfdGV4dGJveCAlfSN0b2MtcHJlZml4YWRvcm5tZW50cykpLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8a2VuZG8tdGV4dGJveD5cbiAqICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RleHRCb3hQcmVmaXhUZW1wbGF0ZT5cbiAqICAgICAgICA8YnV0dG9uIGtlbmRvQnV0dG9uIGxvb2s9XCJjbGVhclwiIGljb249XCJpbWFnZVwiPjwvYnV0dG9uPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLXRleHRib3g+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHt9XG4gKiBgYGBcbiAqL1xuY2xhc3MgVGV4dEJveFByZWZpeFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuVGV4dEJveFByZWZpeFRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UZXh0Qm94UHJlZml4VGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UZXh0Qm94UHJlZml4VGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuY2xhc3MgVGV4dEJveENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIsIGluamVjdG9yLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYHRpdGxlYCBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCBvZiB0aGUgVGV4dEJveC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYHRhYmluZGV4YCBvZiB0aGUgVGV4dEJveC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlcyBhIHZhbHVlIGZvciB0aGUgVGV4dEJveC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB3aG9sZSB2YWx1ZSB3aWxsIGJlIHNlbGVjdGVkIHdoZW4gdGhlIFRleHRCb3ggaXMgY2xpY2tlZC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0T25Gb2N1cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZW4gdGhlIFN1Y2Nlc3MgaWNvbiB3aWxsIGJlIHNob3duIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmFsaWRhdGlvbl90ZXh0Ym94ICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYm9vbGVhbmAmbWRhc2g7VGhlIFN1Y2Nlc3MgaWNvbiBpcyBkaXNwbGF5ZWQsIGlmIHRoZSBjb25kaXRpb24gZ2l2ZW4gYnkgdGhlIGRldmVsb3BlciBpcyBtZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBpbml0aWFsYCZtZGFzaDtUaGUgU3VjY2VzcyBpY29uIHdpbGwgYmUgZGlzcGxheWVkIHdoZW4gdGhlIGNvbXBvbmVudCBzdGF0ZSBpcyBuZWl0aGVyIGBpbnZhbGlkYCBub3IgYHRvdWNoZWRgIG9yIGBkaXJ0eWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dTdWNjZXNzSWNvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZW4gdGhlIEVycm9yIGljb24gd2lsbCBiZSBzaG93biAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHZhbGlkYXRpb25fdGV4dGJveCAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgaW5pdGlhbGAmbWRhc2g7VGhlIEVycm9yIGljb24gd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgY29tcG9uZW50IHN0YXRlIGlzXG4gICAgICAgICAqIGBpbnZhbGlkYCBhbmQgYHRvdWNoZWRgIG9yIGBkaXJ0eWAuXG4gICAgICAgICAqICogYGJvb2xlYW5gJm1kYXNoO1RoZSBFcnJvciBpY29uIGlzIGRpc3BsYXllZCwgaWYgdGhlIGNvbmRpdGlvbiBnaXZlbiBieSB0aGUgZGV2ZWxvcGVyIGlzIG1ldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd0Vycm9ySWNvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgYSBDbGVhciBidXR0b24gd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZCZtZGFzaDtcbiAgICAgICAgICogd2hlbiB0aGUgY29tcG9uZW50IGlzIGJsdXJyZWQgb3IgdGhlIHZhbHVlIGlzIGNsZWFyZWQgdGhyb3VnaCB0aGUgKipDbGVhcioqIGJ1dHRvblxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X3RleHRib3ggJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKiBXaGVuIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50IGlzIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlZCB0byBgbmdNb2RlbGAgb3IgYGZvcm1Db250cm9sYFxuICAgICAgICAgKiB0aHJvdWdoIGl0cyBBUEkgb3IgZm9ybSBiaW5kaW5nLCB0aGUgYHZhbHVlQ2hhbmdlYCBldmVudCBpcyBub3QgdHJpZ2dlcmVkIGJlY2F1c2UgaXRcbiAgICAgICAgICogbWlnaHQgY2F1c2UgYSBtaXgtdXAgd2l0aCB0aGUgYnVpbHQtaW4gYHZhbHVlQ2hhbmdlYCBtZWNoYW5pc21zIG9mIHRoZSBgbmdNb2RlbGAgb3IgYGZvcm1Db250cm9sYCBiaW5kaW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dEZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBgaW5wdXRgIGVsZW1lbnQgZ2V0cyBibHVycmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dEJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgZm9jdXNlcyB0aGUgVGV4dEJveCBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25Gb2N1c2AgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogIDxrZW5kby10ZXh0Ym94IChmb2N1cyk9XCJoYW5kbGVGb2N1cygpXCI+PC9rZW5kby10ZXh0Ym94PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUZvY3VzKCk6IHZvaWQge1xuICAgICAgICAgKiAgICAgIGNvbnNvbGUubG9nKCdDb21wb25lbnQgaXMgaXNGb2N1c2VkJyk7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBUZXh0Qm94IGNvbXBvbmVudCBnZXRzIGJsdXJyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gVG8gd2lyZSB0aGUgZXZlbnQgcHJvZ3JhbW1hdGljYWxseSwgdXNlIHRoZSBgb25CbHVyYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHMtbm8tcnVuXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgPGtlbmRvLXRleHRib3ggKGJsdXIpPVwiaGFuZGxlQmx1cigpXCI+PC9rZW5kby10ZXh0Ym94PlxuICAgICAgICAgKiBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgcHVibGljIGhhbmRsZUJsdXIoKTogdm9pZCB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coJ0NvbXBvbmVudCBpcyBibHVycmVkJyk7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVJbnB1dEZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0T25Gb2N1cyAmJiB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5zZWxlY3RBbGwoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMub25Gb2N1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLmlucHV0Rm9jdXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5IHx8ICh0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgJiYgdGhpcy5jbGVhckJ1dHRvbkNsaWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUlucHV0Qmx1ciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMuaW5wdXRCbHVyKSB8fCByZXF1aXJlc1pvbmVPbkJsdXIodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdUb3VjaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRCbHVyLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBpbmNvbWluZ1ZhbHVlID0gZXYudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShpbmNvbWluZ1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZ0NoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgICAgIHRoaXMubmdUb3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxvY2FsaXphdGlvblNlcnZpY2UucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YWJJbmRleCh0YWJJbmRleCkge1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gdGFiSW5kZXg7XG4gICAgfVxuICAgIGdldCB0YWJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcbiAgICB9XG4gICAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyBmYWxzZSA6IHRoaXMuX2lzRm9jdXNlZDtcbiAgICB9XG4gICAgc2V0IGlzRm9jdXNlZChpc0ZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gaXNGb2N1c2VkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5pbmplY3Rvci5nZXQoTmdDb250cm9sLCBudWxsKTtcbiAgICAgICAgdGhpcy5jaGVja0NsZWFyQnV0dG9uKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IGN1cnNvckluc2lkZVdyYXBwZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRhYmJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9jdXNJbiBhbmQgZm9jdXNPdXQgYXJlIHJlbGF0aXZlIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdmb2N1c291dCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWJiaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RUZXh0Ym94ID0gY2xvc2VzdChhcmdzLnJlbGF0ZWRUYXJnZXQsIChlbGVtZW50KSA9PiBlbGVtZW50ID09PSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3Nlc3RUZXh0Ym94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YWJiaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvckluc2lkZVdyYXBwZXIgJiYgIXRoaXMuY2xlYXJCdXR0b25DbGlja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5yZW5kZXJlci5saXN0ZW4oaG9zdEVsZW1lbnQsICdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnNvckluc2lkZVdyYXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3Vyc29ySW5zaWRlV3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbihob3N0RWxlbWVudCwgJ2tleWRvd24nLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiYmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZGlzYWJsZWQgfHwgY2hhbmdlcy5yZWFkb25seSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NsZWFyQnV0dG9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBUZXh0Qm94LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cImlucHV0LmZvY3VzKClcIj5Gb2N1cyB0aGUgaW5wdXQ8L2J1dHRvbj5cbiAgICAgKiAgPGtlbmRvLXRleHRib3ggI2lucHV0Pjwva2VuZG8tdGV4dGJveD5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2VkUHJvZ3JhbW1hdGljYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgVGV4dEJveC5cbiAgICAgKi9cbiAgICBibHVyKCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc0ZvY3VzZWRFbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJzpmb2N1cycpO1xuICAgICAgICBpZiAoaXNGb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgICAgaXNGb2N1c2VkRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZWRQcm9ncmFtbWF0aWNhbGx5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbGVhclRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmdldCgnY2xlYXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNoZWNrQ2xlYXJCdXR0b24oKSB7XG4gICAgICAgIHRoaXMuc2hvd0NsZWFyQnV0dG9uID1cbiAgICAgICAgICAgICF0aGlzLmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucmVhZG9ubHkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQnV0dG9uICYmXG4gICAgICAgICAgICAgICAgISF0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xlYXJWYWx1ZShldikge1xuICAgICAgICBpZiAoZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbkNsaWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobnVsbCk7XG4gICAgICAgIHRoaXMuY2hlY2tDbGVhckJ1dHRvbigpO1xuICAgICAgICB0aGlzLmNsZWFyQnV0dG9uQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2hlY2tDbGVhckJ1dHRvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5nQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm5nVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXR1cyBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXMgdG8gb3IgZnJvbSBgZGlzYWJsZWRgLlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgdmFsdWUsIGl0IGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGFwcHJvcHJpYXRlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzaG93RXJyb3JzSW5pdGlhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGludmFsaWQsIGRpcnR5LCB0b3VjaGVkIH0gPSB0aGlzLmNvbnRyb2w7XG4gICAgICAgIHJldHVybiBpbnZhbGlkICYmIChkaXJ0eSB8fCB0b3VjaGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNob3dTdWNjZXNzSW5pdGlhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHZhbGlkLCBkaXJ0eSwgdG91Y2hlZCB9ID0gdGhpcy5jb250cm9sO1xuICAgICAgICByZXR1cm4gdmFsaWQgJiYgKGRpcnR5IHx8IHRvdWNoZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN1Y2Nlc3NJY29uQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc0ljb25cbiAgICAgICAgICAgID8gYGstdGV4dC1zdWNjZXNzICR7dGhpcy5zdWNjZXNzSWNvbn1gXG4gICAgICAgICAgICA6IGBrLXRleHQtc3VjY2VzcyBrLWljb24gay1pLWNoZWNrLW91dGxpbmVgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGVycm9ySWNvbkNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9ySWNvblxuICAgICAgICAgICAgPyBgay10ZXh0LWVycm9yICR7dGhpcy5lcnJvckljb259YFxuICAgICAgICAgICAgOiBgay10ZXh0LWVycm9yIGstaWNvbiBrLWktd2FybmluZ2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY2xlYXJCdXR0b25DbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhckJ1dHRvbkljb25cbiAgICAgICAgICAgID8gdGhpcy5jbGVhckJ1dHRvbkljb25cbiAgICAgICAgICAgIDogYGstaWNvbiBrLWktY2xvc2UtY2lyY2xlYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoYXNFcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dFcnJvckljb24gPT09ICdpbml0aWFsJ1xuICAgICAgICAgICAgPyB0aGlzLnNob3dFcnJvcnNJbml0aWFsKClcbiAgICAgICAgICAgIDogdGhpcy5zaG93RXJyb3JJY29uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzU3VjY2Vzc2Z1bCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd1N1Y2Nlc3NJY29uID09PSAnaW5pdGlhbCdcbiAgICAgICAgICAgID8gdGhpcy5zaG93U3VjY2Vzc0luaXRpYWwoKVxuICAgICAgICAgICAgOiB0aGlzLnNob3dTdWNjZXNzSWNvbjtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBpbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuaW5wdXQsICdzZXRTZWxlY3Rpb25SYW5nZScsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEFsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKDAsIHRoaXMudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWFyZVNhbWUodGhpcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDbGVhckJ1dHRvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVCbHVyKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvY3VzQ2hhbmdlZFByb2dyYW1tYXRpY2FsbHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQmx1ci5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5UZXh0Qm94Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RleHRCb3gnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEwxME5fUFJFRklYLCB1c2VWYWx1ZTogJ2tlbmRvLnRleHRib3gnIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEJveENvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEtlbmRvSW5wdXQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRleHRCb3hDb21wb25lbnQpIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGV4dGJveCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb1RleHRCb3hMb2NhbGl6ZWRNZXNzYWdlc1xuICAgICAgICAgICAgaTE4bi1jbGVhcj1cImtlbmRvLnRleHRib3guY2xlYXJ8VGhlIHRpdGxlIGZvciB0aGUgKipDbGVhcioqIGJ1dHRvbiBpbiB0aGUgVGV4dEJveC5cIlxuICAgICAgICAgICAgY2xlYXI9XCJDbGVhclwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWlucHV0LXByZWZpeFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJwcmVmaXhUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwicHJlZml4VGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3M9XCJrLWlucHV0XCJcbiAgICAgICAgICAgICNpbnB1dFxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IHRhYmluZGV4XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAgZm9jdXM6IGhhbmRsZUlucHV0Rm9jdXMsXG4gICAgICAgICAgICAgICAgYmx1cjogaGFuZGxlSW5wdXRCbHVyLFxuICAgICAgICAgICAgICAgIGlucHV0OiBoYW5kbGVJbnB1dH1cIi8+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiay1pbnB1dC1zdWZmaXhcIj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzRXJyb3JzXCIgW25nQ2xhc3NdPVwiZXJyb3JJY29uQ2xhc3Nlc1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaXNTdWNjZXNzZnVsXCIgW25nQ2xhc3NdPVwic3VjY2Vzc0ljb25DbGFzc2VzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImstY2xlYXItdmFsdWVcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2hvd0NsZWFyQnV0dG9uXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2xlYXJWYWx1ZSgpXCJcbiAgICAgICAgICAgICAgICAobW91c2Vkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY2xlYXJUaXRsZSgpXCJcbiAgICAgICAgICAgICAgICBbdGl0bGVdPVwiY2xlYXJUaXRsZSgpXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJjbGVhclZhbHVlKCRldmVudClcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duLnNwYWNlKT1cImNsZWFyVmFsdWUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzcGFuIFtuZ0NsYXNzXT1cImNsZWFyQnV0dG9uQ2xhc3Nlc1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICpuZ0lmPVwic3VmZml4VGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInN1ZmZpeFRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9zcGFuPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVGV4dEJveENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcblRleHRCb3hDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZWFkb25seTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiaW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RPbkZvY3VzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93U3VjY2Vzc0ljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dFcnJvckljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNsZWFyQnV0dG9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdWNjZXNzSWNvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXJyb3JJY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbGVhckJ1dHRvbkljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYkluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBpbnB1dEZvY3VzOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaW5wdXRCbHVyOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgb25Gb2N1czogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2ZvY3VzJyxdIH1dLFxuICAgIG9uQmx1cjogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2JsdXInLF0gfV0sXG4gICAgaW5wdXQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpbnB1dCcsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcbiAgICBzdWZmaXhUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgcHJlZml4VGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW1RleHRCb3hQcmVmaXhUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGRpc2FibGVkQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstc3RhdGUtZGlzYWJsZWQnLF0gfV0sXG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRleHRib3gnLF0gfV0sXG4gICAgaXNGb2N1c2VkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXN0YXRlLWZvY3VzZWQnLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XVxufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBzZXBhcmF0b3IgaW4gdGhlIGNvbnRlbnQgb2YgdGhlIFRleHRCb3ggKFtzZWUgZXhhbXBsZXNdKHslIHNsdWcgYWRvcm5tZW50c190ZXh0Ym94ICV9I3RvYy1zZXBhcmF0b3IpKS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGtlbmRvLXRleHRib3g+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9UZXh0Qm94U3VmZml4VGVtcGxhdGU+XG4gKiAgICAgICAgPGJ1dHRvbiBrZW5kb0J1dHRvbiBsb29rPVwiY2xlYXJcIiBpY29uPVwiaW1hZ2VcIj48L2J1dHRvbj5cbiAqICAgICAgICA8a2VuZG8tdGV4dGJveC1zZXBhcmF0b3I+PC9rZW5kby10ZXh0Ym94LXNlcGFyYXRvcj5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby10ZXh0Ym94PlxuICogYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7fVxuICogYGBgXG4gKi9cbmNsYXNzIFRleHRCb3hTZXBhcmF0b3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxufVxuVGV4dEJveFNlcGFyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdGV4dGJveC1zZXBhcmF0b3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuVGV4dEJveFNlcGFyYXRvckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstdGV4dGJveC1zZXBhcmF0b3InLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUZXh0Qm94TWVzc2FnZXMgZXh0ZW5kcyBDb21wb25lbnRNZXNzYWdlcyB7XG59XG5UZXh0Qm94TWVzc2FnZXMucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2xlYXI6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEN1c3RvbSBjb21wb25lbnQgbWVzc2FnZXMgb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnQgbWVzc2FnZXMuXG4gKi9cbmNsYXNzIFRleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIFRleHRCb3hNZXNzYWdlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblRleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBUZXh0Qm94TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10ZXh0Ym94LW1lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVGV4dEJveEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9jYWxpemVkVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgVGV4dEJveE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxufVxuTG9jYWxpemVkVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFRleHRCb3hNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RleHRCb3hMb2NhbGl6ZWRNZXNzYWdlc10nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgVGV4dEJveCBkaXJlY3RpdmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgVGV4dEJveCBtb2R1bGVcbiAqIGltcG9ydCB7IFRleHRCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBUZXh0Qm94TW9kdWxlXSwgLy8gaW1wb3J0IFRleHRCb3ggbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBUZXh0Qm94TW9kdWxlIHtcbn1cblRleHRCb3hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94RGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBUZXh0QXJlYURpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgVGV4dEJveENvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgVGV4dEJveENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgVGV4dEJveFNlcGFyYXRvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgVGV4dEJveFN1ZmZpeFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94UHJlZml4VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIFRleHRCb3hDdXN0b21NZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemVkVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIFRleHRCb3hEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIFRleHRBcmVhRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94Q29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94U2VwYXJhdG9yQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94U3VmZml4VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIFRleHRCb3hQcmVmaXhUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRzTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRXZlbnRzTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSW4gdGhpcyB3YXksIHRoZSBzb3VyY2UgY29tcG9uZW50IHN1cHByZXNzZXMgdGhlIGJ1aWx0LWluIGJlaGF2aW9yIHRoYXQgZm9sbG93cyB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBhbnkgb2YgaXRzIHN1YnNjcmliZXJzLCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gYHRydWVgIGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkLiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogRmlyZXMgZWFjaCB0aW1lIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIENvbG9yUGlja2VyIHdyYXBwZXIgaXMgY2xpY2tlZC5cbiAqIFRoZSBldmVudCBpcyB0cmlnZ2VyZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGEgQ29sb3JQaWNrZXIgaWNvbiBpcyBzZXQgb3Igbm90LlxuICpcbiAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjb2xvciBhbmQgZ2l2ZXMgdGhlIG9wdGlvbiB0byBwcmV2ZW50IHRoZSBvcGVuaW5nIG9mIHRoZSBwb3B1cC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tY29sb3JwaWNrZXJcbiAqICAgICAgICAgICBbaWNvbl09XCInZWRpdC10b29scydcIlxuICogICAgICAgICAgIFt2YWx1ZV09XCInIzkwMCdcIlxuICogICAgICAgICAgIChhY3RpdmVDb2xvckNsaWNrKT1cImhhbmRsZUFjdGl2ZUNvbG9yQ2xpY2soJGV2ZW50KVwiXG4gKiAgICAgICA+XG4gKiAgICAgICA8L2tlbmRvLWNvbG9ycGlja2VyPlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgaGFuZGxlQWN0aXZlQ29sb3JDbGljayhldmVudDogQWN0aXZlQ29sb3JDbGlja0V2ZW50KTogdm9pZCB7XG4gKiAgICAgICAgIGV2ZW50LnByZXZlbnRPcGVuKCk7XG4gKlxuICogICAgICAgICBjb25zb2xlLmxvZygnT3BlbiBwcmV2ZW50ZWQ6JywgZXZlbnQuaXNPcGVuUHJldmVudGVkKCkpO1xuICogICAgICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBjb2xvcjonLCBldmVudC5jb2xvcik7XG4gKiAgICAgfVxuICogIH1cbiAqIGBgYFxuICovXG5jbGFzcyBBY3RpdmVDb2xvckNsaWNrRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gY29sb3IgUmVwcmVzZW50cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLm9wZW5QcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIG9wZW5pbmcgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHByZXZlbnRPcGVuKCkge1xuICAgICAgICB0aGlzLm9wZW5QcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgb3BlbmluZyBpcyBwcmV2ZW50ZWQgYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZW4gYWN0aW9uIHdhcyBwcmV2ZW50ZWQuIE90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGlzT3BlblByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlblByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJldHVybnMgdGhlIGhleCBvciByZ2JhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3IuXG4gKi9cbmNvbnN0IHBhcnNlQ29sb3IkMSA9ICh2YWx1ZSwgZm9ybWF0LCBzYWZlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGFsbG93ZWRGb3JtYXRzID0gWydoZXgnLCAncmdiYScsICduYW1lJ107XG4gICAgaWYgKGFsbG93ZWRGb3JtYXRzLmluZGV4T2YoZm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb2xvciBvdXRwdXQgZm9ybWF0ICcke2Zvcm1hdH0nLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlICdoZXgnLCAncmdiYScgb3IgJ25hbWUnLmApO1xuICAgIH1cbiAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSAnbmFtZScpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVGb3JtYXQodmFsdWUsIHNhZmUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRDb2xvciA9IHBhcnNlQ29sb3IodmFsdWUudHJpbSgpLCBzYWZlKTtcbiAgICBpZiAoIWlzUHJlc2VudChwYXJzZWRDb2xvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0ID09PSAnaGV4JyA/IHBhcnNlZENvbG9yLnRvQ3NzKCkgOiBwYXJzZWRDb2xvci50b0Nzc1JnYmEoKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXR1cm5zIGFuIEhTViBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yIHN0cmluZy5cbiAqL1xuY29uc3QgZ2V0SFNWID0gKHZhbHVlLCBzYWZlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29sb3IodmFsdWUsIHNhZmUpO1xuICAgIGlmICghaXNQcmVzZW50KHBhcnNlZCkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkLnRvSFNWKCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmV0dXJucyBhbiBSR0JBIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3Igc3RyaW5nLlxuICovXG5jb25zdCBnZXRSR0JBID0gKHZhbHVlLCBzYWZlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29sb3IodmFsdWUsIHNhZmUpO1xuICAgIGlmICghaXNQcmVzZW50KHBhcnNlZCkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkLnRvQnl0ZXMoKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXR1cm5zIHRoZSBSR0JBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3IuXG4gKi9cbmNvbnN0IGdldENvbG9yRnJvbUhTViA9IChoc3ZhKSA9PiB7XG4gICAgY29uc3QgaHVlID0gZml0SW50b0JvdW5kcyhoc3ZhLmgsIDAsIDM1OS45KTtcbiAgICBjb25zdCBzYXR1cmF0aW9uID0gZml0SW50b0JvdW5kcyhoc3ZhLnMsIDAsIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gZml0SW50b0JvdW5kcyhoc3ZhLnYsIDAsIDEpO1xuICAgIGNvbnN0IGFscGhhID0gZml0SW50b0JvdW5kcyhoc3ZhLmEsIDAsIDEpO1xuICAgIHJldHVybiBDb2xvci5mcm9tSFNWKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUsIGFscGhhKS50b0Nzc1JnYmEoKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXR1cm5zIHRoZSBSR0JBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3IgYmFzZWQgb24gdGhlIGBodWVgLCBhc3N1bWluZyB0aGUgYHZhbHVlYCwgYHNhdHVyYXRpb25gIGFuZCBgYWxwaGFgIGhhdmUgdmFsdWUgb2YgYDFgLlxuICovXG5jb25zdCBnZXRDb2xvckZyb21IdWUgPSAoaHVlKSA9PiB7XG4gICAgcmV0dXJuIGdldENvbG9yRnJvbUhTVih7IGg6IGh1ZSwgczogMSwgdjogMSwgYTogMSB9KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBSZXR1cm5zIHRoZSBSR0JBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3IuXG4gKi9cbmNvbnN0IGdldENvbG9yRnJvbVJHQkEgPSAocmdiYSkgPT4ge1xuICAgIGNvbnN0IHJlZCA9IGZpdEludG9Cb3VuZHMocmdiYS5yLCAwLCAyNTUpO1xuICAgIGNvbnN0IGdyZWVuID0gZml0SW50b0JvdW5kcyhyZ2JhLmcsIDAsIDI1NSk7XG4gICAgY29uc3QgYmx1ZSA9IGZpdEludG9Cb3VuZHMocmdiYS5iLCAwLCAyNTUpO1xuICAgIGNvbnN0IGFscGhhID0gZml0SW50b0JvdW5kcyhyZ2JhLmEsIDAsIDEpO1xuICAgIHJldHVybiBDb2xvci5mcm9tQnl0ZXMocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpLnRvQ3NzUmdiYSgpO1xufTtcbi8qKlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbmFtZUZvcm1hdCh2YWx1ZSwgc2FmZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgaWYgKGlzUHJlc2VudChuYW1lZENvbG9yc1t2YWx1ZV0pKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHBhcnNlQ29sb3IodmFsdWUsIHNhZmUpKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VDb2xvcih2YWx1ZSwgc2FmZSkudG9IZXgoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMobmFtZWRDb2xvcnMpLmZpbmQoa2V5ID0+IG5hbWVkQ29sb3JzW2tleV0gPT09IHZhbHVlKTtcbiAgICBpZiAoIWtleSAmJiAhc2FmZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBjb2xvciAke3ZhbHVlfSBpcyBub3Qgc3VwcG9ydGVkIGZvciAnZm9ybWF0PVwibmFtZVwiJyBwcm9wZXJ0eS5UbyBkaXNwbGF5ICR7dmFsdWV9IGNvbG9yLCB0aGUgY29tcG9uZW50ICdmb3JtYXQnIHByb3BlcnR5IHNob3VkIGJlIHNldCB0byAnaGV4JyBvciAncmdiYScgYCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59XG5cbi8vIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aFxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFBBTEVUVEVQUkVTRVRTID0ge1xuICAgIGJhc2ljOiB7XG4gICAgICAgIGNvbG9yczogJzAwMDAwMCw3ZjdmN2YsODgwMDE1LGVkMWMyNCxmZjdmMjcsZmZmMjAwLDIyYjE0YywwMGEyZTgsM2Y0OGNjLGEzNDlhNCxmZmZmZmYsYzNjM2MzLGI5N2E1NyxmZmFlYzksZmZjOTBlLGVmZTRiMCxiNWU2MWQsOTlkOWVhLDcwOTJiZSxjOGJmZTcnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgb2ZmaWNlOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBlNmU2ZTYsIDQzNTU2OSwgNDM3MWM0LCBlZDdlMzIsIGE1YTRhNSwgZmViZjA0LCA1YTliZDUsIDcxYWU0OCwgZjJmMmYzLCA3ZjdmN2YsIGQxY2VjZSwgZDVkZGUzLCBkYWUxZjQsIGZjZTVkNCwgZGVlZGVkLCBmZmYyY2MsIGRlZWFmNiwgZTFlZmQ5LCBkN2Q4ZDgsIDU4NTk1OSwgYWVhYmFiLCBhZGJhY2EsIGI0YzVlNywgZjZjYWFjLCBkYmRiZGIsIGZmZTQ5OCwgYmNkNmVlLCBjNWUwYjIsIGJmYmZjMCwgM2YzZjNmLCA3NjcwNzAsIDg1OTViMSwgOGZhYmRiLCBmNWIxODMsIGM5YzhjOSwgZmVkOTY1LCA5YmM0ZTUsIGE4ZDA4ZCwgYTVhNWE2LCAyNjI2MjUsIDM5MzkzOSwgMzM0MDUwLCAyZTU0OTYsIGM0NWExMSwgN2I3YjdhLCBiZjkwMDAsIDJmNzViNSwgNTQ4MjM1LCA3ZjdmN2YsIDBiMGMwYywgMTYxNjE2LCAyMjJhMzQsIDIwMzc2NCwgODQzZDBiLCA1MjUyNTIsIDdmNjAwMCwgMWQ0ZDc5LCAzNzU2MjMnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgYXBleDoge1xuICAgICAgICBjb2xvcnM6ICdmZmZmZmYsIDAwMDAwMCwgYzljMmQxLCA2OTY3NmQsIGNlYjk2NiwgOWNiMDg0LCA2YmIxYzksIDY1ODVjZiwgN2U2YmM5LCBhMzc5YmIsIGYyZjJmMiwgN2Y3ZjdmLCBmNGYyZjUsIGUwZTBlMiwgZjVmMWUwLCBlYmVmZTYsIGUxZWZmNCwgZTBlNmY1LCBlNWUxZjQsIGVjZTRmMSwgZDhkOGQ4LCA1OTU5NTksIGU5ZTZlYywgYzJjMWM1LCBlYmUzYzEsIGQ3ZGZjZCwgYzNkZmU5LCBjMWNlZWIsIGNiYzNlOSwgZGFjOWUzLCBiZmJmYmYsIDNmM2YzZiwgZGVkYWUzLCBhNGEzYTgsIGUxZDVhMywgYzNjZmI1LCBhNmQwZGUsIGEyYjVlMiwgYjFhNmRlLCBjN2FlZDYsIGE1YTVhNSwgMjYyNjI2LCA5Njg4YTUsIDRlNGQ1MSwgYWU5NjM4LCA3NThjNWEsIDNkOGRhOSwgMzY1YmIwLCA1MzNkYTksIDdkNGQ5OSwgN2Y3ZjdmLCAwYzBjMGMsIDYzNTY3MiwgMzQzMzM2LCA3NDY0MjUsIDRlNWQzYywgMjk1ZTcwLCAyNDNjNzUsIDM3Mjk3MCwgNTMzMzY2JyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9LFxuICAgIGF1c3Rpbjoge1xuICAgICAgICBjb2xvcnM6ICdmZmZmZmYsIDAwMDAwMCwgY2FmMjc4LCAzZTNkMmQsIDk0YzYwMCwgNzE2ODVhLCBmZjY3MDAsIDkwOTQ2NSwgOTU2YjQzLCBmZWEwMjIsIGYyZjJmMiwgN2Y3ZjdmLCBmNGZjZTQsIGRkZGNkMCwgZWZmZmMwLCBlM2UxZGMsIGZmZTBjYiwgZThlOWRmLCBlY2UxZDYsIGZlZWNkMiwgZDhkOGQ4LCA1OTU5NTksIGU5ZjljOSwgYmJiOWExLCBkZmZmODIsIGM4YzNiYSwgZmZjMjk5LCBkMmQ0YzAsIGRhYzNhZCwgZmVkOWE2LCBiZmJmYmYsIDNmM2YzZiwgZGZmN2FlLCBhZGE1OTgsIGNmZmY0MywgYWRhNTk4LCBmZmEzNjUsIGJjYmZhMSwgYzhhNTg1LCBmZWM2N2EsIGE1YTVhNSwgMjYyNjI2LCBhOWVhMjUsIDJlMmQyMSwgNmY5NDAwLCA1NDRlNDMsIGJmNGQwMCwgNmM2ZjRiLCA2ZjUwMzIsIGQ3N2IwMCwgN2Y3ZjdmLCAwYzBjMGMsIDc0YTUwZiwgMWYxZTE2LCA0YTYzMDAsIDM4MzQyZCwgN2YzMzAwLCA0ODRhMzIsIDRhMzUyMSwgOGY1MjAwJyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9LFxuICAgIGNsYXJpdHk6IHtcbiAgICAgICAgY29sb3JzOiAnZmZmZmZmLCAyOTI5MzQsIGYzZjJkYywgZDI1MzNjLCA5M2EyOTksIGFkOGY2NywgNzI2MDU2LCA0YzVhNmEsIDgwOGRhMCwgNzk0NjNkLCBmMmYyZjIsIGU3ZTdlYywgZTdlNWI5LCBmNmRjZDgsIGU5ZWNlYSwgZWVlOGUwLCBlNGRlZGIsIGQ4ZGRlMywgZTVlOGVjLCBlOWQ2ZDMsIGQ4ZDhkOCwgYzRjNGQxLCBkNWQxODUsIGVkYmFiMSwgZDNkOWQ2LCBkZWQyYzIsIGM5YmViOCwgYjJiY2M4LCBjY2QxZDksIGQzYWVhNywgYmZiZmJmLCA4YThhYTMsIGFjYTczYiwgZTQ5NzhhLCBiZWM3YzEsIGNkYmJhMywgYWY5ZTk0LCA4YzliYWMsIGIyYmFjNiwgYmQ4NTdjLCBhNWE1YTUsIDU2NTY2ZSwgNTY1MzFkLCBhNDM5MjUsIDZiN2M3MiwgODY2YjQ4LCA1NTQ4NDAsIDM5NDM0ZiwgNWM2OTdiLCA1YTM0MmQsIDdmN2Y3ZiwgM2IzYjRiLCAyMjIxMGIsIDZkMjYxOSwgNDc1MzRjLCA1OTQ3MzAsIDM5MzAyYiwgMjYyZDM1LCAzZDQ2NTIsIDNjMjMxZScsXG4gICAgICAgIGNvbHVtbnM6IDEwXG4gICAgfSxcbiAgICBzbGlwc3RyZWFtOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBiNGRjZmEsIDIxMjc0NSwgNGU2N2M4LCA1ZWNjZjMsIGE3ZWE1MiwgNWRjZWFmLCBmZjgwMjEsIGYxNDEyNCwgZjJmMmYyLCA3ZjdmN2YsIDhiYzlmNywgYzdjY2U0LCBkYmUwZjQsIGRlZjRmYywgZWRmYWRjLCBkZWY1ZWYsIGZmZTVkMiwgZmNkOWQzLCBkOGQ4ZDgsIDU5NTk1OSwgNGZhY2YzLCA5MDlhY2EsIGI4YzJlOSwgYmVlYWZhLCBkYmY2YjksIGJlZWJkZiwgZmZjY2E2LCBmOWIzYTcsIGJmYmZiZiwgM2YzZjNmLCAwZDc4YzksIDU5NjdhZiwgOTRhM2RlLCA5ZWUwZjcsIGNhZjI5NywgOWRlMWNmLCBmZmIyNzksIGY2OGQ3YiwgYTVhNWE1LCAyNjI2MjYsIDA2M2M2NCwgMTgxZDMzLCAzMTQ3OWYsIDExYjJlYiwgODFkMzE5LCAzNGFjOGIsIGQ4NWMwMCwgYzMyNjBjLCA3ZjdmN2YsIDBjMGMwYywgMDIxODI4LCAxMDEzMjIsIDIwMmY2YSwgMGI3NjljLCA1NjhjMTEsIDIyNzI1YywgOTAzZDAwLCA4MjE5MDgnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgbWV0cm86IHtcbiAgICAgICAgY29sb3JzOiAnZmZmZmZmLCAwMDAwMDAsIGQ2ZWNmZiwgNGU1YjZmLCA3ZmQxM2IsIGVhMTU3YSwgZmViODBhLCAwMGFkZGMsIDczOGFjOCwgMWFiMzlmLCBmMmYyZjIsIDdmN2Y3ZiwgYTdkNmZmLCBkOWRkZTQsIGU1ZjVkNywgZmFkMGU0LCBmZWYwY2QsIGM1ZjJmZiwgZTJlN2Y0LCBjOWY3ZjEsIGQ4ZDhkOCwgNTk1OTU5LCA2MGI1ZmYsIGIzYmNjYSwgY2JlY2IwLCBmNmExYzksIGZlZTI5YywgOGJlNmZmLCBjN2QwZTksIDk0ZWZlMywgYmZiZmJmLCAzZjNmM2YsIDAwN2RlYSwgOGQ5YmFmLCBiMmUzODksIGYyNzJhZiwgZmVkNDZiLCA1MWQ5ZmYsIGFhYjhkZSwgNWZlN2Q1LCBhNWE1YTUsIDI2MjYyNiwgMDAzZTc1LCAzYTQ0NTMsIDVlYTIyNiwgYWYwZjViLCBjNThjMDAsIDAwODFhNSwgNDI1ZWE5LCAxMzg2NzcsIDdmN2Y3ZiwgMGMwYzBjLCAwMDE5MmUsIDI3MmQzNywgM2Y2YzE5LCA3NTBhM2QsIDgzNWQwMCwgMDA1NjZlLCAyYzNmNzEsIDBjNTk0ZicsXG4gICAgICAgIGNvbHVtbnM6IDEwXG4gICAgfSxcbiAgICBmbG93OiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBkYmY1ZjksIDA0NjE3YiwgMGY2ZmM2LCAwMDlkZDksIDBiZDBkOSwgMTBjZjliLCA3Y2NhNjIsIGE1YzI0OSwgZjJmMmYyLCA3ZjdmN2YsIGIyZTlmMiwgYjRlY2ZjLCBjN2UyZmEsIGM0ZWVmZiwgYzlmYWZjLCBjOWZhZWQsIGU0ZjRkZiwgZWRmMmRhLCBkOGQ4ZDgsIDU5NTk1OSwgNzZkOWU4LCA2YWRhZmEsIDkwYzZmNiwgODlkZWZmLCA5M2Y1ZjksIDk0ZjZkYiwgY2FlOWMwLCBkYmU2YjYsIGJmYmZiZiwgM2YzZjNmLCAyMWIyYzgsIDIwYzhmNywgNTlhOWYyLCA0ZmNlZmYsIDVkZjBmNiwgNWZmMmNhLCBiMGRmYTAsIGM5ZGE5MSwgYTVhNWE1LCAyNjI2MjYsIDEwNTk2NCwgMDI0ODVjLCAwYjUzOTQsIDAwNzVhMiwgMDg5Y2EyLCAwYjliNzQsIDU0YTgzOCwgN2U5NTMyLCA3ZjdmN2YsIDBjMGMwYywgMDYyMzI4LCAwMTMwM2QsIDA3Mzc2MywgMDA0ZTZjLCAwNTY4NmMsIDA3Njc0ZCwgMzg3MDI1LCA1NDYzMjEnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgaGFyZGNvdmVyOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBlY2U5YzYsIDg5NWQxZCwgODczNjI0LCBkNjg2MmQsIGQwYmU0MCwgODc3ZjZjLCA5NzIxMDksIGFlYjc5NSwgZjJmMmYyLCA3ZjdmN2YsIGUxZGNhNSwgZjJlMGM2LCBmMGQwYzksIGY2ZTZkNSwgZjVmMmQ4LCBlN2U1ZTEsIGZiYzdiYywgZWVmMGU5LCBkOGQ4ZDgsIDU5NTk1OSwgZDBjOTc0LCBlNmMyOGQsIGUyYTI5MywgZWVjZWFhLCBlY2U1YjIsIGNmY2NjMywgZjc4ZjdhLCBkZWUyZDQsIGJmYmZiZiwgM2YzZjNmLCBhMjlhMzYsIGRhYTQ1NCwgZDQ3MzVlLCBlNmI2ODEsIGUyZDg4YywgYjdiMmE1LCBmMzU4MzgsIGNlZDNiZiwgYTVhNWE1LCAyNjI2MjYsIDUxNGQxYiwgNjY0NTE1LCA2NTI4MWEsIGEyNjQxZiwgYTM5NDI4LCA2NTVmNTAsIDcxMTgwNiwgODc5NDY0LCA3ZjdmN2YsIDBjMGMwYywgMjAxZTBhLCA0NDJlMGUsIDQzMWIxMSwgNmM0MzE1LCA2ZDYyMWEsIDQzM2YzNSwgNGIxMDA0LCA1YTYyNDMnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgdHJlazoge1xuICAgICAgICBjb2xvcnM6ICdmZmZmZmYsIDAwMDAwMCwgZmJlZWM5LCA0ZTNiMzAsIGYwYTIyZSwgYTU2NDRlLCBiNThiODAsIGMzOTg2ZCwgYTE5NTc0LCBjMTc1MjksIGYyZjJmMiwgN2Y3ZjdmLCBmN2UwOWUsIGUxZDZjZiwgZmNlY2Q1LCBlZGRmZGEsIGYwZTdlNSwgZjNlYWUxLCBlY2U5ZTMsIGY1ZTNkMSwgZDhkOGQ4LCA1OTU5NTksIGYzY2M1ZiwgYzRhZDlmLCBmOWQ5YWIsIGRjYzBiNiwgZTFkMGNjLCBlN2Q1YzQsIGQ5ZDRjNywgZWJjN2EzLCBiZmJmYmYsIDNmM2YzZiwgZDI5ZjBmLCBhNzg0NzAsIGY2Yzc4MSwgY2JhMDkyLCBkMmI5YjIsIGRiYzFhNywgYzZiZmFiLCBlMWFjNzYsIGE1YTVhNSwgMjYyNjI2LCA2OTRmMDcsIDNhMmMyNCwgYzg3ZDBlLCA3YjRiM2EsIDkyNjI1NSwgYTE3MjQyLCA3YjcxNTMsIDkwNTcxZSwgN2Y3ZjdmLCAwYzBjMGMsIDJhMWYwMywgMjcxZDE4LCA4NTUzMDksIDUyMzIyNiwgNjE0MTM4LCA2YjRjMmMsIDUyNGIzNywgNjAzYTE0JyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9LFxuICAgIHZlcnZlOiB7XG4gICAgICAgIGNvbG9yczogJ2ZmZmZmZiwgMDAwMDAwLCBkMmQyZDIsIDY2NjY2NiwgZmYzODhjLCBlNDAwNTksIDljMDA3ZiwgNjgwMDdmLCAwMDViZDMsIDAwMzQ5ZSwgZjJmMmYyLCA3ZjdmN2YsIGJkYmRiZCwgZTBlMGUwLCBmZmQ3ZTgsIGZmYzZkYywgZmZiOGYxLCBmMWIyZmYsIGMzZGNmZiwgYjhjZmZmLCBkOGQ4ZDgsIDU5NTk1OSwgOWQ5ZDlkLCBjMWMxYzEsIGZmYWZkMSwgZmY4ZWJhLCBmZjcxZTQsIGUzNjVmZiwgODdiYWZmLCA3MmEwZmYsIGJmYmZiZiwgM2YzZjNmLCA2OTY5NjksIGEzYTNhMywgZmY4N2JhLCBmZjU1OTcsIGZmMmFkNywgZDUxOWZmLCA0Yjk4ZmYsIDJiNzFmZiwgYTVhNWE1LCAyNjI2MjYsIDM0MzQzNCwgNGM0YzRjLCBlOTAwNjIsIGFiMDA0MiwgNzUwMDVmLCA0ZTAwNWYsIDAwNDQ5ZSwgMDAyNjc2LCA3ZjdmN2YsIDBjMGMwYywgMTUxNTE1LCAzMzMzMzMsIDliMDA0MSwgNzIwMDJjLCA0ZTAwM2YsIDM0MDAzZiwgMDAyZDY5LCAwMDE5NGYnLFxuICAgICAgICBjb2x1bW5zOiAxMFxuICAgIH0sXG4gICAgbW9ub2Nocm9tZToge1xuICAgICAgICBjb2xvcnM6ICcwMDAwMDAsIDFhMWExYSwgMzMzMzMzLCA0ZDRkNGQsIDY2NjY2NiwgODA4MDgwLCA5OTk5OTksIGIzYjNiMywgY2NjY2NjLCBlNmU2ZTYsIGYyZjJmMiwgZmZmZmZmJyxcbiAgICAgICAgY29sdW1uczogMTJcbiAgICB9LFxuICAgIGFjY2Vzc2libGU6IHtcbiAgICAgICAgY29sb3JzOiAnYmxhY2ssIGdyZXksIGRhcmtyZWQsIHJlZCwgZGFya29yYW5nZSwgZ29sZCwgZ3JlZW4sIGJsdWUsIGRhcmtibHVlLCBwdXJwbGUsIHdoaXRlLCBkYXJrZ3JleSwgc2FkZGxlYnJvd24sIHBpbmssIG9yYW5nZSwgeWVsbG93LCBsaWdodGdyZWVuLCBsaWdodHNreWJsdWUsIGxpZ2h0Ymx1ZSwgbWVkaXVtcHVycGxlJyxcbiAgICAgICAgY29sdW1uczogMTBcbiAgICB9XG59O1xuXG5jb25zdCBERUZBVUxUX1BSRVNFVCA9ICdvZmZpY2UnO1xuY29uc3QgREVGQVVMVF9BQ0NFU1NJQkxFX1BSRVNFVCA9ICdhY2Nlc3NpYmxlJztcbmxldCBzZXJpYWwgPSAwO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgQ29sb3JQaWNrZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2NvbG9ycGlja2VyICV9KS5cbiAqIERlc2lnbmVkIHRvIHJlcGxhY2UgdGhlIGA8aW5wdXQgdHlwZT1cImNvbG9yXCI+YCBIVE1MNSB0YWcgd2hpY2ggaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgaW4gYnJvd3NlcnMuXG4gKi9cbmNsYXNzIENvbG9yUGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNhYmxlSWQgPSBgay1jb2xvcnBpY2tlci0ke3NlcmlhbCsrfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHdoYXQgdmlldyB0aGUgQ29sb3JQaWNrZXIgd2lsbCByZW5kZXIgaW4gdGhlIHBvcHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gJ2dyYWRpZW50JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHJlYWQtb25seSBzdGF0ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG91dHB1dCBmb3JtYXQgb2YgdGhlIENvbG9yUGlja2VyLlxuICAgICAgICAgKiBUaGUgaW5wdXQgdmFsdWUgbWF5IGJlIGluIGEgZGlmZmVyZW50IGZvcm1hdC4gSG93ZXZlciwgaXQgd2lsbCBiZSBwYXJzZWQgaW50byB0aGUgb3V0cHV0IGBmb3JtYXRgXG4gICAgICAgICAqIGFmdGVyIHRoZSBjb21wb25lbnQgcHJvY2Vzc2VzIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgYGdyYWRpZW50YCB2aWV3IGlzIHVzZWQgd2l0aCB0aGUgYG9wYWNpdHlgIG9wdGlvbiBzZXQgdG8gdHJ1ZSwgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZCBhbmQgYHJnYmFgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc3VwcG9ydGVkIHZhbHVlcyBhcmU6XG4gICAgICAgICAqICogYHJnYmFgIChkZWZhdWx0KVxuICAgICAgICAgKiAqIGBoZXhgXG4gICAgICAgICAqICogW2BuYW1lYF0oaHR0cHM6Ly93d3cudzMub3JnL3dpa2kvQ1NTL1Byb3BlcnRpZXMvY29sb3Iva2V5d29yZHMpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdCA9ICdyZ2JhJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuIElmIHlvdSBjYW5jZWwgaXQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGFib3V0IHRvIGNsb3NlLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIGl0LCB0aGUgcG9wdXAgd2lsbCByZW1haW4gb3Blbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgQ29sb3JQaWNrZXIgaXMgZm9jdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgQ29sb3JQaWNrZXIgaXMgYmx1cnJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIENvbG9yUGlja2VyIHdyYXBwZXIgaXMgY2xpY2tlZC5cbiAgICAgICAgICogVGhlIGV2ZW50IGlzIHRyaWdnZXJlZCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgYSBDb2xvclBpY2tlciBpY29uIGlzIHNldCBvciBub3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBbYEFjdGl2ZUNvbG9yQ2xpY2tFdmVudGBdKHslIHNsdWcgYXBpX2lucHV0c19hY3RpdmVjb2xvcmNsaWNrZXZlbnQgJX0pIGV2ZW50IHByb3ZpZGVzIHRoZSBvcHRpb24gdG8gcHJldmVudCB0aGUgcG9wdXAgb3BlbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlQ29sb3JDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9wb3B1cFNldHRpbmdzID0geyBhbmltYXRlOiB0cnVlIH07XG4gICAgICAgIHRoaXMuX3BhbGV0dGVTZXR0aW5ncyA9IHt9O1xuICAgICAgICB0aGlzLl9ncmFkaWVudFNldHRpbmdzID0geyBvcGFjaXR5OiB0cnVlLCBjbGVhckJ1dHRvbjogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIG9mIHRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgY29sb3IuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcGFyc2VDb2xvciQxKHZhbHVlLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3B1cCBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgc2V0IHBvcHVwU2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcG9wdXBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24odGhpcy5fcG9wdXBTZXR0aW5ncywgdmFsdWUpO1xuICAgIH1cbiAgICBnZXQgcG9wdXBTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwU2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHBhbGV0dGUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIENvbG9yUGlja2VyIHBvcHVwLlxuICAgICAqL1xuICAgIHNldCBwYWxldHRlU2V0dGluZ3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZVNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih0aGlzLl9wYWxldHRlU2V0dGluZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHBhbGV0dGVTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhbGV0dGVTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgZ3JhZGllbnQgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIENvbG9yUGlja2VyIHBvcHVwLlxuICAgICAqL1xuICAgIHNldCBncmFkaWVudFNldHRpbmdzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2dyYWRpZW50U2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHRoaXMuX2dyYWRpZW50U2V0dGluZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGdyYWRpZW50U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFkaWVudFNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIFtgdGFiaW5kZXhgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4KSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNldCB0YWJpbmRleCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0YWJpbmRleCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX3RhYmluZGV4ID0gIWlzTmFOKHRhYmluZGV4KSA/IHRhYmluZGV4IDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBnZXQgdGFiaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCA/IHRoaXMuX3RhYmluZGV4IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgQ29sb3JQaWNrZXIgcG9wdXAgaXMgb3Blbi5cbiAgICAgKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMucG9wdXBSZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGljb25TdHlsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWNvbkNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmljb24pIHtcbiAgICAgICAgICAgIHJldHVybiBgay1pY29uIGstaS0ke3RoaXMuaWNvbn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJlc2V0ID0gKHRoaXMuZm9ybWF0ICE9PSAnbmFtZScpID8gREVGQVVMVF9QUkVTRVQgOiBERUZBVUxUX0FDQ0VTU0lCTEVfUFJFU0VUO1xuICAgICAgICBjb25zdCBzZXR0aW5nc1BhbGV0dGUgPSB0aGlzLl9wYWxldHRlU2V0dGluZ3MucGFsZXR0ZTtcbiAgICAgICAgY29uc3QgcHJlc2V0Q29sdW1ucyA9IHR5cGVvZiBzZXR0aW5nc1BhbGV0dGUgPT09ICdzdHJpbmcnICYmIFBBTEVUVEVQUkVTRVRTW3NldHRpbmdzUGFsZXR0ZV0gP1xuICAgICAgICAgICAgUEFMRVRURVBSRVNFVFNbc2V0dGluZ3NQYWxldHRlXS5jb2x1bW5zIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcGFsZXR0ZVNldHRpbmdzID0ge1xuICAgICAgICAgICAgcGFsZXR0ZTogc2V0dGluZ3NQYWxldHRlIHx8IGRlZmF1bHRQcmVzZXQsXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy5fcGFsZXR0ZVNldHRpbmdzLnRpbGVTaXplIHx8IDI0LFxuICAgICAgICAgICAgY29sdW1uczogdGhpcy5fcGFsZXR0ZVNldHRpbmdzLmNvbHVtbnMgfHwgcHJlc2V0Q29sdW1ucyB8fCAxMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmZvcm1hdCAmJiBjaGFuZ2VzLmZvcm1hdC5jdXJyZW50VmFsdWUgPT09ICduYW1lJykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gJ3BhbGV0dGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXcgPT09ICdncmFkaWVudCcgJiYgdGhpcy5ncmFkaWVudFNldHRpbmdzLm9wYWNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gJ3JnYmEnO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlQ29sb3IkMSh0aGlzLnZhbHVlLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlckNsaWNrKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVdpdGhFdmVudHMoIXRoaXMuaXNPcGVuKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWN0aXZlQ29sb3JDbGljaygpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBBY3RpdmVDb2xvckNsaWNrRXZlbnQodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29sb3JDbGljay5lbWl0KGV2ZW50KTtcbiAgICAgICAgaWYgKCFldmVudC5pc09wZW5QcmV2ZW50ZWQoKSB8fCB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVXcmFwcGVyQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSB3cmFwcGVyIG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlckZvY3VzKCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFsZXR0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFsZXR0ZS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgYmx1cigpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlckJsdXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25CbHVyLmVtaXQoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjb2xvciB2YWx1ZSBvZiB0aGUgQ29sb3JQaWNrZXIuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHBvcHVwIG9mIHRoZSBDb2xvclBpY2tlci5cbiAgICAgKiBEb2VzIG5vdCB0cmlnZ2VyIHRoZSBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3BlbiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIuIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3B1cCB3aWxsIGJlIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICovXG4gICAgdG9nZ2xlKG9wZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICBvcGVuID0gaXNQcmVzZW50KG9wZW4pID8gb3BlbiA6ICF0aGlzLmlzT3BlbjtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcHVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVZhbHVlQ2hhbmdlKGNvbG9yLCBjbG9zZVBvcHVwKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZENvbG9yID0gcGFyc2VDb2xvciQxKGNvbG9yLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IHZhbHVlQ2hhbmdlID0gcGFyc2VkQ29sb3IgIT09IHRoaXMudmFsdWU7XG4gICAgICAgIGlmIChjbG9zZVBvcHVwKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVdpdGhFdmVudHMoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlZENvbG9yO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHBhcnNlZENvbG9yKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkKHBhcnNlZENvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlUG9wdXBCbHVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGZvY3VzSW5Qb3B1cEVsZW1lbnQgPSB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgd3JhcHBlckNsaWNrZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCB8fCB3cmFwcGVyQ2xpY2tlZCB8fCBmb2N1c0luUG9wdXBFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICB0aGlzLm5vdGlmeU5nVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLnRvZ2dsZVdpdGhFdmVudHMoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm5vdGlmeU5nVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlV3JhcHBlcktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVdpdGhFdmVudHModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZVBvcHVwS2V5RG93bihrZXlDb2RlKSB7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLlRhYiB8fCBrZXlDb2RlID09PSBLZXlzLkVzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVXaXRoRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b2dnbGVXaXRoRXZlbnRzKG9wZW4pIHtcbiAgICAgICAgY29uc3Qgc2FtZVN0YXRlID0gdGhpcy5pc09wZW4gPT09IG9wZW47XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkgfHwgc2FtZVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gbmV3IFByZXZlbnRhYmxlRXZlbnQoKTtcbiAgICAgICAgb3BlbiA/IHRoaXMub3Blbi5lbWl0KGV2ZW50QXJncykgOiB0aGlzLmNsb3NlLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKCFldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKG9wZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Qb3B1cCgpIHtcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbEFsaWduID0gdGhpcy5kaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICAgICAgY29uc3QgYW5jaG9yUG9zaXRpb24gPSB7IGhvcml6b250YWw6IGhvcml6b250YWxBbGlnbiwgdmVydGljYWw6IFwiYm90dG9tXCIgfTtcbiAgICAgICAgY29uc3QgcG9wdXBQb3NpdGlvbiA9IHsgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbDogXCJ0b3BcIiB9O1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMud3JhcHBlcixcbiAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMucG9wdXBTZXR0aW5ncy5hbmltYXRlLFxuICAgICAgICAgICAgYXBwZW5kVG86IHRoaXMucG9wdXBTZXR0aW5ncy5hcHBlbmRUbyxcbiAgICAgICAgICAgIHBvcHVwQWxpZ246IHBvcHVwUG9zaXRpb24sXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogYW5jaG9yUG9zaXRpb24sXG4gICAgICAgICAgICBwb3B1cENsYXNzOiAnay1jb2xvcnBpY2tlci1wb3B1cCcsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLnBvcHVwVGVtcGxhdGUsXG4gICAgICAgICAgICBwb3NpdGlvbk1vZGU6ICdhYnNvbHV0ZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXBBbmNob3JWaWV3cG9ydExlYXZlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVdpdGhFdmVudHMoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50LmZvY3VzKHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VQb3B1cCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMucGFsZXR0ZSA9IG51bGw7XG4gICAgfVxufVxuQ29sb3JQaWNrZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNvbG9ycGlja2VyJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sb3JQaWNrZXJDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2xvclBpY2tlckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmNvbG9ycGlja2VyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhblxuICAgICAgICAgICAgI3dyYXBwZXJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAnay1waWNrZXItd3JhcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stc3RhdGUtZGlzYWJsZWQnOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgICdrLXN0YXRlLWZvY3VzZWQnOiB0aGlzLmlzRm9jdXNlZFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICByb2xlPVwibGlzdGJveFwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImlzT3BlblwiXG4gICAgICAgICAgICBbaWRdPVwiZm9jdXNhYmxlSWRcIlxuICAgICAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICAgICAgKGZvY3VzKT1cImhhbmRsZVdyYXBwZXJGb2N1cygpXCJcbiAgICAgICAgICAgIChibHVyKT1cImhhbmRsZVdyYXBwZXJCbHVyKClcIlxuICAgICAgICAgICAgKG1vdXNlZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAoa2V5ZG93bik9XCJoYW5kbGVXcmFwcGVyS2V5RG93bigkZXZlbnQpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCIhaWNvblN0eWxlc1wiIGNsYXNzPVwiay1zZWxlY3RlZC1jb2xvclwiIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cInZhbHVlXCIgKGNsaWNrKT1cImhhbmRsZUFjdGl2ZUNvbG9yQ2xpY2soKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1saW5lXCIgKm5nSWY9XCIhdmFsdWVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cImljb25TdHlsZXNcIiBjbGFzcz1cImstdG9vbC1pY29uXCIgW25nQ2xhc3NdPVwiaWNvblN0eWxlc1wiIChjbGljayk9XCJoYW5kbGVBY3RpdmVDb2xvckNsaWNrKClcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstc2VsZWN0ZWQtY29sb3JcIiBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XCJ2YWx1ZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1zZWxlY3RcIiAoY2xpY2spPVwiaGFuZGxlV3JhcHBlckNsaWNrKClcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWktYXJyb3ctc1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8bmctdGVtcGxhdGUgI3BvcHVwVGVtcGxhdGU+XG4gICAgICAgICAgICA8a2VuZG8tY29sb3JncmFkaWVudFxuICAgICAgICAgICAgICAgICpuZ0lmPVwidmlldyA9PT0gJ2dyYWRpZW50JyB8fCB2aWV3ID09PSAnY29tYm8nXCJcbiAgICAgICAgICAgICAgICBrZW5kb0ZvY3VzT25Eb21SZWFkeVxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFtvcGFjaXR5XT1cImdyYWRpZW50U2V0dGluZ3Mub3BhY2l0eVwiXG4gICAgICAgICAgICAgICAgW2NsZWFyQnV0dG9uXT1cImdyYWRpZW50U2V0dGluZ3MuY2xlYXJCdXR0b25cIlxuICAgICAgICAgICAgICAgIChmb2N1c291dCk9XCJoYW5kbGVQb3B1cEJsdXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudCwgZmFsc2UpXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bik9XCJoYW5kbGVQb3B1cEtleURvd24oJGV2ZW50LmtleUNvZGUpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tY29sb3JncmFkaWVudD5cbiAgICAgICAgICAgIDxrZW5kby1jb2xvcnBhbGV0dGVcbiAgICAgICAgICAgICAgICAjcGFsZXR0ZVxuICAgICAgICAgICAgICAgICpuZ0lmPVwidmlldyA9PT0gJ3BhbGV0dGUnIHx8IHZpZXcgPT09ICdjb21ibydcIlxuICAgICAgICAgICAgICAgIGtlbmRvRm9jdXNPbkRvbVJlYWR5XG4gICAgICAgICAgICAgICAgW3BhbGV0dGVdPVwicGFsZXR0ZVNldHRpbmdzLnBhbGV0dGVcIlxuICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cInBhbGV0dGVTZXR0aW5ncy5jb2x1bW5zXCJcbiAgICAgICAgICAgICAgICBbdGlsZVNpemVdPVwicGFsZXR0ZVNldHRpbmdzLnRpbGVTaXplXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICAoYmx1cik9XCJoYW5kbGVQb3B1cEJsdXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgKGNlbGxTZWxlY3Rpb24pPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50LCB0cnVlKVwiXG4gICAgICAgICAgICAgICAgKG1vdXNlZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgKGtleWRvd24pPVwiaGFuZGxlUG9wdXBLZXlEb3duKCRldmVudC5rZXlDb2RlKVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2tlbmRvLWNvbG9ycGFsZXR0ZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjY29udGFpbmVyPjwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sb3JQaWNrZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBQb3B1cFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcbkNvbG9yUGlja2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXdpZGdldCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY29sb3JwaWNrZXInLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBmb2N1c2FibGVJZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmlldzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3B1cFNldHRpbmdzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWxldHRlU2V0dGluZ3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGdyYWRpZW50U2V0dGluZ3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb25DbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiaW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgb3BlbjogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNsb3NlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgb25Gb2N1czogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2ZvY3VzJyxdIH1dLFxuICAgIG9uQmx1cjogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2JsdXInLF0gfV0sXG4gICAgYWN0aXZlQ29sb3JDbGljazogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRhaW5lcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2NvbnRhaW5lcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9LF0gfV0sXG4gICAgd3JhcHBlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3dyYXBwZXInLF0gfV0sXG4gICAgcG9wdXBUZW1wbGF0ZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3BvcHVwVGVtcGxhdGUnLF0gfV0sXG4gICAgcGFsZXR0ZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3BhbGV0dGUnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sb3JQYWxldHRlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3JSb3dzID0gW107XG4gICAgfVxuICAgIHNldENvbG9yTWF0cml4KHBhbGV0dGUsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jb2xvclJvd3MgPSBbXTtcbiAgICAgICAgaWYgKCEoaXNQcmVzZW50KHBhbGV0dGUpICYmIHBhbGV0dGUubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zIHx8IHBhbGV0dGUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBzdGFydCA9IDA7IHN0YXJ0IDwgcGFsZXR0ZS5sZW5ndGg7IHN0YXJ0ICs9IGNvbHVtbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHBhbGV0dGUuc2xpY2Uoc3RhcnQsIGNvbHVtbnMgKyBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yUm93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2VsbENvb3Jkc0Zvcihjb2xvcikge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChjb2xvcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLmNvbG9yUm93cy5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbG9yUm93c1tyb3ddLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvclJvd3Nbcm93XVtjb2xdID09PSBjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByb3csIGNvbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb2xvckF0KGNlbGxDb29yZHMpIHtcbiAgICAgICAgaWYgKCEoaXNQcmVzZW50KGNlbGxDb29yZHMpICYmIGlzUHJlc2VudCh0aGlzLmNvbG9yUm93c1tjZWxsQ29vcmRzLnJvd10pKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yUm93c1tjZWxsQ29vcmRzLnJvd11bY2VsbENvb3Jkcy5jb2xdO1xuICAgIH1cbiAgICBnZXROZXh0Q2VsbChjdXJyZW50LCBob3Jpem9udGFsU3RlcCwgdmVydGljYWxTdGVwKSB7XG4gICAgICAgIGlmICghKGlzUHJlc2VudChjdXJyZW50KSAmJiBpc1ByZXNlbnQoY3VycmVudC5yb3cpICYmIGlzUHJlc2VudChjdXJyZW50LmNvbCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByb3c6IDAsIGNvbDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuY2xhbXBJbmRleChjdXJyZW50LnJvdyArIHZlcnRpY2FsU3RlcCwgdGhpcy5jb2xvclJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY2xhbXBJbmRleChjdXJyZW50LmNvbCArIGhvcml6b250YWxTdGVwLCB0aGlzLmNvbG9yUm93c1tyb3ddLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4geyByb3csIGNvbCB9O1xuICAgIH1cbiAgICBjbGFtcEluZGV4KGluZGV4LCBtYXgpIHtcbiAgICAgICAgY29uc3QgbWluQXJyYXlJbmRleCA9IDA7XG4gICAgICAgIGlmIChpbmRleCA8IG1pbkFycmF5SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW5BcnJheUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuQ29sb3JQYWxldHRlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuY29uc3QgREVGQVVMVF9USUxFX1NJWkUgPSAyNDtcbmNvbnN0IERFRkFVTFRfQ09MVU1OU19DT1VOVCA9IDEwO1xuY29uc3QgREVGQVVMVF9QUkVTRVQkMSA9ICdvZmZpY2UnO1xuY29uc3QgREVGQVVMVF9BQ0NFU1NJQkxFX1BSRVNFVCQxID0gJ2FjY2Vzc2libGUnO1xubGV0IHNlcmlhbCQxID0gMDtcbi8qKlxuICogVGhlIENvbG9yUGFsZXR0ZSBjb21wb25lbnQgcHJvdmlkZXMgYSBzZXQgb2YgcHJlZGVmaW5lZCBwYWxldHRlIHByZXNldHMgYW5kIGVuYWJsZXMgeW91IHRvIGltcGxlbWVudCBhIGN1c3RvbSBjb2xvciBwYWxldHRlLlxuICogVGhlIENvbG9yUGFsZXR0ZSBpcyBpbmRlcGVuZGVudGx5IHVzZWQgYnkgYGtlbmRvLWNvbG9ycGlja2VyYCBhbmQgY2FuIGJlIGRpcmVjdGx5IGFkZGVkIHRvIHRoZSBwYWdlLlxuICovXG5jbGFzcyBDb2xvclBhbGV0dGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgay1jb2xvcnBhbGV0dGUtJHtzZXJpYWwkMSsrfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG91dHB1dCBmb3JtYXQgb2YgdGhlIENvbG9yUGFsZXR0ZUNvbXBvbmVudC5cbiAgICAgICAgICogVGhlIGlucHV0IHZhbHVlIG1heSBiZSBpbiBhIGRpZmZlcmVudCBmb3JtYXQuIEhvd2V2ZXIsIGl0IHdpbGwgYmUgcGFyc2VkIGludG8gdGhlIG91dHB1dCBgZm9ybWF0YFxuICAgICAgICAgKiBhZnRlciB0aGUgY29tcG9uZW50IHByb2Nlc3NlcyBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN1cHBvcnRlZCB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgaGV4YFxuICAgICAgICAgKiAqIGByZ2JhYFxuICAgICAgICAgKiAqIGBuYW1lYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSAnaGV4JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgc2l6ZSBvZiBhIGNvbG9yIGNlbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgdGlsZVNpemUgPSAyNGBcbiAgICAgICAgICogKiBgeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9YFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IHsgd2lkdGg6IERFRkFVTFRfVElMRV9TSVpFLCBoZWlnaHQ6IERFRkFVTFRfVElMRV9TSVpFIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIGNvbG9yIHNlbGVjdGlvbiBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBjZWxsIHdpdGggdGhlIG1vdXNlIG9yIHByZXNzZXMgYEVudGVyYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RhYmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24gPSBsb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBhbGV0dGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIGluaXRpYWxseSBzZWxlY3RlZCBjb2xvci5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBwYXJzZUNvbG9yJDEodmFsdWUsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgKiBEZWZhdWx0cyB0byBgMTBgLlxuICAgICAqL1xuICAgIHNldCBjb2x1bW5zKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1pbkNvbHVtbnNDb3VudCA9IDE7XG4gICAgICAgIHRoaXMuX2NvbHVtbnMgPSB2YWx1ZSA+IG1pbkNvbHVtbnNDb3VudCA/IHZhbHVlIDogbWluQ29sdW1uc0NvdW50O1xuICAgIH1cbiAgICBnZXQgY29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xvciBwYWxldHRlIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgc3VwcG9ydGVkIHZhbHVlcyBhcmU6XG4gICAgICogKiBUaGUgbmFtZSBvZiB0aGUgcHJlZGVmaW5lZCBwYWxldHRlIHByZXNldCAoZm9yIGV4YW1wbGUsIGBvZmZpY2VgLCBgYmFzaWNgLCBhbmQgYGFwZXhgKS5cbiAgICAgKiAqIEEgc3RyaW5nIHdpdGggY29tbWEtc2VwYXJhdGVkIGNvbG9ycy5cbiAgICAgKiAqIEEgc3RyaW5nIGFycmF5LlxuICAgICAqL1xuICAgIHNldCBwYWxldHRlKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBERUZBVUxUX1BSRVNFVCQxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGlzUHJlc2VudChQQUxFVFRFUFJFU0VUU1t2YWx1ZV0pKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSB0aGlzLmNvbHVtbnMgfHwgUEFMRVRURVBSRVNFVFNbdmFsdWVdLmNvbHVtbnM7XG4gICAgICAgICAgICB2YWx1ZSA9IFBBTEVUVEVQUkVTRVRTW3ZhbHVlXS5jb2xvcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3JzID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gdmFsdWUuc3BsaXQoJywnKSA6IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYWxldHRlID0gY29sb3JzLm1hcChjb2xvciA9PiBwYXJzZUNvbG9yJDEoY29sb3IsIHRoaXMuZm9ybWF0LCBmYWxzZSkpO1xuICAgIH1cbiAgICBnZXQgcGFsZXR0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhbGV0dGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgW2B0YWJpbmRleGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXgpIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IHRhYmluZGV4KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhYmluZGV4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSAhaXNOYU4odGFiaW5kZXgpID8gdGFiaW5kZXggOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGdldCB0YWJpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkID8gdGhpcy5fdGFiaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGlsZUxheW91dCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRpbGVTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHRoaXMudGlsZVNpemUsIGhlaWdodDogdGhpcy50aWxlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbG9yUm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5jb2xvclJvd3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdFRhYmluZGV4KCkgeyByZXR1cm4gdGhpcy50YWJpbmRleDsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWRDbGFzcygpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7IH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFByZXNldCA9ICh0aGlzLmZvcm1hdCAhPT0gJ25hbWUnKSA/IERFRkFVTFRfUFJFU0VUJDEgOiBERUZBVUxUX0FDQ0VTU0lCTEVfUFJFU0VUJDE7XG4gICAgICAgICAgICB0aGlzLnBhbGV0dGUgPSB0aGlzLnBhbGV0dGUgfHwgZGVmYXVsdFByZXNldDtcbiAgICAgICAgICAgIHRoaXMuc2V0Um93cygpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IHRoaXMuc2VydmljZS5nZXRDZWxsQ29vcmRzRm9yKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnBhbGV0dGUgfHwgY2hhbmdlcy5jb2x1bW5zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJvd3MoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5wYWxldHRlIHx8IGNoYW5nZXMudmFsdWUgfHwgY2hhbmdlcy5jb2x1bW5zKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRDZWxsID0gdGhpcy5zZXJ2aWNlLmdldENlbGxDb29yZHNGb3IodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNlbGxOYXZpZ2F0aW9uKDAsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93VXA6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDZWxsTmF2aWdhdGlvbigwLCAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNlbGxOYXZpZ2F0aW9uKGlzUlRMID8gLTEgOiAxLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDZWxsTmF2aWdhdGlvbihpc1JUTCA/IDEgOiAtMSwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuRW50ZXI6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFbnRlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVIb3N0Qmx1cigpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUNlbGxTZWxlY3Rpb24odmFsdWUsIGZvY3VzZWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IGZvY3VzZWRDZWxsO1xuICAgICAgICBjb25zdCBwYXJzZWRDb2xvciA9IHBhcnNlQ29sb3IkMSh2YWx1ZSwgdGhpcy5mb3JtYXQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jZWxsU2VsZWN0aW9uLmVtaXQocGFyc2VkQ29sb3IpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gcGFyc2VkQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZWRDb2xvcjtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChwYXJzZWRDb2xvcik7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU5nQ2hhbmdlZChwYXJzZWRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICE9PSBwYXJzZWRDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBwYXJzZWRDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQocGFyc2VkQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5mb2N1c2VkQ2VsbCA9IHRoaXMuc2VydmljZS5nZXRDZWxsQ29vcmRzRm9yKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5vdGlmeU5nQ2hhbmdlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNvbG9yIHZhbHVlIG9mIHRoZSBDb2xvclBhbGV0dGUuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNlZENlbGwgPSBudWxsO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Um93cygpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYWxldHRlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IHRoaXMuY29sdW1ucyB8fCBERUZBVUxUX0NPTFVNTlNfQ09VTlQ7XG4gICAgICAgIHRoaXMuc2VydmljZS5zZXRDb2xvck1hdHJpeCh0aGlzLnBhbGV0dGUsIHRoaXMuY29sdW1ucyk7XG4gICAgfVxuICAgIGhhbmRsZUNlbGxOYXZpZ2F0aW9uKGhvcml6b250YWxTdGVwLCB2ZXJ0aWNhbFN0ZXApIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzZWRDZWxsID0gdGhpcy5zZXJ2aWNlLmdldE5leHRDZWxsKHRoaXMuZm9jdXNlZENlbGwsIGhvcml6b250YWxTdGVwLCB2ZXJ0aWNhbFN0ZXApO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlcnZpY2UuZ2V0Q29sb3JBdCh0aGlzLmZvY3VzZWRDZWxsKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVudGVyKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmZvY3VzZWRDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ29sb3IgPSB0aGlzLnNlcnZpY2UuZ2V0Q29sb3JBdCh0aGlzLmZvY3VzZWRDZWxsKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDZWxsU2VsZWN0aW9uKHNlbGVjdGVkQ29sb3IsIHRoaXMuZm9jdXNlZENlbGwpO1xuICAgIH1cbn1cbkNvbG9yUGFsZXR0ZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY29sb3JwYWxldHRlJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbG9yUGFsZXR0ZUNvbXBvbmVudCkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBLZW5kb0lucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sb3JQYWxldHRlQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBDb2xvclBhbGV0dGVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY29sb3JwYWxldHRlJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IHJvbGU9XCJncmlkXCI+XG4gICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJrLXBhbGV0dGUgay1yZXNldFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciByb2xlPVwicm93XCIgKm5nRm9yPVwibGV0IHJvdyBvZiBjb2xvclJvd3M7IGxldCByb3dJbmRleCA9IGluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbG9yIG9mIHJvdzsgbGV0IGNvbEluZGV4ID0gaW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLXN0YXRlLXNlbGVjdGVkXT1cImZvY3VzZWRDZWxsPy5yb3cgPT09IHJvd0luZGV4ICYmIGZvY3VzZWRDZWxsPy5jb2wgPT09IGNvbEluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudmFsdWVdPVwiY29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJoYW5kbGVDZWxsU2VsZWN0aW9uKGNvbG9yLCB7IHJvdzogcm93SW5kZXgsIGNvbDogY29sSW5kZXggfSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRpbGVMYXlvdXQud2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRpbGVMYXlvdXQuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHRpbGVMYXlvdXQud2lkdGggKyAncHgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db2xvclBhbGV0dGVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDb2xvclBhbGV0dGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5Db2xvclBhbGV0dGVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBwYWxldHRlSWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaWQnLF0gfV0sXG4gICAgaWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZvcm1hdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhbGV0dGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRpbGVTaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Rpb25DaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNlbGxTZWxlY3Rpb246IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBob3N0VGFiaW5kZXg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGFiaW5kZXgnLF0gfV0sXG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstd2lkZ2V0JyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1jb2xvcnBhbGV0dGUnLF0gfV0sXG4gICAgZGlzYWJsZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcsXSB9XSxcbiAgICBoYW5kbGVLZXlkb3duOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsna2V5ZG93bicsIFsnJGV2ZW50J10sXSB9XSxcbiAgICBoYW5kbGVIb3N0Qmx1cjogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2JsdXInLF0gfV1cbn07XG5cbmNvbnN0IERFRkFVTFRfT1VUUFVUX0ZPUk1BVCA9ICdyZ2JhJztcbmNvbnN0IERFRkFVTFRfQkFDS0dST1VORF9DT0xPUiA9ICdyZ2JhKDI1NSwgMCwgMCwgMSknO1xubGV0IHNlcmlhbCQyID0gMDtcbi8qKlxuICogVGhlIENvbG9yR3JhZGllbnQgY29tcG9uZW50IGVuYWJsZXMgc21vb3RoIGNvbG9yIHRyYW5zaXRpb25zIGFuZCBwcm92aWRlcyBvcHRpb25zIGZvciBzZWxlY3Rpbmcgc3BlY2lmaWMgY29sb3JzIG92ZXIgdGhlIGRyYWcgaGFuZGxlLlxuICogVGhlIENvbG9yR3JhZGllbnQgaXMgaW5kZXBlbmRlbnRseSB1c2VkIGJ5IGBrZW5kby1jb2xvcnBpY2tlcmAgYW5kIGNhbiBiZSBkaXJlY3RseSBhZGRlZCB0byB0aGUgcGFnZS5cbiAqL1xuY2xhc3MgQ29sb3JHcmFkaWVudENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgbmdab25lLCByZW5kZXJlciwgY2RyLCBsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgay1jb2xvcmdyYWRpZW50LSR7c2VyaWFsJDIrK31gO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBhbHBoYSBzbGlkZXIgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIENvbG9yR3JhZGllbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIENvbG9yR3JhZGllbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgQ29sb3JHcmFkaWVudCBzaG91bGQgZGlzcGxheSBhICdDbGVhciBjb2xvcicgYnV0dG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgY29sb3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBgaHVlYCwgYHNhdHVyYXRpb25gLCBgdmFsdWVgLCBhbmQgYGFscGhhYCB2YWx1ZXMuXG4gICAgICAgICAqIFRoZSB2YWx1ZXMgYXJlIGluaXRpYWxseSBzZXQgaW4gYG5nT25Jbml0YCBvciBpbiBgbmdPbkNoYW5nZXNgIGFuZCBhcmVcbiAgICAgICAgICogdXBkYXRlZCBvbiBtb3ZpbmcgdGhlIGRyYWcgaGFuZGxlIG9yIHRoZSBzbGlkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oc3ZhID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG91dHB1dCBmb3JtYXQgb2YgdGhlIENvbG9yR3JhZGllbnRDb21wb25lbnQuXG4gICAgICAgICAqIFRoZSBpbnB1dCB2YWx1ZSBtYXkgYmUgaW4gYSBkaWZmZXJlbnQgZm9ybWF0LiBIb3dldmVyLCBpdCB3aWxsIGJlIHBhcnNlZCBpbnRvIHRoZSBvdXRwdXQgYGZvcm1hdGBcbiAgICAgICAgICogYWZ0ZXIgdGhlIGNvbXBvbmVudCBwcm9jZXNzZXMgaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzdXBwb3J0ZWQgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYHJnYmFgXG4gICAgICAgICAqICogYGhleGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gREVGQVVMVF9PVVRQVVRfRk9STUFUO1xuICAgICAgICB0aGlzLl90YWJpbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLm5vdGlmeU5nVG91Y2hlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5keW5hbWljUlRMU3Vic2NyaXB0aW9uID0gbG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBnZXQgaG9zdFRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBncmFkaWVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSB2YWx1ZSBvZiB0aGUgaW5pdGlhbGx5IHNlbGVjdGVkIGNvbG9yLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHBhcnNlQ29sb3IkMSh2YWx1ZSwgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBbYHRhYmluZGV4YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzZXQgdGFiaW5kZXgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFiaW5kZXggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl90YWJpbmRleCA9ICFpc05hTih0YWJpbmRleCkgPyB0YWJpbmRleCA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQgPyB0aGlzLl90YWJpbmRleCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIENvbG9yR3JhZGllbnQgb3IgYW55IG9mIGl0cyBjb250ZW50IGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgaWYgKCEoaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGlzUHJlc2VudCh0aGlzLmhvc3QpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3QubmF0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBhbHBoYVNsaWRlclZhbHVlKCkge1xuICAgICAgICAvLyBzZXR0aW5nIHRoZSBpbml0aWFsIHZhbHVlIHRvIHVuZGVmaW5lZCB0byBmb3JjZSB0aGUgc2xpZGVyIHRvIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIHNsaWRlciB0cmFjayBvbiB0aGUgbmV4dCBjZHIgcnVuXG4gICAgICAgIGlmICghKGlzUHJlc2VudCh0aGlzLmhzdmEpICYmIGlzUHJlc2VudCh0aGlzLmhzdmEuYSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaHN2YS5hICogMTAwO1xuICAgIH1cbiAgICBnZXQgZ3JhZGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFkaWVudFdyYXBwZXIubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ3ZhbHVlJywgY2hhbmdlcykgJiYgIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gocmVtb3ZlTGlzdGVuZXIgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNSVExTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1JUTFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3QubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ1ByZXNzKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSB8fCAhaXNQcmVzZW50KGFyZ3Mub3JpZ2luYWxFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIGFyZ3Mub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25IYW5kbGVEcmFnKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5ncmFkaWVudFdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stZHJhZ2dpbmcnKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VQb3NpdGlvbihhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uSGFuZGxlUmVsZWFzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5ncmFkaWVudFdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stZHJhZ2dpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNoYW5nZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5tb3ZlRHJhZ0hhbmRsZShwb3NpdGlvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlSHVlU2xpZGVyQ2hhbmdlKGh1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlQ2hhbmdlKGdldENvbG9yRnJvbUhTVih0aGlzLmhzdmEpKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRDb2xvckZyb21IdWUoaHVlKTtcbiAgICAgICAgdGhpcy5zZXRBbHBoYVNsaWRlckJhY2tncm91bmQodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQWxwaGFTbGlkZXJDaGFuZ2UoYWxwaGEpIHtcbiAgICAgICAgdGhpcy5oc3ZhLmEgPSBhbHBoYSAvIDEwMDtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShnZXRDb2xvckZyb21IU1YodGhpcy5oc3ZhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVJbnB1dHNWYWx1ZUNoYW5nZShjb2xvcikge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbG9yJDEoY29sb3IsIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShwYXJzZWQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmdyYWRpZW50V3JhcHBlcikpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVUkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm5vdGlmeU5nQ2hhbmdlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5ub3RpZnlOZ1RvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVzZWQgYnkgdGhlIFRleHRCb3hDb250YWluZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlRHJhZ0hhbmRsZShwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBkZWx0YVggPSBwb3NpdGlvbi5jbGllbnRYIC0gdGhpcy5ncmFkaWVudFJlY3QubGVmdDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gcG9zaXRpb24uY2xpZW50WSAtIHRoaXMuZ3JhZGllbnRSZWN0LnRvcDtcbiAgICAgICAgY29uc3QgdG9wID0gZml0SW50b0JvdW5kcyhkZWx0YVksIDAsIHRoaXMuZ3JhZGllbnRSZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBmaXRJbnRvQm91bmRzKGRlbHRhWCwgMCwgdGhpcy5ncmFkaWVudFJlY3Qud2lkdGgpO1xuICAgICAgICB0aGlzLnNldERyYWdIYW5kbGVFbGVtZW50UG9zaXRpb24odG9wLCBsZWZ0KTtcbiAgICAgICAgdGhpcy5oc3ZhLnMgPSBsZWZ0IC8gdGhpcy5ncmFkaWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHRoaXMuaHN2YS52ID0gMSAtIHRvcCAvIHRoaXMuZ3JhZGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShnZXRDb2xvckZyb21IU1YodGhpcy5oc3ZhKSk7XG4gICAgICAgIHRoaXMuc2V0QWxwaGFTbGlkZXJCYWNrZ3JvdW5kKGdldENvbG9yRnJvbUhTVihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhzdmEsIHsgYTogMSB9KSkpO1xuICAgIH1cbiAgICB1cGRhdGVVSSgpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhzdmEgPSB0aGlzLnZhbHVlID8gZ2V0SFNWKHRoaXMudmFsdWUpIDogeyBoOiAwLCBzOiAwLCB2OiAxLCBhOiAxIH07XG4gICAgICAgIGNvbnN0IHRvcCA9ICgxIC0gdGhpcy5oc3ZhLnYpICogdGhpcy5ncmFkaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5oc3ZhLnMgKiB0aGlzLmdyYWRpZW50UmVjdC53aWR0aDtcbiAgICAgICAgdGhpcy5zZXREcmFnSGFuZGxlRWxlbWVudFBvc2l0aW9uKHRvcCwgbGVmdCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gZ2V0Q29sb3JGcm9tSHVlKHRoaXMuaHN2YS5oKTtcbiAgICAgICAgdGhpcy5zZXRBbHBoYVNsaWRlckJhY2tncm91bmQodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cbiAgICBoYW5kbGVWYWx1ZUNoYW5nZShjb2xvcikge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gY29sb3I7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjb2xvcik7XG4gICAgICAgIHRoaXMubm90aWZ5TmdDaGFuZ2VkKGNvbG9yKTtcbiAgICB9XG4gICAgc2V0RHJhZ0hhbmRsZUVsZW1lbnRQb3NpdGlvbih0b3AsIGxlZnQpIHtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRoaXMuZHJhZ0hhbmRsZS5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRyYWdIYW5kbGUsICd0b3AnLCBgJHt0b3B9cHhgKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkcmFnSGFuZGxlLCAnbGVmdCcsIGAke2xlZnR9cHhgKTtcbiAgICB9XG4gICAgc2V0QWxwaGFTbGlkZXJCYWNrZ3JvdW5kKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmFscGhhU2xpZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWRlclRyYWNrID0gdGhpcy5hbHBoYVNsaWRlci50cmFjay5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHNsaWRlclRyYWNrLCAnYmFja2dyb3VuZCcsIGBsaW5lYXItZ3JhZGllbnQodG8gdG9wLCB0cmFuc3BhcmVudCwgJHtiYWNrZ3JvdW5kQ29sb3J9KWApO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9jdXNPdXRMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LCAnZm9jdXNvdXQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zRm9jdXModGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmIGlzVW50b3VjaGVkKHRoaXMuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMubm90aWZ5TmdUb3VjaGVkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChmb2N1c091dExpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuQ29sb3JHcmFkaWVudENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY29sb3JncmFkaWVudCcsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbG9yR3JhZGllbnRDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtlbmRvSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2xvckdyYWRpZW50Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY29sb3JncmFkaWVudCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImstaGJveCBrLWhzdi13cmFwXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1oc3YtcmVjdGFuZ2xlXCIgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVwiYmFja2dyb3VuZENvbG9yXCI+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAjZ3JhZGllbnRXcmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1oc3YtZ3JhZGllbnRcIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlUG9zaXRpb24oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb1ByZXNzKT1cImhhbmRsZURyYWdQcmVzcygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKGtlbmRvRHJhZyk9XCJvbkhhbmRsZURyYWcoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZW5kb1JlbGVhc2UpPVwib25IYW5kbGVSZWxlYXNlKClcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgI2RyYWdIYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1kcmFnaGFuZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstaGJveCBrLXNsaWRlcnMtd3JhcCB7eyBjbGVhckJ1dHRvbiA/ICdrLXNsaWRlcnMtd3JhcC1jbGVhcmFibGUnIDogJycgfX1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstY2xlYXItY29sb3Igay1idXR0b24gay1iYXJlIGstYnV0dG9uLWljb25cIiAqbmdJZj1cImNsZWFyQnV0dG9uXCIgKGNsaWNrKT1cInJlc2V0KClcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLXJlc2V0LWNvbG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1odWUtc2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dCdXR0b25zXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpY2tQbGFjZW1lbnRdPVwiJ25vbmUnXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIjM2MFwiXG4gICAgICAgICAgICAgICAgICAgIFtzbWFsbFN0ZXBdPVwiNVwiXG4gICAgICAgICAgICAgICAgICAgIFtsYXJnZVN0ZXBdPVwiMTBcIlxuICAgICAgICAgICAgICAgICAgICBbKHZhbHVlKV09XCJoc3ZhLmhcIlxuICAgICAgICAgICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaGFuZGxlSHVlU2xpZGVyQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLXNsaWRlcj5cbiAgICAgICAgICAgICAgICA8a2VuZG8tc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwib3BhY2l0eSAmJiBmb3JtYXQgPT09ICdyZ2JhJ1wiXG4gICAgICAgICAgICAgICAgICAgICNhbHBoYVNsaWRlclxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstYWxwaGEtc2xpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dCdXR0b25zXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpY2tQbGFjZW1lbnRdPVwiJ25vbmUnXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZlcnRpY2FsXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgICAgICAgICBbbWF4XT1cIjEwMFwiXG4gICAgICAgICAgICAgICAgICAgIFtzbWFsbFN0ZXBdPVwiMVwiXG4gICAgICAgICAgICAgICAgICAgIFtsYXJnZVN0ZXBdPVwiMTBcIlxuICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwiYWxwaGFTbGlkZXJWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVBbHBoYVNsaWRlckNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9rZW5kby1zbGlkZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxrZW5kby1jb2xvcmlucHV0XG4gICAgICAgICAgICBbb3BhY2l0eV09XCJvcGFjaXR5XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVJbnB1dHNWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgPlxuICAgICAgICA8L2tlbmRvLWNvbG9yaW5wdXQ+XG5gXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbG9yR3JhZGllbnRDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcbkNvbG9yR3JhZGllbnRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstd2lkZ2V0JyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1mbGF0Y29sb3JwaWNrZXInLF0gfV0sXG4gICAgZGlzYWJsZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1zdGF0ZS1kaXNhYmxlZCcsXSB9XSxcbiAgICBob3N0VGFiaW5kZXg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGFiaW5kZXgnLF0gfV0sXG4gICAgZ3JhZGllbnRJZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5pZCcsXSB9XSxcbiAgICBpZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBvcGFjaXR5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVhZG9ubHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNsZWFyQnV0dG9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiaW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgZm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbHBoYVNsaWRlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2FscGhhU2xpZGVyJyxdIH1dLFxuICAgIGdyYWRpZW50V3JhcHBlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2dyYWRpZW50V3JhcHBlcicsXSB9XSxcbiAgICBkcmFnSGFuZGxlOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnZHJhZ0hhbmRsZScsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbG9ySW5wdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgd2hldGhlciB0aGUgYWxwaGEgc2xpZGVyIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIENvbG9ySW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIENvbG9ySW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhIHBhcnNlZCByZ2JhIHN0cmluZyBjb2xvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29sb3JJbnB1dENsYXNzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZ2JhIGlucHV0cyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJnYmEgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYW55IG9mIHRoZSBpbnB1dHMgYXJlIGZvY3VzZWQuXG4gICAgICovXG4gICAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgaWYgKCEoaXNEb2N1bWVudEF2YWlsYWJsZSgpICYmIGlzUHJlc2VudCh0aGlzLmhvc3QpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGFueSBvZiB0aGUgcmdiYSBpbnB1dHMgaGF2ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgcmdiYUlucHV0VmFsaWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJnYmEpLmV2ZXJ5KGtleSA9PiBpc1ByZXNlbnQodGhpcy5yZ2JhW2tleV0pKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXMudmFsdWUpICYmICF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5oZXggPSBwYXJzZUNvbG9yJDEodGhpcy52YWx1ZSwgJ2hleCcpO1xuICAgICAgICAgICAgdGhpcy5yZ2JhID0gZ2V0UkdCQSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucmdiYS5hID0gcGFyc2VDb2xvciQxKHRoaXMudmFsdWUsICdyZ2JhJykgPyB0aGlzLnJnYmEuYSA6IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUmdiYVZhbHVlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yRnJvbVJHQkEodGhpcy5yZ2JhKTtcbiAgICAgICAgaWYgKCF0aGlzLnJnYmFJbnB1dFZhbGlkIHx8IGNvbG9yID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLnJnYmEgPSBnZXRSR0JBKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLmhleCA9IHBhcnNlQ29sb3IkMShjb2xvciwgJ2hleCcpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoY29sb3IpO1xuICAgIH1cbiAgICBoYW5kbGVIZXhWYWx1ZUNoYW5nZShoZXgpIHtcbiAgICAgICAgdGhpcy5oZXggPSBoZXg7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gcGFyc2VDb2xvciQxKGhleCwgJ3JnYmEnKTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoY29sb3IpIHx8IGNvbG9yID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLnJnYmEgPSBnZXRSR0JBKGNvbG9yKTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KGNvbG9yKTtcbiAgICB9XG4gICAgaGFuZGxlUmdiYUlucHV0Qmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJnYmFJbnB1dFZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnJnYmEgPSBnZXRSR0JBKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUhleElucHV0Qmx1cigpIHtcbiAgICAgICAgdGhpcy5oZXggPSBwYXJzZUNvbG9yJDEodGhpcy52YWx1ZSwgJ2hleCcpO1xuICAgIH1cbn1cbkNvbG9ySW5wdXRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNvbG9yaW5wdXQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWhib3ggay1ncmFkaWVudC12YWx1ZXNcIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICNoZXhJbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiay10ZXh0Ym94IGstaGV4LXZhbHVlXCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cImhleCB8fCAnJ1wiXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJubyBjb2xvclwiXG4gICAgICAgICAgICAgICAgKGJsdXIpPVwiaGFuZGxlSGV4SW5wdXRCbHVyKClcIlxuICAgICAgICAgICAgICAgIChpbnB1dCk9XCJoYW5kbGVIZXhWYWx1ZUNoYW5nZShoZXhJbnB1dC52YWx1ZSlcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxrZW5kby1udW1lcmljdGV4dGJveFxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICBbbWluXT1cIjBcIlxuICAgICAgICAgICAgICAgIFttYXhdPVwiMjU1XCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlJcIlxuICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cInJnYmEuclwiXG4gICAgICAgICAgICAgICAgW2F1dG9Db3JyZWN0XT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFtzcGlubmVyc109XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCInbidcIlxuICAgICAgICAgICAgICAgIFtkZWNpbWFsc109XCIwXCJcbiAgICAgICAgICAgICAgICAoYmx1cik9XCJoYW5kbGVSZ2JhSW5wdXRCbHVyKClcIlxuICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJoYW5kbGVSZ2JhVmFsdWVDaGFuZ2UoKVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2tlbmRvLW51bWVyaWN0ZXh0Ym94PlxuICAgICAgICAgICAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94XG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICAgICAgW21heF09XCIyNTVcIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiR1wiXG4gICAgICAgICAgICAgICAgWyh2YWx1ZSldPVwicmdiYS5nXCJcbiAgICAgICAgICAgICAgICBbYXV0b0NvcnJlY3RdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgW3NwaW5uZXJzXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cIiduJ1wiXG4gICAgICAgICAgICAgICAgW2RlY2ltYWxzXT1cIjBcIlxuICAgICAgICAgICAgICAgIChibHVyKT1cImhhbmRsZVJnYmFJbnB1dEJsdXIoKVwiXG4gICAgICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cImhhbmRsZVJnYmFWYWx1ZUNoYW5nZSgpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tbnVtZXJpY3RleHRib3g+XG4gICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIFtyZWFkb25seV09XCJyZWFkb25seVwiXG4gICAgICAgICAgICAgICAgW21pbl09XCIwXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIjI1NVwiXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJCXCJcbiAgICAgICAgICAgICAgICBbKHZhbHVlKV09XCJyZ2JhLmJcIlxuICAgICAgICAgICAgICAgIFthdXRvQ29ycmVjdF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbc3Bpbm5lcnNdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwiJ24nXCJcbiAgICAgICAgICAgICAgICBbZGVjaW1hbHNdPVwiMFwiXG4gICAgICAgICAgICAgICAgKGJsdXIpPVwiaGFuZGxlUmdiYUlucHV0Qmx1cigpXCJcbiAgICAgICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaGFuZGxlUmdiYVZhbHVlQ2hhbmdlKClcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1udW1lcmljdGV4dGJveD5cbiAgICAgICAgICAgIDxrZW5kby1udW1lcmljdGV4dGJveFxuICAgICAgICAgICAgICAgICpuZ0lmPVwib3BhY2l0eVwiXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICAgICAgW21heF09XCIxXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkFcIlxuICAgICAgICAgICAgICAgIFsodmFsdWUpXT1cInJnYmEuYVwiXG4gICAgICAgICAgICAgICAgW2F1dG9Db3JyZWN0XT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFtzcGlubmVyc109XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgW3N0ZXBdPVwiMC4wMVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCInbjInXCJcbiAgICAgICAgICAgICAgICBbZGVjaW1hbHNdPVwiMlwiXG4gICAgICAgICAgICAgICAgKGJsdXIpPVwiaGFuZGxlUmdiYUlucHV0Qmx1cigpXCJcbiAgICAgICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwiaGFuZGxlUmdiYVZhbHVlQ2hhbmdlKClcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1udW1lcmljdGV4dGJveD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWhib3ggay1ncmFkaWVudC12YWx1ZXNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLWhleC12YWx1ZVwiPmhleDwvZGl2PlxuICAgICAgICAgICAgPGRpdj5yPC9kaXY+XG4gICAgICAgICAgICA8ZGl2Pmc8L2Rpdj5cbiAgICAgICAgICAgIDxkaXY+YjwvZGl2PlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cIm9wYWNpdHlcIj5hPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sb3JJbnB1dENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuXTtcbkNvbG9ySW5wdXRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wYWNpdHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZWFkb25seTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2xvcklucHV0Q2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY29sb3JpbnB1dHMnLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGb2N1c09uRG9tUmVhZHlEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLmZvY3VzT25OZXh0VGljaygpO1xuICAgIH1cbiAgICBmb2N1c09uTmV4dFRpY2soKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKSkpO1xuICAgIH1cbn1cbkZvY3VzT25Eb21SZWFkeURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRm9jdXNPbkRvbVJlYWR5XSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRm9jdXNPbkRvbVJlYWR5RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5cbmNvbnN0IFBVQkxJQ19ESVJFQ1RJVkVTID0gW1xuICAgIENvbG9yUGlja2VyQ29tcG9uZW50LFxuICAgIENvbG9yUGFsZXR0ZUNvbXBvbmVudCxcbiAgICBDb2xvckdyYWRpZW50Q29tcG9uZW50XG5dO1xuY29uc3QgSU5URVJOQUxfRElSRUNUSVZFUyA9IFtcbiAgICBDb2xvcklucHV0Q29tcG9uZW50LFxuICAgIEZvY3VzT25Eb21SZWFkeURpcmVjdGl2ZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIENvbG9yUGlja2VyLlxuICovXG5jbGFzcyBDb2xvclBpY2tlck1vZHVsZSB7XG59XG5Db2xvclBpY2tlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIFBVQkxJQ19ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTF9ESVJFQ1RJVkVTXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbUFVCTElDX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgU2xpZGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOdW1lcmljVGV4dEJveE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQb3B1cE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgRHJhZ2dhYmxlTW9kdWxlXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGl2ZSB0aGF0IHJlbmRlcnMgdGhlIFtLZW5kbyBVSSBDaGVja0JveF0oeyUgc2x1ZyBvdmVydmlld19jaGVja2JveCAlfSkgaW5wdXQgY29tcG9uZW50LlxuICogVGhlIGRpcmVjdGl2ZSBpcyBwbGFjZWQgb24gaW5wdXQgdHlwZT1cImNoZWNrYm94XCIgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGtlbmRvQ2hlY2tCb3ggLz5cbiAqIGBgYFxuICovXG5jbGFzcyBDaGVja0JveERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2VuZG9DbGFzcyA9IHRydWU7XG4gICAgfVxufVxuQ2hlY2tCb3hEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W2tlbmRvQ2hlY2tCb3hdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuQ2hlY2tCb3hEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAga2VuZG9DbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1jaGVja2JveCcsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgQ2hlY2tCb3ggZGlyZWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIENoZWNrQm94IG1vZHVsZVxuICogaW1wb3J0IHsgQ2hlY2tCb3hNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBDaGVja0JveE1vZHVsZV0sIC8vIGltcG9ydCBDaGVja0JveCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIENoZWNrQm94TW9kdWxlIHtcbn1cbkNoZWNrQm94TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDaGVja0JveERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0NoZWNrQm94RGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGl2ZSB0aGF0IHJlbmRlcnMgdGhlIFtLZW5kbyBVSSBSYWRpb0J1dHRvbl0oeyUgc2x1ZyBvdmVydmlld19jaGVja2JveCAlfSkgaW5wdXQgY29tcG9uZW50LlxuICogVGhlIGRpcmVjdGl2ZSBpcyBwbGFjZWQgb24gaW5wdXQgdHlwZT1cInJhZGlvXCIgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogPGlucHV0IHR5cGU9XCJyYWRpb1wiIGtlbmRvUmFkaW9CdXR0b24gLz5cbiAqIGBgYFxuICovXG5jbGFzcyBSYWRpb0J1dHRvbkRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2VuZG9DbGFzcyA9IHRydWU7XG4gICAgfVxufVxuUmFkaW9CdXR0b25EaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W2tlbmRvUmFkaW9CdXR0b25dJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuUmFkaW9CdXR0b25EaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAga2VuZG9DbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1yYWRpbycsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUmFkaW9CdXR0b24gZGlyZWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFJhZGlvQnV0dG9uIG1vZHVsZVxuICogaW1wb3J0IHsgUmFkaW9CdXR0b25Nb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBSYWRpb0J1dHRvbk1vZHVsZV0sIC8vIGltcG9ydCBSYWRpb0J1dHRvbiBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIFJhZGlvQnV0dG9uTW9kdWxlIHtcbn1cblJhZGlvQnV0dG9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtSYWRpb0J1dHRvbkRpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1JhZGlvQnV0dG9uRGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG5sZXQgc2VyaWFsJDMgPSAwO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHNob3duIHVuZGVybmVhdGhcbiAqIGEgS2VuZG8gY29udHJvbCBvciBuYXRpdmUgSFRNTCBmb3JtLWJvdW5kIGNvbXBvbmVudCBhZnRlciBhIHZhbGlkYXRpb24uXG4gKi9cbmNsYXNzIEVycm9yQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhbGlnbm1lbnQgb2YgdGhlIEVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgc3RhcnRgXG4gICAgICAgICAqICogYGVuZGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGBrZW5kby1lcnJvci0ke3NlcmlhbCQzKyt9YDtcbiAgICAgICAgdGhpcy5yb2xlQXR0cmlidXRlID0gJ2FsZXJ0JztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWduID09PSAnc3RhcnQnO1xuICAgIH1cbiAgICBnZXQgZW5kQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWduID09PSAnZW5kJztcbiAgICB9XG4gICAgZ2V0IGlkQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG59XG5FcnJvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZm9ybWVycm9yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuRXJyb3JDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZvcm0tZXJyb3InLF0gfV0sXG4gICAgYWxpZ246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJvbGVBdHRyaWJ1dGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XSxcbiAgICBzdGFydENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRleHQtc3RhcnQnLF0gfV0sXG4gICAgZW5kQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstdGV4dC1lbmQnLF0gfV0sXG4gICAgaWRBdHRyaWJ1dGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaWQnLF0gfV1cbn07XG5cbmxldCBzZXJpYWwkNCA9IDA7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBoaW50IG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHNob3duIHVuZGVybmVhdGggYSBmb3JtLWJvdW5kIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgSGludENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGFsaWdubWVudCBvZiB0aGUgSGludCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYHN0YXJ0YFxuICAgICAgICAgKiAqIGBlbmRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBga2VuZG8taGludC0ke3NlcmlhbCQ0Kyt9YDtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgc3RhcnRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ24gPT09ICdzdGFydCc7XG4gICAgfVxuICAgIGdldCBlbmRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ24gPT09ICdlbmQnO1xuICAgIH1cbiAgICBnZXQgaWRBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cbn1cbkhpbnRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZvcm1oaW50JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuSGludENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBhbGlnbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZvcm0taGludCcsXSB9XSxcbiAgICBzdGFydENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRleHQtc3RhcnQnLF0gfV0sXG4gICAgZW5kQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstdGV4dC1lbmQnLF0gfV0sXG4gICAgaWRBdHRyaWJ1dGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaWQnLF0gfV1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgY29udGFpbmVyIGZvciBmb3JtLWJvdW5kIGNvbnRyb2xzIChLZW5kbyBjb250cm9scyBvciBuYXRpdmUgSFRNTCBjb250cm9scykuXG4gKiBBcHBsaWVzIHN0eWxpbmcgYW5kIGJlaGF2aW9yIHJ1bGVzLlxuICovXG5jbGFzcyBGb3JtRmllbGRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZW4gdGhlIEhpbnQgbWVzc2FnZXMgd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICAgICAqXG4gICAgICAgICAqICogKERlZmF1bHQpIGBpbml0aWFsYCZtZGFzaDtBbGxvd3MgZGlzcGxheWluZyBoaW50cyB3aGVuIHRoZSBmb3JtLWJvdW5kIGNvbXBvbmVudCBzdGF0ZSBpc1xuICAgICAgICAgKiBgdmFsaWRgIG9yIGB1bnRvdWNoZWRgIGFuZCBgcHJpc3RpbmVgLlxuICAgICAgICAgKiAqIGBhbHdheXNgJm1kYXNoO0FsbG93cyBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgaGludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dIaW50cyA9ICdpbml0aWFsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbGF5b3V0IG9yaWVudGF0aW9uIG9mIHRoZSBmb3JtIGZpZWxkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIChEZWZhdWx0KSBgdmVydGljYWxgXG4gICAgICAgICAqICogYGhvcml6b250YWxgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGVuIHRoZSBFcnJvciBtZXNzYWdlcyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiAoRGVmYXVsdCkgYGluaXRpYWxgJm1kYXNoO0FsbG93cyBkaXNwbGF5aW5nIGVycm9ycyB3aGVuIHRoZSBmb3JtLWJvdW5kIGNvbXBvbmVudCBzdGF0ZSBpc1xuICAgICAgICAgKiBgaW52YWxpZGAgYW5kIGB0b3VjaGVkYCBvciBgZGlydHlgLlxuICAgICAgICAgKiAqIGBhbHdheXNgJm1kYXNoO0FsbG93cyBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZXJyb3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93RXJyb3JzID0gJ2luaXRpYWwnO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKCh7IHJ0bCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ0bCA9IHJ0bDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5ydGwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldCBlcnJvckNsYXNzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wuaW52YWxpZCAmJiAodGhpcy5jb250cm9sLnRvdWNoZWQgfHwgdGhpcy5jb250cm9sLmRpcnR5KTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmFkaW9idXR0b24gZ3JvdXBcbiAgICAgICAgaWYgKHRoaXMuaXNSYWRpb0NvbnRyb2wodGhpcy5jb250cm9sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkQ29udHJvbCgpIHx8XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkRWxlbWVudCgpIHx8XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkS2VuZG9JbnB1dCgpO1xuICAgIH1cbiAgICBzZXQgZm9ybUNvbnRyb2xzKGZvcm1Db250cm9scykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlRm9ybUNvbnRyb2woZm9ybUNvbnRyb2xzKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gZm9ybUNvbnRyb2xzLmZpcnN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGFzSGludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dIaW50cyA9PT0gJ2Fsd2F5cycgPyB0cnVlIDogdGhpcy5zaG93SGludHNJbml0aWFsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGFzRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93RXJyb3JzID09PSAnYWx3YXlzJyA/IHRydWUgOiB0aGlzLnNob3dFcnJvcnNJbml0aWFsKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXREZXNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGRpc2FibGVkS2VuZG9JbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2VuZG9JbnB1dCAmJiB0aGlzLmtlbmRvSW5wdXQuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGRpc2FibGVkQ29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbC5kaXNhYmxlZDtcbiAgICB9XG4gICAgZGlzYWJsZWRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuY29udHJvbEVsZW1lbnRSZWZzLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmV2ZXJ5KGUgPT4gZS5uYXRpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSk7XG4gICAgfVxuICAgIHZhbGlkYXRlRm9ybUNvbnRyb2woZm9ybUNvbnRyb2xzKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiBmb3JtQ29udHJvbHMubGVuZ3RoICE9PSAxICYmICF0aGlzLmlzQ29udHJvbEdyb3VwKGZvcm1Db250cm9scykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBrZW5kby1mb3JtZmllbGRgIGNvbXBvbmVudCBzaG91bGQgY29udGFpbiAnICtcbiAgICAgICAgICAgICAgICAnb25seSBvbmUgY29udHJvbCBvZiB0eXBlIE5nQ29udHJvbCB3aXRoIGEgZm9ybUNvbnRyb2xOYW1lKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvZm9ybXMvRm9ybUNvbnRyb2xOYW1lKScgK1xuICAgICAgICAgICAgICAgICdvciBhbiBuZ01vZGVsKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvZm9ybXMvTmdNb2RlbCkgYmluZGluZy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NvbnRyb2xHcm91cChmb3JtQ29udHJvbHMpIHtcbiAgICAgICAgaWYgKCFmb3JtQ29udHJvbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGZvcm1Db250cm9scy5maXJzdC5uYW1lO1xuICAgICAgICByZXR1cm4gZm9ybUNvbnRyb2xzLnRvQXJyYXkoKS5ldmVyeShjID0+IGMubmFtZSA9PT0gbmFtZSAmJiAodGhpcy5pc1JhZGlvQ29udHJvbChjKSkpO1xuICAgIH1cbiAgICBpc1JhZGlvQ29udHJvbChjb250cm9sKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sLnZhbHVlQWNjZXNzb3IgaW5zdGFuY2VvZiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH1cbiAgICB1cGRhdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSB0aGlzLmZpbmRDb250cm9sRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKCFjb250cm9scykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xzLmZvckVhY2goKGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFyaWFJZHMgPSB0aGlzLmdlbmVyYXRlRGVzY3JpcHRpb25JZHMoY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShjb250cm9sLCAnYXJpYS1kZXNjcmliZWRieScsIGFyaWFJZHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluZENvbnRyb2xFbGVtZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xFbGVtZW50UmVmcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBjb250cm9sIGlzIEtlbmRvSW5wdXQgYW5kIGhhcyBmb2N1c2FibGVJZCAtIGRyb3Bkb3ducywgZGF0ZWlucHV0c1xuICAgICAgICBpZiAodGhpcy5rZW5kb0lucHV0ICYmIHRoaXMua2VuZG9JbnB1dC5mb2N1c2FibGVJZCAmJiBpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5rZW5kb0lucHV0LmZvY3VzYWJsZUlkKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVsZW1lbnRSZWZzLm1hcChlbCA9PiBlbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVEZXNjcmlwdGlvbklkcyhjb250cm9sKSB7XG4gICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGNvbnRyb2wuaGFzQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjb250cm9sLmdldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5pbmNsdWRlcygna2VuZG8taGludC0nKSB8fCBhdHRyLmluY2x1ZGVzKCdrZW5kby1lcnJvci0nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkcy5hZGQoYXR0cik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpbnRDaGlsZHJlbi5mb3JFYWNoKChoaW50KSA9PiB7XG4gICAgICAgICAgICBpZHMuYWRkKGhpbnQuaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lcnJvckNoaWxkcmVuLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZHMuYWRkKGVycm9yLmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGlkcykuam9pbignICcpO1xuICAgIH1cbiAgICBzaG93SGludHNJbml0aWFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB2YWxpZCwgdW50b3VjaGVkLCBwcmlzdGluZSB9ID0gdGhpcy5jb250cm9sO1xuICAgICAgICByZXR1cm4gdmFsaWQgfHwgKHVudG91Y2hlZCAmJiBwcmlzdGluZSk7XG4gICAgfVxuICAgIHNob3dFcnJvcnNJbml0aWFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW52YWxpZCwgZGlydHksIHRvdWNoZWQgfSA9IHRoaXMuY29udHJvbDtcbiAgICAgICAgcmV0dXJuIGludmFsaWQgJiYgKGRpcnR5IHx8IHRvdWNoZWQpO1xuICAgIH1cbiAgICBzZXREZXNjcmlwdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEZXNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuZXJyb3JDaGlsZHJlbi5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZURlc2NyaXB0aW9uKCkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmhpbnRDaGlsZHJlbi5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZURlc2NyaXB0aW9uKCkpKTtcbiAgICB9XG59XG5Gb3JtRmllbGRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZvcm1maWVsZCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWwsIGtlbmRvLWxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8ZGl2IFtjbGFzcy5rLWZvcm0tZmllbGQtd3JhcF09XCJob3Jpem9udGFsXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJrZW5kby1mb3JtaGludFwiICpuZ0lmPVwiaGFzSGludHNcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJrZW5kby1mb3JtZXJyb3JcIiAqbmdJZj1cImhhc0Vycm9yc1wiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmZvcm1maWVsZCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRm9ybUZpZWxkQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5Gb3JtRmllbGRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZvcm0tZmllbGQnLF0gfV0sXG4gICAgZGlyZWN0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBlcnJvckNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZvcm0tZmllbGQtZXJyb3InLF0gfV0sXG4gICAgZGlzYWJsZWRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1mb3JtLWZpZWxkLWRpc2FibGVkJyxdIH1dLFxuICAgIGZvcm1Db250cm9sczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdDb250cm9sLCB7IGRlc2NlbmRhbnRzOiB0cnVlLCBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIGNvbnRyb2xFbGVtZW50UmVmczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdDb250cm9sLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIGRlc2NlbmRhbnRzOiB0cnVlLCBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIGtlbmRvSW5wdXQ6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0tlbmRvSW5wdXQsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcbiAgICBlcnJvckNoaWxkcmVuOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtFcnJvckNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH0sXSB9XSxcbiAgICBoaW50Q2hpbGRyZW46IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0hpbnRDb21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUsIHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgc2hvd0hpbnRzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcmllbnRhdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd0Vycm9yczogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEZvcm1GaWVsZCwgRXJyb3IgYW5kIEhpbnQgY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBGb3JtRmllbGQgbW9kdWxlXG4gKiBpbXBvcnQgeyBGb3JtRmllbGRNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnB1dHMnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBGb3JtRmllbGRNb2R1bGVdLCAvLyBpbXBvcnQgRm9ybUZpZWxkIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgRm9ybUZpZWxkTW9kdWxlIHtcbn1cbkZvcm1GaWVsZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbSGludENvbXBvbmVudCwgRXJyb3JDb21wb25lbnQsIEZvcm1GaWVsZENvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0hpbnRDb21wb25lbnQsIEVycm9yQ29tcG9uZW50LCBGb3JtRmllbGRDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIElucHV0cyBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIElucHV0cyBtb2R1bGVcbiAqIGltcG9ydCB7IElucHV0c01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqIGltcG9ydCB7IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBJbnB1dHNNb2R1bGVdLCAvLyBpbXBvcnQgSW5wdXRzIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgSW5wdXRzTW9kdWxlIHtcbn1cbklucHV0c01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1RleHRCb3hNb2R1bGUsIFNsaWRlck1vZHVsZSwgUmFuZ2VTbGlkZXJNb2R1bGUsIFN3aXRjaE1vZHVsZSwgTnVtZXJpY1RleHRCb3hNb2R1bGUsIE1hc2tlZFRleHRCb3hNb2R1bGUsIENvbG9yUGlja2VyTW9kdWxlLCBDaGVja0JveE1vZHVsZSwgUmFkaW9CdXR0b25Nb2R1bGUsIEZvcm1GaWVsZE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBDaGVja0JveE1vZHVsZSwgQ29sb3JJbnB1dENvbXBvbmVudCwgRm9jdXNPbkRvbVJlYWR5RGlyZWN0aXZlLCBDb2xvclBhbGV0dGVTZXJ2aWNlLCBNYXNraW5nU2VydmljZSwgTnVtZXJpY1RleHRCb3hNZXNzYWdlcywgUmFkaW9CdXR0b25Nb2R1bGUsIFJhbmdlU2xpZGVyQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIFJhbmdlU2xpZGVyTWVzc2FnZXMsIFNsaWRlckN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBTbGlkZXJNZXNzYWdlcywgU2xpZGVyQmFzZSwgU2xpZGVyc0NvbW1vbk1vZHVsZSwgU3dpdGNoQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIE1lc3NhZ2VzLCBUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIExvY2FsaXplZFRleHRCb3hNZXNzYWdlc0RpcmVjdGl2ZSwgVGV4dEJveE1lc3NhZ2VzLCBUZXh0Qm94UHJlZml4VGVtcGxhdGVEaXJlY3RpdmUsIFRleHRCb3hTZXBhcmF0b3JDb21wb25lbnQsIFRleHRCb3hTdWZmaXhUZW1wbGF0ZURpcmVjdGl2ZSwgVGV4dEJveENvbXBvbmVudCwgU2xpZGVyQ29tcG9uZW50LCBSYW5nZVNsaWRlckNvbXBvbmVudCwgTGFiZWxUZW1wbGF0ZURpcmVjdGl2ZSwgU3dpdGNoQ29tcG9uZW50LCBUZXh0Qm94Q29udGFpbmVyQ29tcG9uZW50LCBUZXh0Qm94RGlyZWN0aXZlLCBUZXh0QXJlYURpcmVjdGl2ZSwgTnVtZXJpY1RleHRCb3hDb21wb25lbnQsIE51bWVyaWNUZXh0Qm94Q3VzdG9tTWVzc2FnZXNDb21wb25lbnQsIE1hc2tlZFRleHRCb3hDb21wb25lbnQsIElucHV0c01vZHVsZSwgU2xpZGVyVGlja3NDb21wb25lbnQsIFNsaWRlck1vZHVsZSwgUmFuZ2VTbGlkZXJNb2R1bGUsIFN3aXRjaE1vZHVsZSwgTnVtZXJpY1RleHRCb3hNb2R1bGUsIE1hc2tlZFRleHRCb3hNb2R1bGUsIFRleHRCb3hNb2R1bGUsIENvbG9yUGlja2VyQ29tcG9uZW50LCBDb2xvclBhbGV0dGVDb21wb25lbnQsIENvbG9yR3JhZGllbnRDb21wb25lbnQsIENvbG9yUGlja2VyTW9kdWxlLCBBY3RpdmVDb2xvckNsaWNrRXZlbnQsIENoZWNrQm94RGlyZWN0aXZlLCBSYWRpb0J1dHRvbkRpcmVjdGl2ZSwgSGludENvbXBvbmVudCwgRXJyb3JDb21wb25lbnQsIEZvcm1GaWVsZENvbXBvbmVudCwgRm9ybUZpZWxkTW9kdWxlLCBMb2NhbGl6ZWROdW1lcmljVGV4dEJveE1lc3NhZ2VzRGlyZWN0aXZlLCBMb2NhbGl6ZWRTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZSwgTG9jYWxpemVkUmFuZ2VTbGlkZXJNZXNzYWdlc0RpcmVjdGl2ZSwgTG9jYWxpemVkU3dpdGNoTWVzc2FnZXNEaXJlY3RpdmUgfTtcbiJdfQ==