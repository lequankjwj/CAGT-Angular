/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { AfterViewInit, ElementRef, EventEmitter, OnInit, OnChanges, OnDestroy, NgZone, Renderer2, TemplateRef } from '@angular/core';
import { Align } from './models/align.interface';
import { Collision } from './models/collision.interface';
import { Offset } from './models/offset.interface';
import { Margin } from './models/margin.interface';
import { PositionMode } from './models/position-mode';
import { PopupAnimation } from './models/popup-animation.interface';
import { AlignService } from './services/align.service';
import { DOMService } from './services/dom.service';
import { PositionService } from './services/position.service';
import { ResizeService } from './services/resize.service';
import { ScrollableService } from './services/scrollable.service';
import { AnimationService } from './services/animation.service';
import { ResizeSensorComponent } from '@progress/kendo-angular-common';
/**
 * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <button #anchor (click)="show=!show">Toggle</button>
 *  <kendo-popup *ngIf="show" [anchor]="anchor">
 *      <strong>Popup content!</strong>
 *  </kendo-popup>
 * `
 * })
 * class AppComponent {
 *   public show: boolean = false;
 * }
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class PopupComponent implements AfterViewInit, OnInit, OnChanges, OnDestroy {
    container: ElementRef;
    private _alignService;
    domService: DOMService;
    private _positionService;
    private _resizeService;
    private _scrollableService;
    private animationService;
    private _renderer;
    private _zone;
    /**
     * Controls the Popup animation. By default, the opening and closing animations
     * are enabled ([see example]({% slug animations_popup %})).
     */
    animate: boolean | PopupAnimation;
    /**
     * Specifies the element that will be used as an anchor. The Popup opens next to that element.
     * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-components)).
     */
    anchor: ElementRef;
    /**
     * Specifies the anchor pivot point
     * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).
     */
    anchorAlign: Align;
    /**
     * Configures the collision behavior of the Popup
     * ([see example]({% slug viewportboundarydetection_popup %})).
     */
    collision: Collision;
    /**
     * Specifies the pivot point of the Popup
     * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).
     */
    popupAlign: Align;
    /**
     * Controls whether the component will copy the `anchor` font styles.
     */
    copyAnchorStyles: boolean;
    /**
     * Specifies a list of CSS classes that will be added to the internal
     * animated element ([see example]({% slug appearance_popup %})).
     *
     * > To style the content of the Popup, use this property binding.
     */
    popupClass: string | Array<string> | Object;
    /**
     * Specifies the position mode of the component. By default, the Popup uses fixed positioning.
     * To make the Popup acquire absolute positioning, set this option to `absolute`.
     *
     * > If you need to support mobile browsers with the zoom option,
     * use the `absolute` positioning of the Popup.
     *
     * @example
     * ```html
     * <style>
     *  .parent-content {
     *     position: relative;
     *     width: 200px;
     *     height: 200px;
     *     overflow: auto;
     *     margin: 200px auto;
     *     border: 1px solid red;
     *  }
     *  .content {
     *     position: relative;
     *     width: 100px;
     *     height: 100px;
     *     overflow: auto;
     *     margin: 300px;
     *     border: 1px solid blue;
     *  }
     *  .anchor {
     *     position: absolute;
     *     top: 200px;
     *     left: 200px;
     *  }
     * </style>
     * ```
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *   <div class="example-config">
     *      Position mode:
     *      <label><input type="radio" value="fixed" [(ngModel)]="mode" /> Fixed</label>
     *      <label><input type="radio" value="absolute" [(ngModel)]="mode" /> Absolute</label>
     *   </div>
     *   <div class="example-config">
     *       Append to
     *       <label>
     *           <input type="radio" name="place" [value]="1" [(ngModel)]="checked" />
     *           Root component
     *       </label>
     *       <label>
     *           <input type="radio" name="place" [value]="2" [(ngModel)]="checked" />
     *           <span style="color: red">Red Container</span>
     *       </label>
     *       <label>
     *           <input type="radio" name="place" [value]="3" [(ngModel)]="checked" />
     *           <span style="color: blue">Blue Container</span>
     *       </label>
     *   </div>
     *   <div class="example">
     *     <div class="parent-content" [scrollLeft]="250" [scrollTop]="230">
     *         <div class="content" [scrollLeft]="170" [scrollTop]="165">
     *           <button #anchor class="anchor" (click)="show = !show">Toggle</button>
     *           <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 3">
     *             <ul>
     *                 <li>Item1</li>
     *                 <li>Item2</li>
     *                 <li>Item3</li>
     *             </ul>
     *           </kendo-popup>
     *           <span style="position: absolute; top: 400px; left: 400px">Bottom/Right</span>
     *         </div>
     *         <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 2">
     *           <ul>
     *               <li>Item1</li>
     *               <li>Item2</li>
     *               <li>Item3</li>
     *           </ul>
     *         </kendo-popup>
     *         <span style="position: absolute; top: 600px; left: 600px">Bottom/Right</span>
     *     </div>
     *     <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 1">
     *       <ul>
     *           <li>Item1</li>
     *           <li>Item2</li>
     *           <li>Item3</li>
     *       </ul>
     *     </kendo-popup>
     *   </div>
     * `
     * })
     * class AppComponent {
     *   public checked: number = 3;
     *   public mode: string = 'absolute';
     *   public show: boolean = true;
     * }
     * ```
     */
    positionMode: PositionMode;
    /**
     * Specifies the absolute position of the element
     * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).
     * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.
     * The boundary detection is applied by using the window viewport.
     */
    offset: Offset;
    /**
     * Specifies the margin value that will be added to the popup dimensions in pixels and leaves a blank space
     * between the popup and the anchor ([see example]({% slug alignmentpositioning_popup %}#toc-adding-a-margin)).
     */
    margin: Margin;
    /**
     * Fires when the anchor is scrolled outside the screen boundaries.
     * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).
     */
    anchorViewportLeave: EventEmitter<any>;
    /**
     * Fires after the component is closed.
     */
    close: EventEmitter<any>;
    /**
     * Fires after the component is opened and the opening animation ends.
     */
    open: EventEmitter<any>;
    /**
     * Fires after the component is opened and the Popup is positioned.
     */
    positionChange: EventEmitter<any>;
    /**
     * @hidden
     */
    contentContainer: ElementRef;
    /**
     * @hidden
     */
    resizeSensor: ResizeSensorComponent;
    /**
     * @hidden
     */
    content: TemplateRef<any>;
    private resolvedPromise;
    private _currentOffset;
    private animationSubscriptions;
    private repositionSubscription;
    private initialCheck;
    constructor(container: ElementRef, _alignService: AlignService, domService: DOMService, _positionService: PositionService, _resizeService: ResizeService, _scrollableService: ScrollableService, animationService: AnimationService, _renderer: Renderer2, _zone: NgZone);
    ngOnInit(): void;
    ngOnChanges(changes: any): void;
    ngAfterViewInit(): void;
    ngAfterViewChecked(): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    onResize(): void;
    private onAnimationStart;
    private onAnimationEnd;
    private currentOffset;
    private setZIndex;
    private reposition;
    private position;
    private onScroll;
    private copyFontStyles;
    private updateFixedClass;
    private setContainerStyle;
    private unsubscribeReposition;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PopupComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<PopupComponent, "kendo-popup", ["kendo-popup"], { "animate": "animate"; "anchorAlign": "anchorAlign"; "collision": "collision"; "popupAlign": "popupAlign"; "copyAnchorStyles": "copyAnchorStyles"; "positionMode": "positionMode"; "offset": "offset"; "anchor": "anchor"; "popupClass": "popupClass"; "margin": "margin"; }, { "anchorViewportLeave": "anchorViewportLeave"; "close": "close"; "open": "open"; "positionChange": "positionChange"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wdXAuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInBvcHVwLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE5nWm9uZSwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWxpZ24gfSBmcm9tICcuL21vZGVscy9hbGlnbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29sbGlzaW9uIH0gZnJvbSAnLi9tb2RlbHMvY29sbGlzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBPZmZzZXQgfSBmcm9tICcuL21vZGVscy9vZmZzZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IE1hcmdpbiB9IGZyb20gJy4vbW9kZWxzL21hcmdpbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9zaXRpb25Nb2RlIH0gZnJvbSAnLi9tb2RlbHMvcG9zaXRpb24tbW9kZSc7XG5pbXBvcnQgeyBQb3B1cEFuaW1hdGlvbiB9IGZyb20gJy4vbW9kZWxzL3BvcHVwLWFuaW1hdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQWxpZ25TZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9hbGlnbi5zZXJ2aWNlJztcbmltcG9ydCB7IERPTVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2RvbS5zZXJ2aWNlJztcbmltcG9ydCB7IFBvc2l0aW9uU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvcG9zaXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9yZXNpemUuc2VydmljZSc7XG5pbXBvcnQgeyBTY3JvbGxhYmxlU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvc2Nyb2xsYWJsZS5zZXJ2aWNlJztcbmltcG9ydCB7IEFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2FuaW1hdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJlc2l6ZVNlbnNvckNvbXBvbmVudCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBQb3B1cCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfcG9wdXAgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8YnV0dG9uICNhbmNob3IgKGNsaWNrKT1cInNob3c9IXNob3dcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqICA8a2VuZG8tcG9wdXAgKm5nSWY9XCJzaG93XCIgW2FuY2hvcl09XCJhbmNob3JcIj5cbiAqICAgICAgPHN0cm9uZz5Qb3B1cCBjb250ZW50ITwvc3Ryb25nPlxuICogIDwva2VuZG8tcG9wdXA+XG4gKiBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHNob3c6IGJvb2xlYW4gPSBmYWxzZTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQb3B1cENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIGNvbnRhaW5lcjogRWxlbWVudFJlZjtcbiAgICBwcml2YXRlIF9hbGlnblNlcnZpY2U7XG4gICAgZG9tU2VydmljZTogRE9NU2VydmljZTtcbiAgICBwcml2YXRlIF9wb3NpdGlvblNlcnZpY2U7XG4gICAgcHJpdmF0ZSBfcmVzaXplU2VydmljZTtcbiAgICBwcml2YXRlIF9zY3JvbGxhYmxlU2VydmljZTtcbiAgICBwcml2YXRlIGFuaW1hdGlvblNlcnZpY2U7XG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfem9uZTtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB0aGUgUG9wdXAgYW5pbWF0aW9uLiBCeSBkZWZhdWx0LCB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBhbmltYXRpb25zXG4gICAgICogYXJlIGVuYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbmltYXRpb25zX3BvcHVwICV9KSkuXG4gICAgICovXG4gICAgYW5pbWF0ZTogYm9vbGVhbiB8IFBvcHVwQW5pbWF0aW9uO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcyBhbiBhbmNob3IuIFRoZSBQb3B1cCBvcGVucyBuZXh0IHRvIHRoYXQgZWxlbWVudC5cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1hbGlnbmluZy10by1jb21wb25lbnRzKSkuXG4gICAgICovXG4gICAgYW5jaG9yOiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYW5jaG9yIHBpdm90IHBvaW50XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtcG9zaXRpb25pbmcpKS5cbiAgICAgKi9cbiAgICBhbmNob3JBbGlnbjogQWxpZ247XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgY29sbGlzaW9uIGJlaGF2aW9yIG9mIHRoZSBQb3B1cFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmlld3BvcnRib3VuZGFyeWRldGVjdGlvbl9wb3B1cCAlfSkpLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogQ29sbGlzaW9uO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgcGl2b3QgcG9pbnQgb2YgdGhlIFBvcHVwXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtcG9zaXRpb25pbmcpKS5cbiAgICAgKi9cbiAgICBwb3B1cEFsaWduOiBBbGlnbjtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSBjb21wb25lbnQgd2lsbCBjb3B5IHRoZSBgYW5jaG9yYCBmb250IHN0eWxlcy5cbiAgICAgKi9cbiAgICBjb3B5QW5jaG9yU3R5bGVzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbnRlcm5hbFxuICAgICAqIGFuaW1hdGVkIGVsZW1lbnQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcHBlYXJhbmNlX3BvcHVwICV9KSkuXG4gICAgICpcbiAgICAgKiA+IFRvIHN0eWxlIHRoZSBjb250ZW50IG9mIHRoZSBQb3B1cCwgdXNlIHRoaXMgcHJvcGVydHkgYmluZGluZy5cbiAgICAgKi9cbiAgICBwb3B1cENsYXNzOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgT2JqZWN0O1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgcG9zaXRpb24gbW9kZSBvZiB0aGUgY29tcG9uZW50LiBCeSBkZWZhdWx0LCB0aGUgUG9wdXAgdXNlcyBmaXhlZCBwb3NpdGlvbmluZy5cbiAgICAgKiBUbyBtYWtlIHRoZSBQb3B1cCBhY3F1aXJlIGFic29sdXRlIHBvc2l0aW9uaW5nLCBzZXQgdGhpcyBvcHRpb24gdG8gYGFic29sdXRlYC5cbiAgICAgKlxuICAgICAqID4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBtb2JpbGUgYnJvd3NlcnMgd2l0aCB0aGUgem9vbSBvcHRpb24sXG4gICAgICogdXNlIHRoZSBgYWJzb2x1dGVgIHBvc2l0aW9uaW5nIG9mIHRoZSBQb3B1cC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxzdHlsZT5cbiAgICAgKiAgLnBhcmVudC1jb250ZW50IHtcbiAgICAgKiAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAqICAgICB3aWR0aDogMjAwcHg7XG4gICAgICogICAgIGhlaWdodDogMjAwcHg7XG4gICAgICogICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAqICAgICBtYXJnaW46IDIwMHB4IGF1dG87XG4gICAgICogICAgIGJvcmRlcjogMXB4IHNvbGlkIHJlZDtcbiAgICAgKiAgfVxuICAgICAqICAuY29udGVudCB7XG4gICAgICogICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgKiAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAqICAgICBoZWlnaHQ6IDEwMHB4O1xuICAgICAqICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgKiAgICAgbWFyZ2luOiAzMDBweDtcbiAgICAgKiAgICAgYm9yZGVyOiAxcHggc29saWQgYmx1ZTtcbiAgICAgKiAgfVxuICAgICAqICAuYW5jaG9yIHtcbiAgICAgKiAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAqICAgICB0b3A6IDIwMHB4O1xuICAgICAqICAgICBsZWZ0OiAyMDBweDtcbiAgICAgKiAgfVxuICAgICAqIDwvc3R5bGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1jb25maWdcIj5cbiAgICAgKiAgICAgIFBvc2l0aW9uIG1vZGU6XG4gICAgICogICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIHZhbHVlPVwiZml4ZWRcIiBbKG5nTW9kZWwpXT1cIm1vZGVcIiAvPiBGaXhlZDwvbGFiZWw+XG4gICAgICogICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIHZhbHVlPVwiYWJzb2x1dGVcIiBbKG5nTW9kZWwpXT1cIm1vZGVcIiAvPiBBYnNvbHV0ZTwvbGFiZWw+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJleGFtcGxlLWNvbmZpZ1wiPlxuICAgICAqICAgICAgIEFwcGVuZCB0b1xuICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIxXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgKiAgICAgICAgICAgUm9vdCBjb21wb25lbnRcbiAgICAgKiAgICAgICA8L2xhYmVsPlxuICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIyXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgKiAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogcmVkXCI+UmVkIENvbnRhaW5lcjwvc3Bhbj5cbiAgICAgKiAgICAgICA8L2xhYmVsPlxuICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIzXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgKiAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogYmx1ZVwiPkJsdWUgQ29udGFpbmVyPC9zcGFuPlxuICAgICAqICAgICAgIDwvbGFiZWw+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJleGFtcGxlXCI+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQtY29udGVudFwiIFtzY3JvbGxMZWZ0XT1cIjI1MFwiIFtzY3JvbGxUb3BdPVwiMjMwXCI+XG4gICAgICogICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiIFtzY3JvbGxMZWZ0XT1cIjE3MFwiIFtzY3JvbGxUb3BdPVwiMTY1XCI+XG4gICAgICogICAgICAgICAgIDxidXR0b24gI2FuY2hvciBjbGFzcz1cImFuY2hvclwiIChjbGljayk9XCJzaG93ID0gIXNob3dcIj5Ub2dnbGU8L2J1dHRvbj5cbiAgICAgKiAgICAgICAgICAgPGtlbmRvLXBvcHVwIFtwb3NpdGlvbk1vZGVdPVwibW9kZVwiIFthbmNob3JdPVwiYW5jaG9yXCIgKGFuY2hvclZpZXdwb3J0TGVhdmUpPVwic2hvdz1mYWxzZVwiICpuZ0lmPVwic2hvdyAmJiBjaGVja2VkID09PSAzXCI+XG4gICAgICogICAgICAgICAgICAgPHVsPlxuICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTE8L2xpPlxuICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTI8L2xpPlxuICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTM8L2xpPlxuICAgICAqICAgICAgICAgICAgIDwvdWw+XG4gICAgICogICAgICAgICAgIDwva2VuZG8tcG9wdXA+XG4gICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDQwMHB4OyBsZWZ0OiA0MDBweFwiPkJvdHRvbS9SaWdodDwvc3Bhbj5cbiAgICAgKiAgICAgICAgIDwvZGl2PlxuICAgICAqICAgICAgICAgPGtlbmRvLXBvcHVwIFtwb3NpdGlvbk1vZGVdPVwibW9kZVwiIFthbmNob3JdPVwiYW5jaG9yXCIgKGFuY2hvclZpZXdwb3J0TGVhdmUpPVwic2hvdz1mYWxzZVwiICpuZ0lmPVwic2hvdyAmJiBjaGVja2VkID09PSAyXCI+XG4gICAgICogICAgICAgICAgIDx1bD5cbiAgICAgKiAgICAgICAgICAgICAgIDxsaT5JdGVtMTwvbGk+XG4gICAgICogICAgICAgICAgICAgICA8bGk+SXRlbTI8L2xpPlxuICAgICAqICAgICAgICAgICAgICAgPGxpPkl0ZW0zPC9saT5cbiAgICAgKiAgICAgICAgICAgPC91bD5cbiAgICAgKiAgICAgICAgIDwva2VuZG8tcG9wdXA+XG4gICAgICogICAgICAgICA8c3BhbiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA2MDBweDsgbGVmdDogNjAwcHhcIj5Cb3R0b20vUmlnaHQ8L3NwYW4+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDFcIj5cbiAgICAgKiAgICAgICA8dWw+XG4gICAgICogICAgICAgICAgIDxsaT5JdGVtMTwvbGk+XG4gICAgICogICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICogICAgICAgICAgIDxsaT5JdGVtMzwvbGk+XG4gICAgICogICAgICAgPC91bD5cbiAgICAgKiAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgKiAgIDwvZGl2PlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICBwdWJsaWMgY2hlY2tlZDogbnVtYmVyID0gMztcbiAgICAgKiAgIHB1YmxpYyBtb2RlOiBzdHJpbmcgPSAnYWJzb2x1dGUnO1xuICAgICAqICAgcHVibGljIHNob3c6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwb3NpdGlvbk1vZGU6IFBvc2l0aW9uTW9kZTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtYWxpZ25pbmctdG8tYWJzb2x1dGUtcG9pbnRzKSkuXG4gICAgICogVGhlIFBvcHVwIG9wZW5zIG5leHQgdG8gdGhhdCBwb2ludC4gVGhlIFBvcHVwIHBpdm90IHBvaW50IGlzIGRlZmluZWQgYnkgdGhlIGBwb3B1cEFsaWduYCBjb25maWd1cmF0aW9uIG9wdGlvbi5cbiAgICAgKiBUaGUgYm91bmRhcnkgZGV0ZWN0aW9uIGlzIGFwcGxpZWQgYnkgdXNpbmcgdGhlIHdpbmRvdyB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBvZmZzZXQ6IE9mZnNldDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG1hcmdpbiB2YWx1ZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHBvcHVwIGRpbWVuc2lvbnMgaW4gcGl4ZWxzIGFuZCBsZWF2ZXMgYSBibGFuayBzcGFjZVxuICAgICAqIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYW5jaG9yIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYWxpZ25tZW50cG9zaXRpb25pbmdfcG9wdXAgJX0jdG9jLWFkZGluZy1hLW1hcmdpbikpLlxuICAgICAqL1xuICAgIG1hcmdpbjogTWFyZ2luO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGFuY2hvciBpcyBzY3JvbGxlZCBvdXRzaWRlIHRoZSBzY3JlZW4gYm91bmRhcmllcy5cbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNsb3NpbmdfcG9wdXAgJX0jdG9jLWFmdGVyLWxlYXZpbmctdGhlLXZpZXdwb3J0KSkuXG4gICAgICovXG4gICAgYW5jaG9yVmlld3BvcnRMZWF2ZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgY2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgb3BlbmVkIGFuZCB0aGUgb3BlbmluZyBhbmltYXRpb24gZW5kcy5cbiAgICAgKi9cbiAgICBvcGVuOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBhZnRlciB0aGUgY29tcG9uZW50IGlzIG9wZW5lZCBhbmQgdGhlIFBvcHVwIGlzIHBvc2l0aW9uZWQuXG4gICAgICovXG4gICAgcG9zaXRpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb250ZW50Q29udGFpbmVyOiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZXNpemVTZW5zb3I6IFJlc2l6ZVNlbnNvckNvbXBvbmVudDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29udGVudDogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBwcml2YXRlIHJlc29sdmVkUHJvbWlzZTtcbiAgICBwcml2YXRlIF9jdXJyZW50T2Zmc2V0O1xuICAgIHByaXZhdGUgYW5pbWF0aW9uU3Vic2NyaXB0aW9ucztcbiAgICBwcml2YXRlIHJlcG9zaXRpb25TdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBpbml0aWFsQ2hlY2s7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyOiBFbGVtZW50UmVmLCBfYWxpZ25TZXJ2aWNlOiBBbGlnblNlcnZpY2UsIGRvbVNlcnZpY2U6IERPTVNlcnZpY2UsIF9wb3NpdGlvblNlcnZpY2U6IFBvc2l0aW9uU2VydmljZSwgX3Jlc2l6ZVNlcnZpY2U6IFJlc2l6ZVNlcnZpY2UsIF9zY3JvbGxhYmxlU2VydmljZTogU2Nyb2xsYWJsZVNlcnZpY2UsIGFuaW1hdGlvblNlcnZpY2U6IEFuaW1hdGlvblNlcnZpY2UsIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBfem9uZTogTmdab25lKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IGFueSk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoKTogdm9pZDtcbiAgICBwcml2YXRlIG9uQW5pbWF0aW9uU3RhcnQ7XG4gICAgcHJpdmF0ZSBvbkFuaW1hdGlvbkVuZDtcbiAgICBwcml2YXRlIGN1cnJlbnRPZmZzZXQ7XG4gICAgcHJpdmF0ZSBzZXRaSW5kZXg7XG4gICAgcHJpdmF0ZSByZXBvc2l0aW9uO1xuICAgIHByaXZhdGUgcG9zaXRpb247XG4gICAgcHJpdmF0ZSBvblNjcm9sbDtcbiAgICBwcml2YXRlIGNvcHlGb250U3R5bGVzO1xuICAgIHByaXZhdGUgdXBkYXRlRml4ZWRDbGFzcztcbiAgICBwcml2YXRlIHNldENvbnRhaW5lclN0eWxlO1xuICAgIHByaXZhdGUgdW5zdWJzY3JpYmVSZXBvc2l0aW9uO1xufVxuIl19