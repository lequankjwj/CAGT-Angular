/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, ViewChildren, QueryList, Input } from '@angular/core';
import { RecurrenceService } from './recurrence.service';
import { isPresent } from '../../common/util';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { EndRuleRadioButtonDirective } from './end-rule-radio-button.directive';
import { ZonedDate } from '@progress/kendo-date-math';
import { toUTCDate } from '../../views/utils';
/**
 * @hidden
 */
export class RecurrenceEndRuleEditorComponent {
    constructor(recurrence, localization) {
        this.recurrence = recurrence;
        this.localization = localization;
        this.numericOptions = {
            min: 1,
            format: '#',
            autoCorrect: true,
            step: 1,
            spinners: true
        };
        this.datePickerOptions = {
            activeView: 'month',
            bottomView: 'month',
            topView: 'century',
            disabledDatesValidation: true,
            navigation: true,
            format: 'd'
        };
        this.uniqueId = this.recurrence.getUniqueId();
        this.setInitialValues();
        this.subscribeChanges();
    }
    set userNumericOptions(options) {
        this.numericOptions = Object.assign({}, this.numericOptions, options);
    }
    set userDatePickerOptions(options) {
        this.datePickerOptions = Object.assign({}, this.datePickerOptions, options);
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    setEndRule(endRule) {
        if (endRule === 'count') {
            this.recurrence.rrule.count = this.countValue;
        }
        else if (endRule === 'until') {
            this.recurrence.until = this.untilValue;
        }
    }
    get rrule() {
        return this.recurrence.rrule;
    }
    get isCountDisabled() {
        return this.recurrence.endRule !== 'count';
    }
    get isUntilDisabled() {
        return this.recurrence.endRule !== 'until';
    }
    onCountChange(value) {
        if (isPresent(value)) {
            this.recurrence.count = value;
        }
    }
    onCountBlur() {
        if (!isPresent(this.countValue)) {
            this.recurrence.count = this.countValue = 1;
        }
    }
    onUntilChange(value) {
        if (isPresent(value)) {
            this.recurrence.until = this.createUntil(value);
        }
    }
    onUntilBlur() {
        if (!isPresent(this.untilValue)) {
            this.recurrence.until = this.untilValue = this.createUntil(this.recurrence.start);
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onEndLabelClick() {
        const selected = this.endRuleRadioButtons.toArray().find(r => r.elem.checked);
        if (selected) {
            selected.elem.focus();
        }
    }
    setInitialValues() {
        this.countValue = this.rrule.count || 1;
        const currentUntil = this.recurrence.until;
        const currentStart = this.recurrence.start;
        this.untilValue = isPresent(currentUntil) ? currentUntil : this.createUntil(currentStart);
    }
    subscribeChanges() {
        this.subscriptions = this.recurrence.endRuleChange.subscribe((endRule) => {
            this.setEndRule(endRule);
        });
        this.subscriptions.add(this.recurrence.frequencyChange.subscribe(() => {
            this.setInitialValues();
        }));
    }
    createUntil(until) {
        // Read the until date as UTC date parts to avoid interfering with the local time zone.
        const untilDate = toUTCDate(until);
        untilDate.setUTCDate(untilDate.getUTCDate() + 1);
        // Convert to the scheduler time zone.
        return ZonedDate.fromUTCDate(untilDate, this.recurrence.timezone).toLocalDate();
    }
}
RecurrenceEndRuleEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'kendo-recurrence-end-rule-editor',
                template: `
        <div class='k-edit-label'>
            <label (click)="onEndLabelClick()">{{ textFor('endLabel') }}</label>
        </div>
        <div class='k-edit-field'>
            <ul class='k-reset'>
                <li>
                    <input kendoRecurrenceEndRuleRadioButton='k-endrule-never-{{uniqueId}}' />
                    <label class='k-radio-label' for='k-endrule-never-{{uniqueId}}'>{{ textFor('endNever') }}</label>
                </li>
                <li>
                    <input kendoRecurrenceEndRuleRadioButton='k-endrule-count-{{uniqueId}}' />
                    <label class='k-radio-label' for='k-endrule-count-{{uniqueId}}'>{{ textFor('endAfter') }}</label>

                    <kendo-numerictextbox
                        [style.width.px]='70'
                        [autoCorrect]='numericOptions.autoCorrect'
                        [decimals]='0'
                        [disabled]='isCountDisabled'
                        [format]="numericOptions.format"
                        [min]='numericOptions.min'
                        [max]="numericOptions.max"
                        [readonly]="numericOptions.readonly"
                        [selectOnFocus]="numericOptions.selectOnFocus"
                        [spinners]="numericOptions.spinners"
                        [step]="numericOptions.step"
                        [title]="numericOptions.title"
                        [(value)]='countValue'
                        (blur)="onCountBlur()"
                        (valueChange)='onCountChange($event)'>
                    </kendo-numerictextbox>
                    <span>{{ textFor('endOccurrence') }}</span>
                </li>
                <li>
                    <input kendoRecurrenceEndRuleRadioButton='k-endrule-until-{{uniqueId}}' />
                    <label class='k-radio-label' for='k-endrule-until-{{uniqueId}}'>{{ textFor('endOn') }}</label>

                    <kendo-datepicker
                        [style.width.px]='150'
                        [disabled]='isUntilDisabled'
                        [activeView]="datePickerOptions.activeView"
                        [bottomView]="datePickerOptions.bottomView"
                        [disabledDatesValidation]="datePickerOptions.disabledDatesValidation"
                        [focusedDate]="datePickerOptions.focusedDate"
                        [format]="datePickerOptions.format"
                        [formatPlaceholder]="datePickerOptions.formatPlaceHolder"
                        [max]="datePickerOptions.max"
                        [min]="datePickerOptions.min"
                        [navigation]="datePickerOptions.navigation"
                        [placeholder]="datePickerOptions.placeholder"
                        [readOnlyInput]="datePickerOptions.readOnlyInput"
                        [readonly]="datePickerOptions.readonly"
                        [title]="datePickerOptions.title"
                        [topView]="datePickerOptions.topView"
                        [weekNumber]="datePickerOptions.weekNumber"
                        [disabledDates]="datePickerOptions.disabledDates"
                        [popupSettings]="datePickerOptions.popupSettings"
                        [(value)]='untilValue'
                        (blur)="onUntilBlur()"
                        (valueChange)='onUntilChange($event)'>
                    </kendo-datepicker>
                </li>
            </ul>
        </div>
    `
            },] },
];
/** @nocollapse */
RecurrenceEndRuleEditorComponent.ctorParameters = () => [
    { type: RecurrenceService },
    { type: LocalizationService }
];
RecurrenceEndRuleEditorComponent.propDecorators = {
    userNumericOptions: [{ type: Input }],
    userDatePickerOptions: [{ type: Input }],
    endRuleRadioButtons: [{ type: ViewChildren, args: [EndRuleRadioButtonDirective,] }]
};
