/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ChangeDetectorRef, EventEmitter, ElementRef, OnInit, OnDestroy, OnChanges, Renderer2, NgZone, Injector, SimpleChanges } from '@angular/core';
import { AbstractControl, ControlValueAccessor, Validator } from '@angular/forms';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { IntlService } from '@progress/kendo-angular-intl';
import { Arrow } from './arrow.enum';
import { DateInputFormatPlaceholder } from './models/format-placeholder.model';
import { DateInputIncrementalSteps } from './models/incremental-steps.model';
import { PickerService } from '../common/picker.service';
/**
 * Represents the [Kendo UI DateInput component for Angular]({% slug overview_dateinput %}#toc-basic-usage).
 */
import * as ɵngcc0 from '@angular/core';
export declare class DateInputComponent implements OnInit, ControlValueAccessor, OnChanges, OnDestroy, Validator {
    private cdr;
    private intl;
    private renderer;
    private element;
    private ngZone;
    private injector;
    localization: LocalizationService;
    private pickerService?;
    /**
     * @hidden
     */
    focusableId: string;
    /**
     * Sets or gets the `disabled` property of the DateInput and
     * determines whether the component is active
     * ([see example]({% slug disabled_dateinput %})).
     */
    disabled: boolean;
    /**
     * Sets or gets the read-only state of the DateInput
     * ([see example]({% slug readonly_dateinput %})).
     */
    readonly: boolean;
    /**
     * Sets the title of the input element of the DateInput.
     */
    title: string;
    /**
     * Sets or gets the `tabIndex` property of the DateInput.
     * .
     */
    tabindex: number;
    /**
     * @hidden
     */
    role: string;
    /**
     * @hidden
     */
    ariaReadOnly: boolean;
    /**
     * @hidden
     */
    tabIndex: number;
    /**
     * Specifies the date format that is used to display the input value
     * ([see example]({% slug formats_dateinput %})).
     */
    format: string;
    /**
     * Defines the descriptions of the format sections in the input field.
     * For more information, refer to the article on
     * [placeholders]({% slug placeholders_dateinput %}).
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     * <div class="row example-wrapper" style="min-height: 450px;">
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Full-length format description:</p>
     *    <kendo-dateinput formatPlaceholder="wide"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Narrow-length format description:</p>
     *    <kendo-dateinput formatPlaceholder="narrow"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Short-length format description:</p>
     *    <kendo-dateinput formatPlaceholder="short"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Display defined format:</p>
     *    <kendo-dateinput format="MM/dd/yyyy" formatPlaceholder="formatPattern"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Custom defined format descriptions</p>
     *    <kendo-dateinput format="G"
     *      [formatPlaceholder]="{
     *        year: 'y', month: 'M', day: 'd',
     *        hour: 'h', minute: 'm', second: 's'
     *      }"
     *    ></kendo-dateinput>
     *  </div>
     * </div>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    formatPlaceholder: DateInputFormatPlaceholder;
    /**
     * Specifies the hint the DateInput displays when its value is `null`.
     * For more information, refer to the article on
     * [placeholders]({% slug placeholders_dateinput %}).
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-dateinput placeholder="Enter birth date..."></kendo-dateinput>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    placeholder: string;
    /**
     * Configures the incremental steps of the DateInput.
     * For more information, refer to the article on
     * [incremental steps]({% slug incrementalsteps_dateinput %}).
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-dateinput [steps]="steps"></kendo-dateinput>
     * `
     * })
     * export class AppComponent {
     *   public steps = { year: 10, month: 1, day: 5 };
     * }
     * ```
     */
    steps: DateInputIncrementalSteps;
    /**
     * Specifies the biggest date that is valid
     * ([see example]({% slug dateranges_dateinput %})).
     */
    max: Date;
    /**
     * Specifies the smallest date that is valid
     * ([see example]({% slug dateranges_dateinput %})).
     */
    min: Date;
    /**
     * Determines whether the built-in min or max validators are to be enforced when a form is being validated.
     */
    rangeValidation: boolean;
    /**
     * @hidden
     * Based on the min and max values, specifies whether the value will be auto-corrected while typing.
     */
    autoCorrect: boolean;
    /**
     * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
     */
    incompleteDateValidation: boolean;
    /**
     * Specifies the value of the DateInput component.
     *
     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.
     */
    value: Date;
    /**
     * Specifies whether the **Up** and **Down** spin buttons will be rendered.
     * For more information, refer to the article on
     * [spinner buttons]({% slug spinbuttons_dateinput %}).
     */
    spinners: boolean;
    /**
     * @hidden
     */
    isPopupOpen: boolean;
    /**
     * @hidden
     */
    hasPopup: boolean;
    /**
     * Fires each time the user selects a new value.
     * For more information, refer to the section on
     * [events]({% slug overview_dateinput %}#toc-events).
     */
    valueChange: EventEmitter<Date>;
    /**
     * Fires each time the user selects a new value.
     * For more information, refer to the section on
     * [events]({% slug overview_dateinput %}#toc-events).
     */
    valueUpdate: EventEmitter<Date>;
    /**
     * Fires each time the user focuses the input element.
     * For more information, refer to the section on
     * [events]({% slug overview_dateinput %}#toc-events).
     *
     * > To wire the event programmatically, use the `onFocus` property.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-dateinput (focus)="handleFocus()"></kendo-dateinput>
     * `
     * })
     * export class AppComponent {
     *   public handleFocus(): void {
     *      console.log("Component is focused");
     *   }
     * }
     * ```
     *
     */
    onFocus: EventEmitter<null>;
    /**
     * Fires each time the input element gets blurred.
     * For more information, refer to the section on
     * [events]({% slug overview_dateinput %}#toc-events).
     *
     * > To wire the event programmatically, use the `onBlur` property.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <kendo-dateinput (blur)="handleBlur()"></kendo-dateinput>
     * `
     * })
     * export class AppComponent {
     *   public handleBlur(): void {
     *      console.log("Component is blurred");
     *   }
     * }
     * ```
     *
     */
    onBlur: EventEmitter<null>;
    /**
     * @hidden
     */
    dateInput: ElementRef;
    /**
     * @hidden
     */
    wrap: ElementRef;
    readonly wrapperClass: boolean;
    readonly disabledClass: boolean;
    readonly inputElement: any;
    readonly inputValue: string;
    isActive: boolean;
    arrow: any;
    arrowDirection: Arrow;
    formatSections: {
        [x: string]: boolean;
    };
    hasMousedown: boolean;
    focusedPriorToMousedown: boolean;
    /**
     * @hidden
     */
    isDateIncomplete: boolean;
    protected currentValue: string;
    protected currentFormat: string;
    private backspace;
    private resetSegmentValue;
    private symbolsMap;
    private minValidator;
    private maxValidator;
    private incompleteValidator;
    private _value;
    private _active;
    private kendoDate;
    private intlSubscription;
    private paste;
    private domEvents;
    private ngControl;
    private onControlChange;
    private onControlTouched;
    private onValidatorChange;
    constructor(cdr: ChangeDetectorRef, intl: IntlService, renderer: Renderer2, element: ElementRef, ngZone: NgZone, injector: Injector, localization: LocalizationService, pickerService?: PickerService);
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty
     */
    isEmpty(): boolean;
    /**
     * @hidden
     */
    containsElement(element: any): boolean;
    /**
     * @hidden
     */
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    validate(control: AbstractControl): {
        [key: string]: any;
    };
    /**
     * @hidden
     */
    registerOnValidatorChange(fn: Function): void;
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * @hidden
     */
    writeValue(value: Date): void;
    /**
     * @hidden
     */
    triggerChange(): void;
    /**
     * @hidden
     */
    notify(): void;
    /**
     * @hidden
     */
    registerOnChange(fn: () => any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: () => any): void;
    /**
     * Focuses the DateInput component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="dateinput.focus()">Focus date input</button>
     *  <kendo-dateinput #dateinput></kendo-dateinput>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus(): void;
    /**
     * Blurs the DateInput component.
     */
    blur(): void;
    /**
     * @hidden
     */
    handleButtonClick(offset: number): void;
    /**
     * @hidden
     */
    modifyDateSegmentValue(offset: number): void;
    /**
     * @hidden
     */
    protected switchDateSegment(offset: number): boolean;
    /**
     * @hidden
     */
    protected selectDateSegment(symbol: string): void;
    /**
     * @hidden
     */
    handleClick(): void;
    /**
     * @hidden
     */
    handleDragAndDrop(args: any): void;
    /**
     * @hidden
     */
    handleMousedown(): void;
    /**
     * @hidden
     */
    handleFocus(args: any): void;
    /**
     * @hidden
     */
    handleBlur(args: any): void;
    private getKendoDate;
    private dateSymbolMap;
    private updateElementValue;
    private caret;
    private selectNearestSegment;
    private verifyRange;
    private verifyValue;
    private putDateInRange;
    private updateFormatSections;
    private intlChange;
    private updateOnPaste;
    private bindEvents;
    private handleMouseWheel;
    private handlePaste;
    private handleKeydown;
    private handleInput;
    private emitFocus;
    private emitBlur;
    private updateIncompleteValidationStatus;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DateInputComponent, [null, null, null, null, null, null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DateInputComponent, "kendo-dateinput", ["kendo-dateinput"], { "focusableId": "focusableId"; "disabled": "disabled"; "readonly": "readonly"; "title": "title"; "tabindex": "tabindex"; "role": "role"; "ariaReadOnly": "ariaReadOnly"; "format": "format"; "placeholder": "placeholder"; "rangeValidation": "rangeValidation"; "autoCorrect": "autoCorrect"; "incompleteDateValidation": "incompleteDateValidation"; "spinners": "spinners"; "isPopupOpen": "isPopupOpen"; "hasPopup": "hasPopup"; "tabIndex": "tabIndex"; "value": "value"; "formatPlaceholder": "formatPlaceholder"; "steps": "steps"; "max": "max"; "min": "min"; }, { "valueChange": "valueChange"; "valueUpdate": "valueUpdate"; "onFocus": "focus"; "onBlur": "blur"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZWlucHV0LmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJkYXRlaW5wdXQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMsIFJlbmRlcmVyMiwgTmdab25lLCBJbmplY3RvciwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgSW50bFNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnRsJztcbmltcG9ydCB7IEFycm93IH0gZnJvbSAnLi9hcnJvdy5lbnVtJztcbmltcG9ydCB7IERhdGVJbnB1dEZvcm1hdFBsYWNlaG9sZGVyIH0gZnJvbSAnLi9tb2RlbHMvZm9ybWF0LXBsYWNlaG9sZGVyLm1vZGVsJztcbmltcG9ydCB7IERhdGVJbnB1dEluY3JlbWVudGFsU3RlcHMgfSBmcm9tICcuL21vZGVscy9pbmNyZW1lbnRhbC1zdGVwcy5tb2RlbCc7XG5pbXBvcnQgeyBQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3BpY2tlci5zZXJ2aWNlJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW0tlbmRvIFVJIERhdGVJbnB1dCBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZWlucHV0ICV9I3RvYy1iYXNpYy11c2FnZSkuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERhdGVJbnB1dENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBWYWxpZGF0b3Ige1xuICAgIHByaXZhdGUgY2RyO1xuICAgIHByaXZhdGUgaW50bDtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgZWxlbWVudDtcbiAgICBwcml2YXRlIG5nWm9uZTtcbiAgICBwcml2YXRlIGluamVjdG9yO1xuICAgIGxvY2FsaXphdGlvbjogTG9jYWxpemF0aW9uU2VydmljZTtcbiAgICBwcml2YXRlIHBpY2tlclNlcnZpY2U/O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb2N1c2FibGVJZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYGRpc2FibGVkYCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZUlucHV0IGFuZFxuICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFjdGl2ZVxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGlzYWJsZWRfZGF0ZWlucHV0ICV9KSkuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSByZWFkLW9ubHkgc3RhdGUgb2YgdGhlIERhdGVJbnB1dFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVhZG9ubHlfZGF0ZWlucHV0ICV9KSkuXG4gICAgICovXG4gICAgcmVhZG9ubHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGl0bGUgb2YgdGhlIGlucHV0IGVsZW1lbnQgb2YgdGhlIERhdGVJbnB1dC5cbiAgICAgKi9cbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYHRhYkluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgRGF0ZUlucHV0LlxuICAgICAqIC5cbiAgICAgKi9cbiAgICB0YWJpbmRleDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByb2xlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFyaWFSZWFkT25seTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGFiSW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRhdGUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IHRoZSBpbnB1dCB2YWx1ZVxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZm9ybWF0c19kYXRlaW5wdXQgJX0pKS5cbiAgICAgKi9cbiAgICBmb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBkZXNjcmlwdGlvbnMgb2YgdGhlIGZvcm1hdCBzZWN0aW9ucyBpbiB0aGUgaW5wdXQgZmllbGQuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICogW3BsYWNlaG9sZGVyc10oeyUgc2x1ZyBwbGFjZWhvbGRlcnNfZGF0ZWlucHV0ICV9KS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogPGRpdiBjbGFzcz1cInJvdyBleGFtcGxlLXdyYXBwZXJcIiBzdHlsZT1cIm1pbi1oZWlnaHQ6IDQ1MHB4O1wiPlxuICAgICAqICA8ZGl2IGNsYXNzPVwiY29sLXhzLTEyIGNvbC1tZC02IGV4YW1wbGUtY29sXCI+XG4gICAgICogICAgPHA+RnVsbC1sZW5ndGggZm9ybWF0IGRlc2NyaXB0aW9uOjwvcD5cbiAgICAgKiAgICA8a2VuZG8tZGF0ZWlucHV0IGZvcm1hdFBsYWNlaG9sZGVyPVwid2lkZVwiPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAqICA8L2Rpdj5cbiAgICAgKlxuICAgICAqICA8ZGl2IGNsYXNzPVwiY29sLXhzLTEyIGNvbC1tZC02IGV4YW1wbGUtY29sXCI+XG4gICAgICogICAgPHA+TmFycm93LWxlbmd0aCBmb3JtYXQgZGVzY3JpcHRpb246PC9wPlxuICAgICAqICAgIDxrZW5kby1kYXRlaW5wdXQgZm9ybWF0UGxhY2Vob2xkZXI9XCJuYXJyb3dcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgKiAgPC9kaXY+XG4gICAgICpcbiAgICAgKiAgPGRpdiBjbGFzcz1cImNvbC14cy0xMiBjb2wtbWQtNiBleGFtcGxlLWNvbFwiPlxuICAgICAqICAgIDxwPlNob3J0LWxlbmd0aCBmb3JtYXQgZGVzY3JpcHRpb246PC9wPlxuICAgICAqICAgIDxrZW5kby1kYXRlaW5wdXQgZm9ybWF0UGxhY2Vob2xkZXI9XCJzaG9ydFwiPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAqICA8L2Rpdj5cbiAgICAgKlxuICAgICAqICA8ZGl2IGNsYXNzPVwiY29sLXhzLTEyIGNvbC1tZC02IGV4YW1wbGUtY29sXCI+XG4gICAgICogICAgPHA+RGlzcGxheSBkZWZpbmVkIGZvcm1hdDo8L3A+XG4gICAgICogICAgPGtlbmRvLWRhdGVpbnB1dCBmb3JtYXQ9XCJNTS9kZC95eXl5XCIgZm9ybWF0UGxhY2Vob2xkZXI9XCJmb3JtYXRQYXR0ZXJuXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogIDwvZGl2PlxuICAgICAqXG4gICAgICogIDxkaXYgY2xhc3M9XCJjb2wteHMtMTIgY29sLW1kLTYgZXhhbXBsZS1jb2xcIj5cbiAgICAgKiAgICA8cD5DdXN0b20gZGVmaW5lZCBmb3JtYXQgZGVzY3JpcHRpb25zPC9wPlxuICAgICAqICAgIDxrZW5kby1kYXRlaW5wdXQgZm9ybWF0PVwiR1wiXG4gICAgICogICAgICBbZm9ybWF0UGxhY2Vob2xkZXJdPVwie1xuICAgICAqICAgICAgICB5ZWFyOiAneScsIG1vbnRoOiAnTScsIGRheTogJ2QnLFxuICAgICAqICAgICAgICBob3VyOiAnaCcsIG1pbnV0ZTogJ20nLCBzZWNvbmQ6ICdzJ1xuICAgICAqICAgICAgfVwiXG4gICAgICogICAgPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAqICA8L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZvcm1hdFBsYWNlaG9sZGVyOiBEYXRlSW5wdXRGb3JtYXRQbGFjZWhvbGRlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGhpbnQgdGhlIERhdGVJbnB1dCBkaXNwbGF5cyB3aGVuIGl0cyB2YWx1ZSBpcyBgbnVsbGAuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICogW3BsYWNlaG9sZGVyc10oeyUgc2x1ZyBwbGFjZWhvbGRlcnNfZGF0ZWlucHV0ICV9KS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxrZW5kby1kYXRlaW5wdXQgcGxhY2Vob2xkZXI9XCJFbnRlciBiaXJ0aCBkYXRlLi4uXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGluY3JlbWVudGFsIHN0ZXBzIG9mIHRoZSBEYXRlSW5wdXQuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICogW2luY3JlbWVudGFsIHN0ZXBzXSh7JSBzbHVnIGluY3JlbWVudGFsc3RlcHNfZGF0ZWlucHV0ICV9KS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxrZW5kby1kYXRlaW5wdXQgW3N0ZXBzXT1cInN0ZXBzXCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICBwdWJsaWMgc3RlcHMgPSB7IHllYXI6IDEwLCBtb250aDogMSwgZGF5OiA1IH07XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0ZXBzOiBEYXRlSW5wdXRJbmNyZW1lbnRhbFN0ZXBzO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgYmlnZ2VzdCBkYXRlIHRoYXQgaXMgdmFsaWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGVyYW5nZXNfZGF0ZWlucHV0ICV9KSkuXG4gICAgICovXG4gICAgbWF4OiBEYXRlO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgc21hbGxlc3QgZGF0ZSB0aGF0IGlzIHZhbGlkXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRlcmFuZ2VzX2RhdGVpbnB1dCAlfSkpLlxuICAgICAqL1xuICAgIG1pbjogRGF0ZTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1aWx0LWluIG1pbiBvciBtYXggdmFsaWRhdG9ycyBhcmUgdG8gYmUgZW5mb3JjZWQgd2hlbiBhIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkLlxuICAgICAqL1xuICAgIHJhbmdlVmFsaWRhdGlvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQmFzZWQgb24gdGhlIG1pbiBhbmQgbWF4IHZhbHVlcywgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHZhbHVlIHdpbGwgYmUgYXV0by1jb3JyZWN0ZWQgd2hpbGUgdHlwaW5nLlxuICAgICAqL1xuICAgIGF1dG9Db3JyZWN0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYnVpbHQtaW4gdmFsaWRhdGlvbiBmb3IgaW5jb21wbGV0ZSBkYXRlcyBpcyB0byBiZSBlbmZvcmNlZCB3aGVuIGEgZm9ybSBpcyBiZWluZyB2YWxpZGF0ZWQuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZURhdGVWYWxpZGF0aW9uOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIERhdGVJbnB1dCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiA+IFRoZSBgdmFsdWVgIGhhcyB0byBiZSBhIHZhbGlkIFtKYXZhU2NyaXB0IGBEYXRlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZSkgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdmFsdWU6IERhdGU7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlICoqVXAqKiBhbmQgKipEb3duKiogc3BpbiBidXR0b25zIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICogW3NwaW5uZXIgYnV0dG9uc10oeyUgc2x1ZyBzcGluYnV0dG9uc19kYXRlaW5wdXQgJX0pLlxuICAgICAqL1xuICAgIHNwaW5uZXJzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc1BvcHVwT3BlbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFzUG9wdXA6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRmlyZXMgZWFjaCB0aW1lIHRoZSB1c2VyIHNlbGVjdHMgYSBuZXcgdmFsdWUuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICogW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19kYXRlaW5wdXQgJX0jdG9jLWV2ZW50cykuXG4gICAgICovXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHVzZXIgc2VsZWN0cyBhIG5ldyB2YWx1ZS5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVpbnB1dCAlfSN0b2MtZXZlbnRzKS5cbiAgICAgKi9cbiAgICB2YWx1ZVVwZGF0ZTogRXZlbnRFbWl0dGVyPERhdGU+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgdXNlciBmb2N1c2VzIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZWlucHV0ICV9I3RvYy1ldmVudHMpLlxuICAgICAqXG4gICAgICogPiBUbyB3aXJlIHRoZSBldmVudCBwcm9ncmFtbWF0aWNhbGx5LCB1c2UgdGhlIGBvbkZvY3VzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxrZW5kby1kYXRlaW5wdXQgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgKiBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgIHB1YmxpYyBoYW5kbGVGb2N1cygpOiB2b2lkIHtcbiAgICAgKiAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IGlzIGZvY3VzZWRcIik7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgb25Gb2N1czogRXZlbnRFbWl0dGVyPG51bGw+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgaW5wdXQgZWxlbWVudCBnZXRzIGJsdXJyZWQuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICogW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19kYXRlaW5wdXQgJX0jdG9jLWV2ZW50cykuXG4gICAgICpcbiAgICAgKiA+IFRvIHdpcmUgdGhlIGV2ZW50IHByb2dyYW1tYXRpY2FsbHksIHVzZSB0aGUgYG9uQmx1cmAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiB0ZW1wbGF0ZTogYFxuICAgICAqICA8a2VuZG8tZGF0ZWlucHV0IChibHVyKT1cImhhbmRsZUJsdXIoKVwiPjwva2VuZG8tZGF0ZWlucHV0PlxuICAgICAqIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgcHVibGljIGhhbmRsZUJsdXIoKTogdm9pZCB7XG4gICAgICogICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudCBpcyBibHVycmVkXCIpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQmx1cjogRXZlbnRFbWl0dGVyPG51bGw+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkYXRlSW5wdXQ6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyYXA6IEVsZW1lbnRSZWY7XG4gICAgcmVhZG9ubHkgd3JhcHBlckNsYXNzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRpc2FibGVkQ2xhc3M6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgaW5wdXRFbGVtZW50OiBhbnk7XG4gICAgcmVhZG9ubHkgaW5wdXRWYWx1ZTogc3RyaW5nO1xuICAgIGlzQWN0aXZlOiBib29sZWFuO1xuICAgIGFycm93OiBhbnk7XG4gICAgYXJyb3dEaXJlY3Rpb246IEFycm93O1xuICAgIGZvcm1hdFNlY3Rpb25zOiB7XG4gICAgICAgIFt4OiBzdHJpbmddOiBib29sZWFuO1xuICAgIH07XG4gICAgaGFzTW91c2Vkb3duOiBib29sZWFuO1xuICAgIGZvY3VzZWRQcmlvclRvTW91c2Vkb3duOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc0RhdGVJbmNvbXBsZXRlOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBjdXJyZW50VmFsdWU6IHN0cmluZztcbiAgICBwcm90ZWN0ZWQgY3VycmVudEZvcm1hdDogc3RyaW5nO1xuICAgIHByaXZhdGUgYmFja3NwYWNlO1xuICAgIHByaXZhdGUgcmVzZXRTZWdtZW50VmFsdWU7XG4gICAgcHJpdmF0ZSBzeW1ib2xzTWFwO1xuICAgIHByaXZhdGUgbWluVmFsaWRhdG9yO1xuICAgIHByaXZhdGUgbWF4VmFsaWRhdG9yO1xuICAgIHByaXZhdGUgaW5jb21wbGV0ZVZhbGlkYXRvcjtcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICBwcml2YXRlIF9hY3RpdmU7XG4gICAgcHJpdmF0ZSBrZW5kb0RhdGU7XG4gICAgcHJpdmF0ZSBpbnRsU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgcGFzdGU7XG4gICAgcHJpdmF0ZSBkb21FdmVudHM7XG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2w7XG4gICAgcHJpdmF0ZSBvbkNvbnRyb2xDaGFuZ2U7XG4gICAgcHJpdmF0ZSBvbkNvbnRyb2xUb3VjaGVkO1xuICAgIHByaXZhdGUgb25WYWxpZGF0b3JDaGFuZ2U7XG4gICAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgaW50bDogSW50bFNlcnZpY2UsIHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIG5nWm9uZTogTmdab25lLCBpbmplY3RvcjogSW5qZWN0b3IsIGxvY2FsaXphdGlvbjogTG9jYWxpemF0aW9uU2VydmljZSwgcGlja2VyU2VydmljZT86IFBpY2tlclNlcnZpY2UpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVc2VkIGJ5IHRoZSBUZXh0Qm94Q29udGFpbmVyIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGVtcHR5XG4gICAgICovXG4gICAgaXNFbXB0eSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb250YWluc0VsZW1lbnQoZWxlbWVudDogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKToge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogRnVuY3Rpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBEYXRlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdHJpZ2dlckNoYW5nZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBub3RpZnkoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKCkgPT4gYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgRGF0ZUlucHV0IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqIHRlbXBsYXRlOiBgXG4gICAgICogIDxidXR0b24gKGNsaWNrKT1cImRhdGVpbnB1dC5mb2N1cygpXCI+Rm9jdXMgZGF0ZSBpbnB1dDwvYnV0dG9uPlxuICAgICAqICA8a2VuZG8tZGF0ZWlucHV0ICNkYXRlaW5wdXQ+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBEYXRlSW5wdXQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJsdXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQnV0dG9uQ2xpY2sob2Zmc2V0OiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBtb2RpZnlEYXRlU2VnbWVudFZhbHVlKG9mZnNldDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN3aXRjaERhdGVTZWdtZW50KG9mZnNldDogbnVtYmVyKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNlbGVjdERhdGVTZWdtZW50KHN5bWJvbDogc3RyaW5nKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2soKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZ0FuZERyb3AoYXJnczogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2Vkb3duKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUZvY3VzKGFyZ3M6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZUJsdXIoYXJnczogYW55KTogdm9pZDtcbiAgICBwcml2YXRlIGdldEtlbmRvRGF0ZTtcbiAgICBwcml2YXRlIGRhdGVTeW1ib2xNYXA7XG4gICAgcHJpdmF0ZSB1cGRhdGVFbGVtZW50VmFsdWU7XG4gICAgcHJpdmF0ZSBjYXJldDtcbiAgICBwcml2YXRlIHNlbGVjdE5lYXJlc3RTZWdtZW50O1xuICAgIHByaXZhdGUgdmVyaWZ5UmFuZ2U7XG4gICAgcHJpdmF0ZSB2ZXJpZnlWYWx1ZTtcbiAgICBwcml2YXRlIHB1dERhdGVJblJhbmdlO1xuICAgIHByaXZhdGUgdXBkYXRlRm9ybWF0U2VjdGlvbnM7XG4gICAgcHJpdmF0ZSBpbnRsQ2hhbmdlO1xuICAgIHByaXZhdGUgdXBkYXRlT25QYXN0ZTtcbiAgICBwcml2YXRlIGJpbmRFdmVudHM7XG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZVdoZWVsO1xuICAgIHByaXZhdGUgaGFuZGxlUGFzdGU7XG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlkb3duO1xuICAgIHByaXZhdGUgaGFuZGxlSW5wdXQ7XG4gICAgcHJpdmF0ZSBlbWl0Rm9jdXM7XG4gICAgcHJpdmF0ZSBlbWl0Qmx1cjtcbiAgICBwcml2YXRlIHVwZGF0ZUluY29tcGxldGVWYWxpZGF0aW9uU3RhdHVzO1xufVxuIl19