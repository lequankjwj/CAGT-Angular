/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, Renderer2, NgZone, OnInit, OnDestroy } from '@angular/core';
import { DateInputComponent } from '../dateinput/dateinput.component';
import { AutoCorrectOn } from './auto-correct-on.type';
import { DateRangeInput } from './date-range-input';
import { DateRangeService } from './date-range.service';
import { SelectionRange } from '../calendar/models/selection-range.interface';
/**
 * A directive which manages the end range selection.
 *
 * > You can use the DateRangeEndInputDirective only with a DateInput component.
 */
import * as ɵngcc0 from '@angular/core';
export declare class DateRangeEndInputDirective extends DateRangeInput implements OnInit, OnDestroy {
    private rangeService;
    private dateInput;
    /**
     * Specifies the auto-correction behavior. If the start date is greater than the end date, the
     * directive fixes the date range to a single date either on input change or on blur
     * ([see example]({% slug autocorrect_daterange %}#toc-configuring-input-directives)).
     *
     * By default, the component does not perform any auto-correction.
     */
    autoCorrectOn: AutoCorrectOn;
    /**
     * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,
     * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.
     *
     * By default, the automatic navigation behavior on input focus is disabled.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
     *  <kendo-daterange>
     *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
     *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
     *  </kendo-daterange>
     * `
     * })
     * export class AppComponent {
     *   public start: Date = new Date(2018, 3, 10);
     *   public end: Date = new Date(2018, 10, 20);
     * }
     * ```
     */
    navigateCalendarOnFocus: boolean;
    constructor(rangeService: DateRangeService, dateInput: DateInputComponent, element: ElementRef, renderer: Renderer2, zone: NgZone);
    ngOnInit(): void;
    ngOnDestroy(): void;
    protected getRange(value: Date, correctOn: AutoCorrectOn): SelectionRange;
    protected updateInputValue(range: SelectionRange): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DateRangeEndInputDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DateRangeEndInputDirective, "[kendoDateRangeEndInput]", never, { "navigateCalendarOnFocus": "navigateCalendarOnFocus"; "autoCorrectOn": "autoCorrectOn"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1lbmQtaW5wdXQuZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImRhdGUtcmFuZ2UtZW5kLWlucHV0LmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgTmdab25lLCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZUlucHV0Q29tcG9uZW50IH0gZnJvbSAnLi4vZGF0ZWlucHV0L2RhdGVpbnB1dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQXV0b0NvcnJlY3RPbiB9IGZyb20gJy4vYXV0by1jb3JyZWN0LW9uLnR5cGUnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlSW5wdXQgfSBmcm9tICcuL2RhdGUtcmFuZ2UtaW5wdXQnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlU2VydmljZSB9IGZyb20gJy4vZGF0ZS1yYW5nZS5zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvblJhbmdlIH0gZnJvbSAnLi4vY2FsZW5kYXIvbW9kZWxzL3NlbGVjdGlvbi1yYW5nZS5pbnRlcmZhY2UnO1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBlbmQgcmFuZ2Ugc2VsZWN0aW9uLlxuICpcbiAqID4gWW91IGNhbiB1c2UgdGhlIERhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlIG9ubHkgd2l0aCBhIERhdGVJbnB1dCBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERhdGVSYW5nZUVuZElucHV0RGlyZWN0aXZlIGV4dGVuZHMgRGF0ZVJhbmdlSW5wdXQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSByYW5nZVNlcnZpY2U7XG4gICAgcHJpdmF0ZSBkYXRlSW5wdXQ7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBhdXRvLWNvcnJlY3Rpb24gYmVoYXZpb3IuIElmIHRoZSBzdGFydCBkYXRlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZW5kIGRhdGUsIHRoZVxuICAgICAqIGRpcmVjdGl2ZSBmaXhlcyB0aGUgZGF0ZSByYW5nZSB0byBhIHNpbmdsZSBkYXRlIGVpdGhlciBvbiBpbnB1dCBjaGFuZ2Ugb3Igb24gYmx1clxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXV0b2NvcnJlY3RfZGF0ZXJhbmdlICV9I3RvYy1jb25maWd1cmluZy1pbnB1dC1kaXJlY3RpdmVzKSkuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgY29tcG9uZW50IGRvZXMgbm90IHBlcmZvcm0gYW55IGF1dG8tY29ycmVjdGlvbi5cbiAgICAgKi9cbiAgICBhdXRvQ29ycmVjdE9uOiBBdXRvQ29ycmVjdE9uO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiB0aGUgY2FsZW5kYXIgd2hlbiB0aGUgYWN0aXZlIGVuZCBpcyBjaGFuZ2VkIG9uIGlucHV0IGZvY3VzLiBXaGVuIGVuYWJsZWQsXG4gICAgICogdGhlIGNhbGVuZGFyIG5hdmlnYXRlcyB0byB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzZWQgaW5wdXQuIE90aGVyd2lzZSwgdGhlIGNhbGVuZGFyIGRpc3BsYXlzIHRoZSBsYXN0IHBpY2tlZCBkYXRlLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG9tYXRpYyBuYXZpZ2F0aW9uIGJlaGF2aW9yIG9uIGlucHV0IGZvY3VzIGlzIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogdGVtcGxhdGU6IGBcbiAgICAgKiAgPGg1PlRvZ2dsZSBpbnB1dCBmb2N1cyB0byBzZWUgdGhlIGNhbGVuZGFyIG5hdmlnYXRpbmcgYmV0d2VlbiByYW5nZSBlbmRzLjwvaDU+XG4gICAgICogIDxrZW5kby1kYXRlcmFuZ2U+XG4gICAgICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlU3RhcnRJbnB1dCBbbmF2aWdhdGVDYWxlbmRhck9uRm9jdXNdPVwidHJ1ZVwiIFsodmFsdWUpXT1cInN0YXJ0XCI+PC9rZW5kby1kYXRlaW5wdXQ+XG4gICAgICogICAgICA8a2VuZG8tZGF0ZWlucHV0IGtlbmRvRGF0ZVJhbmdlRW5kSW5wdXQgW25hdmlnYXRlQ2FsZW5kYXJPbkZvY3VzXT1cInRydWVcIiBbKHZhbHVlKV09XCJlbmRcIj48L2tlbmRvLWRhdGVpbnB1dD5cbiAgICAgKiAgPC9rZW5kby1kYXRlcmFuZ2U+XG4gICAgICogYFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICBwdWJsaWMgc3RhcnQ6IERhdGUgPSBuZXcgRGF0ZSgyMDE4LCAzLCAxMCk7XG4gICAgICogICBwdWJsaWMgZW5kOiBEYXRlID0gbmV3IERhdGUoMjAxOCwgMTAsIDIwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbmF2aWdhdGVDYWxlbmRhck9uRm9jdXM6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IocmFuZ2VTZXJ2aWNlOiBEYXRlUmFuZ2VTZXJ2aWNlLCBkYXRlSW5wdXQ6IERhdGVJbnB1dENvbXBvbmVudCwgZWxlbWVudDogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgem9uZTogTmdab25lKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGdldFJhbmdlKHZhbHVlOiBEYXRlLCBjb3JyZWN0T246IEF1dG9Db3JyZWN0T24pOiBTZWxlY3Rpb25SYW5nZTtcbiAgICBwcm90ZWN0ZWQgdXBkYXRlSW5wdXRWYWx1ZShyYW5nZTogU2VsZWN0aW9uUmFuZ2UpOiB2b2lkO1xufVxuIl19