/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, EventEmitter, TemplateRef, NgZone, OnInit, OnDestroy, ViewContainerRef, QueryList } from '@angular/core';
import { Align, Collision, Margin, PopupAnimation, PopupService, PopupRef } from '@progress/kendo-angular-popup';
import { DateRangePopupTemplateDirective } from './date-range-popup-template.directive';
import { DateRangeService } from './date-range.service';
import { MultiViewCalendarComponent } from '../calendar/multiview-calendar.component';
import { PreventableEvent } from '../preventable-event';
/**
 * Represents the Kendo UI DateRangePopup component for Angular.
 *
 * @example
 * ```ts
 * import { DateInputsModule, DateRangeService } from '@progress/kendo-angular-dateinputs';
 *
 * _@Component({
 * providers: [DateRangeService],
 * selector: 'my-app',
 * template: `
 *  <button #anchor (click)="popup.toggle()">Toggle</button>
 *  <kendo-daterange-popup [anchor]="anchor" #popup></kendo-daterange-popup>
 * `
 * })
 * export class AppComponent {
 * }
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class DateRangePopupComponent implements OnInit, OnDestroy {
    private popupService;
    private dateRangeService;
    private zone;
    private rtl;
    container: ViewContainerRef;
    defaultTemplate: TemplateRef<any>;
    contentTemplate: DateRangePopupTemplateDirective;
    viewCalendar: QueryList<MultiViewCalendarComponent>;
    contentCalendar: QueryList<MultiViewCalendarComponent>;
    /**
     * Controls the popup animation.
     * By default, the opening and closing animations are enabled.
     * For more information about controlling the popup animations,
     * refer to the article on [animations]({% slug animations_popup %}).
     */
    animate: boolean | PopupAnimation;
    /**
     * Specifies the element that will be used as an anchor. The popup opens next to that element.
     * For more information, refer to the section on
     * [aligning to specific components]({% slug alignmentpositioning_popup %}#toc-aligning-to-components).
     */
    anchor: ElementRef;
    /**
     * Specifies the anchor pivot point.
     * For more information, refer to the section on
     * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
     */
    anchorAlign: Align;
    /**
     * Controls the popup container. By default, the popup is appended to the root component.
     */
    appendTo: 'root' | 'component' | ViewContainerRef;
    /**
     * Configures the collision behavior of the popup.
     * For more information, refer to the article on
     * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).
     */
    collision: Collision;
    /**
     * Specifies the pivot point of the popup.
     * For more information, refer to the section on
     * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
     */
    popupAlign: Align;
    /**
     * Specifies the margin value that will be added to the popup dimensions in pixels
     * and leaves a blank space between the popup and the anchor.
     */
    margin: Margin;
    /**
     * Fires each time the popup is about to open.
     * This event is preventable. If you cancel the event, the popup will remain closed.
     * For more information, refer to the section on
     * [events]({% slug overview_datepicker %}#toc-events).
     */
    open: EventEmitter<PreventableEvent>;
    /**
     * Fires each time the popup is about to close.
     * This event is preventable. If you cancel the event, the popup will remain open.
     * For more information, refer to the section on
     * [events]({% slug overview_datepicker %}#toc-events).
     */
    close: EventEmitter<PreventableEvent>;
    /**
     * Fires each time the calendar element is blurred.
     */
    onBlur: EventEmitter<null>;
    /**
     * Fires each time the calendar element is focused.
     */
    onFocus: EventEmitter<null>;
    /**
     * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport.
     */
    cancel: EventEmitter<null>;
    /**
     * The active calendar that is visible in the popup.
     *
     * > When the popup is closed, the property returns `null`.
     */
    calendar: MultiViewCalendarComponent;
    /**
     * Gets the active state of the component.
     * When the opened calendar is active, returns `true`.
     */
    readonly isActive: boolean;
    /**
     * @hidden
     */
    popupRef: PopupRef;
    /**
     * @hidden
     */
    popupUID: string;
    /**
     * Gets or sets the visibility state of the component.
     */
    show: boolean;
    private activateSubscription;
    private blurSubscription;
    private focusSubscription;
    private calendarSubscriptions;
    private popupSubscriptions;
    private windowBlurSubscription;
    private resolvedPromise;
    private _calendar;
    private _show;
    constructor(popupService: PopupService, dateRangeService: DateRangeService, zone: NgZone, rtl: boolean);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     *  Opens the popup component and focuses the calendar.
     */
    activate(): void;
    /**
     *  Focuses the calendar (if available).
     */
    focus(): void;
    /**
     * Checks if a focused element ids placed inside the popup.
     *
     * @return boolean;
     */
    hasActiveContent(): boolean;
    /**
     * Toggles the visibility of the popup.
     * If you use the `toggle` method to show or hide the popup,
     * the `open` and `close` events do not fire.
     *
     * @param show The state of the popup.
     */
    toggle(show?: boolean): void;
    /**
     * @hidden
     *
     * Closes the popup and triggers the `cancel` event.
     */
    cancelPopup(): void;
    private handleWindowBlur;
    private handleMouseLeave;
    private handleKeydown;
    private subscribeFocusBlur;
    private addPopupSubscriptions;
    private readonly _appendTo;
    private _toggle;
    private destroyPopup;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DateRangePopupComponent, [null, null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DateRangePopupComponent, "kendo-daterange-popup", ["kendo-daterange-popup"], { "animate": "animate"; "collision": "collision"; "anchor": "anchor"; "anchorAlign": "anchorAlign"; "appendTo": "appendTo"; "popupAlign": "popupAlign"; "margin": "margin"; }, { "open": "open"; "close": "close"; "onBlur": "blur"; "onFocus": "focus"; "cancel": "cancel"; }, ["contentTemplate", "contentCalendar"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1wb3B1cC5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiZGF0ZS1yYW5nZS1wb3B1cC5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgVGVtcGxhdGVSZWYsIE5nWm9uZSwgT25Jbml0LCBPbkRlc3Ryb3ksIFZpZXdDb250YWluZXJSZWYsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWxpZ24sIENvbGxpc2lvbiwgTWFyZ2luLCBQb3B1cEFuaW1hdGlvbiwgUG9wdXBTZXJ2aWNlLCBQb3B1cFJlZiB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbmltcG9ydCB7IERhdGVSYW5nZVBvcHVwVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL2RhdGUtcmFuZ2UtcG9wdXAtdGVtcGxhdGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IERhdGVSYW5nZVNlcnZpY2UgfSBmcm9tICcuL2RhdGUtcmFuZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudCB9IGZyb20gJy4uL2NhbGVuZGFyL211bHRpdmlldy1jYWxlbmRhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUHJldmVudGFibGVFdmVudCB9IGZyb20gJy4uL3ByZXZlbnRhYmxlLWV2ZW50Jztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgS2VuZG8gVUkgRGF0ZVJhbmdlUG9wdXAgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRGF0ZUlucHV0c01vZHVsZSwgRGF0ZVJhbmdlU2VydmljZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRhdGVpbnB1dHMnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHByb3ZpZGVyczogW0RhdGVSYW5nZVNlcnZpY2VdLFxuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogdGVtcGxhdGU6IGBcbiAqICA8YnV0dG9uICNhbmNob3IgKGNsaWNrKT1cInBvcHVwLnRvZ2dsZSgpXCI+VG9nZ2xlPC9idXR0b24+XG4gKiAgPGtlbmRvLWRhdGVyYW5nZS1wb3B1cCBbYW5jaG9yXT1cImFuY2hvclwiICNwb3B1cD48L2tlbmRvLWRhdGVyYW5nZS1wb3B1cD5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBEYXRlUmFuZ2VQb3B1cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHBvcHVwU2VydmljZTtcbiAgICBwcml2YXRlIGRhdGVSYW5nZVNlcnZpY2U7XG4gICAgcHJpdmF0ZSB6b25lO1xuICAgIHByaXZhdGUgcnRsO1xuICAgIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbiAgICBkZWZhdWx0VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgY29udGVudFRlbXBsYXRlOiBEYXRlUmFuZ2VQb3B1cFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIHZpZXdDYWxlbmRhcjogUXVlcnlMaXN0PE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50PjtcbiAgICBjb250ZW50Q2FsZW5kYXI6IFF1ZXJ5TGlzdDxNdWx0aVZpZXdDYWxlbmRhckNvbXBvbmVudD47XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgdGhlIHBvcHVwIGFuaW1hdGlvbi5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBhbmltYXRpb25zIGFyZSBlbmFibGVkLlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGNvbnRyb2xsaW5nIHRoZSBwb3B1cCBhbmltYXRpb25zLFxuICAgICAqIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uIFthbmltYXRpb25zXSh7JSBzbHVnIGFuaW1hdGlvbnNfcG9wdXAgJX0pLlxuICAgICAqL1xuICAgIGFuaW1hdGU6IGJvb2xlYW4gfCBQb3B1cEFuaW1hdGlvbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYW4gYW5jaG9yLiBUaGUgcG9wdXAgb3BlbnMgbmV4dCB0byB0aGF0IGVsZW1lbnQuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uXG4gICAgICogW2FsaWduaW5nIHRvIHNwZWNpZmljIGNvbXBvbmVudHNdKHslIHNsdWcgYWxpZ25tZW50cG9zaXRpb25pbmdfcG9wdXAgJX0jdG9jLWFsaWduaW5nLXRvLWNvbXBvbmVudHMpLlxuICAgICAqL1xuICAgIGFuY2hvcjogRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGFuY2hvciBwaXZvdCBwb2ludC5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgKiBbcG9zaXRpb25pbmddKHslIHNsdWcgYWxpZ25tZW50cG9zaXRpb25pbmdfcG9wdXAgJX0jdG9jLXBvc2l0aW9uaW5nKS5cbiAgICAgKi9cbiAgICBhbmNob3JBbGlnbjogQWxpZ247XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgdGhlIHBvcHVwIGNvbnRhaW5lci4gQnkgZGVmYXVsdCwgdGhlIHBvcHVwIGlzIGFwcGVuZGVkIHRvIHRoZSByb290IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhcHBlbmRUbzogJ3Jvb3QnIHwgJ2NvbXBvbmVudCcgfCBWaWV3Q29udGFpbmVyUmVmO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGNvbGxpc2lvbiBiZWhhdmlvciBvZiB0aGUgcG9wdXAuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBhcnRpY2xlIG9uXG4gICAgICogW3ZpZXdwb3J0IGJvdW5kYXJ5IGRldGVjdGlvbl0oeyUgc2x1ZyB2aWV3cG9ydGJvdW5kYXJ5ZGV0ZWN0aW9uX3BvcHVwICV9KS5cbiAgICAgKi9cbiAgICBjb2xsaXNpb246IENvbGxpc2lvbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHBpdm90IHBvaW50IG9mIHRoZSBwb3B1cC5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgKiBbcG9zaXRpb25pbmddKHslIHNsdWcgYWxpZ25tZW50cG9zaXRpb25pbmdfcG9wdXAgJX0jdG9jLXBvc2l0aW9uaW5nKS5cbiAgICAgKi9cbiAgICBwb3B1cEFsaWduOiBBbGlnbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG1hcmdpbiB2YWx1ZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHBvcHVwIGRpbWVuc2lvbnMgaW4gcGl4ZWxzXG4gICAgICogYW5kIGxlYXZlcyBhIGJsYW5rIHNwYWNlIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYW5jaG9yLlxuICAgICAqL1xuICAgIG1hcmdpbjogTWFyZ2luO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgY2FuY2VsIHRoZSBldmVudCwgdGhlIHBvcHVwIHdpbGwgcmVtYWluIGNsb3NlZC5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHNlY3Rpb24gb25cbiAgICAgKiBbZXZlbnRzXSh7JSBzbHVnIG92ZXJ2aWV3X2RhdGVwaWNrZXIgJX0jdG9jLWV2ZW50cykuXG4gICAgICovXG4gICAgb3BlbjogRXZlbnRFbWl0dGVyPFByZXZlbnRhYmxlRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgcG9wdXAgaXMgYWJvdXQgdG8gY2xvc2UuXG4gICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IGNhbmNlbCB0aGUgZXZlbnQsIHRoZSBwb3B1cCB3aWxsIHJlbWFpbiBvcGVuLlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvblxuICAgICAqIFtldmVudHNdKHslIHNsdWcgb3ZlcnZpZXdfZGF0ZXBpY2tlciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgKi9cbiAgICBjbG9zZTogRXZlbnRFbWl0dGVyPFByZXZlbnRhYmxlRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgY2FsZW5kYXIgZWxlbWVudCBpcyBibHVycmVkLlxuICAgICAqL1xuICAgIG9uQmx1cjogRXZlbnRFbWl0dGVyPG51bGw+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIGVhY2ggdGltZSB0aGUgY2FsZW5kYXIgZWxlbWVudCBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIG9uRm9jdXM6IEV2ZW50RW1pdHRlcjxudWxsPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBlYWNoIHRpbWUgdGhlIHBvcHVwIGlzIGNsb3NlZCBlaXRoZXIgb24gYEVTQ2Aga2V5cHJlc3Mgb3Igb24gbGVhdmluZyB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgY2FuY2VsOiBFdmVudEVtaXR0ZXI8bnVsbD47XG4gICAgLyoqXG4gICAgICogVGhlIGFjdGl2ZSBjYWxlbmRhciB0aGF0IGlzIHZpc2libGUgaW4gdGhlIHBvcHVwLlxuICAgICAqXG4gICAgICogPiBXaGVuIHRoZSBwb3B1cCBpcyBjbG9zZWQsIHRoZSBwcm9wZXJ0eSByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cbiAgICBjYWxlbmRhcjogTXVsdGlWaWV3Q2FsZW5kYXJDb21wb25lbnQ7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogV2hlbiB0aGUgb3BlbmVkIGNhbGVuZGFyIGlzIGFjdGl2ZSwgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaXNBY3RpdmU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHBvcHVwUmVmOiBQb3B1cFJlZjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcG9wdXBVSUQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzaG93OiBib29sZWFuO1xuICAgIHByaXZhdGUgYWN0aXZhdGVTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBibHVyU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgZm9jdXNTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBjYWxlbmRhclN1YnNjcmlwdGlvbnM7XG4gICAgcHJpdmF0ZSBwb3B1cFN1YnNjcmlwdGlvbnM7XG4gICAgcHJpdmF0ZSB3aW5kb3dCbHVyU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgcmVzb2x2ZWRQcm9taXNlO1xuICAgIHByaXZhdGUgX2NhbGVuZGFyO1xuICAgIHByaXZhdGUgX3Nob3c7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlOiBQb3B1cFNlcnZpY2UsIGRhdGVSYW5nZVNlcnZpY2U6IERhdGVSYW5nZVNlcnZpY2UsIHpvbmU6IE5nWm9uZSwgcnRsOiBib29sZWFuKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIE9wZW5zIHRoZSBwb3B1cCBjb21wb25lbnQgYW5kIGZvY3VzZXMgdGhlIGNhbGVuZGFyLlxuICAgICAqL1xuICAgIGFjdGl2YXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIEZvY3VzZXMgdGhlIGNhbGVuZGFyIChpZiBhdmFpbGFibGUpLlxuICAgICAqL1xuICAgIGZvY3VzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZm9jdXNlZCBlbGVtZW50IGlkcyBwbGFjZWQgaW5zaWRlIHRoZSBwb3B1cC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbGVhbjtcbiAgICAgKi9cbiAgICBoYXNBY3RpdmVDb250ZW50KCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcG9wdXAuXG4gICAgICogSWYgeW91IHVzZSB0aGUgYHRvZ2dsZWAgbWV0aG9kIHRvIHNob3cgb3IgaGlkZSB0aGUgcG9wdXAsXG4gICAgICogdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgZG8gbm90IGZpcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyBUaGUgc3RhdGUgb2YgdGhlIHBvcHVwLlxuICAgICAqL1xuICAgIHRvZ2dsZShzaG93PzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQ2xvc2VzIHRoZSBwb3B1cCBhbmQgdHJpZ2dlcnMgdGhlIGBjYW5jZWxgIGV2ZW50LlxuICAgICAqL1xuICAgIGNhbmNlbFBvcHVwKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBoYW5kbGVXaW5kb3dCbHVyO1xuICAgIHByaXZhdGUgaGFuZGxlTW91c2VMZWF2ZTtcbiAgICBwcml2YXRlIGhhbmRsZUtleWRvd247XG4gICAgcHJpdmF0ZSBzdWJzY3JpYmVGb2N1c0JsdXI7XG4gICAgcHJpdmF0ZSBhZGRQb3B1cFN1YnNjcmlwdGlvbnM7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfYXBwZW5kVG87XG4gICAgcHJpdmF0ZSBfdG9nZ2xlO1xuICAgIHByaXZhdGUgZGVzdHJveVBvcHVwO1xufVxuIl19