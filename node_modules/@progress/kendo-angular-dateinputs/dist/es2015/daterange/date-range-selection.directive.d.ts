/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ChangeDetectorRef, ElementRef, EventEmitter, OnInit, Renderer2 } from '@angular/core';
import { DateRangeService } from './date-range.service';
import { MultiViewCalendarComponent } from '../calendar/multiview-calendar.component';
import { SelectionRange } from '../calendar/models/selection-range.interface';
import { SelectionRangeEnd } from '../calendar/models/selection-range-end.type';
import { AutoCorrectOn } from './auto-correct-on.type';
/**
 * A directive which manages the MultiViewCalendar range selection.
 */
import * as ɵngcc0 from '@angular/core';
export declare class DateRangeSelectionDirective implements OnInit {
    private calendar;
    private cdr;
    private element;
    private dateRangeService;
    /**
     * Specifies the auto-correction behavior. If the start date is greater than the end date,
     * the directive fixes the date range to a single date either on input change or on blur
     * ([see example]({% slug autocorrect_daterange %}#toc-configuring-the-calendar-selection-directive)).
     *
     * By default, the auto-correction is triggered on change.
     * To disable this behavior, set the `autoCorrectOn` property to `none`.
     */
    autoCorrectOn: AutoCorrectOn;
    /**
     * Gets or sets the selection range of the calendar. When a new range is set,
     * the connected DateRangeService notifies all related parties.
     */
    selectionRange: SelectionRange;
    /**
     * Gets or sets the active end of the selection range. This option determines which range end will be updated on
     * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.
     */
    /**
     * Specifies which end of the selection range will be marked as active. The active end gets modified upon user
     * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For
     * example, the start and end DateInput components.
     *
     * > If the selection range is undefined, the value is ignored.
     */
    activeRangeEnd: SelectionRangeEnd;
    /**
     * Fires when the active range end is changed. For more information, refer to
     * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).
     */
    activeRangeEndChange: EventEmitter<SelectionRangeEnd>;
    /**
     * Fires when the selection range is changed. For more information, refer to
     * the section on [events]({% slug overview_multiviewcalendar %}#toc-events).
     */
    selectionRangeChange: EventEmitter<SelectionRange>;
    private readonly calendarRange;
    private calendarSubscriptions;
    constructor(calendar: MultiViewCalendarComponent, cdr: ChangeDetectorRef, element: ElementRef, renderer: Renderer2, dateRangeService: DateRangeService);
    ngOnInit(): void;
    ngOnDestroy(): void;
    private addSubscriptions;
    private isEqualCalendarRange;
    private handleBlur;
    private handleChange;
    private handleHover;
    private hasCompleteRange;
    private shouldAutoCorrect;
    private updateFocusedDate;
    private updateRange;
    private setSelectionRange;
    private acceptAndEmit;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DateRangeSelectionDirective, [null, null, null, null, { optional: true; }]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DateRangeSelectionDirective, "[kendoDateRangeSelection]", never, { "autoCorrectOn": "autoCorrectOn"; "selectionRange": "selectionRange"; "activeRangeEnd": "activeRangeEnd"; }, { "activeRangeEndChange": "activeRangeEndChange"; "selectionRangeChange": "selectionRangeChange"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1zZWxlY3Rpb24uZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImRhdGUtcmFuZ2Utc2VsZWN0aW9uLmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlU2VydmljZSB9IGZyb20gJy4vZGF0ZS1yYW5nZS5zZXJ2aWNlJztcbmltcG9ydCB7IE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50IH0gZnJvbSAnLi4vY2FsZW5kYXIvbXVsdGl2aWV3LWNhbGVuZGFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWxlY3Rpb25SYW5nZSB9IGZyb20gJy4uL2NhbGVuZGFyL21vZGVscy9zZWxlY3Rpb24tcmFuZ2UuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlbGVjdGlvblJhbmdlRW5kIH0gZnJvbSAnLi4vY2FsZW5kYXIvbW9kZWxzL3NlbGVjdGlvbi1yYW5nZS1lbmQudHlwZSc7XG5pbXBvcnQgeyBBdXRvQ29ycmVjdE9uIH0gZnJvbSAnLi9hdXRvLWNvcnJlY3Qtb24udHlwZSc7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIE11bHRpVmlld0NhbGVuZGFyIHJhbmdlIHNlbGVjdGlvbi5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRGF0ZVJhbmdlU2VsZWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcml2YXRlIGNhbGVuZGFyO1xuICAgIHByaXZhdGUgY2RyO1xuICAgIHByaXZhdGUgZWxlbWVudDtcbiAgICBwcml2YXRlIGRhdGVSYW5nZVNlcnZpY2U7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBhdXRvLWNvcnJlY3Rpb24gYmVoYXZpb3IuIElmIHRoZSBzdGFydCBkYXRlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZW5kIGRhdGUsXG4gICAgICogdGhlIGRpcmVjdGl2ZSBmaXhlcyB0aGUgZGF0ZSByYW5nZSB0byBhIHNpbmdsZSBkYXRlIGVpdGhlciBvbiBpbnB1dCBjaGFuZ2Ugb3Igb24gYmx1clxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXV0b2NvcnJlY3RfZGF0ZXJhbmdlICV9I3RvYy1jb25maWd1cmluZy10aGUtY2FsZW5kYXItc2VsZWN0aW9uLWRpcmVjdGl2ZSkpLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGF1dG8tY29ycmVjdGlvbiBpcyB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICAgICAqIFRvIGRpc2FibGUgdGhpcyBiZWhhdmlvciwgc2V0IHRoZSBgYXV0b0NvcnJlY3RPbmAgcHJvcGVydHkgdG8gYG5vbmVgLlxuICAgICAqL1xuICAgIGF1dG9Db3JyZWN0T246IEF1dG9Db3JyZWN0T247XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugb2YgdGhlIGNhbGVuZGFyLiBXaGVuIGEgbmV3IHJhbmdlIGlzIHNldCxcbiAgICAgKiB0aGUgY29ubmVjdGVkIERhdGVSYW5nZVNlcnZpY2Ugbm90aWZpZXMgYWxsIHJlbGF0ZWQgcGFydGllcy5cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25SYW5nZTogU2VsZWN0aW9uUmFuZ2U7XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBhY3RpdmUgZW5kIG9mIHRoZSBzZWxlY3Rpb24gcmFuZ2UuIFRoaXMgb3B0aW9uIGRldGVybWluZXMgd2hpY2ggcmFuZ2UgZW5kIHdpbGwgYmUgdXBkYXRlZCBvblxuICAgICAqIHVzZXIgaW50ZXJhY3Rpb24uIFdoZW4gYSBuZXcgYWN0aXZlIGVuZCBpcyBzZXQsIHRoZSBjb25uZWN0ZWQgRGF0ZVJhbmdlU2VydmljZSBub3RpZmllcyBhbGwgcmVsYXRlZCBwYXJ0aWVzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB3aGljaCBlbmQgb2YgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsIGJlIG1hcmtlZCBhcyBhY3RpdmUuIFRoZSBhY3RpdmUgZW5kIGdldHMgbW9kaWZpZWQgdXBvbiB1c2VyXG4gICAgICogaW50ZXJhY3Rpb24uIFdoZW4gYSBuZXcgYWN0aXZlIGVuZCBpcyBzZXQsIHRoZSB3aXJlZCBEYXRlUmFuZ2VTZXJ2aWNlIG5vdGlmaWVzIGFsbCByZWxhdGVkIGNvbXBvbmVudHMuIEZvclxuICAgICAqIGV4YW1wbGUsIHRoZSBzdGFydCBhbmQgZW5kIERhdGVJbnB1dCBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogPiBJZiB0aGUgc2VsZWN0aW9uIHJhbmdlIGlzIHVuZGVmaW5lZCwgdGhlIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAgICovXG4gICAgYWN0aXZlUmFuZ2VFbmQ6IFNlbGVjdGlvblJhbmdlRW5kO1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGFjdGl2ZSByYW5nZSBlbmQgaXMgY2hhbmdlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvXG4gICAgICogdGhlIHNlY3Rpb24gb24gW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgKi9cbiAgICBhY3RpdmVSYW5nZUVuZENoYW5nZTogRXZlbnRFbWl0dGVyPFNlbGVjdGlvblJhbmdlRW5kPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3Rpb24gcmFuZ2UgaXMgY2hhbmdlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvXG4gICAgICogdGhlIHNlY3Rpb24gb24gW2V2ZW50c10oeyUgc2x1ZyBvdmVydmlld19tdWx0aXZpZXdjYWxlbmRhciAlfSN0b2MtZXZlbnRzKS5cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25SYW5nZUNoYW5nZTogRXZlbnRFbWl0dGVyPFNlbGVjdGlvblJhbmdlPjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhbGVuZGFyUmFuZ2U7XG4gICAgcHJpdmF0ZSBjYWxlbmRhclN1YnNjcmlwdGlvbnM7XG4gICAgY29uc3RydWN0b3IoY2FsZW5kYXI6IE11bHRpVmlld0NhbGVuZGFyQ29tcG9uZW50LCBjZHI6IENoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50OiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIyLCBkYXRlUmFuZ2VTZXJ2aWNlOiBEYXRlUmFuZ2VTZXJ2aWNlKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBhZGRTdWJzY3JpcHRpb25zO1xuICAgIHByaXZhdGUgaXNFcXVhbENhbGVuZGFyUmFuZ2U7XG4gICAgcHJpdmF0ZSBoYW5kbGVCbHVyO1xuICAgIHByaXZhdGUgaGFuZGxlQ2hhbmdlO1xuICAgIHByaXZhdGUgaGFuZGxlSG92ZXI7XG4gICAgcHJpdmF0ZSBoYXNDb21wbGV0ZVJhbmdlO1xuICAgIHByaXZhdGUgc2hvdWxkQXV0b0NvcnJlY3Q7XG4gICAgcHJpdmF0ZSB1cGRhdGVGb2N1c2VkRGF0ZTtcbiAgICBwcml2YXRlIHVwZGF0ZVJhbmdlO1xuICAgIHByaXZhdGUgc2V0U2VsZWN0aW9uUmFuZ2U7XG4gICAgcHJpdmF0ZSBhY2NlcHRBbmRFbWl0O1xufVxuIl19