/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { TemplateRef } from '@angular/core';
/**
 * Used for rendering the year cell content of the Calendar. To define the year cell template, nest an
 * `<ng-template>` tag with the `kendoCalendarYearCellTemplate` directive inside the component tag.
 * The template context is set to the current component. To get a reference to the current date, use
 * the `let-date` directive. To provide more details about the current year cell, get a reference to the
 * current `cellContext` by using the `let-cellContext` directive.
 *
 * For more examples, refer to the article on [templates]({% slug templates_calendar %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * styles: ['.custom { color: red; }'],
 * template: `
 *  <kendo-calendar [activeView]="activeView">
 *    <ng-template kendoCalendarYearCellTemplate let-context="cellContext">
 *      <span class="custom">{{context.formattedValue}}</span>
 *    </ng-template>
 *  </kendo-calendar>
 * `
 * })
 * export class AppComponent {
 *  public activeView: CalendarView = 'year';
 * }
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class YearCellTemplateDirective {
    templateRef: TemplateRef<any>;
    constructor(templateRef: TemplateRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<YearCellTemplateDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<YearCellTemplateDirective, "[kendoCalendarYearCellTemplate]", never, {}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci1jZWxsLXRlbXBsYXRlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJ5ZWFyLWNlbGwtdGVtcGxhdGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbi8qKlxuICogVXNlZCBmb3IgcmVuZGVyaW5nIHRoZSB5ZWFyIGNlbGwgY29udGVudCBvZiB0aGUgQ2FsZW5kYXIuIFRvIGRlZmluZSB0aGUgeWVhciBjZWxsIHRlbXBsYXRlLCBuZXN0IGFuXG4gKiBgPG5nLXRlbXBsYXRlPmAgdGFnIHdpdGggdGhlIGBrZW5kb0NhbGVuZGFyWWVhckNlbGxUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSB0aGUgY29tcG9uZW50IHRhZy5cbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IGlzIHNldCB0byB0aGUgY3VycmVudCBjb21wb25lbnQuIFRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBkYXRlLCB1c2VcbiAqIHRoZSBgbGV0LWRhdGVgIGRpcmVjdGl2ZS4gVG8gcHJvdmlkZSBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnQgeWVhciBjZWxsLCBnZXQgYSByZWZlcmVuY2UgdG8gdGhlXG4gKiBjdXJyZW50IGBjZWxsQ29udGV4dGAgYnkgdXNpbmcgdGhlIGBsZXQtY2VsbENvbnRleHRgIGRpcmVjdGl2ZS5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb24gW3RlbXBsYXRlc10oeyUgc2x1ZyB0ZW1wbGF0ZXNfY2FsZW5kYXIgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogX0BDb21wb25lbnQoe1xuICogc2VsZWN0b3I6ICdteS1hcHAnLFxuICogc3R5bGVzOiBbJy5jdXN0b20geyBjb2xvcjogcmVkOyB9J10sXG4gKiB0ZW1wbGF0ZTogYFxuICogIDxrZW5kby1jYWxlbmRhciBbYWN0aXZlVmlld109XCJhY3RpdmVWaWV3XCI+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9DYWxlbmRhclllYXJDZWxsVGVtcGxhdGUgbGV0LWNvbnRleHQ9XCJjZWxsQ29udGV4dFwiPlxuICogICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbVwiPnt7Y29udGV4dC5mb3JtYXR0ZWRWYWx1ZX19PC9zcGFuPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2tlbmRvLWNhbGVuZGFyPlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogIHB1YmxpYyBhY3RpdmVWaWV3OiBDYWxlbmRhclZpZXcgPSAneWVhcic7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgWWVhckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pO1xufVxuIl19