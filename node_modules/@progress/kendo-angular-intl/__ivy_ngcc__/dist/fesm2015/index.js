/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Injectable, LOCALE_ID, defineInjectable, inject, Inject, Pipe, NgModule } from '@angular/core';
import { dateFormatNames, dateFieldName, firstDay, format, formatDate, formatNumber, load, numberSymbols, parseDate, parseNumber, splitDateFormat, toString, weekendRange, setData, localeInfo } from '@telerik/kendo-intl';

import * as ɵngcc0 from '@angular/core';
const DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';
/**
 * @hidden
 */
const errorSolutions = {
    'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,
    'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,
    'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,
    'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,
    'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,
    'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,
    'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,
    'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,
    'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`
};

function formatMessage(error) {
    const message = error.message;
    const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];
    return errorSolution ? `${message} ${errorSolution}` : message;
}
function intlMethod(fn) {
    return function (...values) {
        try {
            return fn.apply(null, values);
        }
        catch (error) {
            error.message = formatMessage(error);
            throw error;
        }
    };
}
/**
 * @hidden
 */
const dateFormatNames$1 = intlMethod(dateFormatNames);
/**
 * @hidden
 */
const dateFieldName$1 = intlMethod(dateFieldName);
/**
 * @hidden
 */
const firstDay$1 = intlMethod(firstDay);
/**
 * @hidden
 */
const format$1 = intlMethod(format);
/**
 * @hidden
 */
const formatDate$1 = intlMethod(formatDate);
/**
 * @hidden
 */
const formatNumber$1 = intlMethod(formatNumber);
/**
 * @hidden
 */
const load$1 = intlMethod(load);
/**
 * @hidden
 */
const numberSymbols$1 = intlMethod(numberSymbols);
/**
 * @hidden
 */
const parseDate$1 = intlMethod(parseDate);
/**
 * @hidden
 */
const parseNumber$1 = intlMethod(parseNumber);
/**
 * @hidden
 */
const splitDateFormat$1 = intlMethod(splitDateFormat);
/**
 * @hidden
 */
const toString$1 = intlMethod(toString);
/**
 * @hidden
 */
const weekendRange$1 = intlMethod(weekendRange);
/**
 * Sets a pre-built locale.
 *
 * @params data - The pre-built locale data.
 */
const setData$1 = (data) => setData(data);
/**
 * Retrieves the locale data for the specified locale.
 *
 * @params locale - The locale id.
 * @returns data - The locale data.
 */
const localeData = (locale) => {
    try {
        return localeInfo(locale);
    }
    catch (error) {
        error.message = formatMessage(error);
        throw error;
    }
};

const LOCALE_REGEX = /_/g;
/**
 * @hidden
 */
function cldrServiceFactory(localeId) {
    return new CldrIntlService(localeId);
}
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
class IntlService {
    constructor() {
        /**
         * @hidden
         */
        this.changes = new EventEmitter();
    }
    /**
     * Notifies that the service was changed.
     */
    notify() {
        this.changes.emit();
    }
}
IntlService.ɵfac = function IntlService_Factory(t) { return new (t || IntlService)(); };
IntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntlService, factory: function IntlService_Factory(t) { var r = null; if (t) {
        r = new t();
    }
    else {
        r = cldrServiceFactory(ɵngcc0.ɵɵinject(LOCALE_ID));
    } return r; }, providedIn: 'root' });
IntlService.ngInjectableDef = defineInjectable({ factory: function IntlService_Factory() { return cldrServiceFactory(inject(LOCALE_ID)); }, token: IntlService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
                useFactory: cldrServiceFactory,
                deps: [LOCALE_ID]
            }]
    }], function () { return []; }, null); })();
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
class CldrIntlService extends IntlService {
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId) {
        super();
        this.localeId = localeId;
    }
    /**
     * Gets or sets the current locale ID.
     */
    get localeId() {
        return this.locale;
    }
    set localeId(value) {
        // Angular locales use underscore, for example, en_US
        // while IETF BCP-47 specifies a dash.
        // https://tools.ietf.org/html/bcp47
        const locale = value.replace(LOCALE_REGEX, '-');
        if (locale !== this.locale) {
            this.locale = locale;
            this.notify();
        }
    }
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format$$1, ...values) {
        return format$1(format$$1, values, this.localeId);
    }
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value, format$$1, localeId) {
        return toString$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value, format$$1, localeId) {
        return formatDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value, format$$1, localeId) {
        return parseDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value, format$$1, localeId) {
        return parseNumber$1(value, localeId || this.localeId, format$$1);
    }
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value, format$$1, localeId) {
        return formatNumber$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options, localeId) {
        return dateFieldName$1(options, localeId || this.localeId);
    }
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options, localeId) {
        return dateFormatNames$1(localeId || this.localeId, options);
    }
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format$$1, localeId) {
        return splitDateFormat$1(format$$1, localeId || this.localeId);
    }
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId) {
        return numberSymbols$1(localeId || this.localeId);
    }
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId) {
        return firstDay$1(localeId || this.localeId);
    }
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId) {
        return weekendRange$1(localeId || this.localeId);
    }
}
CldrIntlService.ɵfac = function CldrIntlService_Factory(t) { return new (t || CldrIntlService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
CldrIntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CldrIntlService, factory: CldrIntlService.ɵfac });
/** @nocollapse */
CldrIntlService.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CldrIntlService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();

const isNumeric = (value) => !isNaN(value - parseFloat(value));
const ɵ0 = isNumeric;
/**
 * Formats a date value to a string based on the requested format.
 * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 * <ul>
 *    <li>{{date | kendoDate }}</li>
 *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>
 *    <li>{{stringDate | kendoDate: 'G' }}</li>
 * </ul>
 * ```
 */
class DatePipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.
     * @return - The formatted date.
     */
    transform(value, format$$1 = "", localeId) {
        value = this.normalize(value);
        if (value) {
            return this.intlService.formatDate(value, format$$1, localeId);
        }
        return value;
    }
    normalize(value) {
        if (value && typeof value === 'string') {
            value = this.intlService.parseDate(value);
        }
        else if (value && isNumeric(value)) {
            value = new Date(parseFloat(value));
        }
        return value;
    }
}
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
DatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoDate", type: DatePipe, pure: true });
/** @nocollapse */
DatePipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
                name: 'kendoDate'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();

/**
 * Formats a number value to a string based on the requested format.
 * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 *   <ul>
 *     <li>{{decimal | kendoNumber:'c' }}</li>
 *     <li>{{stringNumber | kendoNumber:'p' }}</li>
 *     <li>{{int | kendoNumber:'##.00' }}</li>
 *  </ul>
 * ```
 */
class NumberPipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Number` object into a string based on the specified format.
     * If no format is provided, the value is formatted as decimal number using the
     * [`"n"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.
     *
     * @param value - The numer that will be formatted.
     * @param format - The format string or options.
     * @param localeId - (Optional) The locale ID that will be used in place of the default one.
     * @return - The formatted number.
     */
    transform(value, format$$1, localeId) {
        if (typeof value === 'string') {
            value = this.intlService.parseNumber(value);
        }
        if (value !== null && value !== undefined) {
            return this.intlService.formatNumber(value, format$$1, localeId);
        }
        return value;
    }
}
NumberPipe.ɵfac = function NumberPipe_Factory(t) { return new (t || NumberPipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
NumberPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoNumber", type: NumberPipe, pure: true });
/** @nocollapse */
NumberPipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberPipe, [{
        type: Pipe,
        args: [{
                name: 'kendoNumber'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();

const pipes = [
    DatePipe,
    NumberPipe
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)
 * definition for the Intl services.
 */
class IntlModule {
}
IntlModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntlModule });
IntlModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntlModule_Factory(t) { return new (t || IntlModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntlModule, { declarations: [DatePipe,
        NumberPipe], exports: [DatePipe,
        NumberPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlModule, [{
        type: NgModule,
        args: [{
                declarations: [pipes],
                exports: [pipes]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { cldrServiceFactory, IntlService, CldrIntlService, DatePipe, ɵ0, NumberPipe, IntlModule, dateFormatNames$1 as dateFormatNames, dateFieldName$1 as dateFieldName, firstDay$1 as firstDay, format$1 as format, formatDate$1 as formatDate, formatNumber$1 as formatNumber, load$1 as load, numberSymbols$1 as numberSymbols, parseDate$1 as parseDate, parseNumber$1 as parseNumber, splitDateFormat$1 as splitDateFormat, toString$1 as toString, weekendRange$1 as weekendRange, setData$1 as setData, localeData };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5Q0FPRTtBQUNGOzs7Ozs7OztnREFBc0w7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0ZBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O3FFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEZBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O3FFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbmplY3RhYmxlLCBMT0NBTEVfSUQsIGRlZmluZUluamVjdGFibGUsIGluamVjdCwgSW5qZWN0LCBQaXBlLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGF0ZUZvcm1hdE5hbWVzLCBkYXRlRmllbGROYW1lLCBmaXJzdERheSwgZm9ybWF0LCBmb3JtYXREYXRlLCBmb3JtYXROdW1iZXIsIGxvYWQsIG51bWJlclN5bWJvbHMsIHBhcnNlRGF0ZSwgcGFyc2VOdW1iZXIsIHNwbGl0RGF0ZUZvcm1hdCwgdG9TdHJpbmcsIHdlZWtlbmRSYW5nZSwgc2V0RGF0YSwgbG9jYWxlSW5mbyB9IGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWludGwnO1xuXG5jb25zdCBET0NTX1VSTCA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9pbnRlcm5hdGlvbmFsaXphdGlvbi90cm91Ymxlc2hvb3RpbmcvJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlcnJvclNvbHV0aW9ucyA9IHtcbiAgICAnTm9DdXJyZW5jeSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5YCxcbiAgICAnTm9DdXJyZW5jeURpc3BsYXknOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeS1kaXNwbGF5YCxcbiAgICAnTm9DdXJyZW5jeVJlZ2lvbic6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5LXJlZ2lvbmAsXG4gICAgJ05vRGF0ZUZpZWxkTmFtZXMnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1kYXRlLWZpbGVkLW5hbWVzYCxcbiAgICAnTm9GaXJzdERheSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWZpcnN0LWRheWAsXG4gICAgJ05vR01USW5mbyc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWdtdC1pbmZvYCxcbiAgICAnTm9Mb2NhbGUnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1sb2NhbGVgLFxuICAgICdOb1ZhbGlkQ3VycmVuY3knOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby12YWxpZC1jdXJyZW5jeWAsXG4gICAgJ05vV2Vla0RhdGEnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby13ZWVrLWRhdGFgXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgY29uc3QgZXJyb3JTb2x1dGlvbiA9IGVycm9yU29sdXRpb25zW09iamVjdC5rZXlzKGVycm9yU29sdXRpb25zKS5maWx0ZXIoa2V5ID0+IG1lc3NhZ2UuaW5kZXhPZihrZXkpID09PSAwKVswXV07XG4gICAgcmV0dXJuIGVycm9yU29sdXRpb24gPyBgJHttZXNzYWdlfSAke2Vycm9yU29sdXRpb259YCA6IG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBpbnRsTWV0aG9kKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi52YWx1ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGVGb3JtYXROYW1lcyQxID0gaW50bE1ldGhvZChkYXRlRm9ybWF0TmFtZXMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGVGaWVsZE5hbWUkMSA9IGludGxNZXRob2QoZGF0ZUZpZWxkTmFtZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZmlyc3REYXkkMSA9IGludGxNZXRob2QoZmlyc3REYXkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdCQxID0gaW50bE1ldGhvZChmb3JtYXQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdERhdGUkMSA9IGludGxNZXRob2QoZm9ybWF0RGF0ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9ybWF0TnVtYmVyJDEgPSBpbnRsTWV0aG9kKGZvcm1hdE51bWJlcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbG9hZCQxID0gaW50bE1ldGhvZChsb2FkKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBudW1iZXJTeW1ib2xzJDEgPSBpbnRsTWV0aG9kKG51bWJlclN5bWJvbHMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhcnNlRGF0ZSQxID0gaW50bE1ldGhvZChwYXJzZURhdGUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhcnNlTnVtYmVyJDEgPSBpbnRsTWV0aG9kKHBhcnNlTnVtYmVyKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzcGxpdERhdGVGb3JtYXQkMSA9IGludGxNZXRob2Qoc3BsaXREYXRlRm9ybWF0KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b1N0cmluZyQxID0gaW50bE1ldGhvZCh0b1N0cmluZyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgd2Vla2VuZFJhbmdlJDEgPSBpbnRsTWV0aG9kKHdlZWtlbmRSYW5nZSk7XG4vKipcbiAqIFNldHMgYSBwcmUtYnVpbHQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbXMgZGF0YSAtIFRoZSBwcmUtYnVpbHQgbG9jYWxlIGRhdGEuXG4gKi9cbmNvbnN0IHNldERhdGEkMSA9IChkYXRhKSA9PiBzZXREYXRhKGRhdGEpO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW1zIGxvY2FsZSAtIFRoZSBsb2NhbGUgaWQuXG4gKiBAcmV0dXJucyBkYXRhIC0gVGhlIGxvY2FsZSBkYXRhLlxuICovXG5jb25zdCBsb2NhbGVEYXRhID0gKGxvY2FsZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVJbmZvKGxvY2FsZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gZm9ybWF0TWVzc2FnZShlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cbmNvbnN0IExPQ0FMRV9SRUdFWCA9IC9fL2c7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY2xkclNlcnZpY2VGYWN0b3J5KGxvY2FsZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBDbGRySW50bFNlcnZpY2UobG9jYWxlSWQpO1xufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRoYXQgaW1wbGVtZW50c1xuICogdGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgbWV0aG9kc1xuICogZm9yIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAqL1xuY2xhc3MgSW50bFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGF0IHRoZSBzZXJ2aWNlIHdhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoKTtcbiAgICB9XG59XG5JbnRsU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogY2xkclNlcnZpY2VGYWN0b3J5LFxuICAgICAgICAgICAgICAgIGRlcHM6IFtMT0NBTEVfSURdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5JbnRsU2VydmljZS5uZ0luamVjdGFibGVEZWYgPSBkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gSW50bFNlcnZpY2VfRmFjdG9yeSgpIHsgcmV0dXJuIGNsZHJTZXJ2aWNlRmFjdG9yeShpbmplY3QoTE9DQUxFX0lEKSk7IH0sIHRva2VuOiBJbnRsU2VydmljZSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG4vKipcbiAqIFRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIGltcGxlbWVudGVkIGJ5IHVzaW5nXG4gKiB0aGUgQ0xEUiBEYXRhYmFzZSB2aWEgdGhlIGBAdGVsZXJpay9rZW5kby1pbnRsYCBwYWNrYWdlLlxuICovXG5jbGFzcyBDbGRySW50bFNlcnZpY2UgZXh0ZW5kcyBJbnRsU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgc2VydmljZSB3aXRoIHRoZSBJRCBvZiB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgcGFydHMgb2YgdGhlIGxvY2FsZSBJRCBjYW4gYmUgc2VwYXJhdGVkIGJ5IGVpdGhlciBgX2AgKHVuZGVyc2NvcmUpXG4gICAgICogb3IgYC1gIChkYXNoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBkZWZhdWx0IGxvY2FsZSBJRC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsZUlkID0gbG9jYWxlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGU7XG4gICAgfVxuICAgIHNldCBsb2NhbGVJZCh2YWx1ZSkge1xuICAgICAgICAvLyBBbmd1bGFyIGxvY2FsZXMgdXNlIHVuZGVyc2NvcmUsIGZvciBleGFtcGxlLCBlbl9VU1xuICAgICAgICAvLyB3aGlsZSBJRVRGIEJDUC00NyBzcGVjaWZpZXMgYSBkYXNoLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvYmNwNDdcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdmFsdWUucmVwbGFjZShMT0NBTEVfUkVHRVgsICctJyk7XG4gICAgICAgIGlmIChsb2NhbGUgIT09IHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHN0cmluZyB3aXRoIHBsYWNlaG9sZGVycyBzdWNoIGFzXG4gICAgICogYFRvdGFsIGFtb3VudCB7MDpjfWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9uZSBvciBtb3JlIHZhbHVlcyB0byBvdXRwdXQgaW4gdGhlIGZvcm1hdCBzdHJpbmcgcGxhY2Vob2xkZXJzLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0JCQxLCAuLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCQxKGZvcm1hdCQkMSwgdmFsdWVzLCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIGZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBEYXRlYCBvYmplY3QgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5ncyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIGRhdGUuXG4gICAgICovXG4gICAgcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBOdW1iZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIG51bWJlci5cbiAgICAgKi9cbiAgICBwYXJzZU51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXIkMSh2YWx1ZSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCwgZm9ybWF0JCQxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgYHR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZXJhYFxuICAgICAqIC0gYHllYXJgXG4gICAgICogLSBgcXVhcnRlcmBcbiAgICAgKiAtIGBtb250aGBcbiAgICAgKiAtIGB3ZWVrYFxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgaG91cmBcbiAgICAgKiAtIGBtaW51dGVgXG4gICAgICogLSBgc2Vjb25kYFxuICAgICAqIC0gYHpvbmVgXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGBuYW1lVHlwZWAgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGB3aWRlYFxuICAgICAqIC0gYG5hcnJvd2BcbiAgICAgKiAtIGBzaG9ydGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmaWVsZCBuYW1lLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRhdGUgZmllbGQgbmFtZSBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScgfSk7ICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICdzaG9ydCcgfSk7IC8vcmV0dXJucyAnbW8uJztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgIC8vcmV0dXJucyAnbW9udGgnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRhdGVGaWVsZE5hbWUob3B0aW9ucywgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVGaWVsZE5hbWUkMShvcHRpb25zLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgYmFzZWQgb24gc3BlY2lmaWMgZGF0ZUZpZWxkTmFtZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSB0eXBlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZGF5YFxuICAgICAqIC0gYGRheXBlcmlvZGBcbiAgICAgKiAtIGBtb250aHNgXG4gICAgICogLSBgcXVhcnRlcnNgXG4gICAgICogLSBgZXJhc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmb3JtYXQuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXROYW1lcyhvcHRpb25zLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZGF0ZUZvcm1hdE5hbWVzJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgZGF0ZSBmb3JtYXQgaW50byBvYmplY3RzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBwYXJ0IG9mIHRoZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCBUaGUgb3B0aW9uYWwgbG9jYWxlIGlkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYFwiZW5cImAgbG9jYWxlIGlkIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUgZm9ybWF0IHBhcnRzLlxuICAgICAqL1xuICAgIHNwbGl0RGF0ZUZvcm1hdChmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBzcGxpdERhdGVGb3JtYXQkMShmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIG51bWJlciBzeW1ib2xzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlLlxuICAgICAqL1xuICAgIG51bWJlclN5bWJvbHMobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclN5bWJvbHMkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZGF5IGluZGV4IHN0YXJ0aW5nIGZyb20gU3VuZGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRC4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqIEByZXR1cm4gLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIGZpcnN0RGF5KGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdERheSQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIHdlZWtlbmRSYW5nZShsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gd2Vla2VuZFJhbmdlJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxufVxuQ2xkckludGxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DbGRySW50bFNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0xPQ0FMRV9JRCxdIH1dIH1cbl07XG5cbmNvbnN0IGlzTnVtZXJpYyA9ICh2YWx1ZSkgPT4gIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpO1xuY29uc3QgybUwID0gaXNOdW1lcmljO1xuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSB2YWx1ZSB0byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgcmVxdWVzdGVkIGZvcm1hdC5cbiAqIFRoaXMgcGlwZSB1c2VzIHRoZSBbSW50bFNlcnZpY2VdKHslIHNsdWcgYXBpX2ludGxfaW50bHNlcnZpY2UgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBuZy10ZW1wbGF0ZS1uby1ydW5cbiAqIDx1bD5cbiAqICAgIDxsaT57e2RhdGUgfCBrZW5kb0RhdGUgfX08L2xpPlxuICogICAgPGxpPnt7bWlsbGlzZWNvbmRzIHwga2VuZG9EYXRlOiAnTS9kZC95eXknIH19PC9saT5cbiAqICAgIDxsaT57e3N0cmluZ0RhdGUgfCBrZW5kb0RhdGU6ICdHJyB9fTwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKi9cbmNsYXNzIERhdGVQaXBlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW50bFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pbnRsU2VydmljZSA9IGludGxTZXJ2aWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNob3J0IGRhdGUgZm9ybWF0IGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gKE9wdGlvbmFsKSBUaGUgSUQgb2YgdGhlIGxvY2FsZSB3aGljaCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0odmFsdWUsIGZvcm1hdCQkMSA9IFwiXCIsIGxvY2FsZUlkKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5ub3JtYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGxTZXJ2aWNlLmZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbm9ybWFsaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW50bFNlcnZpY2UucGFyc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAmJiBpc051bWVyaWModmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuRGF0ZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IFBpcGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2tlbmRvRGF0ZSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRGF0ZVBpcGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJbnRsU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKiBUaGlzIHBpcGUgdXNlcyB0aGUgW2BJbnRsU2VydmljZWBdKHslIHNsdWcgYXBpX2ludGxfaW50bHNlcnZpY2UgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBuZy10ZW1wbGF0ZS1uby1ydW5cbiAqICAgPHVsPlxuICogICAgIDxsaT57e2RlY2ltYWwgfCBrZW5kb051bWJlcjonYycgfX08L2xpPlxuICogICAgIDxsaT57e3N0cmluZ051bWJlciB8IGtlbmRvTnVtYmVyOidwJyB9fTwvbGk+XG4gKiAgICAgPGxpPnt7aW50IHwga2VuZG9OdW1iZXI6JyMjLjAwJyB9fTwvbGk+XG4gKiAgPC91bD5cbiAqIGBgYFxuICovXG5jbGFzcyBOdW1iZXJQaXBlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW50bFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pbnRsU2VydmljZSA9IGludGxTZXJ2aWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBOdW1iZXJgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIHZhbHVlIGlzIGZvcm1hdHRlZCBhcyBkZWNpbWFsIG51bWJlciB1c2luZyB0aGVcbiAgICAgKiBbYFwiblwiYF0oaHR0cHM6Ly9naXRodWIuY29tL3RlbGVyaWsva2VuZG8taW50bC9ibG9iL21hc3Rlci9kb2NzL251bS1mb3JtYXR0aW5nL2luZGV4Lm1kI3N0YW5kYXJkKSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtZXIgdGhhdCB3aWxsIGJlIGZvcm1hdHRlZC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSAoT3B0aW9uYWwpIFRoZSBsb2NhbGUgSUQgdGhhdCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0odmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRsU2VydmljZS5wYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGxTZXJ2aWNlLmZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbk51bWJlclBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IFBpcGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2tlbmRvTnVtYmVyJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5OdW1iZXJQaXBlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogSW50bFNlcnZpY2UgfVxuXTtcblxuY29uc3QgcGlwZXMgPSBbXG4gICAgRGF0ZVBpcGUsXG4gICAgTnVtYmVyUGlwZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19ZG9jcy90cy9sYXRlc3QvZ3VpZGUvbmdtb2R1bGUuaHRtbClcbiAqIGRlZmluaXRpb24gZm9yIHRoZSBJbnRsIHNlcnZpY2VzLlxuICovXG5jbGFzcyBJbnRsTW9kdWxlIHtcbn1cbkludGxNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW3BpcGVzXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbcGlwZXNdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgY2xkclNlcnZpY2VGYWN0b3J5LCBJbnRsU2VydmljZSwgQ2xkckludGxTZXJ2aWNlLCBEYXRlUGlwZSwgybUwLCBOdW1iZXJQaXBlLCBJbnRsTW9kdWxlLCBkYXRlRm9ybWF0TmFtZXMkMSBhcyBkYXRlRm9ybWF0TmFtZXMsIGRhdGVGaWVsZE5hbWUkMSBhcyBkYXRlRmllbGROYW1lLCBmaXJzdERheSQxIGFzIGZpcnN0RGF5LCBmb3JtYXQkMSBhcyBmb3JtYXQsIGZvcm1hdERhdGUkMSBhcyBmb3JtYXREYXRlLCBmb3JtYXROdW1iZXIkMSBhcyBmb3JtYXROdW1iZXIsIGxvYWQkMSBhcyBsb2FkLCBudW1iZXJTeW1ib2xzJDEgYXMgbnVtYmVyU3ltYm9scywgcGFyc2VEYXRlJDEgYXMgcGFyc2VEYXRlLCBwYXJzZU51bWJlciQxIGFzIHBhcnNlTnVtYmVyLCBzcGxpdERhdGVGb3JtYXQkMSBhcyBzcGxpdERhdGVGb3JtYXQsIHRvU3RyaW5nJDEgYXMgdG9TdHJpbmcsIHdlZWtlbmRSYW5nZSQxIGFzIHdlZWtlbmRSYW5nZSwgc2V0RGF0YSQxIGFzIHNldERhdGEsIGxvY2FsZURhdGEgfTtcbiJdfQ==