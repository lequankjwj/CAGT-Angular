/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter } from '@angular/core';
import { DateFieldNameOptions, DateFormatOptions, DateFormatNameOptions, NumberFormatOptions, DateFormatPart, DayRange } from '@telerik/kendo-intl';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
export declare function cldrServiceFactory(localeId: string): CldrIntlService;
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
export declare abstract class IntlService {
    /**
     * @hidden
     */
    readonly changes: EventEmitter<any>;
    /**
     * Notifies that the service was changed.
     */
    notify(): void;
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    abstract format(format: string, ...values: any[]): string;
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The formatted object.
     */
    abstract toString(value: any, format: string | any, localeId?: string): string;
    /**
     * Converts a `Date` object into a string based on the specified format
     * ([see example]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The formatted date.
     */
    abstract formatDate(value: Date, format?: String | DateFormatOptions, localeId?: string): string;
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The parsed date.
     */
    abstract parseDate(value: string, format?: string | DateFormatOptions | string[] | DateFormatOptions[], localeId?: string): Date;
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The parsed number.
     */
    abstract parseNumber(value: string, format?: string | NumberFormatOptions, localeId?: string): number;
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The formatted number.
     */
    abstract formatNumber(value: number, format: string | NumberFormatOptions, localeId?: string): string;
    /**
     * Returns the day names from the current locale based on the option.
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default. Optional.
     * @return - The day names from the current locale based on the option.
     */
    abstract dateFormatNames(options: DateFormatNameOptions, localeId?: string): any;
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    abstract dateFieldName(options: DateFieldNameOptions, localeId?: string): string;
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    abstract splitDateFormat(format: string | DateFormatOptions, localeId?: string): DateFormatPart[];
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    abstract numberSymbols(localeId?: string): any;
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    abstract firstDay(localeId?: string): number;
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    abstract weekendRange(localeId?: string): DayRange;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IntlService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IntlService>;
}
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
export declare class CldrIntlService extends IntlService {
    private locale;
    /**
     * Gets or sets the current locale ID.
     */
    localeId: string;
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId: string);
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format: string, ...values: any[]): string;
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value: any, format: string | any, localeId?: string): string;
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value: Date, format?: String | DateFormatOptions, localeId?: string): string;
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value: string, format?: string | DateFormatOptions | string[] | DateFormatOptions[], localeId?: string): Date;
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value: string, format?: string | NumberFormatOptions, localeId?: string): number;
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value: number, format: string | NumberFormatOptions, localeId?: string): string;
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options: DateFieldNameOptions, localeId?: string): string;
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options: DateFormatNameOptions, localeId?: string): any;
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format: string | DateFormatOptions, localeId?: string): DateFormatPart[];
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId?: string): any;
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId?: string): number;
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId?: string): DayRange;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CldrIntlService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<CldrIntlService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50bC5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImludGwuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlRmllbGROYW1lT3B0aW9ucywgRGF0ZUZvcm1hdE9wdGlvbnMsIERhdGVGb3JtYXROYW1lT3B0aW9ucywgTnVtYmVyRm9ybWF0T3B0aW9ucywgRGF0ZUZvcm1hdFBhcnQsIERheVJhbmdlIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gY2xkclNlcnZpY2VGYWN0b3J5KGxvY2FsZUlkOiBzdHJpbmcpOiBDbGRySW50bFNlcnZpY2U7XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCBpbXBsZW1lbnRzXG4gKiB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gc2VydmljZSBtZXRob2RzXG4gKiBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLlxuICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBJbnRsU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNoYW5nZXM6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoYXQgdGhlIHNlcnZpY2Ugd2FzIGNoYW5nZWQuXG4gICAgICovXG4gICAgbm90aWZ5KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHN0cmluZyB3aXRoIHBsYWNlaG9sZGVycyBzdWNoIGFzXG4gICAgICogYFRvdGFsIGFtb3VudCB7MDpjfWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9uZSBvciBtb3JlIHZhbHVlcyB0byBvdXRwdXQgaW4gdGhlIGZvcm1hdCBzdHJpbmcgcGxhY2Vob2xkZXJzLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmb3JtYXQoZm9ybWF0OiBzdHJpbmcsIC4uLnZhbHVlczogYW55W10pOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdC4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIGFic3RyYWN0IHRvU3RyaW5nKHZhbHVlOiBhbnksIGZvcm1hdDogc3RyaW5nIHwgYW55LCBsb2NhbGVJZD86IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFyc2luZ2FuZGZvcm1hdHRpbmdfaW50bCAlfSN0b2MtZGF0ZS1mb3JtYXR0aW5nKSkuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBzaG9ydCBkYXRlIGZvcm1hdCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0LiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIGFic3RyYWN0IGZvcm1hdERhdGUodmFsdWU6IERhdGUsIGZvcm1hdD86IFN0cmluZyB8IERhdGVGb3JtYXRPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgYERhdGVgIG9iamVjdCBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmdzIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgcGFyc2VkIGRhdGUuXG4gICAgICovXG4gICAgYWJzdHJhY3QgcGFyc2VEYXRlKHZhbHVlOiBzdHJpbmcsIGZvcm1hdD86IHN0cmluZyB8IERhdGVGb3JtYXRPcHRpb25zIHwgc3RyaW5nW10gfCBEYXRlRm9ybWF0T3B0aW9uc1tdLCBsb2NhbGVJZD86IHN0cmluZyk6IERhdGU7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBOdW1iZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0LiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHBhcnNlZCBudW1iZXIuXG4gICAgICovXG4gICAgYWJzdHJhY3QgcGFyc2VOdW1iZXIodmFsdWU6IHN0cmluZywgZm9ybWF0Pzogc3RyaW5nIHwgTnVtYmVyRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmb3JtYXROdW1iZXIodmFsdWU6IG51bWJlciwgZm9ybWF0OiBzdHJpbmcgfCBOdW1iZXJGb3JtYXRPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmb3JtYXQuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZGF5IG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICovXG4gICAgYWJzdHJhY3QgZGF0ZUZvcm1hdE5hbWVzKG9wdGlvbnM6IERhdGVGb3JtYXROYW1lT3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBhbnk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgYmFzZWQgb24gc3BlY2lmaWMgZGF0ZUZpZWxkTmFtZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBEZXRhaWxlZCBjb25maWd1cmF0aW9uIGZvciB0aGUgZGVzaXJlZCBkYXRlIGZpZWxkIG5hbWUuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIFRoZSBvcHRpb25hbCBsb2NhbGUgaWQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBgXCJlblwiYCBsb2NhbGUgaWQgaXMgdXNlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRhdGUgZmllbGQgbmFtZSBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScgfSk7ICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICdzaG9ydCcgfSk7IC8vcmV0dXJucyAnbW8uJztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgIC8vcmV0dXJucyAnbW9udGgnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFic3RyYWN0IGRhdGVGaWVsZE5hbWUob3B0aW9uczogRGF0ZUZpZWxkTmFtZU9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgZGF0ZSBmb3JtYXQgaW50byBvYmplY3RzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBwYXJ0IG9mIHRoZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCBUaGUgb3B0aW9uYWwgbG9jYWxlIGlkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYFwiZW5cImAgbG9jYWxlIGlkIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUgZm9ybWF0IHBhcnRzLlxuICAgICAqL1xuICAgIGFic3RyYWN0IHNwbGl0RGF0ZUZvcm1hdChmb3JtYXQ6IHN0cmluZyB8IERhdGVGb3JtYXRPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IERhdGVGb3JtYXRQYXJ0W107XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBudW1iZXJTeW1ib2xzKGxvY2FsZUlkPzogc3RyaW5nKTogYW55O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGRheSBpbmRleCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmaXJzdERheShsb2NhbGVJZD86IHN0cmluZyk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIGFic3RyYWN0IHdlZWtlbmRSYW5nZShsb2NhbGVJZD86IHN0cmluZyk6IERheVJhbmdlO1xufVxuLyoqXG4gKiBUaGUgSW50ZXJuYXRpb25hbGl6YXRpb24gc2VydmljZSBpbXBsZW1lbnRlZCBieSB1c2luZ1xuICogdGhlIENMRFIgRGF0YWJhc2UgdmlhIHRoZSBgQHRlbGVyaWsva2VuZG8taW50bGAgcGFja2FnZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ2xkckludGxTZXJ2aWNlIGV4dGVuZHMgSW50bFNlcnZpY2Uge1xuICAgIHByaXZhdGUgbG9jYWxlO1xuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgbG9jYWxlSWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzZXJ2aWNlIHdpdGggdGhlIElEIG9mIHRoZSBzcGVjaWZpZWQgbG9jYWxlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBwYXJ0cyBvZiB0aGUgbG9jYWxlIElEIGNhbiBiZSBzZXBhcmF0ZWQgYnkgZWl0aGVyIGBfYCAodW5kZXJzY29yZSlcbiAgICAgKiBvciBgLWAgKGRhc2gpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGRlZmF1bHQgbG9jYWxlIElELlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZUlkOiBzdHJpbmcpO1xuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMgc3VjaCBhc1xuICAgICAqIGBUb3RhbCBhbW91bnQgezA6Y31gLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBPbmUgb3IgbW9yZSB2YWx1ZXMgdG8gb3V0cHV0IGluIHRoZSBmb3JtYXQgc3RyaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdDogc3RyaW5nLCAuLi52YWx1ZXM6IGFueVtdKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byB1c2UuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKHZhbHVlOiBhbnksIGZvcm1hdDogc3RyaW5nIHwgYW55LCBsb2NhbGVJZD86IHN0cmluZyk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNob3J0IGRhdGUgZm9ybWF0IGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBmb3JtYXREYXRlKHZhbHVlOiBEYXRlLCBmb3JtYXQ/OiBTdHJpbmcgfCBEYXRlRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBEYXRlYCBvYmplY3QgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5ncyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIGRhdGUuXG4gICAgICovXG4gICAgcGFyc2VEYXRlKHZhbHVlOiBzdHJpbmcsIGZvcm1hdD86IHN0cmluZyB8IERhdGVGb3JtYXRPcHRpb25zIHwgc3RyaW5nW10gfCBEYXRlRm9ybWF0T3B0aW9uc1tdLCBsb2NhbGVJZD86IHN0cmluZyk6IERhdGU7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBOdW1iZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIG51bWJlci5cbiAgICAgKi9cbiAgICBwYXJzZU51bWJlcih2YWx1ZTogc3RyaW5nLCBmb3JtYXQ/OiBzdHJpbmcgfCBOdW1iZXJGb3JtYXRPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICovXG4gICAgZm9ybWF0TnVtYmVyKHZhbHVlOiBudW1iZXIsIGZvcm1hdDogc3RyaW5nIHwgTnVtYmVyRm9ybWF0T3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBgdHlwZWAgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGBlcmFgXG4gICAgICogLSBgeWVhcmBcbiAgICAgKiAtIGBxdWFydGVyYFxuICAgICAqIC0gYG1vbnRoYFxuICAgICAqIC0gYHdlZWtgXG4gICAgICogLSBgZGF5YFxuICAgICAqIC0gYGRheXBlcmlvZGBcbiAgICAgKiAtIGBob3VyYFxuICAgICAqIC0gYG1pbnV0ZWBcbiAgICAgKiAtIGBzZWNvbmRgXG4gICAgICogLSBgem9uZWBcbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgYG5hbWVUeXBlYCB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYHdpZGVgXG4gICAgICogLSBgbmFycm93YFxuICAgICAqIC0gYHNob3J0YFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBEZXRhaWxlZCBjb25maWd1cmF0aW9uIGZvciB0aGUgZGVzaXJlZCBkYXRlIGZpZWxkIG5hbWUuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnZGF5JyB9KTsgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm5zICdkYXknO1xuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnZGF5JywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgICAgLy9yZXR1cm5zICdkYXknO1xuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnbW9udGgnLCBuYW1lVHlwZTogJ3Nob3J0JyB9KTsgLy9yZXR1cm5zICdtby4nO1xuICAgICAqIGRhdGVGaWVsZE5hbWUoeyB0eXBlOiAnbW9udGgnLCBuYW1lVHlwZTogJ3dpZGUnIH0pOyAgLy9yZXR1cm5zICdtb250aCc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGF0ZUZpZWxkTmFtZShvcHRpb25zOiBEYXRlRmllbGROYW1lT3B0aW9ucywgbG9jYWxlSWQ/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgYmFzZWQgb24gc3BlY2lmaWMgZGF0ZUZpZWxkTmFtZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSB0eXBlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZGF5YFxuICAgICAqIC0gYGRheXBlcmlvZGBcbiAgICAgKiAtIGBtb250aHNgXG4gICAgICogLSBgcXVhcnRlcnNgXG4gICAgICogLSBgZXJhc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmb3JtYXQuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXROYW1lcyhvcHRpb25zOiBEYXRlRm9ybWF0TmFtZU9wdGlvbnMsIGxvY2FsZUlkPzogc3RyaW5nKTogYW55O1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgZGF0ZSBmb3JtYXQgaW50byBvYmplY3RzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBwYXJ0IG9mIHRoZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCBUaGUgb3B0aW9uYWwgbG9jYWxlIGlkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYFwiZW5cImAgbG9jYWxlIGlkIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUgZm9ybWF0IHBhcnRzLlxuICAgICAqL1xuICAgIHNwbGl0RGF0ZUZvcm1hdChmb3JtYXQ6IHN0cmluZyB8IERhdGVGb3JtYXRPcHRpb25zLCBsb2NhbGVJZD86IHN0cmluZyk6IERhdGVGb3JtYXRQYXJ0W107XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAgICAgKi9cbiAgICBudW1iZXJTeW1ib2xzKGxvY2FsZUlkPzogc3RyaW5nKTogYW55O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGRheSBpbmRleCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBmaXJzdERheShsb2NhbGVJZD86IHN0cmluZyk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIHdlZWtlbmRSYW5nZShsb2NhbGVJZD86IHN0cmluZyk6IERheVJhbmdlO1xufVxuIl19