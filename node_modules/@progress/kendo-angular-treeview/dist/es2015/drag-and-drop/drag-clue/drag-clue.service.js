/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable, ComponentFactoryResolver } from '@angular/core';
import { DragClueComponent } from './drag-clue.component';
import { isPresent, dataItemsEqual } from '../../utils';
import { DragAndDropAssetService } from '../editing-services/drag-and-drop-asset.service';
/**
 * @hidden
 */
export const CLUE_OFFSET = 10;
/**
 * @hidden
 */
export const RETURN_ANIMATION_DURATION = 200;
/**
 * @hidden
 */
export class DragClueService extends DragAndDropAssetService {
    constructor(componentFactoryResolver) {
        super();
        this.componentFactoryResolver = componentFactoryResolver;
    }
    initialize(container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        const clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);
        this.componentRef = container.createComponent(clueComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    }
    ngOnDestroy() {
        this.cancelReturnAnimation();
        super.ngOnDestroy();
    }
    move(left, top) {
        super.move(left, top, CLUE_OFFSET);
    }
    animateDragClueToElementPosition(target) {
        if (!(isPresent(target) && isPresent(this.element.animate))) {
            this.hide();
            return;
        }
        const targetElementViewPortCoords = target.getBoundingClientRect();
        const clueElementViewPortCoords = this.element.getBoundingClientRect();
        this.returnAnimation = this.element.animate([
            { transform: 'translate(0, 0)' },
            { transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)` }
        ], RETURN_ANIMATION_DURATION);
        this.returnAnimation.onfinish = () => this.hide();
    }
    cancelReturnAnimation() {
        if (!isPresent(this.returnAnimation)) {
            return;
        }
        this.returnAnimation.cancel();
        this.returnAnimation = null;
    }
    updateDragClueData(action, sourceItem, destinationItem) {
        const dragClue = this.componentRef.instance;
        if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
            return;
        }
        dragClue.action = action;
        dragClue.sourceItem = sourceItem;
        dragClue.destinationItem = destinationItem;
        dragClue.detectChanges();
    }
    updateText(text) {
        if (text === this.componentRef.instance.text) {
            return;
        }
        this.componentRef.instance.text = text;
        this.componentRef.instance.detectChanges();
    }
}
DragClueService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DragClueService.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
