/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { getter, setter } from '@progress/kendo-common';
import { DropPosition } from '../models';
import { collapseEmptyParent, expandDropTarget } from '../drag-and-drop-utils';
import { decrementPageSize, incrementPageSize, copyPageSize } from '../../load-more/load-more-utils';
import { isPresent, getDataItem } from '../../utils';
/**
 * @hidden
 */
export class HierarchyEditingService {
    constructor(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, destinationTree }) {
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationChildren = this.childrenFor(getDataItem(destinationItem));
            // add the moved node just before the load more button if load more is enabled
            const targetIndex = isPresent(destinationTree.loadMoreService) ?
                destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)) :
                destinationChildren.length;
            destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
            setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);
        }
        else {
            const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
        }
        // increment the parent page size => an item is moved into it
        const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    }
    remove({ sourceItem, sourceTree }) {
        const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    }
    getParentNodes(node, treeView) {
        return isPresent(node.parent) ?
            this.childrenFor(getDataItem(node.parent)) :
            treeView.nodes;
    }
    childrenFor(dataItem) {
        return getter(this.hierarchyBinding.childrenField)(dataItem) || [];
    }
}
