/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { isDocumentAvailable } from '@progress/kendo-angular-common';
import { isPresent, closestNode, closestWithMatch, hasParent, isContent, nodeId, getContentElement } from '../utils';
import { DropPosition, DropAction } from './models';
const ɵ0 = () => {
    if (!(isDocumentAvailable() && isPresent(document.body))) {
        return false;
    }
    const top = 10;
    const parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = `<div style="position: fixed; top: ${top}px;">child</div>`;
    document.body.appendChild(parent);
    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
const hasRelativeStackingContext = memoize(ɵ0);
/**
 * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.
 */
function memoize(fn) {
    let result;
    let called = false;
    return (...args) => {
        if (called) {
            return result;
        }
        result = fn(...args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
export const getContainerOffset = (element) => {
    if (!(element && hasRelativeStackingContext())) {
        return { left: 0, top: 0 };
    }
    let offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        const rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
export const getDropAction = (dropPosition, dropTarget) => {
    if (!(isPresent(dropPosition) && isPresent(dropTarget))) {
        return DropAction.Invalid;
    }
    switch (dropPosition) {
        case DropPosition.Over:
            return DropAction.Add;
        case DropPosition.Before:
            return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
        case DropPosition.After:
            return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
        default:
            return DropAction.Invalid;
    }
};
/**
 * @hidden
 */
export const getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {
    if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {
        return;
    }
    // the .k-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    const item = closestWithMatch(target, '.k-mid');
    if (!isPresent(item)) {
        return;
    }
    // the content element (.k-in:not(.k-treeview-load-more-button)) holds just the treeview item text
    const content = getContentElement(item);
    const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
    if (!isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    const itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:
            - dropping should insert before or after
    */
    const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    const pointerPosition = clientY - containerOffset.top;
    const itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return DropPosition.After;
    }
    return DropPosition.Over;
};
/**
 * @hidden
 */
export const treeItemFromEventTarget = (treeView, dropTarget) => {
    if (!(isPresent(treeView) && isPresent(dropTarget))) {
        return null;
    }
    const node = closestNode(dropTarget);
    const index = nodeId(node);
    const lookup = treeView.itemLookup(index);
    if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {
        return null;
    }
    return lookup;
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
export const collapseEmptyParent = (parent, parentNodes, treeview) => {
    if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
export const expandDropTarget = (dropTarget, treeView) => {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
export const getDropTarget = (event) => {
    if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};
export { ɵ0 };
