/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, ElementRef, NgZone, ContentChild, Input, HostBinding } from '@angular/core';
import { hasObservers } from '@progress/kendo-angular-common';
import Draggable from '@telerik/kendo-draggable';
import { DragClueService } from './drag-clue/drag-clue.service';
import { DropHintService } from './drop-hint/drop-hint.service';
import { DragClueTemplateDirective } from './drag-clue/drag-clue-template.directive';
import { DropHintTemplateDirective } from './drop-hint/drop-hint-template.directive';
import { getDropAction, getDropPosition, treeItemFromEventTarget, getContainerOffset, getDropTarget } from './drag-and-drop-utils';
import { closestWithMatch, isPresent, isContent } from '../utils';
import { TreeViewComponent } from '../treeview.component';
import { TreeItemDropEvent, DropPosition, TreeItemDragStartEvent } from './models';
/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances
 * ([see example]({% slug draganddrop_treeview %})).
 *
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
var DragAndDropDirective = /** @class */ (function () {
    function DragAndDropDirective(element, zone, treeview, dragClueService, dropHintService) {
        this.element = element;
        this.zone = zone;
        this.treeview = treeview;
        this.dragClueService = dragClueService;
        this.dropHintService = dropHintService;
        /**
         * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
         * If enabled, the `removeItem` event will not be fired on the source TreeView
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         *
         * @default false
         */
        this.allowCopy = false;
        /**
         * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         */
        this.dropZoneTreeViews = [];
        /**
         * @hidden
         */
        this.userSelectStyle = 'none';
        /**
         * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
         * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
         */
        this.containerOffset = { top: 0, left: 0 };
        this.treeview.touchActions = false;
    }
    DragAndDropDirective.prototype.ngAfterContentInit = function () {
        this.initalizeDraggable();
        this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
        this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
    };
    DragAndDropDirective.prototype.ngOnDestroy = function () {
        this.draggable.destroy();
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handlePress = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent;
        if (!isContent(originalEvent.target)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDragStart)) {
            var dragStartEvent = this.zone.run(function () { return _this.notifyDragStart(originalEvent, dropTarget); });
            if (dragStartEvent.isDefaultPrevented()) {
                return;
            }
        }
        // store the drag target on press, show it only when it's actually dragged
        this.draggedItem = closestWithMatch(originalEvent.target, '.k-in');
        this.dragClueService.cancelReturnAnimation();
        this.dragClueService.updateText(this.draggedItem.innerText);
        this.containerOffset = getContainerOffset(this.draggedItem);
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleDrag = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientX = _a.clientX, clientY = _a.clientY;
        if (!isPresent(this.draggedItem)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDrag)) {
            this.zone.run(function () { return _this.notifyDrag(originalEvent, dropTarget); });
        }
        var targetTreeView = this.getTargetTreeView(dropTarget);
        var dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
        var dropHintAnchor = closestWithMatch(dropTarget, '.k-mid');
        this.updateDropHintState(dropPosition, dropHintAnchor);
        var dropAction = getDropAction(dropPosition, dropTarget);
        var sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
        var destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
        this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleRelease = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientY = _a.clientY;
        if (!isPresent(this.draggedItem)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        var sourceTree = this.treeview;
        var destinationTree = this.getTargetTreeView(dropTarget);
        var dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
        var sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
        var destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
        if (isPresent(destinationItem) && isPresent(dropPosition)) {
            this.zone.run(function () { return _this.notifyDrop({ sourceItem: sourceItem, destinationItem: destinationItem, dropPosition: dropPosition, sourceTree: sourceTree, destinationTree: destinationTree }, originalEvent); });
        }
        else {
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
        if (hasObservers(this.treeview.nodeDragEnd)) {
            this.zone.run(function () { return _this.notifyDragEnd({ sourceItem: sourceItem, destinationItem: destinationItem, originalEvent: originalEvent }); });
        }
        this.dropHintService.hide();
        this.draggedItem = null;
    };
    DragAndDropDirective.prototype.updateDropHintState = function (dropPosition, dropHintAnchor) {
        if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {
            this.dropHintService.hide();
            return;
        }
        var anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
        var insertBefore = dropPosition === DropPosition.Before;
        var top = insertBefore ? anchorViewPortCoords.top : (anchorViewPortCoords.top + anchorViewPortCoords.height);
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
        this.dropHintService.show();
    };
    DragAndDropDirective.prototype.updateDragClueState = function (dropAction, clientX, clientY, sourceItem, destinationItem) {
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
        this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
        this.dragClueService.show();
    };
    DragAndDropDirective.prototype.initalizeDraggable = function () {
        var _this = this;
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(function () { return _this.draggable.bindTo(_this.element.nativeElement); });
    };
    DragAndDropDirective.prototype.notifyDragStart = function (originalEvent, dropTarget) {
        var sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
        var event = new TreeItemDragStartEvent({ sourceItem: sourceItem, originalEvent: originalEvent });
        this.treeview.nodeDragStart.emit(event);
        return event;
    };
    DragAndDropDirective.prototype.notifyDrag = function (originalEvent, dropTarget) {
        var dragEvent = {
            sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
            destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
            originalEvent: originalEvent
        };
        this.treeview.nodeDrag.emit(dragEvent);
    };
    DragAndDropDirective.prototype.notifyDrop = function (args, originalEvent) {
        var event = new TreeItemDropEvent(args, originalEvent);
        args.destinationTree.nodeDrop.emit(event);
        // disable the animations on drop and restore them afterwards (if they were initially turned on)
        this.disableAnimationsForNextTick(args.destinationTree);
        if (args.sourceTree !== args.destinationTree) {
            this.disableAnimationsForNextTick(args.sourceTree);
        }
        if (!event.isDefaultPrevented() && event.isValid) {
            this.dragClueService.hide();
            // order matters in a flat data binding scenario (first add, then remove)
            args.destinationTree.addItem.emit(args);
            if (!(originalEvent.ctrlKey && this.allowCopy)) {
                args.sourceTree.removeItem.emit(args);
            }
        }
        else if (event.isDefaultPrevented()) {
            // directly hide the clue if the default is prevented
            this.dragClueService.hide();
        }
        else if (!event.isValid) {
            // animate the clue back to the source item position if marked as invalid
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
    };
    DragAndDropDirective.prototype.notifyDragEnd = function (dragEndEvent) {
        this.treeview.nodeDragEnd.emit(dragEndEvent);
    };
    DragAndDropDirective.prototype.getTargetTreeView = function (dropTarget) {
        var treeViewTagName = this.treeview.element.nativeElement.tagName;
        var targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
        return [this.treeview].concat(this.dropZoneTreeViews).find(function (treeView) {
            return isPresent(treeView) && treeView.element.nativeElement === targetTreeView;
        });
    };
    DragAndDropDirective.prototype.disableAnimationsForNextTick = function (treeView) {
        // the treeView.animate getter returns `true` when the animations are turned off
        // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)
        if (treeView.animate) {
            return;
        }
        treeView.animate = false;
        this.zone.runOutsideAngular(function () {
            return setTimeout(function () { return treeView.animate = true; });
        });
    };
    DragAndDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewDragAndDrop]',
                    providers: [
                        DragClueService,
                        DropHintService
                    ]
                },] },
    ];
    /** @nocollapse */
    DragAndDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: TreeViewComponent },
        { type: DragClueService },
        { type: DropHintService }
    ]; };
    DragAndDropDirective.propDecorators = {
        allowCopy: [{ type: Input }],
        dropZoneTreeViews: [{ type: Input }],
        dragClueTemplate: [{ type: ContentChild, args: [DragClueTemplateDirective,] }],
        dropHintTemplate: [{ type: ContentChild, args: [DropHintTemplateDirective,] }],
        userSelectStyle: [{ type: HostBinding, args: ['style.user-select',] }, { type: HostBinding, args: ['style.-ms-user-select',] }]
    };
    return DragAndDropDirective;
}());
export { DragAndDropDirective };
