/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var kendo_angular_common_1 = require("@progress/kendo-angular-common");
var kendo_draggable_1 = require("@telerik/kendo-draggable");
var drag_clue_service_1 = require("./drag-clue/drag-clue.service");
var drop_hint_service_1 = require("./drop-hint/drop-hint.service");
var drag_clue_template_directive_1 = require("./drag-clue/drag-clue-template.directive");
var drop_hint_template_directive_1 = require("./drop-hint/drop-hint-template.directive");
var drag_and_drop_utils_1 = require("./drag-and-drop-utils");
var utils_1 = require("../utils");
var treeview_component_1 = require("../treeview.component");
var models_1 = require("./models");
/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances
 * ([see example]({% slug draganddrop_treeview %})).
 *
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
var DragAndDropDirective = /** @class */ (function () {
    function DragAndDropDirective(element, zone, treeview, dragClueService, dropHintService) {
        this.element = element;
        this.zone = zone;
        this.treeview = treeview;
        this.dragClueService = dragClueService;
        this.dropHintService = dropHintService;
        /**
         * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
         * If enabled, the `removeItem` event will not be fired on the source TreeView
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         *
         * @default false
         */
        this.allowCopy = false;
        /**
         * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         */
        this.dropZoneTreeViews = [];
        /**
         * @hidden
         */
        this.userSelectStyle = 'none';
        /**
         * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
         * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
         */
        this.containerOffset = { top: 0, left: 0 };
        this.treeview.touchActions = false;
    }
    DragAndDropDirective.prototype.ngAfterContentInit = function () {
        this.initalizeDraggable();
        this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
        this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
    };
    DragAndDropDirective.prototype.ngOnDestroy = function () {
        this.draggable.destroy();
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handlePress = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent;
        if (!utils_1.isContent(originalEvent.target)) {
            return;
        }
        var dropTarget = drag_and_drop_utils_1.getDropTarget(originalEvent);
        if (kendo_angular_common_1.hasObservers(this.treeview.nodeDragStart)) {
            var dragStartEvent = this.zone.run(function () { return _this.notifyDragStart(originalEvent, dropTarget); });
            if (dragStartEvent.isDefaultPrevented()) {
                return;
            }
        }
        // store the drag target on press, show it only when it's actually dragged
        this.draggedItem = utils_1.closestWithMatch(originalEvent.target, '.k-in');
        this.dragClueService.cancelReturnAnimation();
        this.dragClueService.updateText(this.draggedItem.innerText);
        this.containerOffset = drag_and_drop_utils_1.getContainerOffset(this.draggedItem);
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleDrag = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientX = _a.clientX, clientY = _a.clientY;
        if (!utils_1.isPresent(this.draggedItem)) {
            return;
        }
        var dropTarget = drag_and_drop_utils_1.getDropTarget(originalEvent);
        if (kendo_angular_common_1.hasObservers(this.treeview.nodeDrag)) {
            this.zone.run(function () { return _this.notifyDrag(originalEvent, dropTarget); });
        }
        var targetTreeView = this.getTargetTreeView(dropTarget);
        var dropPosition = drag_and_drop_utils_1.getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
        var dropHintAnchor = utils_1.closestWithMatch(dropTarget, '.k-mid');
        this.updateDropHintState(dropPosition, dropHintAnchor);
        var dropAction = drag_and_drop_utils_1.getDropAction(dropPosition, dropTarget);
        var sourceItem = drag_and_drop_utils_1.treeItemFromEventTarget(this.treeview, this.draggedItem);
        var destinationItem = drag_and_drop_utils_1.treeItemFromEventTarget(targetTreeView, dropTarget);
        this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleRelease = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientY = _a.clientY;
        if (!utils_1.isPresent(this.draggedItem)) {
            return;
        }
        var dropTarget = drag_and_drop_utils_1.getDropTarget(originalEvent);
        var sourceTree = this.treeview;
        var destinationTree = this.getTargetTreeView(dropTarget);
        var dropPosition = drag_and_drop_utils_1.getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
        var sourceItem = drag_and_drop_utils_1.treeItemFromEventTarget(sourceTree, this.draggedItem);
        var destinationItem = drag_and_drop_utils_1.treeItemFromEventTarget(destinationTree, dropTarget);
        if (utils_1.isPresent(destinationItem) && utils_1.isPresent(dropPosition)) {
            this.zone.run(function () { return _this.notifyDrop({ sourceItem: sourceItem, destinationItem: destinationItem, dropPosition: dropPosition, sourceTree: sourceTree, destinationTree: destinationTree }, originalEvent); });
        }
        else {
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
        if (kendo_angular_common_1.hasObservers(this.treeview.nodeDragEnd)) {
            this.zone.run(function () { return _this.notifyDragEnd({ sourceItem: sourceItem, destinationItem: destinationItem, originalEvent: originalEvent }); });
        }
        this.dropHintService.hide();
        this.draggedItem = null;
    };
    DragAndDropDirective.prototype.updateDropHintState = function (dropPosition, dropHintAnchor) {
        if (!utils_1.isPresent(dropHintAnchor) || dropPosition === models_1.DropPosition.Over || !utils_1.isPresent(dropPosition)) {
            this.dropHintService.hide();
            return;
        }
        var anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
        var insertBefore = dropPosition === models_1.DropPosition.Before;
        var top = insertBefore ? anchorViewPortCoords.top : (anchorViewPortCoords.top + anchorViewPortCoords.height);
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
        this.dropHintService.show();
    };
    DragAndDropDirective.prototype.updateDragClueState = function (dropAction, clientX, clientY, sourceItem, destinationItem) {
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
        this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
        this.dragClueService.show();
    };
    DragAndDropDirective.prototype.initalizeDraggable = function () {
        var _this = this;
        this.draggable = new kendo_draggable_1.default({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(function () { return _this.draggable.bindTo(_this.element.nativeElement); });
    };
    DragAndDropDirective.prototype.notifyDragStart = function (originalEvent, dropTarget) {
        var sourceItem = drag_and_drop_utils_1.treeItemFromEventTarget(this.treeview, dropTarget);
        var event = new models_1.TreeItemDragStartEvent({ sourceItem: sourceItem, originalEvent: originalEvent });
        this.treeview.nodeDragStart.emit(event);
        return event;
    };
    DragAndDropDirective.prototype.notifyDrag = function (originalEvent, dropTarget) {
        var dragEvent = {
            sourceItem: drag_and_drop_utils_1.treeItemFromEventTarget(this.treeview, this.draggedItem),
            destinationItem: drag_and_drop_utils_1.treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
            originalEvent: originalEvent
        };
        this.treeview.nodeDrag.emit(dragEvent);
    };
    DragAndDropDirective.prototype.notifyDrop = function (args, originalEvent) {
        var event = new models_1.TreeItemDropEvent(args, originalEvent);
        args.destinationTree.nodeDrop.emit(event);
        // disable the animations on drop and restore them afterwards (if they were initially turned on)
        this.disableAnimationsForNextTick(args.destinationTree);
        if (args.sourceTree !== args.destinationTree) {
            this.disableAnimationsForNextTick(args.sourceTree);
        }
        if (!event.isDefaultPrevented() && event.isValid) {
            this.dragClueService.hide();
            // order matters in a flat data binding scenario (first add, then remove)
            args.destinationTree.addItem.emit(args);
            if (!(originalEvent.ctrlKey && this.allowCopy)) {
                args.sourceTree.removeItem.emit(args);
            }
        }
        else if (event.isDefaultPrevented()) {
            // directly hide the clue if the default is prevented
            this.dragClueService.hide();
        }
        else if (!event.isValid) {
            // animate the clue back to the source item position if marked as invalid
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
    };
    DragAndDropDirective.prototype.notifyDragEnd = function (dragEndEvent) {
        this.treeview.nodeDragEnd.emit(dragEndEvent);
    };
    DragAndDropDirective.prototype.getTargetTreeView = function (dropTarget) {
        var treeViewTagName = this.treeview.element.nativeElement.tagName;
        var targetTreeView = utils_1.closestWithMatch(dropTarget, treeViewTagName);
        return [this.treeview].concat(this.dropZoneTreeViews).find(function (treeView) {
            return utils_1.isPresent(treeView) && treeView.element.nativeElement === targetTreeView;
        });
    };
    DragAndDropDirective.prototype.disableAnimationsForNextTick = function (treeView) {
        // the treeView.animate getter returns `true` when the animations are turned off
        // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)
        if (treeView.animate) {
            return;
        }
        treeView.animate = false;
        this.zone.runOutsideAngular(function () {
            return setTimeout(function () { return treeView.animate = true; });
        });
    };
    DragAndDropDirective.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[kendoTreeViewDragAndDrop]',
                    providers: [
                        drag_clue_service_1.DragClueService,
                        drop_hint_service_1.DropHintService
                    ]
                },] },
    ];
    /** @nocollapse */
    DragAndDropDirective.ctorParameters = function () { return [
        { type: core_1.ElementRef },
        { type: core_1.NgZone },
        { type: treeview_component_1.TreeViewComponent },
        { type: drag_clue_service_1.DragClueService },
        { type: drop_hint_service_1.DropHintService }
    ]; };
    DragAndDropDirective.propDecorators = {
        allowCopy: [{ type: core_1.Input }],
        dropZoneTreeViews: [{ type: core_1.Input }],
        dragClueTemplate: [{ type: core_1.ContentChild, args: [drag_clue_template_directive_1.DragClueTemplateDirective,] }],
        dropHintTemplate: [{ type: core_1.ContentChild, args: [drop_hint_template_directive_1.DropHintTemplateDirective,] }],
        userSelectStyle: [{ type: core_1.HostBinding, args: ['style.user-select',] }, { type: core_1.HostBinding, args: ['style.-ms-user-select',] }]
    };
    return DragAndDropDirective;
}());
exports.DragAndDropDirective = DragAndDropDirective;
