/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_angular_common_1 = require("@progress/kendo-angular-common");
var utils_1 = require("../utils");
var models_1 = require("./models");
var ɵ0 = function () {
    if (!(kendo_angular_common_1.isDocumentAvailable() && utils_1.isPresent(document.body))) {
        return false;
    }
    var top = 10;
    var parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = "<div style=\"position: fixed; top: " + top + "px;\">child</div>";
    document.body.appendChild(parent);
    var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
exports.ɵ0 = ɵ0;
/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
var hasRelativeStackingContext = memoize(ɵ0);
/**
 * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.
 */
function memoize(fn) {
    var result;
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (called) {
            return result;
        }
        result = fn.apply(void 0, args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
exports.getContainerOffset = function (element) {
    if (!(element && hasRelativeStackingContext())) {
        return { left: 0, top: 0 };
    }
    var offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        var rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
exports.getDropAction = function (dropPosition, dropTarget) {
    if (!(utils_1.isPresent(dropPosition) && utils_1.isPresent(dropTarget))) {
        return models_1.DropAction.Invalid;
    }
    switch (dropPosition) {
        case models_1.DropPosition.Over:
            return models_1.DropAction.Add;
        case models_1.DropPosition.Before:
            return utils_1.isPresent(utils_1.closestNode(dropTarget).previousElementSibling) ? models_1.DropAction.InsertMiddle : models_1.DropAction.InsertTop;
        case models_1.DropPosition.After:
            return utils_1.isPresent(utils_1.closestNode(dropTarget).nextElementSibling) ? models_1.DropAction.InsertMiddle : models_1.DropAction.InsertBottom;
        default:
            return models_1.DropAction.Invalid;
    }
};
/**
 * @hidden
 */
exports.getDropPosition = function (draggedItem, target, clientY, targetTreeView, containerOffset) {
    if (!(utils_1.isPresent(draggedItem) && utils_1.isPresent(target) && utils_1.isPresent(targetTreeView) && utils_1.isPresent(containerOffset))) {
        return;
    }
    // the .k-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    var item = utils_1.closestWithMatch(target, '.k-mid');
    if (!utils_1.isPresent(item)) {
        return;
    }
    // the content element (.k-in:not(.k-treeview-load-more-button)) holds just the treeview item text
    var content = utils_1.getContentElement(item);
    var targetChildOfDraggedItem = utils_1.hasParent(item, utils_1.closestNode(draggedItem));
    if (!utils_1.isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    var itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:
            - dropping should insert before or after
    */
    var itemDivisionHeight = itemViewPortCoords.height / (utils_1.isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    var pointerPosition = clientY - containerOffset.top;
    var itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return models_1.DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return models_1.DropPosition.After;
    }
    return models_1.DropPosition.Over;
};
/**
 * @hidden
 */
exports.treeItemFromEventTarget = function (treeView, dropTarget) {
    if (!(utils_1.isPresent(treeView) && utils_1.isPresent(dropTarget))) {
        return null;
    }
    var node = utils_1.closestNode(dropTarget);
    var index = utils_1.nodeId(node);
    var lookup = treeView.itemLookup(index);
    if (!(utils_1.isPresent(lookup) && utils_1.isPresent(lookup.item.dataItem))) {
        return null;
    }
    return lookup;
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
exports.collapseEmptyParent = function (parent, parentNodes, treeview) {
    if (utils_1.isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
exports.expandDropTarget = function (dropTarget, treeView) {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
exports.getDropTarget = function (event) {
    if (!(kendo_angular_common_1.isDocumentAvailable() && utils_1.isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};
