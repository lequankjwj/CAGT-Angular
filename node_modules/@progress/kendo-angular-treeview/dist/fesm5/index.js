/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Injectable, Directive, TemplateRef, Optional, isDevMode, Component, ChangeDetectionStrategy, ElementRef, NgZone, Renderer2, HostBinding, ViewChild, ViewContainerRef, Input, Output, ContentChild, ChangeDetectorRef, NgModule, ComponentFactoryResolver } from '@angular/core';
import { isDocumentAvailable, Keys, hasObservers, isChanged, anyChanged, guid } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject, of, BehaviorSubject, Subscription, EMPTY, merge } from 'rxjs';
import { trigger, transition, style, animate } from '@angular/animations';
import { getter, setter } from '@progress/kendo-common';
import { filter, catchError, tap, finalize, switchMap, take, map, delay, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { __assign, __extends } from 'tslib';
import Draggable from '@telerik/kendo-draggable';

/**
 * @hidden
 */
var DataChangeNotificationService = /** @class */ (function () {
    function DataChangeNotificationService() {
        this.changes = new EventEmitter();
    }
    DataChangeNotificationService.prototype.notify = function () {
        this.changes.emit();
    };
    return DataChangeNotificationService;
}());

/**
 * @hidden
 */
var hasChildren = function () { return false; };
/**
 * @hidden
 */
var isChecked = function () { return 'none'; };
/**
 * @hidden
 */
var isDisabled = function () { return false; };
/**
 * @hidden
 */
var isExpanded = function () { return true; };
/**
 * @hidden
 */
var isSelected = function () { return false; };
/**
 * @hidden
 */
var trackBy = function (_, item) { return item; };

/**
 * @hidden
 */
var ExpandStateService = /** @class */ (function () {
    function ExpandStateService() {
        this.changes = new Subject();
    }
    ExpandStateService.prototype.expand = function (index, dataItem) {
        this.changes.next({ dataItem: dataItem, index: index, expand: true });
    };
    ExpandStateService.prototype.collapse = function (index, dataItem) {
        this.changes.next({ dataItem: dataItem, index: index, expand: false });
    };
    ExpandStateService.decorators = [
        { type: Injectable },
    ];
    return ExpandStateService;
}());

/**
 * @hidden
 */
var IndexBuilderService = /** @class */ (function () {
    function IndexBuilderService() {
        this.INDEX_SEPARATOR = '_';
    }
    IndexBuilderService.prototype.nodeIndex = function (index, parentIndex) {
        if (index === void 0) { index = ''; }
        if (parentIndex === void 0) { parentIndex = ''; }
        return "" + parentIndex + (parentIndex ? this.INDEX_SEPARATOR : '') + index;
    };
    IndexBuilderService.prototype.indexForLevel = function (index, level) {
        return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);
    };
    IndexBuilderService.prototype.lastLevelIndex = function (index) {
        if (index === void 0) { index = ''; }
        var parts = index.split(this.INDEX_SEPARATOR);
        if (!parts.length) {
            return NaN;
        }
        return parseInt(parts[parts.length - 1], 10);
    };
    IndexBuilderService.prototype.level = function (index) {
        return index.split(this.INDEX_SEPARATOR).length;
    };
    IndexBuilderService.decorators = [
        { type: Injectable },
    ];
    return IndexBuilderService;
}());

/**
 * @hidden
 */
var LoadingNotificationService = /** @class */ (function () {
    function LoadingNotificationService() {
        this.changes = new Subject();
    }
    LoadingNotificationService.prototype.notifyLoaded = function (index) {
        this.changes.next(index);
    };
    LoadingNotificationService.decorators = [
        { type: Injectable },
    ];
    return LoadingNotificationService;
}());

var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
var match = function (element, selector) {
    var matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
/**
 * @hidden
 */
var closestWithMatch = function (element, selector) {
    if (!document.documentElement.contains(element)) {
        return null;
    }
    var parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (match(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 */
var noop = function () { };
/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
var isBlank = function (value) { return value === null || value === undefined; };
/**
 * @hidden
 */
var isArray = function (value) { return Array.isArray(value); };
/**
 * @hidden
 */
var isNullOrEmptyString = function (value) { return isBlank(value) || value.trim().length === 0; };
/**
 * @hidden
 */
var closestNode = function (element) {
    var selector = 'li.k-treeview-item';
    if (!isDocumentAvailable()) {
        return null;
    }
    if (element.closest) {
        return element.closest(selector);
    }
    else {
        return closestWithMatch(element, selector);
    }
};
/**
 * @hidden
 */
var isFocusable = function (element) {
    if (element.tagName) {
        var tagName = element.tagName.toLowerCase();
        var tabIndex = element.getAttribute('tabIndex');
        var skipTab = tabIndex === '-1';
        var focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
var isContent = function (element) {
    var scopeSelector = '.k-in:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';
    if (!isDocumentAvailable()) {
        return null;
    }
    var node = element;
    while (node && !match(node, scopeSelector)) {
        node = node.parentNode;
    }
    if (node) {
        return match(node, '.k-in:not(.k-treeview-load-more-button)');
    }
};
/**
 * @hidden
 *
 * Returns the nested .k-in:not(.k-treeview-load-more-button) element.
 * If the passed parent item is itself a content node, it is returned.
 */
var getContentElement = function (parent) {
    if (!isPresent(parent)) {
        return null;
    }
    var selector = '.k-in:not(.k-treeview-load-more-button)';
    if (match(parent, selector)) {
        return parent;
    }
    return parent.querySelector(selector);
};
/**
 * @hidden
 */
var isLoadMoreButton = function (element) {
    return isPresent(closestWithMatch(element, '.k-in.k-treeview-load-more-button'));
};
/**
 * @hidden
 */
var closest = function (node, predicate) {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
var hasParent = function (element, container) {
    return Boolean(closest(element, function (node) { return node === container; }));
};
/**
 * @hidden
 */
var focusableNode = function (element) { return element.nativeElement.querySelector('li[tabindex="0"]'); };
/**
 * @hidden
 */
var nodeId = function (node) { return node ? node.getAttribute('data-treeindex') : ''; };
/**
 * @hidden
 */
var nodeIndex = function (item) { return (item || {}).index; };
/**
 * @hidden
 */
var dataItemsEqual = function (first, second) {
    if (!isPresent(first) && !isPresent(second)) {
        return true;
    }
    return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;
};
/**
 * @hidden
 */
var getDataItem = function (lookup) {
    if (!isPresent(lookup)) {
        return lookup;
    }
    return lookup.item.dataItem;
};

var last = function (list) { return list[list.length - 1]; };
var safe = function (node) { return (node || {}); };
var safeChildren = function (node) { return (safe(node).children || []); };
var findLast = function (node) {
    var lastNode = node;
    var children = [].concat(safeChildren(node));
    while (children.length) {
        children = children.concat(safeChildren(last(children)));
        lastNode = children.shift();
    }
    return lastNode;
};
/**
 * @hidden
 */
var NavigationModel = /** @class */ (function () {
    function NavigationModel() {
        this.ib = new IndexBuilderService();
        this.nodes = [];
    }
    NavigationModel.prototype.firstNode = function () {
        return this.nodes[0] || null;
    };
    NavigationModel.prototype.lastNode = function () {
        var node = this.nodes[this.nodes.length - 1];
        if (!node) {
            return null;
        }
        return findLast(last(this.container(node))) || node;
    };
    NavigationModel.prototype.closestNode = function (index) {
        var prev = safe(this.findNode(index)).prev;
        var sibling = prev || this.firstNode();
        return safe(sibling).index === index ? this.sibling(sibling, 1) : sibling;
    };
    NavigationModel.prototype.findNode = function (index) {
        return this.find(index, this.nodes);
    };
    NavigationModel.prototype.findParent = function (index) {
        var parentLevel = this.ib.level(index) - 1;
        return this.findNode(this.ib.indexForLevel(index, parentLevel));
    };
    NavigationModel.prototype.findChild = function (index) {
        return safeChildren(this.findNode(index))[0] || null;
    };
    NavigationModel.prototype.findPrev = function (item) {
        var index = item.index;
        var parent = this.findParent(index);
        var levelIndex = this.ib.lastLevelIndex(index);
        if (levelIndex === 0) {
            return parent;
        }
        var currentNode = this.findNode(index);
        var prev = this.sibling(currentNode, -1);
        if (prev) {
            var children = this.container(prev);
            while (children.length > 0) {
                prev = last(children);
                children = this.container(prev);
            }
        }
        return prev;
    };
    NavigationModel.prototype.findNext = function (item) {
        var children = this.container(item);
        if (children.length === 0) {
            return this.sibling(item, 1);
        }
        return children[0];
    };
    NavigationModel.prototype.registerItem = function (id, index, disabled, loadMoreButton) {
        if (loadMoreButton === void 0) { loadMoreButton = false; }
        var children = [];
        var level = this.ib.level(index);
        var parent = this.findParent(index);
        if (parent || level === 1) {
            var node = { id: id, children: children, index: index, parent: parent, disabled: disabled, loadMoreButton: loadMoreButton };
            this.insert(node, parent);
        }
    };
    NavigationModel.prototype.unregisterItem = function (id, index) {
        var node = this.find(index, this.nodes);
        if (!node || node.id !== id) {
            return;
        }
        var children = this.container(node.parent);
        children.splice(children.indexOf(node), 1);
    };
    NavigationModel.prototype.childLevel = function (nodes) {
        var children = nodes.filter(function (node) { return isPresent(node); });
        if (!children || !children.length) {
            return 1;
        }
        return this.ib.level(children[0].index);
    };
    NavigationModel.prototype.container = function (node) {
        return node ? node.children : this.nodes;
    };
    NavigationModel.prototype.find = function (index, nodes) {
        var childLevel = this.childLevel(nodes);
        var indexToMatch = this.ib.indexForLevel(index, childLevel);
        var isLeaf = childLevel === this.ib.level(index);
        var node = nodes.find(function (n) { return n && n.index === indexToMatch; });
        if (!node) {
            return null;
        }
        return isLeaf ? node : this.find(index, node.children);
    };
    NavigationModel.prototype.insert = function (node, parent) {
        var nodes = this.container(parent);
        nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
    };
    NavigationModel.prototype.sibling = function (node, offset) {
        if (!node) {
            return null;
        }
        var parent = this.findParent(node.index);
        var container = this.container(parent);
        return container[container.indexOf(node) + offset] || this.sibling(parent, offset) || null;
    };
    return NavigationModel;
}());

/**
 * @hidden
 */
var NavigationService = /** @class */ (function () {
    function NavigationService(localization) {
        var _a;
        var _this = this;
        this.localization = localization;
        this.expands = new Subject();
        this.moves = new Subject();
        this.checks = new Subject();
        this.selects = new Subject();
        this.loadMore = new Subject();
        this.navigable = true;
        this.actions = (_a = {},
            _a[Keys.ArrowUp] = function () { return _this.activate(_this.model.findPrev(_this.focusableItem)); },
            _a[Keys.ArrowDown] = function () { return _this.activate(_this.model.findNext(_this.focusableItem)); },
            _a[Keys.ArrowLeft] = function () { return !_this.isLoadMoreButton && (_this.expand({
                expand: _this.localization.rtl,
                intercept: _this.localization.rtl ? _this.moveToChild : _this.moveToParent
            })); },
            _a[Keys.ArrowRight] = function () { return !_this.isLoadMoreButton && (_this.expand({
                expand: !_this.localization.rtl,
                intercept: _this.localization.rtl ? _this.moveToParent : _this.moveToChild
            })); },
            _a[Keys.Home] = function () { return _this.activate(_this.model.firstNode()); },
            _a[Keys.End] = function () { return _this.activate(_this.model.lastNode()); },
            _a[Keys.Enter] = function () { return _this.handleEnter(); },
            _a[Keys.Space] = function () { return _this.handleSpace(); },
            _a);
        this.isFocused = false;
        this._model = new NavigationModel();
        this.moveToChild = this.moveToChild.bind(this);
        this.moveToParent = this.moveToParent.bind(this);
    }
    Object.defineProperty(NavigationService.prototype, "model", {
        get: function () {
            return this._model;
        },
        set: function (model) {
            this._model = model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "activeIndex", {
        get: function () {
            return nodeIndex(this.activeItem) || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "focusableItem", {
        get: function () {
            return this.activeItem || this.model.firstNode();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "isActiveExpanded", {
        get: function () {
            return this.activeItem && this.activeItem.children.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationService.prototype, "isLoadMoreButton", {
        get: function () {
            return this.activeItem && this.activeItem.loadMoreButton;
        },
        enumerable: true,
        configurable: true
    });
    NavigationService.prototype.activate = function (item) {
        if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
            return;
        }
        this.isFocused = true;
        this.activeItem = item || this.activeItem;
        this.notifyMove();
    };
    NavigationService.prototype.activateParent = function (index) {
        this.activate(this.model.findParent(index));
    };
    NavigationService.prototype.activateIndex = function (index) {
        if (!index) {
            return;
        }
        this.activate(this.model.findNode(index));
    };
    NavigationService.prototype.activateClosest = function (index) {
        if (!index || nodeIndex(this.focusableItem) !== index) {
            return;
        }
        this.activeItem = this.model.closestNode(index);
        this.notifyMove();
    };
    NavigationService.prototype.activateFocusable = function () {
        if (this.activeItem) {
            return;
        }
        this.activeItem = this.model.firstNode();
        this.notifyMove();
    };
    NavigationService.prototype.deactivate = function () {
        if (!this.navigable || !this.isFocused) {
            return;
        }
        this.isFocused = false;
        this.notifyMove();
    };
    NavigationService.prototype.checkIndex = function (index) {
        if (!this.isDisabled(index)) {
            this.checks.next(index);
        }
    };
    NavigationService.prototype.selectIndex = function (index) {
        if (!this.isDisabled(index)) {
            this.selects.next(index);
        }
    };
    NavigationService.prototype.notifyLoadMore = function (index) {
        if (!isPresent(index)) {
            return;
        }
        this.loadMore.next(index);
    };
    NavigationService.prototype.isActive = function (index) {
        if (!index) {
            return false;
        }
        return this.isFocused && this.activeIndex === index;
    };
    NavigationService.prototype.isFocusable = function (index) {
        return nodeIndex(this.focusableItem) === index;
    };
    NavigationService.prototype.isDisabled = function (index) {
        return this.model.findNode(index).disabled;
    };
    NavigationService.prototype.registerItem = function (id, index, disabled, loadMoreButton) {
        if (loadMoreButton === void 0) { loadMoreButton = false; }
        var itemAtIndex = this.model.findNode(index);
        if (isPresent(itemAtIndex)) {
            this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);
            if (this.isActive(index)) {
                this.deactivate();
            }
        }
        this.model.registerItem(id, index, disabled, loadMoreButton);
    };
    NavigationService.prototype.unregisterItem = function (id, index) {
        if (this.isActive(index)) {
            this.activateParent(index);
        }
        this.model.unregisterItem(id, index);
    };
    NavigationService.prototype.move = function (e) {
        if (!this.navigable) {
            return;
        }
        var moveAction = this.actions[e.keyCode];
        if (!moveAction) {
            return;
        }
        moveAction();
        e.preventDefault();
    };
    NavigationService.prototype.expand = function (_a) {
        var expand = _a.expand, intercept = _a.intercept;
        var index = nodeIndex(this.activeItem);
        if (!index || intercept(index)) {
            return;
        }
        this.notifyExpand(expand);
    };
    NavigationService.prototype.moveToParent = function () {
        if (this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findParent(nodeIndex(this.activeItem)));
        return true;
    };
    NavigationService.prototype.moveToChild = function () {
        if (!this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findChild(nodeIndex(this.activeItem)));
        return true;
    };
    NavigationService.prototype.notifyExpand = function (expand) {
        this.expands.next(this.navigationState(expand));
    };
    NavigationService.prototype.notifyMove = function () {
        this.moves.next(this.navigationState());
    };
    NavigationService.prototype.navigationState = function (expand) {
        if (expand === void 0) { expand = false; }
        return ({ expand: expand, index: this.activeIndex, isFocused: this.isFocused });
    };
    NavigationService.prototype.handleEnter = function () {
        if (!this.navigable) {
            return;
        }
        if (this.isLoadMoreButton) {
            this.notifyLoadMore(this.activeIndex);
        }
        else {
            this.selectIndex(this.activeIndex);
        }
    };
    NavigationService.prototype.handleSpace = function () {
        if (!this.navigable) {
            return;
        }
        if (this.isLoadMoreButton) {
            this.notifyLoadMore(this.activeIndex);
        }
        else {
            this.checkIndex(this.activeIndex);
        }
    };
    NavigationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NavigationService.ctorParameters = function () { return [
        { type: LocalizationService }
    ]; };
    return NavigationService;
}());

/**
 * @hidden
 */
var NodeChildrenService = /** @class */ (function () {
    function NodeChildrenService() {
        this.changes = new Subject();
    }
    NodeChildrenService.prototype.childrenLoaded = function (item, children) {
        this.changes.next({ item: item, children: children });
    };
    NodeChildrenService.decorators = [
        { type: Injectable },
    ];
    return NodeChildrenService;
}());

/**
 * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).
 * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`
 * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.
 *
 *
 * The node data item and its hierarchical index are available as context variables:
 *
 * - `let-dataItem` (`any`) - available as implicit context variable
 * - `let-index="index"` (`string`)
 *
 *
 * @example
 * ```ts
 *
 *  import { Component } from '@angular/core';
 *  @Component({
 *      selector: 'my-app',
 *      template: `
 *      <kendo-treeview
 *          [nodes]="data"
 *          kendoTreeViewExpandable
 *
 *          kendoTreeViewHierarchyBinding
 *          childrenField="items">
 *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index="index">
 *          <span [style.fontWeight]="dataItem.items ? 'bolder': 'normal' ">{{ index }}: {{ dataItem.text }}</span>
 *        </ng-template>
 *      </kendo-treeview>
 *    `
 *  })
 *  export class AppComponent {
 *      public data: any[] = [
 *          {
 *              text: "Inbox",
 *              items: [{ text: "Read Mail" }]
 *          },
 *          {
 *              text: "Drafts"
 *          },
 *          {
 *              text: "Search Folders",
 *              items: [
 *                  { text: "Categorized Mail" },
 *                  { text: "Large Mail" },
 *                  { text: "Unread Mail"}
 *              ]
 *          },
 *          { text: "Settings" }
 *      ];
 *  }
 *
 * ```
 */
var NodeTemplateDirective = /** @class */ (function () {
    function NodeTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    NodeTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewNodeTemplate]'
                },] },
    ];
    /** @nocollapse */
    NodeTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return NodeTemplateDirective;
}());

/**
 * Represents the template for the TreeView load more buttons.
 * To define a button template, nest an `<ng-template>`
 * tag with the `kendoTreeViewLoadMoreButtonTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug loadmorebutton_treeview %}#toc-button-template)).
 *
 * The hierarchical index of the load more button node is available as a context variable:
 *
 * - `let-index="index"` (`string`)
 */
var LoadMoreButtonTemplateDirective = /** @class */ (function () {
    function LoadMoreButtonTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    LoadMoreButtonTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewLoadMoreButtonTemplate]'
                },] },
    ];
    /** @nocollapse */
    LoadMoreButtonTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return LoadMoreButtonTemplateDirective;
}());

/**
 * @hidden
 */
var SelectionService = /** @class */ (function () {
    function SelectionService() {
        this.changes = new Subject();
    }
    SelectionService.prototype.isFirstSelected = function (index) {
        return this.firstIndex === index;
    };
    SelectionService.prototype.setFirstSelected = function (index, selected) {
        if (this.firstIndex === index && selected === false) {
            this.firstIndex = null;
        }
        else if (!this.firstIndex && selected) {
            this.firstIndex = index;
        }
    };
    SelectionService.prototype.select = function (index, dataItem) {
        this.changes.next({ dataItem: dataItem, index: index });
    };
    SelectionService.decorators = [
        { type: Injectable },
    ];
    return SelectionService;
}());

var INDEX_REGEX = /\d+$/;
/**
 * @hidden
 */
var TreeViewLookupService = /** @class */ (function () {
    function TreeViewLookupService() {
        this.map = new Map();
    }
    TreeViewLookupService.prototype.registerItem = function (item, parent) {
        var currentLookup = {
            children: [],
            item: item,
            parent: this.item(nodeIndex(parent))
        };
        this.map.set(item.index, currentLookup);
    };
    TreeViewLookupService.prototype.registerChildren = function (index, children) {
        var item = this.item(index);
        if (!item) {
            return;
        }
        item.children = children;
    };
    TreeViewLookupService.prototype.unregisterItem = function (index, dataItem) {
        var current = this.item(index);
        if (current && current.item.dataItem === dataItem) {
            this.map.delete(index);
            if (current.parent && current.parent.children) {
                current.parent.children = current.parent.children.filter(function (item) { return item.dataItem !== dataItem; });
            }
        }
    };
    TreeViewLookupService.prototype.replaceItem = function (index, item, parent) {
        if (!item) {
            return;
        }
        this.unregisterItem(index, item.dataItem);
        this.registerItem(item, parent);
        this.addToParent(item, parent);
    };
    TreeViewLookupService.prototype.itemLookup = function (index) {
        var item = this.item(index);
        if (!item) {
            return null;
        }
        return {
            children: this.mapChildren(item.children),
            item: item.item,
            parent: item.parent
        };
    };
    TreeViewLookupService.prototype.hasItem = function (index) {
        return this.map.has(index);
    };
    TreeViewLookupService.prototype.item = function (index) {
        return this.map.get(index) || null;
    };
    TreeViewLookupService.prototype.addToParent = function (item, parent) {
        if (parent) {
            var parentItem = this.item(parent.index);
            var index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);
            parentItem.children = parentItem.children || [];
            parentItem.children.splice(index, 0, item);
        }
    };
    TreeViewLookupService.prototype.mapChildren = function (children) {
        var _this = this;
        if (children === void 0) { children = []; }
        return children.map(function (c) {
            var _a = _this.item(c.index), item = _a.item, parent = _a.parent, children = _a.children;
            return {
                children: _this.mapChildren(children),
                item: item,
                parent: parent
            };
        });
    };
    TreeViewLookupService.decorators = [
        { type: Injectable },
    ];
    return TreeViewLookupService;
}());

var LOAD_MORE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';
var providers = [
    ExpandStateService,
    IndexBuilderService,
    TreeViewLookupService,
    LoadingNotificationService,
    NodeChildrenService,
    NavigationService,
    SelectionService,
    DataChangeNotificationService,
    LocalizationService,
    {
        provide: L10N_PREFIX,
        useValue: 'kendo.treeview'
    }
];
/* tslint:disable:member-ordering */
/**
 * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).
 *
 * @example
 * {% meta height:350 %}
 * {% embed_file basic-usage/app.component.ts preview %}
 * {% embed_file basic-usage/app.module.ts %}
 * {% endmeta %}
 */
var TreeViewComponent = /** @class */ (function () {
    function TreeViewComponent(element, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {
        var _this = this;
        this.element = element;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.selectionService = selectionService;
        this.treeViewLookupService = treeViewLookupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.dataChangeNotification = dataChangeNotification;
        this.localization = localization;
        this.classNames = true;
        this.role = 'tree';
        /** @hidden */
        this.fetchNodes = function () { return _this.data; };
        /**
         * Fires when the children of the expanded node are loaded.
         */
        this.childrenLoaded = new EventEmitter();
        /**
         * Fires when the user blurs the component.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the user focuses the component.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires when the user expands a TreeView node.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the user collapses a TreeView node.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.
         * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.
         */
        this.nodeDragStart = new EventEmitter();
        /**
         * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDrag = new EventEmitter();
        /**
         * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),
         * the `addItem` and `removeItem` events will not be triggered.
         *
         * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was
         * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.
         * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.
         */
        this.nodeDrop = new EventEmitter();
        /**
         * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDragEnd = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView where the item is dropped.
         */
        this.addItem = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView from where the item is dragged.
         */
        this.removeItem = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node checkbox
         * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
         */
        this.checkedChange = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node
         * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when the user clicks a TreeView node.
         */
        this.nodeClick = new EventEmitter();
        /**
         * Fires when the user double clicks a TreeView node.
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * A function that defines how to track node changes.
         * By default, the TreeView tracks the nodes by data item object reference.
         *
         * @example
         * ```ts
         *  @Component({
         *      selector: 'my-app',
         *      template: `
         *          <kendo-treeview
         *              [nodes]="data"
         *              [textField]="'text'"
         *              [trackBy]="trackBy"
         *          >
         *          </kendo-treeview>
         *      `
         *  })
         *  export class AppComponent {
         *      public data: any[] = [
         *          { text: "Furniture" },
         *          { text: "Decor" }
         *      ];
         *
         *      public trackBy(index: number, item: any): any {
         *          return item.text;
         *      }
         *  }
         * ```
         */
        this.trackBy = trackBy;
        /**
         * A function which determines if a specific node is disabled.
         */
        this.isDisabled = isDisabled;
        /**
         * Determines whether the TreeView keyboard navigable is enabled.
         */
        this.navigable = true;
        /**
         * A function which provides the child nodes for a given parent node
         * ([see example]({% slug databinding_treeview %})).
         */
        this.children = function () { return of([]); };
        this.checkboxes = false;
        this.expandIcons = false;
        this.selectable = false;
        this.touchActions = true;
        this.isActive = false;
        this.data = new BehaviorSubject([]);
        this._animate = true;
        this.subscriptions = new Subscription();
        this.domSubscriptions = [];
    }
    Object.defineProperty(TreeViewComponent.prototype, "direction", {
        /** @hidden */
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "animate", {
        get: function () {
            return !this._animate;
        },
        /**
         * Determines whether the content animation is enabled.
         */
        set: function (value) {
            this._animate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "nodes", {
        get: function () {
            return this.data.value;
        },
        /**
         * The nodes which will be displayed by the TreeView
         * ([see example]({% slug databinding_treeview %})).
         */
        set: function (value) {
            this.dataChangeNotification.notify();
            this.data.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "hasChildren", {
        /**
         * A function which determines if a specific node has child nodes
         * ([see example]({% slug databinding_treeview %})).
         */
        get: function () {
            return this._hasChildren || hasChildren;
        },
        set: function (callback) {
            this._hasChildren = callback;
            this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "isChecked", {
        /**
         * A function which determines if a specific node is checked
         * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
         */
        get: function () {
            return this._isChecked || isChecked;
        },
        set: function (callback) {
            this._isChecked = callback;
            this.checkboxes = Boolean(this._isChecked);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "isExpanded", {
        /**
         * A function which determines if a specific node is expanded.
         */
        get: function () {
            return this._isExpanded || isExpanded;
        },
        set: function (callback) {
            this._isExpanded = callback;
            this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewComponent.prototype, "isSelected", {
        /**
         * A function which determines if a specific node is selected
         * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
         */
        get: function () {
            return this._isSelected || isSelected;
        },
        set: function (callback) {
            this._isSelected = callback;
            this.selectable = Boolean(this._isSelected);
        },
        enumerable: true,
        configurable: true
    });
    TreeViewComponent.prototype.ngOnChanges = function (_) {
        this.navigationService.navigable = Boolean(this.navigable);
    };
    TreeViewComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.domSubscriptions.forEach(function (subscription) { return subscription(); });
    };
    TreeViewComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions.add(this.nodeChildrenService
            .changes
            .subscribe(function (x) { return _this.childrenLoaded.emit(x); }));
        this.subscriptions.add(this.expandService.changes
            .subscribe(function (_a) {
            var index = _a.index, dataItem = _a.dataItem, expand = _a.expand;
            return expand
                ? _this.expand.emit({ index: index, dataItem: dataItem })
                : _this.collapse.emit({ index: index, dataItem: dataItem });
        }));
        this.subscriptions.add(this.navigationService.checks
            .subscribe(function (x) {
            return _this.checkedChange.emit(_this.treeViewLookupService.itemLookup(x));
        }));
        this.subscriptions.add(this.selectionService.changes
            .subscribe(function (x) {
            if (hasObservers(_this.selectionChange)) {
                _this.ngZone.run(function () {
                    _this.selectionChange.emit(x);
                });
            }
        }));
        if (this.element) {
            this.ngZone.runOutsideAngular(function () {
                _this.attachDomHandlers();
            });
        }
    };
    /**
     * Blurs the focused TreeView item.
     */
    TreeViewComponent.prototype.blur = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        var target = focusableNode(this.element);
        if (document.activeElement === target) {
            target.blur();
        }
    };
    /**
     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.
     *
     * @example
     * ```ts
     * import { Component } from '@angular/core';
     *
     *  @Component({
     *      selector: 'my-app',
     *      template: `
     *      <button (click)="treeview.focus('1')">Focuses the second node</button>
     *      <kendo-treeview
     *          #treeview
     *          [nodes]="data"
     *          textField="text"
     *      >
     *      </kendo-treeview>
     *  `
     *  })
     *  export class AppComponent {
     *      public data: any[] = [
     *          { text: "Furniture" },
     *          { text: "Decor" }
     *      ];
     *  }
     * ```
     */
    TreeViewComponent.prototype.focus = function (index) {
        this.navigationService.activateIndex(index);
        var target = focusableNode(this.element);
        if (target) {
            target.focus();
        }
    };
    /**
     * Based on the specified index, returns the TreeItemLookup node.
     *
     * @param index - The index of the node.
     * @returns {TreeItemLookup} - The item that was searched (looked up).
     */
    TreeViewComponent.prototype.itemLookup = function (index) {
        return this.treeViewLookupService.itemLookup(index);
    };
    /**
     * Triggers the [`children`]({% slug api_treeview_treeviewcomponent %}#toc-children) function for every expanded node,
     * causing all rendered child nodes to be fetched again.
     */
    TreeViewComponent.prototype.rebindChildren = function () {
        this.dataChangeNotification.notify();
    };
    /**
     * @hidden
     */
    TreeViewComponent.prototype.isDisabledNode = function (node) {
        return this.navigationService.isDisabled(node.item.index);
    };
    /**
     * Triggers the `expand` event for the provided node and displays it's loading indicator.
     */
    TreeViewComponent.prototype.expandNode = function (item, index) {
        this.expandService.expand(index, item);
    };
    /**
     * Triggers the `collapse` event for the provided node.
     */
    TreeViewComponent.prototype.collapseNode = function (item, index) {
        this.expandService.collapse(index, item);
    };
    /**
     * Gets the current page size of the checked data item children collection
     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
     *
     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to get its page size.
     *
     * @param dataItem {any} - The parent data item of the targeted collection.
     * @returns {number} - The page size of the checked data item children collection.
     */
    TreeViewComponent.prototype.getNodePageSize = function (dataItem) {
        this.verifyLoadMoreService();
        return this.loadMoreService.getGroupSize(dataItem);
    };
    /**
     * Sets the page size of the targeted data item children collection
     * ([see example]({% slug loadmorebutton_treeview %}#toc-managing-page-sizes)).
     *
     * > Since the root nodes collection is not associated with any parent data item, pass `null` as `dataItem` param to target its page size.
     *
     * @param dataItem {any} - The parent data item of the targeted collection.
     * @param pageSize {number} - The new page size.
     */
    TreeViewComponent.prototype.setNodePageSize = function (dataItem, pageSize) {
        this.verifyLoadMoreService();
        this.loadMoreService.setGroupSize(dataItem, pageSize);
    };
    TreeViewComponent.prototype.attachDomHandlers = function () {
        var element = this.element.nativeElement;
        this.clickHandler = this.clickHandler.bind(this);
        this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));
    };
    TreeViewComponent.prototype.focusHandler = function (e) {
        var _this = this;
        var focusItem;
        if (match(e.target, '.k-treeview-item')) {
            focusItem = e.target;
        }
        else if (!isFocusable(e.target)) { // with compliments to IE
            focusItem = closestNode(e.target);
        }
        if (focusItem) {
            this.navigationService.activateIndex(nodeId(e.target));
            if (!this.isActive && hasObservers(this.onFocus)) {
                this.ngZone.run(function () {
                    _this.onFocus.emit();
                });
            }
            this.isActive = true;
        }
    };
    TreeViewComponent.prototype.blurHandler = function (e) {
        var _this = this;
        if (this.isActive && match(e.target, '.k-treeview-item') &&
            (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {
            this.navigationService.deactivate();
            this.isActive = false;
            if (hasObservers(this.onBlur)) {
                this.ngZone.run(function () {
                    _this.onBlur.emit();
                });
            }
        }
    };
    TreeViewComponent.prototype.clickHandler = function (e) {
        var _this = this;
        var target = e.target;
        if ((e.type === 'contextmenu' && !hasObservers(this.nodeClick)) ||
            (e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target)) ||
            (e.type === 'dblclick' && !hasObservers(this.nodeDblClick)) || isFocusable(target) ||
            (!isContent(target) && !isLoadMoreButton(target)) || !hasParent(target, this.element.nativeElement)) {
            return;
        }
        var index = nodeId(closestNode(target));
        // the disabled check is probably not needed due to the k-state-disabled styles
        if (!index || this.navigationService.isDisabled(index)) {
            return;
        }
        this.ngZone.run(function () {
            var lookup = _this.treeViewLookupService.itemLookup(index);
            if (e.type === 'click') {
                var loadMoreButton = _this.navigationService.model.findNode(index).loadMoreButton;
                if (loadMoreButton) {
                    _this.navigationService.notifyLoadMore(index);
                }
                else {
                    _this.navigationService.selectIndex(index);
                }
            }
            var emitter = e.type === 'dblclick' ? _this.nodeDblClick : _this.nodeClick;
            emitter.emit({
                item: lookup.item,
                originalEvent: e,
                type: e.type
            });
        });
    };
    TreeViewComponent.prototype.keydownHandler = function (e) {
        var _this = this;
        if (this.isActive && this.navigable) {
            this.ngZone.run(function () {
                _this.navigationService.move(e);
            });
        }
    };
    TreeViewComponent.prototype.verifyLoadMoreService = function () {
        if (isDevMode() && !isPresent(this.loadMoreService)) {
            throw new Error("To use the TreeView paging functionality, you need to assign the `kendoTreeViewLoadMore` directive. See " + LOAD_MORE_DOC_LINK + ".");
        }
    };
    TreeViewComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.Default,
                    exportAs: 'kendoTreeView',
                    providers: providers,
                    selector: 'kendo-treeview',
                    template: "\n        <ul class=\"k-treeview-lines\"\n            kendoTreeViewGroup\n            role=\"group\"\n            [checkboxes]=\"checkboxes\"\n            [expandIcons]=\"expandIcons\"\n            [selectable]=\"selectable\"\n            [touchActions]=\"touchActions\"\n            [children]=\"children\"\n            [hasChildren]=\"hasChildren\"\n            [isChecked]=\"isChecked\"\n            [isDisabled]=\"isDisabled\"\n            [isExpanded]=\"isExpanded\"\n            [isSelected]=\"isSelected\"\n            [nodeTemplateRef]=\"nodeTemplate?.templateRef\"\n            [loadMoreButtonTemplateRef]=\"loadMoreButtonTemplate?.templateRef\"\n            [textField]=\"textField\"\n            [nodes]=\"fetchNodes\"\n            [loadMoreService]=\"loadMoreService\"\n            [trackBy]=\"trackBy\"\n        >\n        </ul>\n        <ng-container #assetsContainer></ng-container>\n    "
                },] },
    ];
    /** @nocollapse */
    TreeViewComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ExpandStateService },
        { type: NavigationService },
        { type: NodeChildrenService },
        { type: SelectionService },
        { type: TreeViewLookupService },
        { type: NgZone },
        { type: Renderer2 },
        { type: DataChangeNotificationService },
        { type: LocalizationService }
    ]; };
    TreeViewComponent.propDecorators = {
        classNames: [{ type: HostBinding, args: ["class.k-widget",] }, { type: HostBinding, args: ["class.k-treeview",] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        direction: [{ type: HostBinding, args: ["attr.dir",] }],
        assetsContainer: [{ type: ViewChild, args: ['assetsContainer', { read: ViewContainerRef, static: true },] }],
        animate: [{ type: Input }, { type: HostBinding, args: ['@.disabled',] }],
        childrenLoaded: [{ type: Output }],
        onBlur: [{ type: Output, args: ['blur',] }],
        onFocus: [{ type: Output, args: ['focus',] }],
        expand: [{ type: Output }],
        collapse: [{ type: Output }],
        nodeDragStart: [{ type: Output }],
        nodeDrag: [{ type: Output }],
        nodeDrop: [{ type: Output }],
        nodeDragEnd: [{ type: Output }],
        addItem: [{ type: Output }],
        removeItem: [{ type: Output }],
        checkedChange: [{ type: Output }],
        selectionChange: [{ type: Output }],
        nodeClick: [{ type: Output }],
        nodeDblClick: [{ type: Output }],
        nodeTemplate: [{ type: ContentChild, args: [NodeTemplateDirective,] }],
        loadMoreButtonTemplate: [{ type: ContentChild, args: [LoadMoreButtonTemplateDirective,] }],
        trackBy: [{ type: Input }],
        nodes: [{ type: Input }],
        textField: [{ type: Input }],
        hasChildren: [{ type: Input }],
        isChecked: [{ type: Input }],
        isDisabled: [{ type: Input }],
        isExpanded: [{ type: Input }],
        isSelected: [{ type: Input }],
        navigable: [{ type: Input }],
        children: [{ type: Input }]
    };
    return TreeViewComponent;
}());

/**
 * @hidden
 */
var TreeViewGroupComponent = /** @class */ (function () {
    function TreeViewGroupComponent(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.indexBuilder = indexBuilder;
        this.treeViewLookupService = treeViewLookupService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.dataChangeNotification = dataChangeNotification;
        this.changeDetectorRef = changeDetectorRef;
        this.kGroupClass = true;
        this.role = 'group';
        this.textField = "";
        this.initialNodesLoaded = false;
        this.loadingMoreNodes = false;
        this._data = [];
        this.singleRecordSubscriptions = new Subscription();
        this.isChecked = function () { return 'none'; };
        this.isDisabled = function () { return false; };
        this.isExpanded = function () { return false; };
        this.isSelected = function () { return false; };
        this.children = function () { return of([]); };
        this.hasChildren = function () { return false; };
    }
    Object.defineProperty(TreeViewGroupComponent.prototype, "moreNodesAvailable", {
        get: function () {
            if (!isPresent(this.loadMoreService)) {
                return false;
            }
            return this.pageSize < this.totalNodesCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "pageSize", {
        get: function () {
            if (!isPresent(this.loadMoreService)) {
                return null;
            }
            return this.loadMoreService.getGroupSize(this.parentDataItem);
        },
        set: function (pageSize) {
            this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "data", {
        get: function () {
            if (isPresent(this.pageSize)) {
                var normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;
                return this._data.slice(0, normalizedSizeValue);
            }
            return this._data;
        },
        set: function (data) {
            this._data = data;
            this.registerLoadedNodes(this.data);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "loadMoreButtonIndex", {
        get: function () {
            if (!this.loadMoreService) {
                return null;
            }
            return this.nodeIndex(this.data.length);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "totalNodesCount", {
        /**
         * Represents the total number of nodes for the current level.
         */
        get: function () {
            if (!this.loadMoreService) {
                return this.data.length;
            }
            return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewGroupComponent.prototype, "hasTemplate", {
        get: function () {
            return isPresent(this.nodeTemplateRef);
        },
        enumerable: true,
        configurable: true
    });
    TreeViewGroupComponent.prototype.expandNode = function (index, dataItem, expand) {
        if (expand) {
            this.expandService.expand(index, dataItem);
        }
        else {
            this.expandService.collapse(index, dataItem);
        }
    };
    TreeViewGroupComponent.prototype.checkNode = function (index) {
        this.navigationService.checkIndex(index);
        this.navigationService.activateIndex(index);
    };
    TreeViewGroupComponent.prototype.nodeIndex = function (index) {
        return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);
    };
    TreeViewGroupComponent.prototype.nodeText = function (dataItem) {
        var textField = isArray(this.textField) ? this.textField[0] : this.textField;
        return getter(textField)(dataItem);
    };
    TreeViewGroupComponent.prototype.ngOnDestroy = function () {
        if (isPresent(this.nodesSubscription)) {
            this.nodesSubscription.unsubscribe();
        }
        if (isPresent(this.loadMoreNodesSubscription)) {
            this.loadMoreNodesSubscription.unsubscribe();
        }
        this.singleRecordSubscriptions.unsubscribe();
    };
    TreeViewGroupComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscribeToNodesChange();
        this.singleRecordSubscriptions.add(this.dataChangeNotification
            .changes
            .subscribe(this.subscribeToNodesChange.bind(this)));
        this.singleRecordSubscriptions.add(this.navigationService.loadMore
            .pipe(filter(function (index) { return index === _this.loadMoreButtonIndex; }))
            .subscribe(this.loadMoreNodes.bind(this)));
    };
    TreeViewGroupComponent.prototype.ngOnChanges = function (changes) {
        if (changes.parentIndex) {
            this.setNodeChildren(this.mapToTreeItem(this.data));
        }
    };
    TreeViewGroupComponent.prototype.fetchChildren = function (node, index) {
        var _this = this;
        return this.children(node)
            .pipe(catchError(function () {
            _this.loadingService.notifyLoaded(index);
            return EMPTY;
        }), tap(function () { return _this.loadingService.notifyLoaded(index); }));
    };
    Object.defineProperty(TreeViewGroupComponent.prototype, "nextFields", {
        get: function () {
            if (isArray(this.textField)) {
                return this.textField.length > 1 ? this.textField.slice(1) : this.textField;
            }
            return [this.textField];
        },
        enumerable: true,
        configurable: true
    });
    TreeViewGroupComponent.prototype.loadMoreNodes = function () {
        if (isPresent(this.loadMoreService.loadMoreNodes)) {
            this.fetchMoreNodes();
        }
        else {
            this.loadMoreLocalNodes();
        }
    };
    TreeViewGroupComponent.prototype.loadMoreLocalNodes = function () {
        var initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
        this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);
        this.registerLoadedNodes(this.data);
        // forces the new items to be registered before the focus is changed
        this.changeDetectorRef.detectChanges();
        this.reselectItemAt(initialLoadMoreButtonIndex);
    };
    TreeViewGroupComponent.prototype.fetchMoreNodes = function () {
        var _this = this;
        if (this.loadingMoreNodes) {
            return;
        }
        this.loadingMoreNodes = true;
        if (isPresent(this.loadMoreNodesSubscription)) {
            this.loadMoreNodesSubscription.unsubscribe();
        }
        this.loadMoreNodesSubscription = this.loadMoreService
            .loadMoreNodes({
            dataItem: this.parentDataItem,
            skip: this.data.length,
            take: this.loadMoreService.getInitialPageSize(this.parentDataItem)
        })
            .pipe(finalize(function () { return _this.loadingMoreNodes = false; }))
            .subscribe(function (items) {
            if (!(Array.isArray(items) && items.length > 0)) {
                return;
            }
            var initialLoadMoreButtonIndex = _this.loadMoreButtonIndex;
            _this.pageSize += items.length;
            _this.data = _this.data.concat(items);
            if (_this.navigationService.isActive(initialLoadMoreButtonIndex)) {
                // forces the new items to be registered before the focus is changed
                _this.changeDetectorRef.detectChanges();
                _this.reselectItemAt(initialLoadMoreButtonIndex);
            }
        });
    };
    TreeViewGroupComponent.prototype.setNodeChildren = function (children) {
        this.treeViewLookupService.registerChildren(this.parentIndex, children);
    };
    TreeViewGroupComponent.prototype.mapToTreeItem = function (data) {
        var _this = this;
        if (!this.parentIndex) {
            return [];
        }
        return data.map(function (dataItem, idx) { return ({ dataItem: dataItem, index: _this.nodeIndex(idx) }); });
    };
    TreeViewGroupComponent.prototype.emitChildrenLoaded = function (children) {
        if (!this.parentIndex) {
            return;
        }
        // ignores the registered load-more button
        var contentChildren = children.filter(function (item) { return item.dataItem; });
        this.nodeChildrenService.childrenLoaded({ dataItem: this.parentDataItem, index: this.parentIndex }, contentChildren);
    };
    TreeViewGroupComponent.prototype.subscribeToNodesChange = function () {
        var _this = this;
        if (this.nodesSubscription) {
            this.nodesSubscription.unsubscribe();
        }
        this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex)
            .subscribe(function (data) {
            _this.data = data;
            _this.initialNodesLoaded = true;
        });
    };
    TreeViewGroupComponent.prototype.reselectItemAt = function (index) {
        if (!isPresent(index)) {
            return;
        }
        // make sure the old index is cleared first
        this.navigationService.deactivate();
        this.navigationService.activateIndex(index);
    };
    TreeViewGroupComponent.prototype.registerLoadedNodes = function (nodes) {
        if (nodes === void 0) { nodes = []; }
        var mappedChildren = this.mapToTreeItem(nodes);
        this.setNodeChildren(mappedChildren);
        this.emitChildrenLoaded(mappedChildren);
    };
    TreeViewGroupComponent.decorators = [
        { type: Component, args: [{
                    animations: [
                        trigger('toggle', [
                            transition('void => *', [
                                style({ height: 0 }),
                                animate('0.1s ease-in', style({ height: "*" }))
                            ]),
                            transition('* => void', [
                                style({ height: "*" }),
                                animate('0.1s ease-in', style({ height: 0 }))
                            ])
                        ])
                    ],
                    selector: '[kendoTreeViewGroup]',
                    template: "\n        <li\n            *ngFor=\"let node of data; let index = index; trackBy: trackBy\"\n            class=\"k-item k-treeview-item\"\n            kendoTreeViewItem\n            [attr.aria-setsize]=\"totalNodesCount\"\n            [dataItem]=\"node\"\n            [index]=\"nodeIndex(index)\"\n            [parentDataItem]=\"parentDataItem\"\n            [parentIndex]=\"parentIndex\"\n            [checkable]=\"checkboxes\"\n            [isChecked]=\"isChecked(node, nodeIndex(index))\"\n            [isDisabled]=\"disabled || isDisabled(node, nodeIndex(index))\"\n            [expandable]=\"expandIcons && hasChildren(node)\"\n            [isExpanded]=\"isExpanded(node, nodeIndex(index))\"\n            [selectable]=\"selectable\"\n            [isSelected]=\"isSelected(node, nodeIndex(index))\"\n            [attr.data-treeindex]=\"nodeIndex(index)\"\n        >\n            <div class=\"k-mid\">\n                <span\n                    class=\"k-icon\"\n                    [class.k-i-collapse]=\"isExpanded(node, nodeIndex(index))\"\n                    [class.k-i-expand]=\"!isExpanded(node, nodeIndex(index))\"\n                    [kendoTreeViewLoading]=\"nodeIndex(index)\"\n                    (click)=\"expandNode(nodeIndex(index), node, !isExpanded(node, nodeIndex(index)))\"\n                    *ngIf=\"expandIcons && hasChildren(node)\"\n                >\n                </span>\n                <kendo-checkbox\n                    *ngIf=\"checkboxes\"\n                    [node]=\"node\"\n                    [index]=\"nodeIndex(index)\"\n                    [isChecked]=\"isChecked\"\n                    (checkStateChange)=\"checkNode(nodeIndex(index))\"\n                    tabindex=\"-1\"\n                ></kendo-checkbox>\n                <span kendoTreeViewItemContent\n                    [attr.data-treeindex]=\"nodeIndex(index)\"\n                    [dataItem]=\"node\"\n                    [index]=\"nodeIndex(index)\"\n                    [initialSelection]=\"isSelected(node, nodeIndex(index))\"\n                    [isSelected]=\"isSelected\"\n                    class=\"k-in\"\n                    [style.touch-action]=\"touchActions ? '' : 'none'\"\n                >\n                    <ng-container [ngSwitch]=\"hasTemplate\">\n                        <ng-container *ngSwitchCase=\"true\">\n                            <ng-template\n                                [ngTemplateOutlet]=\"nodeTemplateRef\"\n                                [ngTemplateOutletContext]=\"{\n                                    $implicit: node,\n                                    index: nodeIndex(index)\n                                }\"\n                            >\n                            </ng-template>\n                        </ng-container>\n                        <ng-container *ngSwitchDefault>\n                            {{nodeText(node)}}\n                        </ng-container>\n                    </ng-container>\n                </span>\n            </div>\n            <ul\n                *ngIf=\"isExpanded(node, nodeIndex(index)) && hasChildren(node)\"\n                kendoTreeViewGroup\n                role=\"group\"\n                [nodes]=\"fetchChildren\"\n                [checkboxes]=\"checkboxes\"\n                [expandIcons]=\"expandIcons\"\n                [selectable]=\"selectable\"\n                [touchActions]=\"touchActions\"\n                [children]=\"children\"\n                [hasChildren]=\"hasChildren\"\n                [isChecked]=\"isChecked\"\n                [isDisabled]=\"isDisabled\"\n                [disabled]=\"disabled || isDisabled(node, nodeIndex(index))\"\n                [isExpanded]=\"isExpanded\"\n                [isSelected]=\"isSelected\"\n                [nodeTemplateRef]=\"nodeTemplateRef\"\n                [loadMoreButtonTemplateRef]=\"loadMoreButtonTemplateRef\"\n                [parentIndex]=\"nodeIndex(index)\"\n                [parentDataItem]=\"node\"\n                [textField]=\"nextFields\"\n                [loadMoreService]=\"loadMoreService\"\n                [@toggle]=\"true\"\n                [trackBy]=\"trackBy\"\n            >\n            </ul>\n        </li>\n        <li\n            *ngIf=\"initialNodesLoaded && moreNodesAvailable\"\n            class=\"k-item k-treeview-item\"\n            [class.k-treeview-load-more-checkboxes-container]=\"checkboxes\"\n            kendoTreeViewItem\n            [role]=\"'button'\"\n            [selectable]=\"false\"\n            [checkable]=\"false\"\n            [expandable]=\"false\"\n            [index]=\"loadMoreButtonIndex\"\n            [parentDataItem]=\"parentDataItem\"\n            [parentIndex]=\"parentIndex\"\n            [attr.data-treeindex]=\"loadMoreButtonIndex\"\n        >\n            <div class=\"k-mid\">\n                <span\n                    *ngIf=\"loadingMoreNodes\"\n                    class=\"k-icon k-i-loading k-i-expand\"\n                >\n                </span>\n                <span\n                    class=\"k-in k-treeview-load-more-button\"\n                    [attr.data-treeindex]=\"loadMoreButtonIndex\"\n                    kendoTreeViewItemContent\n                    [index]=\"loadMoreButtonIndex\"\n                >\n                    <ng-template\n                        *ngIf=\"loadMoreButtonTemplateRef\"\n                        [ngTemplateOutlet]=\"loadMoreButtonTemplateRef\"\n                        [ngTemplateOutletContext]=\"{\n                            index: loadMoreButtonIndex\n                        }\"\n                    >\n                    </ng-template>\n                    <ng-container *ngIf=\"!loadMoreButtonTemplateRef\">\n                        Load more\n                    </ng-container>\n                </span>\n            </div>\n        </li>\n    "
                },] },
    ];
    /** @nocollapse */
    TreeViewGroupComponent.ctorParameters = function () { return [
        { type: ExpandStateService },
        { type: LoadingNotificationService },
        { type: IndexBuilderService },
        { type: TreeViewLookupService },
        { type: NavigationService },
        { type: NodeChildrenService },
        { type: DataChangeNotificationService },
        { type: ChangeDetectorRef }
    ]; };
    TreeViewGroupComponent.propDecorators = {
        kGroupClass: [{ type: HostBinding, args: ["class.k-group",] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        checkboxes: [{ type: Input }],
        expandIcons: [{ type: Input }],
        disabled: [{ type: Input }],
        selectable: [{ type: Input }],
        touchActions: [{ type: Input }],
        trackBy: [{ type: Input }],
        nodes: [{ type: Input }],
        textField: [{ type: Input }],
        parentDataItem: [{ type: Input }],
        parentIndex: [{ type: Input }],
        nodeTemplateRef: [{ type: Input }],
        loadMoreButtonTemplateRef: [{ type: Input }],
        loadMoreService: [{ type: Input }],
        isChecked: [{ type: Input }],
        isDisabled: [{ type: Input }],
        isExpanded: [{ type: Input }],
        isSelected: [{ type: Input }],
        children: [{ type: Input }],
        hasChildren: [{ type: Input }]
    };
    return TreeViewGroupComponent;
}());

var indexChecked = function (keys, index) { return keys.filter(function (k) { return k === index; }).length > 0; };
var matchKey = function (index) { return function (k) {
    if (index === k) {
        return true;
    }
    if (!k.split) {
        return false;
    }
    return k.split('_').reduce(function (_a, part) {
        var key = _a.key, result = _a.result;
        key += part;
        if (index === key || result) {
            return { result: true };
        }
        key += "_";
        return { key: key, result: false };
    }, { key: "", result: false }).result;
}; };
var getDescendantsFromLookup = function (lookup) {
    if (!isPresent(lookup) || lookup.children.length === 0) {
        return [];
    }
    var descendants = lookup.children;
    descendants.forEach(function (child) { return descendants = descendants.concat(getDescendantsFromLookup(child)); });
    return descendants;
};
/**
 * A directive which manages the in-memory checked state of the TreeView node
 * ([see example]({% slug checkboxes_treeview %})).
 */
var CheckDirective = /** @class */ (function () {
    function CheckDirective(treeView, zone) {
        var _this = this;
        this.treeView = treeView;
        this.zone = zone;
        /**
         * Fires when the `checkedKeys` collection was updated.
         */
        this.checkedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.checkActions = {
            'multiple': function (e) { return _this.checkMultiple(e); },
            'single': function (e) { return _this.checkSingle(e); }
        };
        this._checkedKeys = [];
        this.subscriptions.add(this.treeView.checkedChange
            .subscribe(function (e) { return _this.check(e); }));
        var expandedItems = [];
        this.subscriptions.add(this.treeView.childrenLoaded
            .pipe(filter(function () { return _this.options.checkChildren; }), tap(function (item) { return expandedItems.push(item); }), switchMap(function () { return _this.zone.onStable.pipe(take(1)); }))
            .subscribe(function () { return _this.addCheckedItemsChildren(expandedItems); }));
        this.treeView.isChecked = this.isItemChecked.bind(this);
    }
    Object.defineProperty(CheckDirective.prototype, "isChecked", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isChecked = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckDirective.prototype, "checkedKeys", {
        /**
         * Defines the collection that will store the checked keys
         * ([see example]({% slug checkboxes_treeview %})).
         */
        get: function () {
            return this._checkedKeys;
        },
        set: function (keys) {
            this._checkedKeys = keys;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckDirective.prototype, "options", {
        get: function () {
            var defaultOptions = {
                checkChildren: true,
                checkParents: true,
                enabled: true,
                mode: "multiple"
            };
            if (!isPresent(this.checkable) || typeof this.checkable === 'string') {
                return defaultOptions;
            }
            var isBoolean = typeof this.checkable === 'boolean';
            var checkSettings = isBoolean
                ? { enabled: this.checkable }
                : this.checkable;
            return Object.assign(defaultOptions, checkSettings);
        },
        enumerable: true,
        configurable: true
    });
    CheckDirective.prototype.ngOnChanges = function (changes) {
        if (changes.checkable) {
            this.treeView.checkboxes = this.options.enabled;
            this.toggleCheckOnClick();
        }
    };
    CheckDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.unsubscribeClick();
    };
    CheckDirective.prototype.isItemChecked = function (dataItem, index) {
        if (!this.checkKey) {
            return this.isIndexChecked(index);
        }
        var keyIndex = this.checkedKeys.indexOf(this.itemKey({ dataItem: dataItem, index: index }));
        return keyIndex > -1 ? 'checked' : 'none';
    };
    CheckDirective.prototype.isIndexChecked = function (index) {
        var checkedKeys = this.checkedKeys.filter(matchKey(index));
        if (indexChecked(checkedKeys, index)) {
            return 'checked';
        }
        var _a = this.options, mode = _a.mode, checkParents = _a.checkParents;
        if (mode === 'multiple' && checkParents && checkedKeys.length) {
            return 'indeterminate';
        }
        return 'none';
    };
    CheckDirective.prototype.itemKey = function (item) {
        if (!isPresent(this.checkKey)) {
            return item.index;
        }
        if (typeof this.checkKey === "string" && isPresent(item.dataItem)) {
            return item.dataItem[this.checkKey];
        }
        if (typeof this.checkKey === "function") {
            return this.checkKey(item);
        }
    };
    CheckDirective.prototype.check = function (e) {
        var _a = this.options, enabled = _a.enabled, mode = _a.mode;
        var performSelection = this.checkActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    };
    CheckDirective.prototype.checkSingle = function (node) {
        var key = this.itemKey(node.item);
        this.checkedKeys = this.checkedKeys[0] !== key ? [key] : [];
        this.notify();
    };
    CheckDirective.prototype.checkMultiple = function (node) {
        this.checkNode(node);
        if (this.options.checkParents) {
            this.checkParents(node.parent);
        }
        this.notify();
    };
    CheckDirective.prototype.toggleCheckOnClick = function () {
        var _this = this;
        this.unsubscribeClick();
        if (this.options.checkOnClick) {
            this.clickSubscription = this.treeView.nodeClick.subscribe(function (args) {
                if (args.type === 'click') {
                    var lookup = _this.treeView.itemLookup(args.item.index);
                    _this.check(lookup);
                }
            });
        }
    };
    CheckDirective.prototype.unsubscribeClick = function () {
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
            this.clickSubscription = null;
        }
    };
    CheckDirective.prototype.checkNode = function (node) {
        var _this = this;
        if (!isPresent(node.item.dataItem) || this.treeView.isDisabledNode(node)) {
            return;
        }
        var currentKey = this.itemKey(node.item);
        if (!isPresent(currentKey)) {
            return;
        }
        var checkedKeys = new Set(this.checkedKeys);
        var pendingCheck = [currentKey];
        if (this.options.checkChildren) {
            var descendants = getDescendantsFromLookup(node)
                .filter(function (lookup) { return isPresent(lookup.item.dataItem) && !_this.treeView.isDisabledNode(lookup); })
                .map(function (_a) {
                var item = _a.item;
                return _this.itemKey(item);
            });
            pendingCheck.push.apply(pendingCheck, descendants);
        }
        var shouldCheck = !checkedKeys.has(currentKey);
        pendingCheck.forEach(function (key) {
            if (shouldCheck) {
                checkedKeys.add(key);
            }
            else {
                checkedKeys.delete(key);
            }
        });
        this.checkedKeys = Array.from(checkedKeys);
    };
    CheckDirective.prototype.checkParents = function (parent) {
        var _this = this;
        if (!isPresent(parent)) {
            return;
        }
        var checkedKeys = new Set(this.checkedKeys);
        var currentParent = parent;
        while (currentParent) {
            var parentKey = this.itemKey(currentParent.item);
            var allChildrenSelected = currentParent.children.every(function (item) { return checkedKeys.has(_this.itemKey(item)); });
            if (allChildrenSelected) {
                checkedKeys.add(parentKey);
            }
            else {
                checkedKeys.delete(parentKey);
            }
            currentParent = currentParent.parent;
        }
        this.checkedKeys = Array.from(checkedKeys);
    };
    CheckDirective.prototype.notify = function () {
        this.checkedKeysChange.emit(this.checkedKeys.slice());
    };
    CheckDirective.prototype.addCheckedItemsChildren = function (lookups) {
        var _this = this;
        if (!isPresent(lookups) || lookups.length === 0) {
            return;
        }
        var initiallyCheckedItemsCount = this.checkedKeys.length;
        var checkedKeys = new Set(this.checkedKeys);
        lookups.forEach(function (lookup) {
            var itemKey = _this.itemKey(lookup.item);
            if (!checkedKeys.has(itemKey)) {
                return;
            }
            lookup.children.forEach(function (item) {
                return isPresent(item.dataItem) && checkedKeys.add(_this.itemKey(item));
            });
        });
        var hasNewlyCheckedItems = initiallyCheckedItemsCount !== checkedKeys.size;
        if (hasNewlyCheckedItems) {
            this.checkedKeys = Array.from(checkedKeys);
            this.zone.run(function () { return _this.notify(); });
        }
    };
    CheckDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewCheckable]' },] },
    ];
    /** @nocollapse */
    CheckDirective.ctorParameters = function () { return [
        { type: TreeViewComponent },
        { type: NgZone }
    ]; };
    CheckDirective.propDecorators = {
        isChecked: [{ type: Input }],
        checkKey: [{ type: Input, args: ["checkBy",] }],
        checkedKeys: [{ type: Input }],
        checkable: [{ type: Input, args: ['kendoTreeViewCheckable',] }],
        checkedKeysChange: [{ type: Output }]
    };
    return CheckDirective;
}());

/**
 * A directive which manages the disabled in-memory state of the TreeView node
 * ([see example]({% slug disabledstate_treeview %})).
 */
var DisableDirective = /** @class */ (function () {
    function DisableDirective(treeView, cdr) {
        var _this = this;
        this.treeView = treeView;
        this.cdr = cdr;
        /**
         * Defines the collection that will store the disabled keys.
         */
        this.disabledKeys = [];
        this.treeView.isDisabled = function (dataItem, index) { return (_this.disabledKeys.indexOf(_this.itemKey({ dataItem: dataItem, index: index })) > -1); };
    }
    Object.defineProperty(DisableDirective.prototype, "isDisabled", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isDisabled = value;
        },
        enumerable: true,
        configurable: true
    });
    DisableDirective.prototype.ngOnChanges = function (changes) {
        if (changes === void 0) { changes = {}; }
        var disabledKeys = changes.disabledKeys;
        if (disabledKeys && !disabledKeys.firstChange) {
            this.cdr.markForCheck();
        }
    };
    DisableDirective.prototype.itemKey = function (e) {
        if (!this.disableKey) {
            return e.index;
        }
        if (typeof this.disableKey === "string") {
            return e.dataItem[this.disableKey];
        }
        if (typeof this.disableKey === "function") {
            return this.disableKey(e);
        }
    };
    DisableDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewDisable]' },] },
    ];
    /** @nocollapse */
    DisableDirective.ctorParameters = function () { return [
        { type: TreeViewComponent },
        { type: ChangeDetectorRef }
    ]; };
    DisableDirective.propDecorators = {
        isDisabled: [{ type: Input }],
        disableKey: [{ type: Input, args: ["kendoTreeViewDisable",] }],
        disabledKeys: [{ type: Input }]
    };
    return DisableDirective;
}());

/**
 * A directive which manages the expanded state of the TreeView
 * ([see example]({% slug expandedstate_treeview %})).
 */
var ExpandDirective = /** @class */ (function () {
    function ExpandDirective(treeView) {
        var _this = this;
        this.treeView = treeView;
        /**
         * Fires when the `expandedKeys` collection was updated.
         */
        this.expandedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this._expandedKeys = [];
        this.subscriptions.add(merge(this.treeView.expand.pipe(map(function (e) { return (__assign({ expand: true }, e)); })), this.treeView.collapse.pipe(map(function (e) { return (__assign({ expand: false }, e)); }))).subscribe(this.toggleExpand.bind(this)));
        this.treeView.isExpanded = function (dataItem, index) {
            return _this.expandedKeys.indexOf(_this.itemKey({ dataItem: dataItem, index: index })) > -1;
        };
    }
    Object.defineProperty(ExpandDirective.prototype, "isExpanded", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isExpanded = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpandDirective.prototype, "expandedKeys", {
        /**
         * Defines the collection that will store the expanded keys.
         */
        get: function () {
            return this._expandedKeys;
        },
        set: function (keys) {
            this._expandedKeys = keys;
        },
        enumerable: true,
        configurable: true
    });
    ExpandDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    ExpandDirective.prototype.itemKey = function (e) {
        if (this.expandKey) {
            if (typeof this.expandKey === "string") {
                return e.dataItem[this.expandKey];
            }
            if (typeof this.expandKey === "function") {
                return this.expandKey(e);
            }
        }
        return e.index;
    };
    ExpandDirective.prototype.toggleExpand = function (_a) {
        var index = _a.index, dataItem = _a.dataItem, expand = _a.expand;
        var item = this.itemKey({ index: index, dataItem: dataItem });
        var idx = this.expandedKeys.indexOf(item);
        var notify = false;
        if (idx > -1 && !expand) {
            this.expandedKeys.splice(idx, 1);
            notify = true;
        }
        else if (idx === -1 && expand) {
            this.expandedKeys.push(item);
            notify = true;
        }
        if (notify) {
            this.expandedKeysChange.emit(this.expandedKeys);
        }
    };
    ExpandDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewExpandable]' },] },
    ];
    /** @nocollapse */
    ExpandDirective.ctorParameters = function () { return [
        { type: TreeViewComponent }
    ]; };
    ExpandDirective.propDecorators = {
        isExpanded: [{ type: Input }],
        expandKey: [{ type: Input, args: ["expandBy",] }],
        expandedKeysChange: [{ type: Output }],
        expandedKeys: [{ type: Input }]
    };
    return ExpandDirective;
}());

/**
 * A directive which manages the in-memory selection state of the TreeView node
 * ([see example]({% slug selection_treeview %})).
 */
var SelectDirective = /** @class */ (function () {
    function SelectDirective(treeView) {
        var _this = this;
        this.treeView = treeView;
        /**
         * Fires when the `selectedKeys` collection was updated.
         */
        this.selectedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.selectActions = {
            'multiple': function (e) { return _this.selectMultiple(e); },
            'single': function (e) { return _this.selectSingle(e); }
        };
        this._selectedKeys = [];
        this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));
        this.treeView.isSelected = function (dataItem, index) { return (_this.selectedKeys.indexOf(_this.itemKey({ dataItem: dataItem, index: index })) > -1); };
    }
    Object.defineProperty(SelectDirective.prototype, "isSelected", {
        /**
         * @hidden
         */
        set: function (value) {
            this.treeView.isSelected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectDirective.prototype, "selectedKeys", {
        /**
         * Defines the collection that will store the selected keys
         * ([see example]({% slug selection_treeview %}#toc-selection-modes)).
         */
        get: function () {
            return this._selectedKeys;
        },
        set: function (keys) {
            this._selectedKeys = keys;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectDirective.prototype, "getAriaMultiselectable", {
        get: function () {
            return this.options.mode === 'multiple';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectDirective.prototype, "options", {
        get: function () {
            var defaultOptions = {
                enabled: true,
                mode: 'single'
            };
            if (!isPresent(this.selection) || typeof this.selection === 'string') {
                return defaultOptions;
            }
            var isBoolean = typeof this.selection === 'boolean';
            var selectionSettings = isBoolean ? { enabled: this.selection } : this.selection;
            return Object.assign(defaultOptions, selectionSettings);
        },
        enumerable: true,
        configurable: true
    });
    SelectDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    SelectDirective.prototype.itemKey = function (e) {
        if (!this.selectKey) {
            return e.index;
        }
        if (typeof this.selectKey === 'string') {
            return e.dataItem[this.selectKey];
        }
        if (typeof this.selectKey === 'function') {
            return this.selectKey(e);
        }
    };
    SelectDirective.prototype.select = function (e) {
        var _a = this.options, enabled = _a.enabled, mode = _a.mode;
        var performSelection = this.selectActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    };
    SelectDirective.prototype.selectSingle = function (node) {
        var key = this.itemKey(node);
        if (this.selectedKeys[0] === key) {
            return;
        }
        this.selectedKeys = [key];
        this.notify();
    };
    SelectDirective.prototype.selectMultiple = function (node) {
        var key = this.itemKey(node);
        var idx = this.selectedKeys.indexOf(key);
        var isSelected = idx > -1;
        if (!isPresent(key)) {
            return;
        }
        if (isSelected) {
            this.selectedKeys.splice(idx, 1);
        }
        else {
            this.selectedKeys.push(key);
        }
        this.notify();
    };
    SelectDirective.prototype.notify = function () {
        this.selectedKeysChange.emit(this.selectedKeys.slice());
    };
    SelectDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewSelectable]' },] },
    ];
    /** @nocollapse */
    SelectDirective.ctorParameters = function () { return [
        { type: TreeViewComponent }
    ]; };
    SelectDirective.propDecorators = {
        isSelected: [{ type: Input }],
        selectKey: [{ type: Input, args: ['selectBy',] }],
        selection: [{ type: Input, args: ['kendoTreeViewSelectable',] }],
        selectedKeys: [{ type: Input }],
        selectedKeysChange: [{ type: Output }],
        getAriaMultiselectable: [{ type: HostBinding, args: ['attr.aria-multiselectable',] }]
    };
    return SelectDirective;
}());

/**
 * Describes the attempted drop action during dragging.
 * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.
 * By default, this value defines the rendered icon in the drag clue.
 */
var DropAction;
(function (DropAction) {
    DropAction[DropAction["Add"] = 0] = "Add";
    DropAction[DropAction["InsertTop"] = 1] = "InsertTop";
    DropAction[DropAction["InsertBottom"] = 2] = "InsertBottom";
    DropAction[DropAction["InsertMiddle"] = 3] = "InsertMiddle";
    DropAction[DropAction["Invalid"] = 4] = "Invalid";
})(DropAction || (DropAction = {}));

/**
 * Describes where the dragged item is dropped relative to the drop target item.
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["Over"] = 0] = "Over";
    DropPosition[DropPosition["Before"] = 1] = "Before";
    DropPosition[DropPosition["After"] = 2] = "After";
})(DropPosition || (DropPosition = {}));

/**
 * @hidden
 */
var PreventableEvent = /** @class */ (function () {
    function PreventableEvent() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    PreventableEvent.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    PreventableEvent.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent;
}());

/**
 * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.
 */
var TreeItemDropEvent = /** @class */ (function (_super) {
    __extends(TreeItemDropEvent, _super);
    /**
     * @hidden
     */
    function TreeItemDropEvent(initializer, originalEvent) {
        var _this = _super.call(this) || this;
        /**
         * @hidden
         */
        _this.isValid = true;
        Object.assign(_this, initializer);
        _this.originalEvent = originalEvent;
        return _this;
    }
    /**
     * Specifies if the drop action should be marked as valid.
     * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
     * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue
     * will be animated back to the source item to indicate the action is marked as invalid.
     */
    TreeItemDropEvent.prototype.setValid = function (isValid) {
        this.isValid = isValid;
    };
    return TreeItemDropEvent;
}(PreventableEvent));

/**
 * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.
 */
var TreeItemDragStartEvent = /** @class */ (function (_super) {
    __extends(TreeItemDragStartEvent, _super);
    /**
     * @hidden
     */
    function TreeItemDragStartEvent(initializer) {
        var _this = _super.call(this) || this;
        Object.assign(_this, initializer);
        return _this;
    }
    return TreeItemDragStartEvent;
}(PreventableEvent));

/**
 * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.
 */
var TreeItemDragEvent = /** @class */ (function () {
    function TreeItemDragEvent() {
    }
    return TreeItemDragEvent;
}());

var Éµ0$2 = function () {
    if (!(isDocumentAvailable() && isPresent(document.body))) {
        return false;
    }
    var top = 10;
    var parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = "<div style=\"position: fixed; top: " + top + "px;\">child</div>";
    document.body.appendChild(parent);
    var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
var hasRelativeStackingContext = memoize(Éµ0$2);
/**
 * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.
 */
function memoize(fn) {
    var result;
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (called) {
            return result;
        }
        result = fn.apply(void 0, args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
var getContainerOffset = function (element) {
    if (!(element && hasRelativeStackingContext())) {
        return { left: 0, top: 0 };
    }
    var offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        var rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
var getDropAction = function (dropPosition, dropTarget) {
    if (!(isPresent(dropPosition) && isPresent(dropTarget))) {
        return DropAction.Invalid;
    }
    switch (dropPosition) {
        case DropPosition.Over:
            return DropAction.Add;
        case DropPosition.Before:
            return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
        case DropPosition.After:
            return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
        default:
            return DropAction.Invalid;
    }
};
/**
 * @hidden
 */
var getDropPosition = function (draggedItem, target, clientY, targetTreeView, containerOffset) {
    if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {
        return;
    }
    // the .k-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    var item = closestWithMatch(target, '.k-mid');
    if (!isPresent(item)) {
        return;
    }
    // the content element (.k-in:not(.k-treeview-load-more-button)) holds just the treeview item text
    var content = getContentElement(item);
    var targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
    if (!isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    var itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:
            - dropping should insert before or after
    */
    var itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    var pointerPosition = clientY - containerOffset.top;
    var itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return DropPosition.After;
    }
    return DropPosition.Over;
};
/**
 * @hidden
 */
var treeItemFromEventTarget = function (treeView, dropTarget) {
    if (!(isPresent(treeView) && isPresent(dropTarget))) {
        return null;
    }
    var node = closestNode(dropTarget);
    var index = nodeId(node);
    var lookup = treeView.itemLookup(index);
    if (!(isPresent(lookup) && isPresent(lookup.item.dataItem))) {
        return null;
    }
    return lookup;
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
var collapseEmptyParent = function (parent, parentNodes, treeview) {
    if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
var expandDropTarget = function (dropTarget, treeView) {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
var getDropTarget = function (event) {
    if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};

/**
 * @hidden
 */
var copyPageSize = function (treeview, source, target) {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    var sourceGroupSize = treeview.getNodePageSize(source);
    treeview.setNodePageSize(target, sourceGroupSize);
};
/**
 * @hidden
 */
var incrementPageSize = function (treeview, dataItem) {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    var currentPageSize = treeview.getNodePageSize(dataItem);
    treeview.setNodePageSize(dataItem, currentPageSize + 1);
};
/**
 * @hidden
 */
var decrementPageSize = function (treeview, dataItem) {
    if (!isPresent(treeview.loadMoreService)) {
        return;
    }
    var currentPageSize = treeview.getNodePageSize(dataItem);
    treeview.setNodePageSize(dataItem, currentPageSize - 1);
};

/**
 * @hidden
 */
var HierarchyEditingService = /** @class */ (function () {
    function HierarchyEditingService(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    HierarchyEditingService.prototype.add = function (_a) {
        var sourceItem = _a.sourceItem, destinationItem = _a.destinationItem, dropPosition = _a.dropPosition, destinationTree = _a.destinationTree;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        var clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            var destinationChildren = this.childrenFor(getDataItem(destinationItem));
            // add the moved node just before the load more button if load more is enabled
            var targetIndex = isPresent(destinationTree.loadMoreService) ?
                destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)) :
                destinationChildren.length;
            destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
            setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);
        }
        else {
            var destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            var shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            var targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
        }
        // increment the parent page size => an item is moved into it
        var updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    };
    HierarchyEditingService.prototype.remove = function (_a) {
        var sourceItem = _a.sourceItem, sourceTree = _a.sourceTree;
        var sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        var sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    };
    HierarchyEditingService.prototype.getParentNodes = function (node, treeView) {
        return isPresent(node.parent) ?
            this.childrenFor(getDataItem(node.parent)) :
            treeView.nodes;
    };
    HierarchyEditingService.prototype.childrenFor = function (dataItem) {
        return getter(this.hierarchyBinding.childrenField)(dataItem) || [];
    };
    return HierarchyEditingService;
}());

/**
 * A directive which encapsulates the retrieval of child nodes.
 */
var HierarchyBindingDirective = /** @class */ (function () {
    function HierarchyBindingDirective(treeView) {
        this.treeView = treeView;
    }
    Object.defineProperty(HierarchyBindingDirective.prototype, "childrenField", {
        /**
         * The field name which holds the data items of the child component.
         */
        get: function () {
            return this._childrenField;
        },
        /**
         * The field name which holds the data items of the child component.
         */
        set: function (value) {
            if (!value) {
                throw new Error("'childrenField' cannot be empty");
            }
            this._childrenField = value;
        },
        enumerable: true,
        configurable: true
    });
    HierarchyBindingDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (isPresent(this.childrenField)) {
            this.treeView.children = function (item) { return of(getter(_this.childrenField)(item)); };
            this.treeView.hasChildren = function (item) {
                var children = getter(_this.childrenField)(item);
                return Boolean(children && children.length);
            };
            this.treeView.editService = new HierarchyEditingService(this);
        }
    };
    HierarchyBindingDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewHierarchyBinding]' },] },
    ];
    /** @nocollapse */
    HierarchyBindingDirective.ctorParameters = function () { return [
        { type: TreeViewComponent }
    ]; };
    HierarchyBindingDirective.propDecorators = {
        childrenField: [{ type: Input }]
    };
    return HierarchyBindingDirective;
}());

/**
 * @hidden
 */
var LoadingIndicatorDirective = /** @class */ (function () {
    function LoadingIndicatorDirective(expandService, loadingService, cd) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.cd = cd;
        this._loading = false;
    }
    Object.defineProperty(LoadingIndicatorDirective.prototype, "loading", {
        get: function () {
            return this._loading;
        },
        set: function (value) {
            this._loading = value;
            this.cd.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    LoadingIndicatorDirective.prototype.ngOnInit = function () {
        var _this = this;
        var loadingNotifications = this.loadingService
            .changes
            .pipe(filter(function (index) { return index === _this.index; }));
        this.subscription = this.expandService
            .changes
            .pipe(filter(function (_a) {
            var index = _a.index;
            return index === _this.index;
        }), tap(function (_a) {
            var expand = _a.expand;
            if (!expand && _this.loading) {
                _this.loading = false;
            }
        }), filter(function (_a) {
            var expand = _a.expand;
            return expand;
        }), switchMap(function (x) { return of(x).pipe(delay(100), takeUntil(loadingNotifications)); }))
            .subscribe(function () { return _this.loading = true; });
        this.subscription.add(loadingNotifications.subscribe(function () { return _this.loading = false; }));
    };
    LoadingIndicatorDirective.prototype.ngOnDestroy = function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    LoadingIndicatorDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewLoading]' },] },
    ];
    /** @nocollapse */
    LoadingIndicatorDirective.ctorParameters = function () { return [
        { type: ExpandStateService },
        { type: LoadingNotificationService },
        { type: ChangeDetectorRef }
    ]; };
    LoadingIndicatorDirective.propDecorators = {
        loading: [{ type: HostBinding, args: ["class.k-i-loading",] }],
        index: [{ type: Input, args: ["kendoTreeViewLoading",] }]
    };
    return LoadingIndicatorDirective;
}());

/**
 * @hidden
 * Performs the right-to-left function composition. Functions must have a unary.
 */
var compose = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (data) { return args.reduceRight(function (acc, curr) { return curr(acc); }, data); };
};

/**
 * @hidden
 */
var FlatEditingService = /** @class */ (function () {
    function FlatEditingService(flatBinding) {
        this.flatBinding = flatBinding;
    }
    FlatEditingService.prototype.add = function (_a) {
        var sourceItem = _a.sourceItem, destinationItem = _a.destinationItem, dropPosition = _a.dropPosition, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        var clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            var destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));
            setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);
            var lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem));
            // insert after the last visible child
            var targetIndex = lastChildNodeIndex + 1;
            this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
        }
        else {
            var shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            var targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;
            this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
            var destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));
            setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId);
        }
        if (sourceTree !== destinationTree) {
            this.addChildNodes(clonedSourceDataItem, sourceTree);
        }
        this.rebindData();
        // increment the parent page size => an item is moved into it
        var updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
        incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    };
    FlatEditingService.prototype.remove = function (_a) {
        var sourceItem = _a.sourceItem, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        var sourceDataItem = getDataItem(sourceItem);
        var sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
        this.flatBinding.originalData.splice(sourceItemIndex, 1);
        if (sourceTree !== destinationTree) {
            this.removeChildNodes(sourceDataItem, sourceTree);
        }
        this.rebindData();
        // emit collapse for the parent node if its last child node was spliced
        var parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
        collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    };
    FlatEditingService.prototype.addChildNodes = function (dataItem, source) {
        var _a;
        var itemChildren = this.fetchAllDescendantNodes(dataItem, source);
        (_a = this.flatBinding.originalData).push.apply(_a, itemChildren);
    };
    FlatEditingService.prototype.removeChildNodes = function (dataItem, source) {
        var _this = this;
        var sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
        sourceChildren.forEach(function (item) {
            var index = _this.flatBinding.originalData.indexOf(item);
            _this.flatBinding.originalData.splice(index, 1);
        });
    };
    FlatEditingService.prototype.fetchAllDescendantNodes = function (node, treeview) {
        var _this = this;
        var nodes = this.fetchChildNodes(node, treeview);
        nodes.forEach(function (node) { return nodes = nodes.concat(_this.fetchAllDescendantNodes(node, treeview) || []); });
        return nodes;
    };
    FlatEditingService.prototype.fetchChildNodes = function (node, treeview) {
        if (!node) {
            return [];
        }
        var nodes = [];
        treeview
            .children(node)
            .pipe(take(1))
            .subscribe(function (children) { return nodes = nodes.concat(children || []); });
        return nodes;
    };
    FlatEditingService.prototype.getLastVisibleChildNodeIndex = function (treeview, data, node) {
        if (!isPresent(treeview.loadMoreService) || !treeview.hasChildren(node)) {
            return data.length;
        }
        var visibleNodesCount = treeview.loadMoreService.getGroupSize(node);
        var visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);
        var lastNode = visibleChildren[visibleChildren.length - 1];
        var lastNodeIndex = data.indexOf(lastNode);
        return lastNodeIndex;
    };
    FlatEditingService.prototype.rebindData = function () {
        this.flatBinding.nodes = this.flatBinding.originalData;
    };
    return FlatEditingService;
}());

var findChildren = function (prop, nodes, value) { return nodes.filter(function (x) { return prop(x) === value; }); };
/**
 * A directive which encapsulates the retrieval of the child nodes.
 */
var FlatDataBindingDirective = /** @class */ (function () {
    function FlatDataBindingDirective(treeView) {
        this.treeView = treeView;
        /**
         * @hidden
         */
        this.originalData = [];
    }
    Object.defineProperty(FlatDataBindingDirective.prototype, "nodes", {
        /**
         * The nodes which will be displayed by the TreeView.
         */
        set: function (values) {
            this.originalData = values || [];
            if (!isNullOrEmptyString(this.parentIdField)) {
                var prop = getter(this.parentIdField);
                this.treeView.nodes = (this.originalData).filter(compose(isBlank, prop));
            }
            else {
                this.treeView.nodes = this.originalData.slice(0);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    FlatDataBindingDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (isPresent(this.parentIdField) && isPresent(this.idField)) {
            var fetchChildren_1 = function (node) {
                return findChildren(getter(_this.parentIdField), _this.originalData || [], getter(_this.idField)(node));
            };
            this.treeView.hasChildren = function (node) { return fetchChildren_1(node).length > 0; };
            this.treeView.children = function (node) { return of(fetchChildren_1(node)); };
            this.treeView.editService = new FlatEditingService(this);
        }
    };
    /**
     * @hidden
     */
    FlatDataBindingDirective.prototype.ngOnChanges = function (changes) {
        if (isChanged("parentIdField", changes, false)) {
            this.nodes = this.originalData;
        }
    };
    FlatDataBindingDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewFlatDataBinding]' },] },
    ];
    /** @nocollapse */
    FlatDataBindingDirective.ctorParameters = function () { return [
        { type: TreeViewComponent }
    ]; };
    FlatDataBindingDirective.propDecorators = {
        nodes: [{ type: Input }],
        parentIdField: [{ type: Input }],
        idField: [{ type: Input }]
    };
    return FlatDataBindingDirective;
}());

var buildItem = function (index, dataItem) { return ({ dataItem: dataItem, index: index }); };
var id = 0;
var TREE_ITEM_ROLE = 'treeitem';
var BUTTON_ROLE = 'button';
/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
var TreeViewItemDirective = /** @class */ (function () {
    function TreeViewItemDirective(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {
        this.element = element;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.lookupService = lookupService;
        this.renderer = renderer;
        this.ib = ib;
        this.role = TREE_ITEM_ROLE;
        this.isDisabled = false;
        this.ariaChecked = 'false';
        this.id = id++;
        this.isInitialized = false;
        this.subscriptions = [];
        this.subscribe();
    }
    Object.defineProperty(TreeViewItemDirective.prototype, "isChecked", {
        set: function (checked) {
            if (checked === 'checked') {
                this.ariaChecked = 'true';
            }
            else if (checked === 'indeterminate') {
                this.ariaChecked = 'mixed';
            }
            else {
                this.ariaChecked = 'false';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "isExpanded", {
        get: function () {
            return this._isExpanded || false;
        },
        set: function (isExpanded) {
            this._isExpanded = isExpanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "isSelected", {
        get: function () {
            return this._isSelected || false;
        },
        set: function (isSelected) {
            this._isSelected = isSelected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "isButton", {
        get: function () {
            return this.role === BUTTON_ROLE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "treeItem", {
        get: function () {
            return buildItem(this.index, this.dataItem);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeViewItemDirective.prototype, "parentTreeItem", {
        get: function () {
            return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;
        },
        enumerable: true,
        configurable: true
    });
    TreeViewItemDirective.prototype.ngOnInit = function () {
        this.lookupService.registerItem(this.treeItem, this.parentTreeItem);
        this.registerNavigationItem();
        this.isInitialized = true;
        this.setAttribute('role', this.role);
        this.setAriaAttributes();
        this.setDisabledClass();
        this.updateTabIndex();
    };
    TreeViewItemDirective.prototype.ngOnChanges = function (changes) {
        var index = changes.index, isDisabled = changes.isDisabled;
        if (anyChanged(['index', 'checkable', 'isChecked', 'expandable', 'isExpanded', 'selectable', 'isSelected'], changes)) {
            this.setAriaAttributes();
        }
        if (isDisabled) {
            this.setDisabledClass();
        }
        this.moveLookupItem(changes);
        this.moveNavigationItem(index);
        this.disableNavigationItem(isDisabled);
    };
    TreeViewItemDirective.prototype.ngOnDestroy = function () {
        this.navigationService.unregisterItem(this.id, this.index);
        this.lookupService.unregisterItem(this.index, this.dataItem);
        this.subscriptions = this.subscriptions.reduce(function (list, callback) { return (callback.unsubscribe(), list); }, []);
    };
    TreeViewItemDirective.prototype.subscribe = function () {
        var _this = this;
        this.subscriptions = [
            this.navigationService.moves
                .subscribe(function () {
                _this.updateTabIndex();
                _this.focusItem();
            }),
            this.navigationService.expands
                .pipe(filter(function (_a) {
                var index = _a.index;
                return index === _this.index && !_this.isDisabled;
            }))
                .subscribe(function (_a) {
                var expand = _a.expand;
                return _this.expand(expand);
            })
        ];
    };
    TreeViewItemDirective.prototype.registerNavigationItem = function () {
        this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton);
        this.activateItem();
    };
    TreeViewItemDirective.prototype.activateItem = function () {
        if (this.isDisabled) {
            return;
        }
        var navigationService = this.navigationService;
        var selectionService = this.selectionService;
        var index = this.index;
        selectionService.setFirstSelected(index, this.isSelected);
        if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {
            navigationService.activateIndex(index);
        }
    };
    TreeViewItemDirective.prototype.expand = function (shouldExpand) {
        this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);
    };
    TreeViewItemDirective.prototype.isFocusable = function () {
        return !this.isDisabled && this.navigationService.isFocusable(this.index);
    };
    TreeViewItemDirective.prototype.focusItem = function () {
        if (this.isInitialized && this.navigationService.isActive(this.index)) {
            this.element.nativeElement.focus();
        }
    };
    TreeViewItemDirective.prototype.moveLookupItem = function (changes) {
        if (changes === void 0) { changes = {}; }
        var dataItem = changes.dataItem, index = changes.index, parentDataItem = changes.parentDataItem, parentIndex = changes.parentIndex;
        if ((index && index.firstChange) || //skip first change
            (!dataItem && !index && !parentDataItem && !parentIndex)) {
            return;
        }
        var oldIndex = (index || {}).previousValue || this.index;
        this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);
    };
    TreeViewItemDirective.prototype.moveNavigationItem = function (indexChange) {
        if (indexChange === void 0) { indexChange = {}; }
        var currentValue = indexChange.currentValue, firstChange = indexChange.firstChange, previousValue = indexChange.previousValue;
        if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {
            this.navigationService.unregisterItem(this.id, previousValue);
            this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);
        }
    };
    TreeViewItemDirective.prototype.disableNavigationItem = function (disableChange) {
        if (!disableChange || disableChange.firstChange) {
            return;
        }
        var service = this.navigationService;
        if (this.isDisabled) {
            service.activateClosest(this.index); //activate before unregister the item
        }
        else {
            service.activateFocusable();
        }
        service.unregisterItem(this.id, this.index);
        service.registerItem(this.id, this.index, this.isDisabled, this.isButton);
    };
    TreeViewItemDirective.prototype.setAriaAttributes = function () {
        this.setAttribute('aria-level', this.ib.level(this.index).toString());
        // don't render attributes when the component configuration doesn't allow the specified state
        this.setAttribute('aria-expanded', this.expandable ? this.isExpanded.toString() : null);
        this.setAttribute('aria-selected', this.selectable ? this.isSelected.toString() : null);
        this.setAttribute('aria-checked', this.checkable ? this.ariaChecked : null);
    };
    TreeViewItemDirective.prototype.setDisabledClass = function () {
        this.setClass('k-state-disabled', this.isDisabled);
    };
    TreeViewItemDirective.prototype.setClass = function (className, toggle) {
        var action = toggle ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    };
    TreeViewItemDirective.prototype.updateTabIndex = function () {
        this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');
    };
    TreeViewItemDirective.prototype.setAttribute = function (attr, value) {
        if (!isPresent(value)) {
            this.renderer.removeAttribute(this.element.nativeElement, attr);
            return;
        }
        this.renderer.setAttribute(this.element.nativeElement, attr, value);
    };
    TreeViewItemDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewItem]' },] },
    ];
    /** @nocollapse */
    TreeViewItemDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ExpandStateService },
        { type: NavigationService },
        { type: SelectionService },
        { type: TreeViewLookupService },
        { type: Renderer2 },
        { type: IndexBuilderService }
    ]; };
    TreeViewItemDirective.propDecorators = {
        dataItem: [{ type: Input }],
        index: [{ type: Input }],
        parentDataItem: [{ type: Input }],
        parentIndex: [{ type: Input }],
        role: [{ type: Input }],
        checkable: [{ type: Input }],
        selectable: [{ type: Input }],
        expandable: [{ type: Input }],
        isChecked: [{ type: Input }],
        isDisabled: [{ type: Input }],
        isExpanded: [{ type: Input }],
        isSelected: [{ type: Input }]
    };
    return TreeViewItemDirective;
}());

/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
var TreeViewItemContentDirective = /** @class */ (function () {
    function TreeViewItemContentDirective(element, navigationService, selectionService, renderer) {
        var _this = this;
        this.element = element;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.renderer = renderer;
        this.initialSelection = false;
        this.isSelected = isSelected;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.navigationService.moves
            .subscribe(this.updateItem.bind(this)));
        this.subscriptions.add(this.navigationService.selects
            .pipe(filter(function (index) { return index === _this.index; }))
            .subscribe(function (index) {
            return _this.selectionService.select(index, _this.dataItem);
        }));
        this.subscriptions.add(this.selectionService.changes
            .subscribe(function () {
            _this.updateSelection(_this.isSelected(_this.dataItem, _this.index));
        }));
    }
    TreeViewItemContentDirective.prototype.ngOnChanges = function (changes) {
        if (changes.initialSelection) {
            this.updateSelection(this.initialSelection);
        }
    };
    TreeViewItemContentDirective.prototype.ngOnInit = function () {
        this.updateSelection(this.initialSelection);
    };
    TreeViewItemContentDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    TreeViewItemContentDirective.prototype.updateItem = function () {
        this.render(this.navigationService.isActive(this.index), 'k-state-focused');
    };
    TreeViewItemContentDirective.prototype.updateSelection = function (selected) {
        this.render(selected, 'k-state-selected');
    };
    TreeViewItemContentDirective.prototype.render = function (addClass, className) {
        var action = addClass ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    };
    TreeViewItemContentDirective.decorators = [
        { type: Directive, args: [{ selector: '[kendoTreeViewItemContent]' },] },
    ];
    /** @nocollapse */
    TreeViewItemContentDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NavigationService },
        { type: SelectionService },
        { type: Renderer2 }
    ]; };
    TreeViewItemContentDirective.propDecorators = {
        dataItem: [{ type: Input }],
        index: [{ type: Input }],
        initialSelection: [{ type: Input }],
        isSelected: [{ type: Input }]
    };
    return TreeViewItemContentDirective;
}());

/**
 * @hidden
 *
 * Represents the CheckBox component of the Kendo UI TreeView for Angular.
 *
 */
var CheckBoxComponent = /** @class */ (function () {
    function CheckBoxComponent(element, renderer, changeDetector) {
        this.element = element;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        /**
         * Specifies the [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) of the component.
         */
        this.id = "_" + guid();
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires when the user changes the check state of the component.
         */
        this.checkStateChange = new EventEmitter();
        this.checkState = 'none';
    }
    Object.defineProperty(CheckBoxComponent.prototype, "classWrapper", {
        //XXX: implement ComponentValueAccessor
        //XXX: focus/blur methods
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckBoxComponent.prototype, "indeterminate", {
        get: function () {
            return this.checkState === 'indeterminate';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckBoxComponent.prototype, "checked", {
        get: function () {
            return this.checkState === 'checked';
        },
        enumerable: true,
        configurable: true
    });
    CheckBoxComponent.prototype.ngOnInit = function () {
        this.renderer.removeAttribute(this.element.nativeElement, "tabindex");
    };
    CheckBoxComponent.prototype.ngDoCheck = function () {
        this.checkState = this.isChecked(this.node, this.index);
    };
    CheckBoxComponent.prototype.handleChange = function (e) {
        var state = e.target.checked ? 'checked' : 'none';
        // update the View State so that Angular updates the input if the isChecked value is the same
        this.checkState = state;
        this.changeDetector.detectChanges();
        this.checkStateChange.emit(state);
    };
    CheckBoxComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-checkbox',
                    template: "\n        <input\n            class=\"k-checkbox\"\n            type=\"checkbox\"\n            [id]=\"id\"\n            [checked]=\"checked\"\n            [indeterminate]=\"indeterminate\"\n            [tabindex]=\"tabindex\"\n            (change)=\"handleChange($event)\"\n        />\n        <label\n            class=\"k-checkbox-label\"\n            tabindex=\"-1\"\n            [for]=\"id\"\n        >{{labelText}}</label>\n    "
                },] },
    ];
    /** @nocollapse */
    CheckBoxComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ChangeDetectorRef }
    ]; };
    CheckBoxComponent.propDecorators = {
        classWrapper: [{ type: HostBinding, args: ['class.k-checkbox-wrapper',] }],
        id: [{ type: Input }],
        isChecked: [{ type: Input }],
        node: [{ type: Input }],
        index: [{ type: Input }],
        labelText: [{ type: Input }],
        tabindex: [{ type: Input }],
        checkStateChange: [{ type: Output }]
    };
    return CheckBoxComponent;
}());

var COMPONENT_DIRECTIVES = [
    CheckBoxComponent
];
/**
 * @hidden
 *
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the CheckBox component.
 */
var CheckBoxModule = /** @class */ (function () {
    function CheckBoxModule() {
    }
    CheckBoxModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [COMPONENT_DIRECTIVES],
                    exports: [COMPONENT_DIRECTIVES]
                },] },
    ];
    return CheckBoxModule;
}());

/**
 * @hidden
 */
var DragClueComponent = /** @class */ (function () {
    function DragClueComponent(cdr) {
        this.cdr = cdr;
        this.hostClasses = true;
        this.posistionStyle = 'fixed';
    }
    Object.defineProperty(DragClueComponent.prototype, "statusIconClass", {
        get: function () {
            switch (this.action) {
                case DropAction.Add: return 'k-i-plus';
                case DropAction.InsertTop: return 'k-i-insert-up';
                case DropAction.InsertBottom: return 'k-i-insert-down';
                case DropAction.InsertMiddle: return 'k-i-insert-middle';
                case DropAction.Invalid:
                default: return 'k-i-cancel';
            }
        },
        enumerable: true,
        configurable: true
    });
    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
    DragClueComponent.prototype.detectChanges = function () {
        this.cdr.detectChanges();
    };
    DragClueComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-treeview-drag-clue',
                    template: "\n        <ng-container *ngIf=\"!template\">\n            <span class=\"k-icon {{statusIconClass}} k-drag-status\"></span>\n            <span>{{text}}</span>\n        </ng-container>\n\n        <ng-template\n            *ngIf=\"template\"\n            [ngTemplateOutlet]=\"template\"\n            [ngTemplateOutletContext]=\"{\n                text: text,\n                action: action,\n                sourceItem: sourceItem,\n                destinationItem: destinationItem\n            }\"\n        >\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    DragClueComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    DragClueComponent.propDecorators = {
        hostClasses: [{ type: HostBinding, args: ['class.k-header',] }, { type: HostBinding, args: ['class.k-drag-clue',] }],
        posistionStyle: [{ type: HostBinding, args: ['style.position',] }]
    };
    return DragClueComponent;
}());

/**
 * @hidden
 */
var DragAndDropAssetService = /** @class */ (function () {
    function DragAndDropAssetService() {
    }
    Object.defineProperty(DragAndDropAssetService.prototype, "componentRef", {
        get: function () {
            if (!isPresent(this._componentRef)) {
                throw new Error('The `initalize` method must be called before calling other service methods.');
            }
            return this._componentRef;
        },
        set: function (componentRef) {
            this._componentRef = componentRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragAndDropAssetService.prototype, "element", {
        get: function () {
            return this.componentRef.location.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    DragAndDropAssetService.prototype.ngOnDestroy = function () {
        if (!isPresent(this._componentRef)) {
            return;
        }
        this.element.parentElement.removeChild(this.element);
        this.componentRef.destroy();
        this.componentRef = null;
    };
    DragAndDropAssetService.prototype.show = function () {
        this.element.style.display = '';
    };
    DragAndDropAssetService.prototype.hide = function () {
        this.element.style.display = 'none';
    };
    DragAndDropAssetService.prototype.move = function (left, top, offset) {
        if (offset === void 0) { offset = 0; }
        this.element.style.left = left + offset + "px";
        this.element.style.top = top + offset + "px";
    };
    return DragAndDropAssetService;
}());

/**
 * @hidden
 */
var CLUE_OFFSET = 10;
/**
 * @hidden
 */
var RETURN_ANIMATION_DURATION = 200;
/**
 * @hidden
 */
var DragClueService = /** @class */ (function (_super) {
    __extends(DragClueService, _super);
    function DragClueService(componentFactoryResolver) {
        var _this = _super.call(this) || this;
        _this.componentFactoryResolver = componentFactoryResolver;
        return _this;
    }
    DragClueService.prototype.initialize = function (container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        var clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);
        this.componentRef = container.createComponent(clueComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    };
    DragClueService.prototype.ngOnDestroy = function () {
        this.cancelReturnAnimation();
        _super.prototype.ngOnDestroy.call(this);
    };
    DragClueService.prototype.move = function (left, top) {
        _super.prototype.move.call(this, left, top, CLUE_OFFSET);
    };
    DragClueService.prototype.animateDragClueToElementPosition = function (target) {
        var _this = this;
        if (!(isPresent(target) && isPresent(this.element.animate))) {
            this.hide();
            return;
        }
        var targetElementViewPortCoords = target.getBoundingClientRect();
        var clueElementViewPortCoords = this.element.getBoundingClientRect();
        this.returnAnimation = this.element.animate([
            { transform: 'translate(0, 0)' },
            { transform: "translate(" + (targetElementViewPortCoords.left - clueElementViewPortCoords.left) + "px, " + (targetElementViewPortCoords.top - clueElementViewPortCoords.top) + "px)" }
        ], RETURN_ANIMATION_DURATION);
        this.returnAnimation.onfinish = function () { return _this.hide(); };
    };
    DragClueService.prototype.cancelReturnAnimation = function () {
        if (!isPresent(this.returnAnimation)) {
            return;
        }
        this.returnAnimation.cancel();
        this.returnAnimation = null;
    };
    DragClueService.prototype.updateDragClueData = function (action, sourceItem, destinationItem) {
        var dragClue = this.componentRef.instance;
        if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
            return;
        }
        dragClue.action = action;
        dragClue.sourceItem = sourceItem;
        dragClue.destinationItem = destinationItem;
        dragClue.detectChanges();
    };
    DragClueService.prototype.updateText = function (text) {
        if (text === this.componentRef.instance.text) {
            return;
        }
        this.componentRef.instance.text = text;
        this.componentRef.instance.detectChanges();
    };
    DragClueService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DragClueService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver }
    ]; };
    return DragClueService;
}(DragAndDropAssetService));

/**
 * @hidden
 */
var DropHintComponent = /** @class */ (function () {
    function DropHintComponent() {
        this.hostClass = true;
        this.position = 'fixed';
        this.pointerEvents = 'none';
    }
    DropHintComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-treeview-drop-hint',
                    template: "\n        <div\n            *ngIf=\"!template\"\n            class=\"k-drop-hint k-drop-hint-h\"\n        >\n            <div class='k-drop-hint-start'></div>\n            <div class='k-drop-hint-line'></div>\n        </div>\n\n        <ng-template\n            *ngIf=\"template\"\n            [ngTemplateOutlet]=\"template\"\n        >\n        <ng-template>\n    "
                },] },
    ];
    DropHintComponent.propDecorators = {
        hostClass: [{ type: HostBinding, args: ['class.k-drop-hint-container',] }],
        position: [{ type: HostBinding, args: ['style.position',] }],
        pointerEvents: [{ type: HostBinding, args: ['style.pointer-events',] }]
    };
    return DropHintComponent;
}());

/**
 * @hidden
 */
var DropHintService = /** @class */ (function (_super) {
    __extends(DropHintService, _super);
    function DropHintService(componentFactoryResolver) {
        var _this = _super.call(this) || this;
        _this.componentFactoryResolver = componentFactoryResolver;
        return _this;
    }
    DropHintService.prototype.initialize = function (container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        var hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);
        this.componentRef = container.createComponent(hintComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    };
    DropHintService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DropHintService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver }
    ]; };
    return DropHintService;
}(DragAndDropAssetService));

/**
 * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 *
 *
 * The text, attempted drop action, source item and destination item are available as context variables in the template:
 *
 *
 * - `let-text="text"` (`string`)
 * - `let-action="action"` ([`DropAction`]({% slug api_treeview_dropaction %}))
 * - `let-sourceItem="sourceItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 * - `let-destinationItem="destinationItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 */
var DragClueTemplateDirective = /** @class */ (function () {
    function DragClueTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DragClueTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewDragClueTemplate]'
                },] },
    ];
    /** @nocollapse */
    DragClueTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return DragClueTemplateDirective;
}());

/**
 * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 */
var DropHintTemplateDirective = /** @class */ (function () {
    function DropHintTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DropHintTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewDropHintTemplate]'
                },] },
    ];
    /** @nocollapse */
    DropHintTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return DropHintTemplateDirective;
}());

/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances
 * ([see example]({% slug draganddrop_treeview %})).
 *
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
var DragAndDropDirective = /** @class */ (function () {
    function DragAndDropDirective(element, zone, treeview, dragClueService, dropHintService) {
        this.element = element;
        this.zone = zone;
        this.treeview = treeview;
        this.dragClueService = dragClueService;
        this.dropHintService = dropHintService;
        /**
         * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
         * If enabled, the `removeItem` event will not be fired on the source TreeView
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         *
         * @default false
         */
        this.allowCopy = false;
        /**
         * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         */
        this.dropZoneTreeViews = [];
        /**
         * @hidden
         */
        this.userSelectStyle = 'none';
        /**
         * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
         * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
         */
        this.containerOffset = { top: 0, left: 0 };
        this.treeview.touchActions = false;
    }
    DragAndDropDirective.prototype.ngAfterContentInit = function () {
        this.initalizeDraggable();
        this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
        this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
    };
    DragAndDropDirective.prototype.ngOnDestroy = function () {
        this.draggable.destroy();
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handlePress = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent;
        if (!isContent(originalEvent.target)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDragStart)) {
            var dragStartEvent = this.zone.run(function () { return _this.notifyDragStart(originalEvent, dropTarget); });
            if (dragStartEvent.isDefaultPrevented()) {
                return;
            }
        }
        // store the drag target on press, show it only when it's actually dragged
        this.draggedItem = closestWithMatch(originalEvent.target, '.k-in');
        this.dragClueService.cancelReturnAnimation();
        this.dragClueService.updateText(this.draggedItem.innerText);
        this.containerOffset = getContainerOffset(this.draggedItem);
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleDrag = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientX = _a.clientX, clientY = _a.clientY;
        if (!isPresent(this.draggedItem)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDrag)) {
            this.zone.run(function () { return _this.notifyDrag(originalEvent, dropTarget); });
        }
        var targetTreeView = this.getTargetTreeView(dropTarget);
        var dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
        var dropHintAnchor = closestWithMatch(dropTarget, '.k-mid');
        this.updateDropHintState(dropPosition, dropHintAnchor);
        var dropAction = getDropAction(dropPosition, dropTarget);
        var sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
        var destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
        this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
    };
    /**
     * @hidden
     */
    DragAndDropDirective.prototype.handleRelease = function (_a) {
        var _this = this;
        var originalEvent = _a.originalEvent, clientY = _a.clientY;
        if (!isPresent(this.draggedItem)) {
            return;
        }
        var dropTarget = getDropTarget(originalEvent);
        var sourceTree = this.treeview;
        var destinationTree = this.getTargetTreeView(dropTarget);
        var dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
        var sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
        var destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
        if (isPresent(destinationItem) && isPresent(dropPosition)) {
            this.zone.run(function () { return _this.notifyDrop({ sourceItem: sourceItem, destinationItem: destinationItem, dropPosition: dropPosition, sourceTree: sourceTree, destinationTree: destinationTree }, originalEvent); });
        }
        else {
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
        if (hasObservers(this.treeview.nodeDragEnd)) {
            this.zone.run(function () { return _this.notifyDragEnd({ sourceItem: sourceItem, destinationItem: destinationItem, originalEvent: originalEvent }); });
        }
        this.dropHintService.hide();
        this.draggedItem = null;
    };
    DragAndDropDirective.prototype.updateDropHintState = function (dropPosition, dropHintAnchor) {
        if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {
            this.dropHintService.hide();
            return;
        }
        var anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
        var insertBefore = dropPosition === DropPosition.Before;
        var top = insertBefore ? anchorViewPortCoords.top : (anchorViewPortCoords.top + anchorViewPortCoords.height);
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
        this.dropHintService.show();
    };
    DragAndDropDirective.prototype.updateDragClueState = function (dropAction, clientX, clientY, sourceItem, destinationItem) {
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
        this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
        this.dragClueService.show();
    };
    DragAndDropDirective.prototype.initalizeDraggable = function () {
        var _this = this;
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(function () { return _this.draggable.bindTo(_this.element.nativeElement); });
    };
    DragAndDropDirective.prototype.notifyDragStart = function (originalEvent, dropTarget) {
        var sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
        var event = new TreeItemDragStartEvent({ sourceItem: sourceItem, originalEvent: originalEvent });
        this.treeview.nodeDragStart.emit(event);
        return event;
    };
    DragAndDropDirective.prototype.notifyDrag = function (originalEvent, dropTarget) {
        var dragEvent = {
            sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
            destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
            originalEvent: originalEvent
        };
        this.treeview.nodeDrag.emit(dragEvent);
    };
    DragAndDropDirective.prototype.notifyDrop = function (args, originalEvent) {
        var event = new TreeItemDropEvent(args, originalEvent);
        args.destinationTree.nodeDrop.emit(event);
        // disable the animations on drop and restore them afterwards (if they were initially turned on)
        this.disableAnimationsForNextTick(args.destinationTree);
        if (args.sourceTree !== args.destinationTree) {
            this.disableAnimationsForNextTick(args.sourceTree);
        }
        if (!event.isDefaultPrevented() && event.isValid) {
            this.dragClueService.hide();
            // order matters in a flat data binding scenario (first add, then remove)
            args.destinationTree.addItem.emit(args);
            if (!(originalEvent.ctrlKey && this.allowCopy)) {
                args.sourceTree.removeItem.emit(args);
            }
        }
        else if (event.isDefaultPrevented()) {
            // directly hide the clue if the default is prevented
            this.dragClueService.hide();
        }
        else if (!event.isValid) {
            // animate the clue back to the source item position if marked as invalid
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
    };
    DragAndDropDirective.prototype.notifyDragEnd = function (dragEndEvent) {
        this.treeview.nodeDragEnd.emit(dragEndEvent);
    };
    DragAndDropDirective.prototype.getTargetTreeView = function (dropTarget) {
        var treeViewTagName = this.treeview.element.nativeElement.tagName;
        var targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
        return [this.treeview].concat(this.dropZoneTreeViews).find(function (treeView) {
            return isPresent(treeView) && treeView.element.nativeElement === targetTreeView;
        });
    };
    DragAndDropDirective.prototype.disableAnimationsForNextTick = function (treeView) {
        // the treeView.animate getter returns `true` when the animations are turned off
        // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)
        if (treeView.animate) {
            return;
        }
        treeView.animate = false;
        this.zone.runOutsideAngular(function () {
            return setTimeout(function () { return treeView.animate = true; });
        });
    };
    DragAndDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewDragAndDrop]',
                    providers: [
                        DragClueService,
                        DropHintService
                    ]
                },] },
    ];
    /** @nocollapse */
    DragAndDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: TreeViewComponent },
        { type: DragClueService },
        { type: DropHintService }
    ]; };
    DragAndDropDirective.propDecorators = {
        allowCopy: [{ type: Input }],
        dropZoneTreeViews: [{ type: Input }],
        dragClueTemplate: [{ type: ContentChild, args: [DragClueTemplateDirective,] }],
        dropHintTemplate: [{ type: ContentChild, args: [DropHintTemplateDirective,] }],
        userSelectStyle: [{ type: HostBinding, args: ['style.user-select',] }, { type: HostBinding, args: ['style.-ms-user-select',] }]
    };
    return DragAndDropDirective;
}());

/**
 * A directive which enables the update of the initially provided data array during drag-and-drop.
 *
 * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})
 * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide
 * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * handlers when the corresponding events are triggered by the TreeView component.
 */
var DragAndDropEditingDirective = /** @class */ (function () {
    function DragAndDropEditingDirective(treeview) {
        this.treeview = treeview;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));
        this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));
    }
    Object.defineProperty(DragAndDropEditingDirective.prototype, "editService", {
        /**
         * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)
         * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.
         */
        set: function (service) {
            this.treeview.editService = service;
        },
        enumerable: true,
        configurable: true
    });
    DragAndDropEditingDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    DragAndDropEditingDirective.prototype.handleAdd = function (args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.add(args);
    };
    DragAndDropEditingDirective.prototype.handleRemove = function (args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.remove(args);
    };
    DragAndDropEditingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewDragAndDropEditing]'
                },] },
    ];
    /** @nocollapse */
    DragAndDropEditingDirective.ctorParameters = function () { return [
        { type: TreeViewComponent }
    ]; };
    DragAndDropEditingDirective.propDecorators = {
        editService: [{ type: Input }]
    };
    return DragAndDropEditingDirective;
}());

var LOAD_MORE_DOC_LINK$1 = 'http://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/';
/**
 * A directive that enables the display of only a limited amount of nodes per level
 * ([see example]({% slug loadmorebutton_treeview %})).
 */
var LoadMoreDirective = /** @class */ (function () {
    function LoadMoreDirective(treeview) {
        this.treeview = treeview;
        /**
         * Keeps track of the current page size of each node over expand/collapse cycles.
         */
        this.pageSizes = new Map();
        /**
         * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.
         */
        this.rootLevelId = guid();
        this.treeview.loadMoreService = {
            getInitialPageSize: this.getInitalPageSize.bind(this),
            getGroupSize: this.getGroupSize.bind(this),
            setGroupSize: this.setGroupSize.bind(this),
            getTotalNodesCount: this.getTotalNodesCount.bind(this)
        };
    }
    Object.defineProperty(LoadMoreDirective.prototype, "loadMoreNodes", {
        /**
         * Specifies the callback that will be called when the load more button is clicked.
         * Providing a function is only required when additional nodes are fetched on demand
         * ([see example]({% slug loadmorebutton_treeview %}#toc-remote-data)).
         */
        set: function (loadMoreNodes) {
            if (typeof loadMoreNodes === 'string') {
                return;
            }
            this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;
        },
        enumerable: true,
        configurable: true
    });
    LoadMoreDirective.prototype.ngOnChanges = function () {
        this.verifySettings();
    };
    LoadMoreDirective.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (!isPresent(this.pageSize)) {
            throw new Error("To use the TreeView `kendoTreeViewLoadMore` directive, you need to assign a `pageSize` value. See " + LOAD_MORE_DOC_LINK$1 + ".");
        }
        var loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;
        if (isPresent(loadMoreNodes) && typeof loadMoreNodes !== 'function') {
            throw new Error("The passed value to the `kendoTreeViewLoadMore` directive must be a function that retrieves additional nodes. See " + LOAD_MORE_DOC_LINK$1 + ".");
        }
        if (isPresent(loadMoreNodes) && !isPresent(this.totalField)) {
            throw new Error("When a function to fetch additional nodes is provided to the `kendoTreeViewLoadMore` directive, the `totalField` and `totalRootNodes` values must also be provided. See " + LOAD_MORE_DOC_LINK$1 + ".");
        }
    };
    LoadMoreDirective.prototype.getGroupSize = function (dataItem) {
        var itemKey = dataItem || this.rootLevelId;
        return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;
    };
    LoadMoreDirective.prototype.setGroupSize = function (dataItem, pageSize) {
        var itemKey = dataItem || this.rootLevelId;
        var normalizedSizeValue = pageSize > 0 ? pageSize : 0;
        this.pageSizes.set(itemKey, normalizedSizeValue);
    };
    LoadMoreDirective.prototype.getTotalNodesCount = function (dataItem, loadedNodesCount) {
        if (isPresent(dataItem) && isPresent(this.totalField)) {
            return dataItem[this.totalField];
        }
        else if (!isPresent(dataItem) && isPresent(this.totalRootNodes)) {
            return this.totalRootNodes;
        }
        else {
            return loadedNodesCount;
        }
    };
    LoadMoreDirective.prototype.getInitalPageSize = function () {
        return this.pageSize;
    };
    LoadMoreDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeViewLoadMore]'
                },] },
    ];
    /** @nocollapse */
    LoadMoreDirective.ctorParameters = function () { return [
        { type: TreeViewComponent }
    ]; };
    LoadMoreDirective.propDecorators = {
        loadMoreNodes: [{ type: Input, args: ['kendoTreeViewLoadMore',] }],
        pageSize: [{ type: Input }],
        totalRootNodes: [{ type: Input }],
        totalField: [{ type: Input }]
    };
    return LoadMoreDirective;
}());

var COMPONENT_DIRECTIVES$1 = [
    TreeViewComponent,
    TreeViewGroupComponent,
    TreeViewItemDirective,
    TreeViewItemContentDirective,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    LoadingIndicatorDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DragClueComponent,
    DropHintTemplateDirective,
    DropHintComponent,
    DragAndDropEditingDirective,
    LoadMoreDirective,
    LoadMoreButtonTemplateDirective
];
/**
 * @hidden
 */
var SharedModule = /** @class */ (function () {
    function SharedModule() {
    }
    SharedModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [COMPONENT_DIRECTIVES$1],
                    exports: [COMPONENT_DIRECTIVES$1],
                    imports: [CommonModule, CheckBoxModule],
                    entryComponents: [
                        DragClueComponent,
                        DropHintComponent
                    ]
                },] },
    ];
    return SharedModule;
}());

var EXPORTS = [
    TreeViewComponent,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DropHintTemplateDirective,
    DragAndDropEditingDirective,
    LoadMoreDirective,
    LoadMoreButtonTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the TreeView component.
 */
var TreeViewModule = /** @class */ (function () {
    function TreeViewModule() {
    }
    TreeViewModule.decorators = [
        { type: NgModule, args: [{
                    exports: [EXPORTS],
                    imports: [SharedModule]
                },] },
    ];
    return TreeViewModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { CheckBoxComponent, CheckBoxModule, DataChangeNotificationService, DragClueComponent, DragClueService, DropHintComponent, DropHintService, DragAndDropAssetService, PreventableEvent, ExpandStateService, IndexBuilderService, LoadingIndicatorDirective, LoadingNotificationService, NavigationService, NodeChildrenService, SelectionService, SharedModule, TreeViewGroupComponent, TreeViewItemContentDirective, TreeViewItemDirective, TreeViewLookupService, TreeViewComponent, TreeViewModule, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragAndDropEditingDirective, DropHintTemplateDirective, DragClueTemplateDirective, DropAction, DropPosition, TreeItemDropEvent, TreeItemDragStartEvent, TreeItemDragEvent, LoadMoreDirective, LoadMoreButtonTemplateDirective };
