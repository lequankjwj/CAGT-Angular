/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, HostBinding, ChangeDetectorRef } from '@angular/core';
import { DraggableDirective } from '@progress/kendo-angular-common';
import { SelectionService } from './selection.service';
import { createState } from './selection-state';
var createElement = function () {
    var marquee = document.createElement("div");
    marquee.className = "k-marquee";
    var marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
    return marquee;
};
var ɵ0 = createElement;
var elementUnderCursor = function (_a) {
    var clientX = _a.clientX, clientY = _a.clientY;
    return document.elementFromPoint(clientX, clientY);
};
var ɵ1 = elementUnderCursor;
/**
 * @hidden
 */
var MarqueeDirective = /** @class */ (function () {
    function MarqueeDirective(draggable, selection, changeDetector) {
        this.draggable = draggable;
        this.selection = selection;
        this.changeDetector = changeDetector;
        this.cellSelected = this.cellSelected.bind(this);
        this.rowSelected = this.rowSelected.bind(this);
    }
    Object.defineProperty(MarqueeDirective.prototype, "userSelection", {
        get: function () {
            return this.selection.enableMarquee ? 'none' : null;
        },
        enumerable: true,
        configurable: true
    });
    MarqueeDirective.prototype.ngOnInit = function () {
        // handle esc
        // trigger cancel
        this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));
        this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(this.endSelection.bind(this)));
    };
    MarqueeDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.clean();
    };
    MarqueeDirective.prototype.cellSelected = function (dataItem, column) {
        return this.state.has(dataItem, column);
    };
    MarqueeDirective.prototype.rowSelected = function (dataItem) {
        return this.state.has(dataItem);
    };
    MarqueeDirective.prototype.start = function (args) {
        var pressTarget = this.targetArgs(args, true);
        if (!pressTarget) {
            return;
        }
        this.pressTarget = pressTarget;
        this.pressArgs = args;
    };
    MarqueeDirective.prototype.moveMarquee = function (args) {
        if (this.pressTarget && !this.state) {
            this.initMarquee();
        }
        if (this.marqueeElement) {
            var element = this.marqueeElement;
            var press = this.pressArgs;
            var left = Math.min(args.pageX, press.pageX);
            var top_1 = Math.min(args.pageY, press.pageY);
            var width = Math.abs(args.pageX - press.pageX);
            var height = Math.abs(args.pageY - press.pageY);
            element.style.left = left + "px";
            element.style.top = top_1 + "px";
            element.style.width = width + "px";
            element.style.height = height + "px";
        }
        else if (this.state) {
            var currentTarget = this.targetArgs(args);
            if (currentTarget && (!this.currentTarget || this.currentTarget.item.data !== currentTarget.item.data ||
                (this.selection.settings.mode === 'cell' && this.currentTarget.column !== currentTarget.column))) {
                this.currentTarget = currentTarget;
                this.state.fromArray(this.selection.rangeItems(this.pressTarget, currentTarget).map(function (item) { return ({ itemKey: item.dataItem, columnKey: item.column }); }));
                this.selection.updateSelectedState();
                this.changeDetector.detectChanges();
            }
        }
    };
    MarqueeDirective.prototype.endSelection = function (args) {
        if (!this.state) {
            return;
        }
        if ((this.pressArgs.pageX !== args.pageX || this.pressArgs.pageY !== args.pageY)) {
            var pressTarget = this.pressTarget;
            var releaseTarget = this.targetArgs(args);
            this.clean();
            // if one is missing select first / last viewItem depending on the position
            // select column based on coordinates
            if (pressTarget && releaseTarget) {
                this.selection.selectRange(pressTarget, releaseTarget);
            }
            else {
                this.changeDetector.detectChanges();
            }
        }
        else {
            this.clean();
            this.changeDetector.detectChanges();
        }
    };
    MarqueeDirective.prototype.clean = function () {
        if (this.marqueeElement) {
            document.body.removeChild(this.marqueeElement);
            this.marqueeElement = null;
        }
        if (this.selectionSelected) {
            if (this.selection.settings.mode === 'cell') {
                this.selection.isCellSelected = this.selectionSelected;
            }
            else {
                this.selection.isRowSelected = this.selectionSelected;
            }
            this.selectionSelected = null;
        }
        if (this.state) {
            this.state.clear();
            this.state = null;
        }
        this.pressTarget = null;
        this.pressArgs = null;
    };
    MarqueeDirective.prototype.targetArgs = function (args, skipFocusable) {
        var target = args.originalEvent.target;
        if (this.marqueeElement) {
            this.marqueeElement.style.display = 'none';
            target = elementUnderCursor(args);
            this.marqueeElement.style.display = 'block';
        }
        return this.selection.targetArgs(target, skipFocusable);
    };
    MarqueeDirective.prototype.initMarquee = function () {
        this.state = createState(this.selection.settings);
        if (this.selection.settings.mode === 'cell') {
            this.selectionSelected = this.selection.isCellSelected;
            this.selection.isCellSelected = this.cellSelected;
        }
        else {
            this.selectionSelected = this.selection.isRowSelected;
            this.selection.isRowSelected = this.rowSelected;
        }
        this.changeDetector.detectChanges();
        var drag = this.selection.settings.drag;
        if (!(drag && drag.snap)) {
            this.marqueeElement = createElement();
            document.body.appendChild(this.marqueeElement);
        }
    };
    MarqueeDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTreeListSelectionMarquee]'
                },] },
    ];
    /** @nocollapse */
    MarqueeDirective.ctorParameters = function () { return [
        { type: DraggableDirective },
        { type: SelectionService },
        { type: ChangeDetectorRef }
    ]; };
    MarqueeDirective.propDecorators = {
        userSelection: [{ type: HostBinding, args: ['style.user-select',] }]
    };
    return MarqueeDirective;
}());
export { MarqueeDirective };
export { ɵ0, ɵ1 };
