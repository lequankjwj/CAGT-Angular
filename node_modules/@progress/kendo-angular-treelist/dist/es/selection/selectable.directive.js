/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, Input, Output, EventEmitter } from '@angular/core';
import { TreeListComponent } from '../treelist.component';
import { getter } from '@progress/kendo-common';
import { isString } from '../utils';
import { createState, RowSelectionState } from './selection-state';
var defaultColumnKeyGetter = function (_column, columnIndex) { return columnIndex; };
var ɵ0 = defaultColumnKeyGetter;
/**
 * A directive which controls the selection state
 */
var SelectableDirective = /** @class */ (function () {
    function SelectableDirective(treelist) {
        this.treelist = treelist;
        /**
         * Fires when the selected items are changed.
         */
        this.selectedItemsChange = new EventEmitter();
        this.state = new RowSelectionState();
        this.cellSelected = this.cellSelected.bind(this);
        this.rowSelected = this.rowSelected.bind(this);
        this.selectionChange = this.selectionChange.bind(this);
        this.updateColumnIndices = this.updateColumnIndices.bind(this);
        this.treelist.selectable = this.selectable = true;
    }
    Object.defineProperty(SelectableDirective.prototype, "selectable", {
        /**
         * @hidden
         */
        set: function (value) {
            if (typeof value === 'object') { // add method to normalize this
                this._settings = value;
            }
            else {
                this._settings = {
                    enabled: value
                };
            }
            this.state = createState(this._settings);
            if (this._settings.enabled !== false) {
                this.treelist.isSelected = this._settings.mode === 'cell' ? this.cellSelected : this.rowSelected;
                this.subscribeSelection();
            }
            else {
                this.treelist.isSelected = null;
                this.unsubscribeSelection();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectableDirective.prototype, "selectedItems", {
        /**
         * Specifies the selected items.
         */
        set: function (value) {
            if (!value) {
                this.state.clear();
            }
            else if (value !== this.lastChange) {
                this.state.fromArray(value);
                this.treelist.updateView();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectableDirective.prototype, "itemKey", {
        /**
         * The field name or a function that specify the dataItems key.
         */
        set: function (value) {
            if (isString(value)) {
                this._keyGetter = getter(String(value));
            }
            else {
                this._keyGetter = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectableDirective.prototype, "columnKey", {
        /**
         * The field name or a function that specify the columns key.
         */
        set: function (value) {
            if (isString(value)) {
                this._columnKeyGetter = getter(String(value));
            }
            else if (value) {
                this._columnKeyGetter = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectableDirective.prototype, "keyGetter", {
        get: function () {
            return this._keyGetter || this.treelist.idGetter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectableDirective.prototype, "columnKeyGetter", {
        get: function () {
            return this._columnKeyGetter || defaultColumnKeyGetter;
        },
        enumerable: true,
        configurable: true
    });
    SelectableDirective.prototype.ngOnDestroy = function () {
        this.unsubscribeSelection();
    };
    /**
     * @hidden
     */
    SelectableDirective.prototype.cellSelected = function (dataItem, column, columnIndex) {
        return this.state.has(this.keyGetter(dataItem), this.columnKeyGetter(column, columnIndex));
    };
    /**
     * @hidden
     */
    SelectableDirective.prototype.rowSelected = function (dataItem) {
        return this.state.has(this.keyGetter(dataItem));
    };
    SelectableDirective.prototype.selectionChange = function (_a) {
        var _this = this;
        var action = _a.action, items = _a.items;
        if (action === 'select' || action === 'add') {
            if (action === 'select') {
                this.state.clear();
            }
            items.forEach(function (item) {
                _this.state.add(_this.keyGetter(item.dataItem), _this.columnKeyGetter(item.column, item.columnIndex));
            });
        }
        else {
            items.forEach(function (item) {
                _this.state.remove(_this.keyGetter(item.dataItem), _this.columnKeyGetter(item.column, item.columnIndex));
            });
        }
        this.emitSelectedItemsChange();
    };
    SelectableDirective.prototype.emitSelectedItemsChange = function () {
        this.lastChange = this.state.toArray();
        this.selectedItemsChange.emit(this.lastChange);
    };
    SelectableDirective.prototype.subscribeSelection = function () {
        this.unsubscribeSelection();
        this.subscriptions = this.treelist.selectionChange.subscribe(this.selectionChange);
        if (this._settings.mode === 'cell') {
            this.subscriptions.add(this.treelist.columnOrderChange.subscribe(this.updateColumnIndices));
            this.subscriptions.add(this.treelist.columnLockedChange.subscribe(this.updateColumnIndices));
        }
    };
    SelectableDirective.prototype.unsubscribeSelection = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
            this.subscriptions = null;
        }
    };
    SelectableDirective.prototype.updateColumnIndices = function () {
        if (!this._columnKeyGetter) {
            var changes_1 = new Map();
            var currentIndices_1 = [];
            this.leafColumns.forEach(function (column) {
                currentIndices_1.push(column);
            });
            this.treelist.columnsContainer.refresh();
            var leafColumns_1 = this.leafColumns;
            currentIndices_1.forEach(function (column, index) {
                if (column !== leafColumns_1[index]) {
                    changes_1.set(index, leafColumns_1.indexOf(column));
                }
            });
            if (changes_1.size && this.state.updateColumKeys(changes_1)) {
                this.emitSelectedItemsChange();
            }
        }
    };
    Object.defineProperty(SelectableDirective.prototype, "leafColumns", {
        get: function () {
            return this.treelist.lockedLeafColumns.toArray().concat(this.treelist.nonLockedLeafColumns.toArray());
        },
        enumerable: true,
        configurable: true
    });
    SelectableDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'kendoTreeListSelectable',
                    selector: '[kendoTreeListSelectable]'
                },] },
    ];
    /** @nocollapse */
    SelectableDirective.ctorParameters = function () { return [
        { type: TreeListComponent }
    ]; };
    SelectableDirective.propDecorators = {
        selectable: [{ type: Input }],
        selectedItems: [{ type: Input }],
        selectedItemsChange: [{ type: Output }],
        itemKey: [{ type: Input }],
        columnKey: [{ type: Input }]
    };
    return SelectableDirective;
}());
export { SelectableDirective };
export { ɵ0 };
