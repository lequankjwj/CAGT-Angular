/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, HostBinding, ChangeDetectorRef } from '@angular/core';
import { DraggableDirective } from '@progress/kendo-angular-common';
import { SelectionService } from './selection.service';
import { createState } from './selection-state';
const createElement = () => {
    const marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
    return marquee;
};
const ɵ0 = createElement;
const elementUnderCursor = ({ clientX, clientY }) => document.elementFromPoint(clientX, clientY);
const ɵ1 = elementUnderCursor;
/**
 * @hidden
 */
export class MarqueeDirective {
    constructor(draggable, selection, changeDetector) {
        this.draggable = draggable;
        this.selection = selection;
        this.changeDetector = changeDetector;
        this.cellSelected = this.cellSelected.bind(this);
        this.rowSelected = this.rowSelected.bind(this);
    }
    get userSelection() {
        return this.selection.enableMarquee ? 'none' : null;
    }
    ngOnInit() {
        // handle esc
        // trigger cancel
        this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));
        this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(this.endSelection.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.clean();
    }
    cellSelected(dataItem, column) {
        return this.state.has(dataItem, column);
    }
    rowSelected(dataItem) {
        return this.state.has(dataItem);
    }
    start(args) {
        const pressTarget = this.targetArgs(args, true);
        if (!pressTarget) {
            return;
        }
        this.pressTarget = pressTarget;
        this.pressArgs = args;
    }
    moveMarquee(args) {
        if (this.pressTarget && !this.state) {
            this.initMarquee();
        }
        if (this.marqueeElement) {
            const element = this.marqueeElement;
            const press = this.pressArgs;
            const left = Math.min(args.pageX, press.pageX);
            const top = Math.min(args.pageY, press.pageY);
            const width = Math.abs(args.pageX - press.pageX);
            const height = Math.abs(args.pageY - press.pageY);
            element.style.left = `${left}px`;
            element.style.top = `${top}px`;
            element.style.width = `${width}px`;
            element.style.height = `${height}px`;
        }
        else if (this.state) {
            const currentTarget = this.targetArgs(args);
            if (currentTarget && (!this.currentTarget || this.currentTarget.item.data !== currentTarget.item.data ||
                (this.selection.settings.mode === 'cell' && this.currentTarget.column !== currentTarget.column))) {
                this.currentTarget = currentTarget;
                this.state.fromArray(this.selection.rangeItems(this.pressTarget, currentTarget).map(item => ({ itemKey: item.dataItem, columnKey: item.column })));
                this.selection.updateSelectedState();
                this.changeDetector.detectChanges();
            }
        }
    }
    endSelection(args) {
        if (!this.state) {
            return;
        }
        if ((this.pressArgs.pageX !== args.pageX || this.pressArgs.pageY !== args.pageY)) {
            const pressTarget = this.pressTarget;
            const releaseTarget = this.targetArgs(args);
            this.clean();
            // if one is missing select first / last viewItem depending on the position
            // select column based on coordinates
            if (pressTarget && releaseTarget) {
                this.selection.selectRange(pressTarget, releaseTarget);
            }
            else {
                this.changeDetector.detectChanges();
            }
        }
        else {
            this.clean();
            this.changeDetector.detectChanges();
        }
    }
    clean() {
        if (this.marqueeElement) {
            document.body.removeChild(this.marqueeElement);
            this.marqueeElement = null;
        }
        if (this.selectionSelected) {
            if (this.selection.settings.mode === 'cell') {
                this.selection.isCellSelected = this.selectionSelected;
            }
            else {
                this.selection.isRowSelected = this.selectionSelected;
            }
            this.selectionSelected = null;
        }
        if (this.state) {
            this.state.clear();
            this.state = null;
        }
        this.pressTarget = null;
        this.pressArgs = null;
    }
    targetArgs(args, skipFocusable) {
        let target = args.originalEvent.target;
        if (this.marqueeElement) {
            this.marqueeElement.style.display = 'none';
            target = elementUnderCursor(args);
            this.marqueeElement.style.display = 'block';
        }
        return this.selection.targetArgs(target, skipFocusable);
    }
    initMarquee() {
        this.state = createState(this.selection.settings);
        if (this.selection.settings.mode === 'cell') {
            this.selectionSelected = this.selection.isCellSelected;
            this.selection.isCellSelected = this.cellSelected;
        }
        else {
            this.selectionSelected = this.selection.isRowSelected;
            this.selection.isRowSelected = this.rowSelected;
        }
        this.changeDetector.detectChanges();
        const drag = this.selection.settings.drag;
        if (!(drag && drag.snap)) {
            this.marqueeElement = createElement();
            document.body.appendChild(this.marqueeElement);
        }
    }
}
MarqueeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendoTreeListSelectionMarquee]'
            },] },
];
/** @nocollapse */
MarqueeDirective.ctorParameters = () => [
    { type: DraggableDirective },
    { type: SelectionService },
    { type: ChangeDetectorRef }
];
MarqueeDirective.propDecorators = {
    userSelection: [{ type: HostBinding, args: ['style.user-select',] }]
};
export { ɵ0, ɵ1 };
