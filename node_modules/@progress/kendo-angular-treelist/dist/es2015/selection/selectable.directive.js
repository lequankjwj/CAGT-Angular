/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, Input, Output, EventEmitter } from '@angular/core';
import { TreeListComponent } from '../treelist.component';
import { getter } from '@progress/kendo-common';
import { isString } from '../utils';
import { createState, RowSelectionState } from './selection-state';
const defaultColumnKeyGetter = (_column, columnIndex) => columnIndex;
const ɵ0 = defaultColumnKeyGetter;
/**
 * A directive which controls the selection state
 */
export class SelectableDirective {
    constructor(treelist) {
        this.treelist = treelist;
        /**
         * Fires when the selected items are changed.
         */
        this.selectedItemsChange = new EventEmitter();
        this.state = new RowSelectionState();
        this.cellSelected = this.cellSelected.bind(this);
        this.rowSelected = this.rowSelected.bind(this);
        this.selectionChange = this.selectionChange.bind(this);
        this.updateColumnIndices = this.updateColumnIndices.bind(this);
        this.treelist.selectable = this.selectable = true;
    }
    /**
     * @hidden
     */
    set selectable(value) {
        if (typeof value === 'object') { // add method to normalize this
            this._settings = value;
        }
        else {
            this._settings = {
                enabled: value
            };
        }
        this.state = createState(this._settings);
        if (this._settings.enabled !== false) {
            this.treelist.isSelected = this._settings.mode === 'cell' ? this.cellSelected : this.rowSelected;
            this.subscribeSelection();
        }
        else {
            this.treelist.isSelected = null;
            this.unsubscribeSelection();
        }
    }
    /**
     * Specifies the selected items.
     */
    set selectedItems(value) {
        if (!value) {
            this.state.clear();
        }
        else if (value !== this.lastChange) {
            this.state.fromArray(value);
            this.treelist.updateView();
        }
    }
    /**
     * The field name or a function that specify the dataItems key.
     */
    set itemKey(value) {
        if (isString(value)) {
            this._keyGetter = getter(String(value));
        }
        else {
            this._keyGetter = value;
        }
    }
    /**
     * The field name or a function that specify the columns key.
     */
    set columnKey(value) {
        if (isString(value)) {
            this._columnKeyGetter = getter(String(value));
        }
        else if (value) {
            this._columnKeyGetter = value;
        }
    }
    get keyGetter() {
        return this._keyGetter || this.treelist.idGetter;
    }
    get columnKeyGetter() {
        return this._columnKeyGetter || defaultColumnKeyGetter;
    }
    ngOnDestroy() {
        this.unsubscribeSelection();
    }
    /**
     * @hidden
     */
    cellSelected(dataItem, column, columnIndex) {
        return this.state.has(this.keyGetter(dataItem), this.columnKeyGetter(column, columnIndex));
    }
    /**
     * @hidden
     */
    rowSelected(dataItem) {
        return this.state.has(this.keyGetter(dataItem));
    }
    selectionChange({ action, items }) {
        if (action === 'select' || action === 'add') {
            if (action === 'select') {
                this.state.clear();
            }
            items.forEach(item => {
                this.state.add(this.keyGetter(item.dataItem), this.columnKeyGetter(item.column, item.columnIndex));
            });
        }
        else {
            items.forEach(item => {
                this.state.remove(this.keyGetter(item.dataItem), this.columnKeyGetter(item.column, item.columnIndex));
            });
        }
        this.emitSelectedItemsChange();
    }
    emitSelectedItemsChange() {
        this.lastChange = this.state.toArray();
        this.selectedItemsChange.emit(this.lastChange);
    }
    subscribeSelection() {
        this.unsubscribeSelection();
        this.subscriptions = this.treelist.selectionChange.subscribe(this.selectionChange);
        if (this._settings.mode === 'cell') {
            this.subscriptions.add(this.treelist.columnOrderChange.subscribe(this.updateColumnIndices));
            this.subscriptions.add(this.treelist.columnLockedChange.subscribe(this.updateColumnIndices));
        }
    }
    unsubscribeSelection() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
            this.subscriptions = null;
        }
    }
    updateColumnIndices() {
        if (!this._columnKeyGetter) {
            const changes = new Map();
            const currentIndices = [];
            this.leafColumns.forEach((column) => {
                currentIndices.push(column);
            });
            this.treelist.columnsContainer.refresh();
            const leafColumns = this.leafColumns;
            currentIndices.forEach((column, index) => {
                if (column !== leafColumns[index]) {
                    changes.set(index, leafColumns.indexOf(column));
                }
            });
            if (changes.size && this.state.updateColumKeys(changes)) {
                this.emitSelectedItemsChange();
            }
        }
    }
    get leafColumns() {
        return this.treelist.lockedLeafColumns.toArray().concat(this.treelist.nonLockedLeafColumns.toArray());
    }
}
SelectableDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'kendoTreeListSelectable',
                selector: '[kendoTreeListSelectable]'
            },] },
];
/** @nocollapse */
SelectableDirective.ctorParameters = () => [
    { type: TreeListComponent }
];
SelectableDirective.propDecorators = {
    selectable: [{ type: Input }],
    selectedItems: [{ type: Input }],
    selectedItemsChange: [{ type: Output }],
    itemKey: [{ type: Input }],
    columnKey: [{ type: Input }]
};
export { ɵ0 };
