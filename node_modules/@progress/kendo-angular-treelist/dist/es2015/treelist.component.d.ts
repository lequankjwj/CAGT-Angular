/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { AfterContentInit, AfterViewInit, ElementRef, EventEmitter, OnChanges, OnDestroy, OnInit, Renderer2, QueryList, SimpleChange, NgZone, ChangeDetectorRef, TemplateRef, TrackByFunction } from '@angular/core';
import { Observable } from 'rxjs';
import { SortDescriptor, CompositeFilterDescriptor } from '@progress/kendo-data-query';
import { ScrollMode } from './scrolling/scrollmode';
import { SortSettings } from './columns/sort-settings';
import { PagerSettings } from './pager/pager-settings';
import { BrowserSupportService } from './layout/browser-support.service';
import { TreeListDataResult, ViewCollection } from './data/data.collection';
import { EditService } from './editing/edit.service';
import { PageChangeEvent, DataStateChangeEvent } from './data/change-event-args.interface';
import { ColumnsContainer } from './columns/columns-container';
import { ChangeNotificationService } from './data/change-notification.service';
import { NoRecordsTemplateDirective } from './rendering/no-records-template.directive';
import { ColumnBase } from './columns/column-base';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { FilterService } from './filtering/filter.service';
import { PagerTemplateDirective } from './pager/pager-template.directive';
import { PDFService } from './pdf/pdf.service';
import { PDFExportEvent } from './pdf/pdf-export-event';
import { ResponsiveService } from "./layout/responsive.service";
import { ExcelService } from './excel/excel.service';
import { ExcelExportEvent } from './excel/excel-export-event';
import { ColumnList } from './columns/column-list';
import { RowClassFn } from './rendering/common/row-class';
import { ToolbarTemplateDirective } from "./rendering/toolbar/toolbar-template.directive";
import { EditEvent } from "./editing/edit-event-args.interface";
import { RemoveEvent } from "./editing/remove-event-args.interface";
import { SaveEvent } from "./editing/save-event-args.interface";
import { CancelEvent } from "./editing/cancel-event-args.interface";
import { AddEvent } from "./editing/add-event-args.interface";
import { CellCloseEvent } from './editing/cell-close-event';
import { CellClickEvent } from './common/cell-click-event-args.interface';
import { ScrollSyncService } from "./scrolling/scroll-sync.service";
import { DomEventsService } from './common/dom-events.service';
import { ColumnResizingService } from "./column-resizing/column-resizing.service";
import { ColumnResizeArgs } from './column-resizing/column-resize.interface';
import { FilterableSettings } from './filtering/filterable';
import { ColumnReorderService } from './dragdrop/column-reorder.service';
import { ColumnReorderEvent } from './dragdrop/column-reorder-event';
import { ColumnReorderConfig } from './dragdrop/column-reorder-config';
import { NavigationService } from './navigation/navigation.service';
import { NavigationCell } from './navigation/navigation-cell.interface';
import { NavigationRow } from './navigation/navigation-row.interface';
import { ColumnInfoService } from "./common/column-info.service";
import { ScrollRequestService, ScrollRequest } from './scrolling/scroll-request.service';
import { SortService } from './common/sort.service';
import { ColumnMenuTemplateDirective } from './column-menu/column-menu-template.directive';
import { ColumnMenuSettings } from './column-menu/column-menu-settings.interface';
import { ColumnVisibilityChangeEvent } from './column-menu/column-visibility-change-event';
import { ColumnLockedChangeEvent } from './column-menu/column-locked-change-event';
import { ScrollBottomEvent } from './scrolling/scroll-bottom-event';
import { ContentScrollEvent } from './scrolling/content-scroll-event';
import { TreeListItem } from './data/treelist-item.interface';
import { ExpandStateService } from './expand-state/expand-state.service';
import { ExpandEvent } from './expand-state/expand-event';
import { OptionChangesService } from "./common/option-changes.service";
import { SelectionService } from './selection/selection.service';
import { SelectableSettings } from './selection/selectable-settings';
import { SelectionChangeEvent } from './selection/selection-change-event';
import { IsSelectedFn } from './selection/is-selected';
/**
 * Represents the Kendo UI TreeList component for Angular.
 *
 * {% meta height:470 %}
 * {% embed_file data-binding/flat/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
import * as ɵngcc0 from '@angular/core';
export declare class TreeListComponent implements AfterContentInit, AfterViewInit, OnDestroy, OnChanges, OnInit {
    private supportService;
    wrapper: ElementRef;
    private changeNotification;
    private editService;
    private filterService;
    private pdfService;
    private responsiveService;
    private renderer;
    private excelService;
    private ngZone;
    private scrollSyncService;
    private domEvents;
    private columnResizingService;
    private changeDetectorRef;
    private columnReorderService;
    private columnInfoService;
    private navigationService;
    private sortService;
    private scrollRequestService;
    private expandStateService;
    private optionChanges;
    selectionService: SelectionService;
    /**
     * An optional accessible description of the component.
     */
    ariaLabel: string;
    /**
     * Sets the data of the TreeList. If an array is provided, the TreeList automatically gets the total count
     * ([more information and example]({% slug databinding_treelist %})).
     */
    data: Array<any> | TreeListDataResult | Observable<any>;
    /**
     * Defines the page size used by the TreeList when [paging]({% slug paging_treelist %}) is enabled.
     *
     * @default 10
     */
    pageSize: number;
    /**
     * Defines the height (in pixels) that is used when the `scrollable` option of the TreeList is set.
     * To set the height of the TreeList, you can also use `style.height`. The `style.height`
     * option supports units such as `px`, `%`, `em`, `rem`, and others.
     */
    height: number;
    /**
     * Defines the row height that is used when the `scrollable` option of the TreeList is set to `virtual`.
     * Required by the [virtual scrolling functionality]({% slug scrollmmodes_treelist %}).
     */
    rowHeight: number;
    /**
     * Defines the number of records to be skipped by the pager.
     * Required by the [paging]({% slug paging_treelist %}) functionality.
     */
    skip: number;
    /**
     * Defines the scroll mode used by the TreeList.
     *
     * The available options are:
     *  - `none`&mdash;Renders no scrollbar.
     *  - `scrollable`&mdash;The default scroll mode. It requires the setting of the `height` option.
     */
    scrollable: ScrollMode;
    /**
     * The descriptors by which the data will be sorted ([see example]({% slug sorting_treelist %})).
     */
    sort: Array<SortDescriptor>;
    /**
     * A function that defines how to track changes for the data rows.
     *
     * By default, the TreeList tracks changes by the index of the data item.
     * Edited rows are tracked by reference.
     * In some cases, you might need to override the default behavior,
     * for example, when you implement editing with immutable data items.
     *
     * The following example demonstrates how to track items only by index.
     *
     * @example
     * ```ts
     * import { Component } from '@angular/core';
     * import { TreeListItem } from '@progress/kendo-angular-treelist';
     *
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-treelist [data]="treelistData" [trackBy]="trackBy">
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     *
     *    public trackBy(index: number, item: TreeListItem): any {
     *        console.log(item);
     *        return index;
     *    }
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    trackBy: TrackByFunction<TreeListItem>;
    /**
     * The descriptor by which the data will be filtered ([see examples]({% slug filtering_treelist %})).
     */
    filter: CompositeFilterDescriptor;
    /**
     * If set to `true`, the treelist will render only the columns in the current viewport.
     */
    virtualColumns: boolean;
    /**
     * @hidden
     */
    readonly showTopToolbar: boolean;
    /**
     * @hidden
     */
    readonly showBottomToolbar: boolean;
    /**
     * @hidden
     */
    readonly isLocked: boolean;
    /**
     * @hidden
     */
    readonly showPager: boolean;
    readonly marqueeSelection: boolean;
    /**
     * Enables the [filtering]({% slug filtering_treelist %}) of the TreeList columns that have their `field` option set.
     */
    filterable: FilterableSettings;
    /**
     * Enables the [sorting]({% slug sorting_treelist %}) of the TreeList columns that have their `field` option set.
     */
    sortable: SortSettings;
    /**
     * Configures the pager of the TreeList ([see example]({% slug paging_treelist %})).
     *
     * The available options are:
     * - `buttonCount: Number`&mdash;Sets the maximum numeric buttons count before the buttons are collapsed.
     * - `info: Boolean`&mdash;Toggles the information about the current page and the total number of records.
     * - `type: PagerType`&mdash;Accepts the `numeric` (buttons with numbers) and `input` (input for typing the page number) values.
     * - `pageSizes: Boolean` or `Array<number>`&mdash;Shows a menu for selecting the page size.
     * - `previousNext: Boolean`&mdash;Toggles the **Previous** and **Next** buttons.
     */
    pageable: PagerSettings | boolean;
    /**
     * If set to `true`, the user can use dedicated shortcuts to interact with the TreeList.
     * By default, navigation is disabled and the TreeList content is accessible in the normal tab sequence.
     */
    navigable: boolean;
    /**
     * @hidden
     *
     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.
     */
    /**
    * @hidden
    */
    navigatable: boolean;
    /**
     * Indicates whether the TreeList columns will be resized during initialization so that
     * they fit their headers and row content. Defaults to `false`.
     * Columns with `autoSize` set to `false` are excluded.
     * To dynamically update the column width to match the new content,
     * refer to [this example]({% slug resizing_columns_treelist %}).
     */
    autoSize: boolean;
    /**
     * Defines a function that is executed for every data row in the component.
     *
     * @example
     * ```ts
     * import { Component, ViewEncapsulation } from '@angular/core';
     * import { RowClassArgs } from '@progress/kendo-angular-treelist';
     *
     * _@Component({
     *    selector: 'my-app',
     *    encapsulation: ViewEncapsulation.None,
     *    styles: [`
     *        .k-treelist tr.even { background-color: #f45c42; }
     *        .k-treelist tr.odd { background-color: #41f4df; }
     *    `],
     *    template: `
     *        <kendo-treelist [data]="treelistData" [rowClass]="rowCallback">
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     *
     *    public rowCallback(context: RowClassArgs) {
     *        const isEven = context.index % 2 == 0;
     *        return {
     *            even: isEven,
     *            odd: !isEven
     *        };
     *    }
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    rowClass: RowClassFn;
    /**
     * Returns the currently focused cell (if any).
     */
    readonly activeCell: NavigationCell;
    /**
     * Returns the currently focused row (if any).
     */
    readonly activeRow: NavigationRow;
    /**
     * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells
     * ([see example]({% slug resizing_columns_treelist %})).
     *
     * @default false
     */
    resizable: boolean;
    /**
     * If set to `true`, the user can reorder columns by dragging their header cells
     * ([see example]({% slug reordering_columns_treelist %})).
     *
     * @default false
     */
    reorderable: boolean;
    /**
     * Specifies if the loading indicator of the TreeList will be displayed ([see example]({% slug databinding_treelist %})).
     *
     * @default false
     */
    loading: boolean;
    /**
     * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_treelist %})).
     *
     * @default false
     */
    columnMenu: boolean | ColumnMenuSettings;
    /**
     * Specifies if the header of the treelist will be hidden. The header is visible by default.
     *
     * > The header includes column headers and the [filter row]({% slug filtering_treelist %}#toc-filter-row).
     */
    hideHeader: boolean;
    /**
     * The name of the field which contains the unique identifier of the node.
     *
     * @default "id"
     */
    idField: string;
    /**
     * Specified the treelist selection settings
     */
    selectable: boolean | SelectableSettings;
    /**
     * Provides a callback that determines if the given row / cell is selected.
     */
    isSelected: IsSelectedFn;
    /**
     * Fires when the TreeList selection is changed.
     */
    selectionChange: EventEmitter<SelectionChangeEvent>;
    /**
     * Fires when the TreeList filter is modified through the UI.
     * You have to handle the event yourself and filter the data.
     */
    filterChange: EventEmitter<CompositeFilterDescriptor>;
    /**
     * Fires when the page of the TreeList is changed ([see example]({% slug paging_treelist %})).
     * You have to handle the event yourself and page the data.
     */
    pageChange: EventEmitter<PageChangeEvent>;
    /**
     * Fires when the sorting of the TreeList is changed ([see example]({% slug sorting_treelist %})).
     * You have to handle the event yourself and sort the data.
     */
    sortChange: EventEmitter<Array<SortDescriptor>>;
    /**
     * Fires when the data state of the TreeList is changed.
     */
    dataStateChange: EventEmitter<DataStateChangeEvent>;
    /**
     * Fires when the user clicks the **Edit** command button to edit a row
     * ([see example]({% slug editing_template_forms_treelist %}#toc-editing-records)).
     */
    edit: EventEmitter<EditEvent>;
    /**
     * Fires when the user clicks the **Cancel** command button to close a row
     * ([see example]({% slug editing_template_forms_treelist %}#toc-cancelling-editing)).
     */
    cancel: EventEmitter<CancelEvent>;
    /**
     * Fires when the user clicks the **Save** command button to save changes in a row
     * ([see example]({% slug editing_template_forms_treelist %}#toc-saving-records)).
     */
    save: EventEmitter<SaveEvent>;
    /**
     * Fires when the user clicks the **Remove** command button to remove a row
     * ([see example]({% slug editing_template_forms_treelist %}#toc-removing-records)).
     */
    remove: EventEmitter<RemoveEvent>;
    /**
     * Fires when the user clicks the **Add** command button to add a new row
     * ([see example]({% slug editing_template_forms_treelist %}#toc-adding-records)).
     */
    add: EventEmitter<AddEvent>;
    /**
     * Fires when the user leaves an edited cell ([see example]({% slug editing_incell_treelist %}#toc-basic-concepts)).
     */
    cellClose: EventEmitter<CellCloseEvent>;
    /**
     * Fires when the user clicks a cell ([see example]({% slug editing_incell_treelist %}#toc-basic-concepts)).
     */
    cellClick: EventEmitter<CellClickEvent>;
    /**
     * Fires when the user clicks the **Export to PDF** command button.
     */
    pdfExport: EventEmitter<PDFExportEvent>;
    /**
     * Fires when the user clicks the **Export to Excel** command button.
     */
    excelExport: EventEmitter<ExcelExportEvent>;
    /**
     * Fires when the user completes the resizing of the column.
     */
    columnResize: EventEmitter<Array<ColumnResizeArgs>>;
    /**
     * Fires when the user completes the reordering of the column.
     */
    columnReorder: EventEmitter<ColumnReorderEvent>;
    /**
     * Fires when the user changes the visibility of the columns from the column menu or column chooser.
     */
    columnVisibilityChange: EventEmitter<ColumnVisibilityChangeEvent>;
    /**
     * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.
     */
    columnLockedChange: EventEmitter<ColumnLockedChangeEvent>;
    /**
     * Fires when the user scrolls to the last record on the page and enables endless scrolling
     * ([see example]({% slug scrollmmodes_treelist %}#toc-endless-scrolling)).
     * You have to handle the event yourself and page the data.
     */
    scrollBottom: EventEmitter<ScrollBottomEvent>;
    /**
     * Fires when the treelist content is scrolled.
     * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.
     */
    contentScroll: EventEmitter<ContentScrollEvent>;
    /**
     * Fires when an item is expanded.
     */
    expandEvent: EventEmitter<ExpandEvent>;
    /**
     * Fires when an item is collapsed.
     */
    collapseEvent: EventEmitter<ExpandEvent>;
    /**
     * @hidden
     */
    expandStateChange: EventEmitter<ExpandEvent>;
    /**
     * @hidden
     */
    columnOrderChange: EventEmitter<ColumnReorderEvent>;
    /**
     * A query list of all declared columns.
     */
    columns: QueryList<ColumnBase>;
    readonly dir: string;
    readonly hostClasses: boolean;
    readonly lockedClasses: boolean;
    readonly virtualClasses: boolean;
    readonly noScrollbarClass: boolean;
    noRecordsTemplateChildren: QueryList<NoRecordsTemplateDirective>;
    noRecordsTemplate: NoRecordsTemplateDirective;
    pagerTemplateChildren: QueryList<PagerTemplateDirective>;
    pagerTemplate: PagerTemplateDirective;
    toolbarTemplateChildren: QueryList<ToolbarTemplateDirective>;
    toolbarTemplate: ToolbarTemplateDirective;
    columnMenuTemplates: QueryList<ColumnMenuTemplateDirective>;
    lockedHeader: any;
    header: any;
    footer: QueryList<any>;
    ariaRoot: ElementRef;
    readonly scrollbarWidth: number;
    readonly headerPadding: any;
    columnMenuOptions: any;
    columnList: ColumnList;
    columnsContainer: ColumnsContainer;
    readonly showLoading: boolean;
    readonly showFooter: boolean;
    readonly ariaRowCount: number;
    readonly ariaColCount: number;
    readonly ariaMultiselectable: any;
    readonly isVirtual: boolean;
    readonly isScrollable: boolean;
    readonly visibleColumns: QueryList<ColumnBase>;
    readonly lockedColumns: QueryList<ColumnBase>;
    readonly nonLockedColumns: QueryList<ColumnBase>;
    readonly lockedLeafColumns: QueryList<ColumnBase>;
    readonly nonLockedLeafColumns: QueryList<ColumnBase>;
    readonly leafColumns: QueryList<ColumnBase>;
    readonly totalColumnLevels: number;
    readonly headerColumns: any;
    readonly headerLeafColumns: any;
    readonly lockedWidth: number;
    readonly nonLockedWidth: number;
    readonly columnMenuTemplate: TemplateRef<any>;
    readonly totalCount: number;
    /**
     * Gets or sets the callback function that retrieves the child nodes for a particular node.
     */
    fetchChildren: (node: any) => Observable<any[]> | any[];
    /**
     * Gets or sets the callback function that indicates if a particular node has child nodes.
     */
    hasChildren: (node: any) => boolean;
    /**
     * Sets the callback function that indicates if a particular item is expanded.
     */
    isExpanded: (node: any) => boolean;
    idGetter: any;
    localEditService: any;
    view: ViewCollection;
    expandIcons: boolean;
    private dataChanged;
    private loadedData;
    private _fetchChildren;
    private _hasChildren;
    private subscriptions;
    private dataLoadedSubscription;
    private focusElementSubscription;
    private detachElementEventHandlers;
    private rtl;
    private shouldGenerateColumns;
    private direction;
    private _data;
    private _sort;
    private _skip;
    private cachedWindowWidth;
    private _customNoRecordsTemplate;
    private _customPagerTemplate;
    private _customToolbarTemplate;
    private leafViewportColumns;
    private viewportColumns;
    private pageChangeTimeout;
    constructor(supportService: BrowserSupportService, wrapper: ElementRef, changeNotification: ChangeNotificationService, editService: EditService, filterService: FilterService, pdfService: PDFService, responsiveService: ResponsiveService, renderer: Renderer2, excelService: ExcelService, ngZone: NgZone, scrollSyncService: ScrollSyncService, domEvents: DomEventsService, columnResizingService: ColumnResizingService, changeDetectorRef: ChangeDetectorRef, columnReorderService: ColumnReorderService, columnInfoService: ColumnInfoService, navigationService: NavigationService, sortService: SortService, scrollRequestService: ScrollRequestService, expandStateService: ExpandStateService, optionChanges: OptionChangesService, selectionService: SelectionService, localization: LocalizationService);
    /**
     * @hidden
     */
    viewFieldAccessor(): any;
    /**
     * @hidden
     */
    onDataChange(): void;
    ngOnChanges(changes: {
        [propertyName: string]: SimpleChange;
    }): void;
    ngAfterViewInit(): void;
    ngAfterContentChecked(): void;
    ngAfterContentInit(): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    attachScrollSync(): void;
    /**
     * Switches the specified table row in the edit mode ([see example]({% slug editing_template_forms_treelist %}#toc-editing-records)).
     *
     * @param index - The row index that will be switched in the edit mode.
     * @param group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }})
     * that describes the edit form.
     * @param options - Additional options. Use skipFocus to determine if the row's edit element should be focused. Defaults to `false`.
     */
    editRow(item: any, group?: any, options?: {
        [skipFocus: string]: boolean;
    }): void;
    /**
     * Closes the editor for a given row ([see example]({% slug editing_template_forms_treelist %}#toc-cancelling-editing)).
     *
     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed
     * that the new item editor will be closed.
     */
    closeRow(item: any, isNew: boolean): void;
    /**
     * Creates a new row editor ([see example]({% slug editing_template_forms_treelist %}#toc-adding-records)).
     *
     * @param {FormGroup} group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }}) that describes
     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.
     */
    addRow(group: any, parent?: any): void;
    /**
     * Puts the cell that is specified by the table row and column in edit mode.
     *
     * @param {number} rowIndex - The data row index that will be switched in the edit mode.
     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.
     * @param {FormGroup} group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }})
     * that describes the edit form.
     */
    editCell(dataItem: any, column: number | string | any, group?: any): void;
    /**
     * Closes the current cell in edit mode and fires
     * the [`cellClose`]({% slug api_treelist_treelistcomponent %}#toc-cellclose) event.
     *
     * @return {boolean} Indicates whether the edited cell was closed.
     * A `false` value indicates that the
     * [`cellClose`]({% slug api_treelist_treelistcomponent %}#toc-cellclose) event was prevented.
     */
    closeCell(): boolean;
    /**
     * Closes the current cell in edit mode.
     */
    cancelCell(): void;
    /**
     * Returns a flag which indicates if a row or a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a row or a cell is currently edited.
     */
    isEditing(): boolean;
    /**
     * Returns a flag which indicates if a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a cell is currently being edited.
     */
    isEditingCell(): boolean;
    /**
     * Initiates the PDF export ([see example]({% slug pdfexport_treelist %})).
     */
    saveAsPDF(): void;
    /**
     * Exports the TreeList element to a Drawing [`Group`]({% slug api_kendo-drawing_group %}) by using the `kendo-treelist-pdf` component options.
     * ([see example]({% slug pdfexport_treelist %}#toc-exporting-multiple-treelists-to-the-same-pdf)).
     *
     * @return {Promise} - A promise that will be resolved with the Drawing `Group`.
     */
    drawPDF(): Promise<any>;
    /**
     * Initiates the Excel export ([see example]({% slug excelexport_treelist %})).
     */
    saveAsExcel(): void;
    /**
     * Applies the minimum possible width for the specified column,
     * so that the whole text fits without wrapping. This method expects the TreeList
     * to be resizable (set `resizable` to `true`).
     * Makes sense to execute this method only
     * after the TreeList is already populated with data.
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-treelist
     *            #treelist
     *            [data]="treelistData"
     *            [resizable]="true"
     *            style="height: 300px">
     *            <ng-template kendoTreeListToolbarTemplate>
     *                 <button class="k-button" (click)="treelist.autoFitColumn(groupColumn)">
     *                     Auto-fit the group column
     *                 </button>
     *            </ng-template>
     *            <kendo-treelist-column-group #groupColumn title="Product Info">
     *                <kendo-treelist-column
     *                    field="ProductID"
     *                    [width]="50"
     *                    [minResizableWidth]="30"
     *                    title="ID">
     *                </kendo-treelist-column>
     *
     *                <kendo-treelist-column
     *                    field="ProductName"
     *                    title="Product Name">
     *                </kendo-treelist-column>
     *            </kendo-treelist-column-group>
     *
     *            <kendo-treelist-column
     *                field="UnitPrice"
     *                title="Unit Price"
     *                [width]="180"
     *                filter="numeric"
     *                format="{0:c}">
     *            </kendo-treelist-column>
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    autoFitColumn(column: ColumnBase): void;
    /**
     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
     * If no columns are specified, `autoFitColumns` is applied to all columns.
     *
     * This method requires the TreeList to be resizable (set `resizable` to `true`).
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *      <kendo-treelist
     *          #treelist
     *          [data]="treelistData"
     *          [resizable]="true"
     *          style="height: 300px">
     *          <ng-template kendoTreeListToolbarTemplate>
     *              <button class="k-button" (click)="treelist.autoFitColumns([firstColumn, lastColumn])">
     *                  Auto-fit the first and last column
     *              </button>
     *              <button class="k-button" (click)="treelist.autoFitColumns()">
     *                  Auto-fit all columns
     *              </button>
     *          </ng-template>
     *          <kendo-treelist-column-group title="Product Info">
     *              <kendo-treelist-column
     *                  #firstColumn
     *                  field="ProductID"
     *                  [width]="50"
     *                  [minResizableWidth]="30"
     *                  title="ID">
     *              </kendo-treelist-column>
     *
     *              <kendo-treelist-column
     *                  field="ProductName"
     *                  title="Product Name"
     *                  >
     *              </kendo-treelist-column>
     *          </kendo-treelist-column-group>
     *
     *          <kendo-treelist-column
     *              #lastColumn
     *              field="UnitPrice"
     *              title="Unit Price"
     *              [width]="180"
     *              filter="numeric"
     *              format="{0:c}">
     *          </kendo-treelist-column>
     *      </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    autoFitColumns(columns?: Array<ColumnBase> | QueryList<ColumnBase>): void;
    /**
     * @hidden
     */
    notifyPageChange(source: string, event: any): void;
    /**
     * @hidden
     */
    notifyScrollBottom(): void;
    /**
     * @hidden
     */
    focusEditElement(containerSelector: () => string): void;
    /**
     * Focuses the last active or the first cell of the TreeList.
     *
     * @returns {NavigationCell} The focused cell.
     */
    focus(): NavigationCell;
    /**
     * Focuses the cell with the specified row and column index.
     *
     * The row index is based on the logical structure of the TreeList and does not correspond to the data item index:
     * * Header rows are included, starting at index 0.
     * * The row indexing is absolute and does not change with paging.
     *
     * If the TreeList is configured for scrolling, including virtual scrolling, the scroll position will be updated.
     * If the row is not present on the current page, the method will have no effect.
     *
     * @param rowIndex - The logical row index to focus. The top header row has an index 0.
     * @param colIndex - The column index to focus.
     * @returns {NavigationCell} The focused cell.
     *
     */
    focusCell(rowIndex: number, colIndex: number): NavigationCell;
    /**
     * Focuses the next cell, optionally wrapping to the next row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
     */
    focusNextCell(wrap?: boolean): NavigationCell;
    /**
     * Focuses the previous cell. Optionally wraps to the previous row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
     */
    focusPrevCell(wrap?: boolean): NavigationCell;
    /**
     * Scrolls to the specified row and column
     */
    scrollTo(request: ScrollRequest): void;
    /**
     * Changes the position of the specified column.
     * The reordering of columns operates only on the level
     * which is inferred by the source column.
     * For the `reorderColumn` method to work properly,
     * the `source` column has to be visible.
     *
     * @param {ColumnBase} source - The column whose position will be changed.
     * @param {number} destIndex - The new position of the column.
     * @param {ColumnReorderConfig} options - Additional options.
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-treelist
     *            #treelist
     *            [data]="treelistData"
     *            [reorderable]="true"
     *            style="height: 300px">
     *            <ng-template kendoTreeListToolbarTemplate>
     *                 <button class="k-button"
     *                     (click)="treelist.reorderColumn(groupColumn, 2, { before: true })">
     *                     Move the group column before the last one.
     *                 </button>
     *            </ng-template>
     *            <kendo-treelist-column-group #groupColumn title="Product Info">
     *                <kendo-treelist-column
     *                    field="ProductID"
     *                    [width]="50"
     *                    title="ID">
     *                </kendo-treelist-column>
     *
     *                <kendo-treelist-column
     *                    field="ProductName"
     *                    title="Product Name">
     *                </kendo-treelist-column>
     *            </kendo-treelist-column-group>
     *
     *            <kendo-treelist-column
     *                field="UnitPrice"
     *                title="Unit Price"
     *                [width]="180"
     *                format="{0:c}">
     *            </kendo-treelist-column>
     *
     *            <kendo-treelist-column
     *                field="Discontinued"
     *                title="Discontinued"
     *                [width]="100">
     *            </kendo-treelist-column>
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    reorderColumn(source: ColumnBase, destIndex: number, options?: ColumnReorderConfig): void;
    /**
     * Clears the already loaded children for the dataItem so that the TreeList will fetch them again the next time it is rendered.
     */
    reload(dataItem: any, reloadChildren?: boolean): void;
    /**
     * Updates the state of the current view without reloading the data.
     *
     * Checks all currently rendered items for changes and
     * triggers re-evaluation of the the [isExpanded](#toc-isexpanded) and
     * [isSelected](#toc-isSelected) callbacks.
     */
    updateView(): void;
    /**
     * Expands the row for the specified dataItem.
     */
    expand(dataItem: any): void;
    /**
     * Collapses the row for the specified dataItem.
     */
    collapse(dataItem: any): void;
    /**
     * @hidden
     */
    private reorder;
    private updateColumnIndices;
    private updateIndicesForLevel;
    private columnsForLevel;
    private setEditFocus;
    private columnInstance;
    private verifySettings;
    private autoGenerateColumns;
    private attachStateChangesEmitter;
    private attachEditHandlers;
    private emitCRUDEvent;
    private attachDomEventHandlers;
    private attachElementEventHandlers;
    private matchesMedia;
    private resizeCheck;
    private emitPDFExportEvent;
    private syncHeaderHeight;
    private columnsContainerChange;
    private handleColumnResize;
    private notifyResize;
    private assertNavigable;
    private _rowClass;
    private navigationMetadata;
    private updateNavigationMetadata;
    private applyAutoSize;
    private onColumnRangeChange;
    private dataLoaded;
    private unsubscribeDataLoaded;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<TreeListComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<TreeListComponent, "kendo-treelist", ["kendoTreeList"], { "pageSize": "pageSize"; "scrollable": "scrollable"; "trackBy": "trackBy"; "virtualColumns": "virtualColumns"; "filterable": "filterable"; "sortable": "sortable"; "pageable": "pageable"; "navigable": "navigable"; "autoSize": "autoSize"; "resizable": "resizable"; "reorderable": "reorderable"; "loading": "loading"; "columnMenu": "columnMenu"; "hideHeader": "hideHeader"; "skip": "skip"; "data": "data"; "sort": "sort"; "navigatable": "navigatable"; "rowClass": "rowClass"; "idField": "idField"; "selectable": "selectable"; "isSelected": "isSelected"; "fetchChildren": "fetchChildren"; "hasChildren": "hasChildren"; "isExpanded": "isExpanded"; "ariaLabel": "aria-label"; "height": "height"; "rowHeight": "rowHeight"; "filter": "filter"; }, { "selectionChange": "selectionChange"; "filterChange": "filterChange"; "pageChange": "pageChange"; "sortChange": "sortChange"; "dataStateChange": "dataStateChange"; "edit": "edit"; "cancel": "cancel"; "save": "save"; "remove": "remove"; "add": "add"; "cellClose": "cellClose"; "cellClick": "cellClick"; "pdfExport": "pdfExport"; "excelExport": "excelExport"; "columnResize": "columnResize"; "columnReorder": "columnReorder"; "columnVisibilityChange": "columnVisibilityChange"; "columnLockedChange": "columnLockedChange"; "scrollBottom": "scrollBottom"; "contentScroll": "contentScroll"; "expandEvent": "expand"; "collapseEvent": "collapse"; }, ["columns", "noRecordsTemplateChildren", "pagerTemplateChildren", "toolbarTemplateChildren", "columnMenuTemplates"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZWxpc3QuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInRyZWVsaXN0LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2UsIE5nWm9uZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFRlbXBsYXRlUmVmLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFNvcnREZXNjcmlwdG9yLCBDb21wb3NpdGVGaWx0ZXJEZXNjcmlwdG9yIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRhdGEtcXVlcnknO1xuaW1wb3J0IHsgU2Nyb2xsTW9kZSB9IGZyb20gJy4vc2Nyb2xsaW5nL3Njcm9sbG1vZGUnO1xuaW1wb3J0IHsgU29ydFNldHRpbmdzIH0gZnJvbSAnLi9jb2x1bW5zL3NvcnQtc2V0dGluZ3MnO1xuaW1wb3J0IHsgUGFnZXJTZXR0aW5ncyB9IGZyb20gJy4vcGFnZXIvcGFnZXItc2V0dGluZ3MnO1xuaW1wb3J0IHsgQnJvd3NlclN1cHBvcnRTZXJ2aWNlIH0gZnJvbSAnLi9sYXlvdXQvYnJvd3Nlci1zdXBwb3J0LnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUxpc3REYXRhUmVzdWx0LCBWaWV3Q29sbGVjdGlvbiB9IGZyb20gJy4vZGF0YS9kYXRhLmNvbGxlY3Rpb24nO1xuaW1wb3J0IHsgRWRpdFNlcnZpY2UgfSBmcm9tICcuL2VkaXRpbmcvZWRpdC5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VDaGFuZ2VFdmVudCwgRGF0YVN0YXRlQ2hhbmdlRXZlbnQgfSBmcm9tICcuL2RhdGEvY2hhbmdlLWV2ZW50LWFyZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IENvbHVtbnNDb250YWluZXIgfSBmcm9tICcuL2NvbHVtbnMvY29sdW1ucy1jb250YWluZXInO1xuaW1wb3J0IHsgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4vZGF0YS9jaGFuZ2Utbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTm9SZWNvcmRzVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL3JlbmRlcmluZy9uby1yZWNvcmRzLXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDb2x1bW5CYXNlIH0gZnJvbSAnLi9jb2x1bW5zL2NvbHVtbi1iYXNlJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IEZpbHRlclNlcnZpY2UgfSBmcm9tICcuL2ZpbHRlcmluZy9maWx0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlclRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9wYWdlci9wYWdlci10ZW1wbGF0ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUERGU2VydmljZSB9IGZyb20gJy4vcGRmL3BkZi5zZXJ2aWNlJztcbmltcG9ydCB7IFBERkV4cG9ydEV2ZW50IH0gZnJvbSAnLi9wZGYvcGRmLWV4cG9ydC1ldmVudCc7XG5pbXBvcnQgeyBSZXNwb25zaXZlU2VydmljZSB9IGZyb20gXCIuL2xheW91dC9yZXNwb25zaXZlLnNlcnZpY2VcIjtcbmltcG9ydCB7IEV4Y2VsU2VydmljZSB9IGZyb20gJy4vZXhjZWwvZXhjZWwuc2VydmljZSc7XG5pbXBvcnQgeyBFeGNlbEV4cG9ydEV2ZW50IH0gZnJvbSAnLi9leGNlbC9leGNlbC1leHBvcnQtZXZlbnQnO1xuaW1wb3J0IHsgQ29sdW1uTGlzdCB9IGZyb20gJy4vY29sdW1ucy9jb2x1bW4tbGlzdCc7XG5pbXBvcnQgeyBSb3dDbGFzc0ZuIH0gZnJvbSAnLi9yZW5kZXJpbmcvY29tbW9uL3Jvdy1jbGFzcyc7XG5pbXBvcnQgeyBUb29sYmFyVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tIFwiLi9yZW5kZXJpbmcvdG9vbGJhci90b29sYmFyLXRlbXBsYXRlLmRpcmVjdGl2ZVwiO1xuaW1wb3J0IHsgRWRpdEV2ZW50IH0gZnJvbSBcIi4vZWRpdGluZy9lZGl0LWV2ZW50LWFyZ3MuaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBSZW1vdmVFdmVudCB9IGZyb20gXCIuL2VkaXRpbmcvcmVtb3ZlLWV2ZW50LWFyZ3MuaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBTYXZlRXZlbnQgfSBmcm9tIFwiLi9lZGl0aW5nL3NhdmUtZXZlbnQtYXJncy5pbnRlcmZhY2VcIjtcbmltcG9ydCB7IENhbmNlbEV2ZW50IH0gZnJvbSBcIi4vZWRpdGluZy9jYW5jZWwtZXZlbnQtYXJncy5pbnRlcmZhY2VcIjtcbmltcG9ydCB7IEFkZEV2ZW50IH0gZnJvbSBcIi4vZWRpdGluZy9hZGQtZXZlbnQtYXJncy5pbnRlcmZhY2VcIjtcbmltcG9ydCB7IENlbGxDbG9zZUV2ZW50IH0gZnJvbSAnLi9lZGl0aW5nL2NlbGwtY2xvc2UtZXZlbnQnO1xuaW1wb3J0IHsgQ2VsbENsaWNrRXZlbnQgfSBmcm9tICcuL2NvbW1vbi9jZWxsLWNsaWNrLWV2ZW50LWFyZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSBcIi4vc2Nyb2xsaW5nL3Njcm9sbC1zeW5jLnNlcnZpY2VcIjtcbmltcG9ydCB7IERvbUV2ZW50c1NlcnZpY2UgfSBmcm9tICcuL2NvbW1vbi9kb20tZXZlbnRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sdW1uUmVzaXppbmdTZXJ2aWNlIH0gZnJvbSBcIi4vY29sdW1uLXJlc2l6aW5nL2NvbHVtbi1yZXNpemluZy5zZXJ2aWNlXCI7XG5pbXBvcnQgeyBDb2x1bW5SZXNpemVBcmdzIH0gZnJvbSAnLi9jb2x1bW4tcmVzaXppbmcvY29sdW1uLXJlc2l6ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmlsdGVyYWJsZVNldHRpbmdzIH0gZnJvbSAnLi9maWx0ZXJpbmcvZmlsdGVyYWJsZSc7XG5pbXBvcnQgeyBDb2x1bW5SZW9yZGVyU2VydmljZSB9IGZyb20gJy4vZHJhZ2Ryb3AvY29sdW1uLXJlb3JkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDb2x1bW5SZW9yZGVyRXZlbnQgfSBmcm9tICcuL2RyYWdkcm9wL2NvbHVtbi1yZW9yZGVyLWV2ZW50JztcbmltcG9ydCB7IENvbHVtblJlb3JkZXJDb25maWcgfSBmcm9tICcuL2RyYWdkcm9wL2NvbHVtbi1yZW9yZGVyLWNvbmZpZyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNlbGwgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1jZWxsLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uUm93IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24tcm93LmludGVyZmFjZSc7XG5pbXBvcnQgeyBDb2x1bW5JbmZvU2VydmljZSB9IGZyb20gXCIuL2NvbW1vbi9jb2x1bW4taW5mby5zZXJ2aWNlXCI7XG5pbXBvcnQgeyBTY3JvbGxSZXF1ZXN0U2VydmljZSwgU2Nyb2xsUmVxdWVzdCB9IGZyb20gJy4vc2Nyb2xsaW5nL3Njcm9sbC1yZXF1ZXN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgU29ydFNlcnZpY2UgfSBmcm9tICcuL2NvbW1vbi9zb3J0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sdW1uTWVudVRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9jb2x1bW4tbWVudS9jb2x1bW4tbWVudS10ZW1wbGF0ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ29sdW1uTWVudVNldHRpbmdzIH0gZnJvbSAnLi9jb2x1bW4tbWVudS9jb2x1bW4tbWVudS1zZXR0aW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29sdW1uVmlzaWJpbGl0eUNoYW5nZUV2ZW50IH0gZnJvbSAnLi9jb2x1bW4tbWVudS9jb2x1bW4tdmlzaWJpbGl0eS1jaGFuZ2UtZXZlbnQnO1xuaW1wb3J0IHsgQ29sdW1uTG9ja2VkQ2hhbmdlRXZlbnQgfSBmcm9tICcuL2NvbHVtbi1tZW51L2NvbHVtbi1sb2NrZWQtY2hhbmdlLWV2ZW50JztcbmltcG9ydCB7IFNjcm9sbEJvdHRvbUV2ZW50IH0gZnJvbSAnLi9zY3JvbGxpbmcvc2Nyb2xsLWJvdHRvbS1ldmVudCc7XG5pbXBvcnQgeyBDb250ZW50U2Nyb2xsRXZlbnQgfSBmcm9tICcuL3Njcm9sbGluZy9jb250ZW50LXNjcm9sbC1ldmVudCc7XG5pbXBvcnQgeyBUcmVlTGlzdEl0ZW0gfSBmcm9tICcuL2RhdGEvdHJlZWxpc3QtaXRlbS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRXhwYW5kU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi9leHBhbmQtc3RhdGUvZXhwYW5kLXN0YXRlLnNlcnZpY2UnO1xuaW1wb3J0IHsgRXhwYW5kRXZlbnQgfSBmcm9tICcuL2V4cGFuZC1zdGF0ZS9leHBhbmQtZXZlbnQnO1xuaW1wb3J0IHsgT3B0aW9uQ2hhbmdlc1NlcnZpY2UgfSBmcm9tIFwiLi9jb21tb24vb3B0aW9uLWNoYW5nZXMuc2VydmljZVwiO1xuaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGFibGVTZXR0aW5ncyB9IGZyb20gJy4vc2VsZWN0aW9uL3NlbGVjdGFibGUtc2V0dGluZ3MnO1xuaW1wb3J0IHsgU2VsZWN0aW9uQ2hhbmdlRXZlbnQgfSBmcm9tICcuL3NlbGVjdGlvbi9zZWxlY3Rpb24tY2hhbmdlLWV2ZW50JztcbmltcG9ydCB7IElzU2VsZWN0ZWRGbiB9IGZyb20gJy4vc2VsZWN0aW9uL2lzLXNlbGVjdGVkJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgS2VuZG8gVUkgVHJlZUxpc3QgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjQ3MCAlfVxuICogeyUgZW1iZWRfZmlsZSBkYXRhLWJpbmRpbmcvZmxhdC9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2VtcGxveWVlcy50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBUcmVlTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBPbkluaXQge1xuICAgIHByaXZhdGUgc3VwcG9ydFNlcnZpY2U7XG4gICAgd3JhcHBlcjogRWxlbWVudFJlZjtcbiAgICBwcml2YXRlIGNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICBwcml2YXRlIGVkaXRTZXJ2aWNlO1xuICAgIHByaXZhdGUgZmlsdGVyU2VydmljZTtcbiAgICBwcml2YXRlIHBkZlNlcnZpY2U7XG4gICAgcHJpdmF0ZSByZXNwb25zaXZlU2VydmljZTtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgZXhjZWxTZXJ2aWNlO1xuICAgIHByaXZhdGUgbmdab25lO1xuICAgIHByaXZhdGUgc2Nyb2xsU3luY1NlcnZpY2U7XG4gICAgcHJpdmF0ZSBkb21FdmVudHM7XG4gICAgcHJpdmF0ZSBjb2x1bW5SZXNpemluZ1NlcnZpY2U7XG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjtcbiAgICBwcml2YXRlIGNvbHVtblJlb3JkZXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgY29sdW1uSW5mb1NlcnZpY2U7XG4gICAgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICBwcml2YXRlIHNvcnRTZXJ2aWNlO1xuICAgIHByaXZhdGUgc2Nyb2xsUmVxdWVzdFNlcnZpY2U7XG4gICAgcHJpdmF0ZSBleHBhbmRTdGF0ZVNlcnZpY2U7XG4gICAgcHJpdmF0ZSBvcHRpb25DaGFuZ2VzO1xuICAgIHNlbGVjdGlvblNlcnZpY2U6IFNlbGVjdGlvblNlcnZpY2U7XG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgYWNjZXNzaWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGFyaWFMYWJlbDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGEgb2YgdGhlIFRyZWVMaXN0LiBJZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgdGhlIFRyZWVMaXN0IGF1dG9tYXRpY2FsbHkgZ2V0cyB0aGUgdG90YWwgY291bnRcbiAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBkYXRhOiBBcnJheTxhbnk+IHwgVHJlZUxpc3REYXRhUmVzdWx0IHwgT2JzZXJ2YWJsZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHBhZ2Ugc2l6ZSB1c2VkIGJ5IHRoZSBUcmVlTGlzdCB3aGVuIFtwYWdpbmddKHslIHNsdWcgcGFnaW5nX3RyZWVsaXN0ICV9KSBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgMTBcbiAgICAgKi9cbiAgICBwYWdlU2l6ZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGhlaWdodCAoaW4gcGl4ZWxzKSB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgYHNjcm9sbGFibGVgIG9wdGlvbiBvZiB0aGUgVHJlZUxpc3QgaXMgc2V0LlxuICAgICAqIFRvIHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBUcmVlTGlzdCwgeW91IGNhbiBhbHNvIHVzZSBgc3R5bGUuaGVpZ2h0YC4gVGhlIGBzdHlsZS5oZWlnaHRgXG4gICAgICogb3B0aW9uIHN1cHBvcnRzIHVuaXRzIHN1Y2ggYXMgYHB4YCwgYCVgLCBgZW1gLCBgcmVtYCwgYW5kIG90aGVycy5cbiAgICAgKi9cbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSByb3cgaGVpZ2h0IHRoYXQgaXMgdXNlZCB3aGVuIHRoZSBgc2Nyb2xsYWJsZWAgb3B0aW9uIG9mIHRoZSBUcmVlTGlzdCBpcyBzZXQgdG8gYHZpcnR1YWxgLlxuICAgICAqIFJlcXVpcmVkIGJ5IHRoZSBbdmlydHVhbCBzY3JvbGxpbmcgZnVuY3Rpb25hbGl0eV0oeyUgc2x1ZyBzY3JvbGxtbW9kZXNfdHJlZWxpc3QgJX0pLlxuICAgICAqL1xuICAgIHJvd0hlaWdodDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG51bWJlciBvZiByZWNvcmRzIHRvIGJlIHNraXBwZWQgYnkgdGhlIHBhZ2VyLlxuICAgICAqIFJlcXVpcmVkIGJ5IHRoZSBbcGFnaW5nXSh7JSBzbHVnIHBhZ2luZ190cmVlbGlzdCAlfSkgZnVuY3Rpb25hbGl0eS5cbiAgICAgKi9cbiAgICBza2lwOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgc2Nyb2xsIG1vZGUgdXNlZCBieSB0aGUgVHJlZUxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqICAtIGBub25lYCZtZGFzaDtSZW5kZXJzIG5vIHNjcm9sbGJhci5cbiAgICAgKiAgLSBgc2Nyb2xsYWJsZWAmbWRhc2g7VGhlIGRlZmF1bHQgc2Nyb2xsIG1vZGUuIEl0IHJlcXVpcmVzIHRoZSBzZXR0aW5nIG9mIHRoZSBgaGVpZ2h0YCBvcHRpb24uXG4gICAgICovXG4gICAgc2Nyb2xsYWJsZTogU2Nyb2xsTW9kZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRvcnMgYnkgd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBzb3J0ZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzb3J0aW5nX3RyZWVsaXN0ICV9KSkuXG4gICAgICovXG4gICAgc29ydDogQXJyYXk8U29ydERlc2NyaXB0b3I+O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGhvdyB0byB0cmFjayBjaGFuZ2VzIGZvciB0aGUgZGF0YSByb3dzLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIFRyZWVMaXN0IHRyYWNrcyBjaGFuZ2VzIGJ5IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBpdGVtLlxuICAgICAqIEVkaXRlZCByb3dzIGFyZSB0cmFja2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvcixcbiAgICAgKiBmb3IgZXhhbXBsZSwgd2hlbiB5b3UgaW1wbGVtZW50IGVkaXRpbmcgd2l0aCBpbW11dGFibGUgZGF0YSBpdGVtcy5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZXMgaG93IHRvIHRyYWNrIGl0ZW1zIG9ubHkgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHsgVHJlZUxpc3RJdGVtIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZWxpc3QnO1xuICAgICAqXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICAgICA8a2VuZG8tdHJlZWxpc3QgW2RhdGFdPVwidHJlZWxpc3REYXRhXCIgW3RyYWNrQnldPVwidHJhY2tCeVwiPlxuICAgICAqICAgICAgICA8L2tlbmRvLXRyZWVsaXN0PlxuICAgICAqICAgIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgcHVibGljIHRyZWVsaXN0RGF0YTogYW55W10gPSBwcm9kdWN0cztcbiAgICAgKlxuICAgICAqICAgIHB1YmxpYyB0cmFja0J5KGluZGV4OiBudW1iZXIsIGl0ZW06IFRyZWVMaXN0SXRlbSk6IGFueSB7XG4gICAgICogICAgICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xuICAgICAqICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gICAgICogIH0sIHtcbiAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE5LjAwMDAsXG4gICAgICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAgICAgKiAgfVxuICAgICAqIF07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdHJhY2tCeTogVHJhY2tCeUZ1bmN0aW9uPFRyZWVMaXN0SXRlbT47XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0b3IgYnkgd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBmaWx0ZXJlZCAoW3NlZSBleGFtcGxlc10oeyUgc2x1ZyBmaWx0ZXJpbmdfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBmaWx0ZXI6IENvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3I7XG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHRyZWVsaXN0IHdpbGwgcmVuZGVyIG9ubHkgdGhlIGNvbHVtbnMgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICovXG4gICAgdmlydHVhbENvbHVtbnM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNob3dUb3BUb29sYmFyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWFkb25seSBzaG93Qm90dG9tVG9vbGJhcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaXNMb2NrZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNob3dQYWdlcjogYm9vbGVhbjtcbiAgICByZWFkb25seSBtYXJxdWVlU2VsZWN0aW9uOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIFtmaWx0ZXJpbmddKHslIHNsdWcgZmlsdGVyaW5nX3RyZWVsaXN0ICV9KSBvZiB0aGUgVHJlZUxpc3QgY29sdW1ucyB0aGF0IGhhdmUgdGhlaXIgYGZpZWxkYCBvcHRpb24gc2V0LlxuICAgICAqL1xuICAgIGZpbHRlcmFibGU6IEZpbHRlcmFibGVTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBbc29ydGluZ10oeyUgc2x1ZyBzb3J0aW5nX3RyZWVsaXN0ICV9KSBvZiB0aGUgVHJlZUxpc3QgY29sdW1ucyB0aGF0IGhhdmUgdGhlaXIgYGZpZWxkYCBvcHRpb24gc2V0LlxuICAgICAqL1xuICAgIHNvcnRhYmxlOiBTb3J0U2V0dGluZ3M7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgcGFnZXIgb2YgdGhlIFRyZWVMaXN0IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFnaW5nX3RyZWVsaXN0ICV9KSkuXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAqIC0gYGJ1dHRvbkNvdW50OiBOdW1iZXJgJm1kYXNoO1NldHMgdGhlIG1heGltdW0gbnVtZXJpYyBidXR0b25zIGNvdW50IGJlZm9yZSB0aGUgYnV0dG9ucyBhcmUgY29sbGFwc2VkLlxuICAgICAqIC0gYGluZm86IEJvb2xlYW5gJm1kYXNoO1RvZ2dsZXMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHBhZ2UgYW5kIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkcy5cbiAgICAgKiAtIGB0eXBlOiBQYWdlclR5cGVgJm1kYXNoO0FjY2VwdHMgdGhlIGBudW1lcmljYCAoYnV0dG9ucyB3aXRoIG51bWJlcnMpIGFuZCBgaW5wdXRgIChpbnB1dCBmb3IgdHlwaW5nIHRoZSBwYWdlIG51bWJlcikgdmFsdWVzLlxuICAgICAqIC0gYHBhZ2VTaXplczogQm9vbGVhbmAgb3IgYEFycmF5PG51bWJlcj5gJm1kYXNoO1Nob3dzIGEgbWVudSBmb3Igc2VsZWN0aW5nIHRoZSBwYWdlIHNpemUuXG4gICAgICogLSBgcHJldmlvdXNOZXh0OiBCb29sZWFuYCZtZGFzaDtUb2dnbGVzIHRoZSAqKlByZXZpb3VzKiogYW5kICoqTmV4dCoqIGJ1dHRvbnMuXG4gICAgICovXG4gICAgcGFnZWFibGU6IFBhZ2VyU2V0dGluZ3MgfCBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB1c2VyIGNhbiB1c2UgZGVkaWNhdGVkIHNob3J0Y3V0cyB0byBpbnRlcmFjdCB3aXRoIHRoZSBUcmVlTGlzdC5cbiAgICAgKiBCeSBkZWZhdWx0LCBuYXZpZ2F0aW9uIGlzIGRpc2FibGVkIGFuZCB0aGUgVHJlZUxpc3QgY29udGVudCBpcyBhY2Nlc3NpYmxlIGluIHRoZSBub3JtYWwgdGFiIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIG5hdmlnYWJsZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBBbiBhbGlhcyBmb3IgYG5hdmlnYWJsZWAgZm9yIHVzZXJzIHdobyBtaWdyYXRlIGZyb20gS2VuZG8gVUkgZm9yIGpRdWVyeS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIG5hdmlnYXRhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBUcmVlTGlzdCBjb2x1bW5zIHdpbGwgYmUgcmVzaXplZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gc28gdGhhdFxuICAgICAqIHRoZXkgZml0IHRoZWlyIGhlYWRlcnMgYW5kIHJvdyBjb250ZW50LiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqIENvbHVtbnMgd2l0aCBgYXV0b1NpemVgIHNldCB0byBgZmFsc2VgIGFyZSBleGNsdWRlZC5cbiAgICAgKiBUbyBkeW5hbWljYWxseSB1cGRhdGUgdGhlIGNvbHVtbiB3aWR0aCB0byBtYXRjaCB0aGUgbmV3IGNvbnRlbnQsXG4gICAgICogcmVmZXIgdG8gW3RoaXMgZXhhbXBsZV0oeyUgc2x1ZyByZXNpemluZ19jb2x1bW5zX3RyZWVsaXN0ICV9KS5cbiAgICAgKi9cbiAgICBhdXRvU2l6ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBmb3IgZXZlcnkgZGF0YSByb3cgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHsgUm93Q2xhc3NBcmdzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZWxpc3QnO1xuICAgICAqXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAqICAgIHN0eWxlczogW2BcbiAgICAgKiAgICAgICAgLmstdHJlZWxpc3QgdHIuZXZlbiB7IGJhY2tncm91bmQtY29sb3I6ICNmNDVjNDI7IH1cbiAgICAgKiAgICAgICAgLmstdHJlZWxpc3QgdHIub2RkIHsgYmFja2dyb3VuZC1jb2xvcjogIzQxZjRkZjsgfVxuICAgICAqICAgIGBdLFxuICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICAgIDxrZW5kby10cmVlbGlzdCBbZGF0YV09XCJ0cmVlbGlzdERhdGFcIiBbcm93Q2xhc3NdPVwicm93Q2FsbGJhY2tcIj5cbiAgICAgKiAgICAgICAgPC9rZW5kby10cmVlbGlzdD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyB0cmVlbGlzdERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICpcbiAgICAgKiAgICBwdWJsaWMgcm93Q2FsbGJhY2soY29udGV4dDogUm93Q2xhc3NBcmdzKSB7XG4gICAgICogICAgICAgIGNvbnN0IGlzRXZlbiA9IGNvbnRleHQuaW5kZXggJSAyID09IDA7XG4gICAgICogICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICAgICBldmVuOiBpc0V2ZW4sXG4gICAgICogICAgICAgICAgICBvZGQ6ICFpc0V2ZW5cbiAgICAgKiAgICAgICAgfTtcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByb3dDbGFzczogUm93Q2xhc3NGbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBjZWxsIChpZiBhbnkpLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGFjdGl2ZUNlbGw6IE5hdmlnYXRpb25DZWxsO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBmb2N1c2VkIHJvdyAoaWYgYW55KS5cbiAgICAgKi9cbiAgICByZWFkb25seSBhY3RpdmVSb3c6IE5hdmlnYXRpb25Sb3c7XG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHVzZXIgY2FuIHJlc2l6ZSBjb2x1bW5zIGJ5IGRyYWdnaW5nIHRoZSBlZGdlcyAocmVzaXplIGhhbmRsZXMpIG9mIHRoZWlyIGhlYWRlciBjZWxsc1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcmVzaXppbmdfY29sdW1uc190cmVlbGlzdCAlfSkpLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByZXNpemFibGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHVzZXIgY2FuIHJlb3JkZXIgY29sdW1ucyBieSBkcmFnZ2luZyB0aGVpciBoZWFkZXIgY2VsbHNcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJlb3JkZXJpbmdfY29sdW1uc190cmVlbGlzdCAlfSkpLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByZW9yZGVyYWJsZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIG9mIHRoZSBUcmVlTGlzdCB3aWxsIGJlIGRpc3BsYXllZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX3RyZWVsaXN0ICV9KSkuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGxvYWRpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBjb2x1bW4gbWVudSBvZiB0aGUgY29sdW1ucyB3aWxsIGJlIGRpc3BsYXllZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbm1lbnVfdHJlZWxpc3QgJX0pKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgY29sdW1uTWVudTogYm9vbGVhbiB8IENvbHVtbk1lbnVTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGhlYWRlciBvZiB0aGUgdHJlZWxpc3Qgd2lsbCBiZSBoaWRkZW4uIFRoZSBoZWFkZXIgaXMgdmlzaWJsZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogPiBUaGUgaGVhZGVyIGluY2x1ZGVzIGNvbHVtbiBoZWFkZXJzIGFuZCB0aGUgW2ZpbHRlciByb3ddKHslIHNsdWcgZmlsdGVyaW5nX3RyZWVsaXN0ICV9I3RvYy1maWx0ZXItcm93KS5cbiAgICAgKi9cbiAgICBoaWRlSGVhZGVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBcImlkXCJcbiAgICAgKi9cbiAgICBpZEZpZWxkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVkIHRoZSB0cmVlbGlzdCBzZWxlY3Rpb24gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlOiBib29sZWFuIHwgU2VsZWN0YWJsZVNldHRpbmdzO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgY2FsbGJhY2sgdGhhdCBkZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByb3cgLyBjZWxsIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IElzU2VsZWN0ZWRGbjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBUcmVlTGlzdCBzZWxlY3Rpb24gaXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxTZWxlY3Rpb25DaGFuZ2VFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgVHJlZUxpc3QgZmlsdGVyIGlzIG1vZGlmaWVkIHRocm91Z2ggdGhlIFVJLlxuICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgZXZlbnQgeW91cnNlbGYgYW5kIGZpbHRlciB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBmaWx0ZXJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxDb21wb3NpdGVGaWx0ZXJEZXNjcmlwdG9yPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYWdlIG9mIHRoZSBUcmVlTGlzdCBpcyBjaGFuZ2VkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFnaW5nX3RyZWVsaXN0ICV9KSkuXG4gICAgICogWW91IGhhdmUgdG8gaGFuZGxlIHRoZSBldmVudCB5b3Vyc2VsZiBhbmQgcGFnZSB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBwYWdlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8UGFnZUNoYW5nZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzb3J0aW5nIG9mIHRoZSBUcmVlTGlzdCBpcyBjaGFuZ2VkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc29ydGluZ190cmVlbGlzdCAlfSkpLlxuICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgZXZlbnQgeW91cnNlbGYgYW5kIHNvcnQgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc29ydENoYW5nZTogRXZlbnRFbWl0dGVyPEFycmF5PFNvcnREZXNjcmlwdG9yPj47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgZGF0YSBzdGF0ZSBvZiB0aGUgVHJlZUxpc3QgaXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBkYXRhU3RhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRhU3RhdGVDaGFuZ2VFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqRWRpdCoqIGNvbW1hbmQgYnV0dG9uIHRvIGVkaXQgYSByb3dcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfdHJlZWxpc3QgJX0jdG9jLWVkaXRpbmctcmVjb3JkcykpLlxuICAgICAqL1xuICAgIGVkaXQ6IEV2ZW50RW1pdHRlcjxFZGl0RXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKkNhbmNlbCoqIGNvbW1hbmQgYnV0dG9uIHRvIGNsb3NlIGEgcm93XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX3RyZWVsaXN0ICV9I3RvYy1jYW5jZWxsaW5nLWVkaXRpbmcpKS5cbiAgICAgKi9cbiAgICBjYW5jZWw6IEV2ZW50RW1pdHRlcjxDYW5jZWxFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqU2F2ZSoqIGNvbW1hbmQgYnV0dG9uIHRvIHNhdmUgY2hhbmdlcyBpbiBhIHJvd1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2Mtc2F2aW5nLXJlY29yZHMpKS5cbiAgICAgKi9cbiAgICBzYXZlOiBFdmVudEVtaXR0ZXI8U2F2ZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgKipSZW1vdmUqKiBjb21tYW5kIGJ1dHRvbiB0byByZW1vdmUgYSByb3dcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfdHJlZWxpc3QgJX0jdG9jLXJlbW92aW5nLXJlY29yZHMpKS5cbiAgICAgKi9cbiAgICByZW1vdmU6IEV2ZW50RW1pdHRlcjxSZW1vdmVFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqQWRkKiogY29tbWFuZCBidXR0b24gdG8gYWRkIGEgbmV3IHJvd1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2MtYWRkaW5nLXJlY29yZHMpKS5cbiAgICAgKi9cbiAgICBhZGQ6IEV2ZW50RW1pdHRlcjxBZGRFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBsZWF2ZXMgYW4gZWRpdGVkIGNlbGwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2luY2VsbF90cmVlbGlzdCAlfSN0b2MtYmFzaWMtY29uY2VwdHMpKS5cbiAgICAgKi9cbiAgICBjZWxsQ2xvc2U6IEV2ZW50RW1pdHRlcjxDZWxsQ2xvc2VFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBjZWxsIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ19pbmNlbGxfdHJlZWxpc3QgJX0jdG9jLWJhc2ljLWNvbmNlcHRzKSkuXG4gICAgICovXG4gICAgY2VsbENsaWNrOiBFdmVudEVtaXR0ZXI8Q2VsbENsaWNrRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKkV4cG9ydCB0byBQREYqKiBjb21tYW5kIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBwZGZFeHBvcnQ6IEV2ZW50RW1pdHRlcjxQREZFeHBvcnRFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqRXhwb3J0IHRvIEV4Y2VsKiogY29tbWFuZCBidXR0b24uXG4gICAgICovXG4gICAgZXhjZWxFeHBvcnQ6IEV2ZW50RW1pdHRlcjxFeGNlbEV4cG9ydEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgcmVzaXppbmcgb2YgdGhlIGNvbHVtbi5cbiAgICAgKi9cbiAgICBjb2x1bW5SZXNpemU6IEV2ZW50RW1pdHRlcjxBcnJheTxDb2x1bW5SZXNpemVBcmdzPj47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIHJlb3JkZXJpbmcgb2YgdGhlIGNvbHVtbi5cbiAgICAgKi9cbiAgICBjb2x1bW5SZW9yZGVyOiBFdmVudEVtaXR0ZXI8Q29sdW1uUmVvcmRlckV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbHVtbnMgZnJvbSB0aGUgY29sdW1uIG1lbnUgb3IgY29sdW1uIGNob29zZXIuXG4gICAgICovXG4gICAgY29sdW1uVmlzaWJpbGl0eUNoYW5nZTogRXZlbnRFbWl0dGVyPENvbHVtblZpc2liaWxpdHlDaGFuZ2VFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBsb2NrZWQgc3RhdGUgb2YgdGhlIGNvbHVtbnMgZnJvbSB0aGUgY29sdW1uIG1lbnUgb3IgYnkgcmVvcmRlcmluZyB0aGUgY29sdW1ucy5cbiAgICAgKi9cbiAgICBjb2x1bW5Mb2NrZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxDb2x1bW5Mb2NrZWRDaGFuZ2VFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBzY3JvbGxzIHRvIHRoZSBsYXN0IHJlY29yZCBvbiB0aGUgcGFnZSBhbmQgZW5hYmxlcyBlbmRsZXNzIHNjcm9sbGluZ1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2Nyb2xsbW1vZGVzX3RyZWVsaXN0ICV9I3RvYy1lbmRsZXNzLXNjcm9sbGluZykpLlxuICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgZXZlbnQgeW91cnNlbGYgYW5kIHBhZ2UgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2Nyb2xsQm90dG9tOiBFdmVudEVtaXR0ZXI8U2Nyb2xsQm90dG9tRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHRyZWVsaXN0IGNvbnRlbnQgaXMgc2Nyb2xsZWQuXG4gICAgICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQgb3V0c2lkZSB0aGUgQW5ndWxhciB6b25lLiBFbnRlciB0aGUgQW5ndWxhciB6b25lIGlmIHlvdSBtYWtlIGFueSBjaGFuZ2VzIHRoYXQgcmVxdWlyZSBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqL1xuICAgIGNvbnRlbnRTY3JvbGw6IEV2ZW50RW1pdHRlcjxDb250ZW50U2Nyb2xsRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gYW4gaXRlbSBpcyBleHBhbmRlZC5cbiAgICAgKi9cbiAgICBleHBhbmRFdmVudDogRXZlbnRFbWl0dGVyPEV4cGFuZEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGFuIGl0ZW0gaXMgY29sbGFwc2VkLlxuICAgICAqL1xuICAgIGNvbGxhcHNlRXZlbnQ6IEV2ZW50RW1pdHRlcjxFeHBhbmRFdmVudD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGV4cGFuZFN0YXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RXhwYW5kRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb2x1bW5PcmRlckNoYW5nZTogRXZlbnRFbWl0dGVyPENvbHVtblJlb3JkZXJFdmVudD47XG4gICAgLyoqXG4gICAgICogQSBxdWVyeSBsaXN0IG9mIGFsbCBkZWNsYXJlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGNvbHVtbnM6IFF1ZXJ5TGlzdDxDb2x1bW5CYXNlPjtcbiAgICByZWFkb25seSBkaXI6IHN0cmluZztcbiAgICByZWFkb25seSBob3N0Q2xhc3NlczogYm9vbGVhbjtcbiAgICByZWFkb25seSBsb2NrZWRDbGFzc2VzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHZpcnR1YWxDbGFzc2VzOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IG5vU2Nyb2xsYmFyQ2xhc3M6IGJvb2xlYW47XG4gICAgbm9SZWNvcmRzVGVtcGxhdGVDaGlsZHJlbjogUXVlcnlMaXN0PE5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlPjtcbiAgICBub1JlY29yZHNUZW1wbGF0ZTogTm9SZWNvcmRzVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgcGFnZXJUZW1wbGF0ZUNoaWxkcmVuOiBRdWVyeUxpc3Q8UGFnZXJUZW1wbGF0ZURpcmVjdGl2ZT47XG4gICAgcGFnZXJUZW1wbGF0ZTogUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICB0b29sYmFyVGVtcGxhdGVDaGlsZHJlbjogUXVlcnlMaXN0PFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZT47XG4gICAgdG9vbGJhclRlbXBsYXRlOiBUb29sYmFyVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgY29sdW1uTWVudVRlbXBsYXRlczogUXVlcnlMaXN0PENvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZT47XG4gICAgbG9ja2VkSGVhZGVyOiBhbnk7XG4gICAgaGVhZGVyOiBhbnk7XG4gICAgZm9vdGVyOiBRdWVyeUxpc3Q8YW55PjtcbiAgICBhcmlhUm9vdDogRWxlbWVudFJlZjtcbiAgICByZWFkb25seSBzY3JvbGxiYXJXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGhlYWRlclBhZGRpbmc6IGFueTtcbiAgICBjb2x1bW5NZW51T3B0aW9uczogYW55O1xuICAgIGNvbHVtbkxpc3Q6IENvbHVtbkxpc3Q7XG4gICAgY29sdW1uc0NvbnRhaW5lcjogQ29sdW1uc0NvbnRhaW5lcjtcbiAgICByZWFkb25seSBzaG93TG9hZGluZzogYm9vbGVhbjtcbiAgICByZWFkb25seSBzaG93Rm9vdGVyOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGFyaWFSb3dDb3VudDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGFyaWFDb2xDb3VudDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGFyaWFNdWx0aXNlbGVjdGFibGU6IGFueTtcbiAgICByZWFkb25seSBpc1ZpcnR1YWw6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgaXNTY3JvbGxhYmxlOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHZpc2libGVDb2x1bW5zOiBRdWVyeUxpc3Q8Q29sdW1uQmFzZT47XG4gICAgcmVhZG9ubHkgbG9ja2VkQ29sdW1uczogUXVlcnlMaXN0PENvbHVtbkJhc2U+O1xuICAgIHJlYWRvbmx5IG5vbkxvY2tlZENvbHVtbnM6IFF1ZXJ5TGlzdDxDb2x1bW5CYXNlPjtcbiAgICByZWFkb25seSBsb2NrZWRMZWFmQ29sdW1uczogUXVlcnlMaXN0PENvbHVtbkJhc2U+O1xuICAgIHJlYWRvbmx5IG5vbkxvY2tlZExlYWZDb2x1bW5zOiBRdWVyeUxpc3Q8Q29sdW1uQmFzZT47XG4gICAgcmVhZG9ubHkgbGVhZkNvbHVtbnM6IFF1ZXJ5TGlzdDxDb2x1bW5CYXNlPjtcbiAgICByZWFkb25seSB0b3RhbENvbHVtbkxldmVsczogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGhlYWRlckNvbHVtbnM6IGFueTtcbiAgICByZWFkb25seSBoZWFkZXJMZWFmQ29sdW1uczogYW55O1xuICAgIHJlYWRvbmx5IGxvY2tlZFdpZHRoOiBudW1iZXI7XG4gICAgcmVhZG9ubHkgbm9uTG9ja2VkV2lkdGg6IG51bWJlcjtcbiAgICByZWFkb25seSBjb2x1bW5NZW51VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgcmVhZG9ubHkgdG90YWxDb3VudDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZXMgdGhlIGNoaWxkIG5vZGVzIGZvciBhIHBhcnRpY3VsYXIgbm9kZS5cbiAgICAgKi9cbiAgICBmZXRjaENoaWxkcmVuOiAobm9kZTogYW55KSA9PiBPYnNlcnZhYmxlPGFueVtdPiB8IGFueVtdO1xuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpbmRpY2F0ZXMgaWYgYSBwYXJ0aWN1bGFyIG5vZGUgaGFzIGNoaWxkIG5vZGVzLlxuICAgICAqL1xuICAgIGhhc0NoaWxkcmVuOiAobm9kZTogYW55KSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaW5kaWNhdGVzIGlmIGEgcGFydGljdWxhciBpdGVtIGlzIGV4cGFuZGVkLlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQ6IChub2RlOiBhbnkpID0+IGJvb2xlYW47XG4gICAgaWRHZXR0ZXI6IGFueTtcbiAgICBsb2NhbEVkaXRTZXJ2aWNlOiBhbnk7XG4gICAgdmlldzogVmlld0NvbGxlY3Rpb247XG4gICAgZXhwYW5kSWNvbnM6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBkYXRhQ2hhbmdlZDtcbiAgICBwcml2YXRlIGxvYWRlZERhdGE7XG4gICAgcHJpdmF0ZSBfZmV0Y2hDaGlsZHJlbjtcbiAgICBwcml2YXRlIF9oYXNDaGlsZHJlbjtcbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM7XG4gICAgcHJpdmF0ZSBkYXRhTG9hZGVkU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgZm9jdXNFbGVtZW50U3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgZGV0YWNoRWxlbWVudEV2ZW50SGFuZGxlcnM7XG4gICAgcHJpdmF0ZSBydGw7XG4gICAgcHJpdmF0ZSBzaG91bGRHZW5lcmF0ZUNvbHVtbnM7XG4gICAgcHJpdmF0ZSBkaXJlY3Rpb247XG4gICAgcHJpdmF0ZSBfZGF0YTtcbiAgICBwcml2YXRlIF9zb3J0O1xuICAgIHByaXZhdGUgX3NraXA7XG4gICAgcHJpdmF0ZSBjYWNoZWRXaW5kb3dXaWR0aDtcbiAgICBwcml2YXRlIF9jdXN0b21Ob1JlY29yZHNUZW1wbGF0ZTtcbiAgICBwcml2YXRlIF9jdXN0b21QYWdlclRlbXBsYXRlO1xuICAgIHByaXZhdGUgX2N1c3RvbVRvb2xiYXJUZW1wbGF0ZTtcbiAgICBwcml2YXRlIGxlYWZWaWV3cG9ydENvbHVtbnM7XG4gICAgcHJpdmF0ZSB2aWV3cG9ydENvbHVtbnM7XG4gICAgcHJpdmF0ZSBwYWdlQ2hhbmdlVGltZW91dDtcbiAgICBjb25zdHJ1Y3RvcihzdXBwb3J0U2VydmljZTogQnJvd3NlclN1cHBvcnRTZXJ2aWNlLCB3cmFwcGVyOiBFbGVtZW50UmVmLCBjaGFuZ2VOb3RpZmljYXRpb246IENoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UsIGVkaXRTZXJ2aWNlOiBFZGl0U2VydmljZSwgZmlsdGVyU2VydmljZTogRmlsdGVyU2VydmljZSwgcGRmU2VydmljZTogUERGU2VydmljZSwgcmVzcG9uc2l2ZVNlcnZpY2U6IFJlc3BvbnNpdmVTZXJ2aWNlLCByZW5kZXJlcjogUmVuZGVyZXIyLCBleGNlbFNlcnZpY2U6IEV4Y2VsU2VydmljZSwgbmdab25lOiBOZ1pvbmUsIHNjcm9sbFN5bmNTZXJ2aWNlOiBTY3JvbGxTeW5jU2VydmljZSwgZG9tRXZlbnRzOiBEb21FdmVudHNTZXJ2aWNlLCBjb2x1bW5SZXNpemluZ1NlcnZpY2U6IENvbHVtblJlc2l6aW5nU2VydmljZSwgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBjb2x1bW5SZW9yZGVyU2VydmljZTogQ29sdW1uUmVvcmRlclNlcnZpY2UsIGNvbHVtbkluZm9TZXJ2aWNlOiBDb2x1bW5JbmZvU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2U6IE5hdmlnYXRpb25TZXJ2aWNlLCBzb3J0U2VydmljZTogU29ydFNlcnZpY2UsIHNjcm9sbFJlcXVlc3RTZXJ2aWNlOiBTY3JvbGxSZXF1ZXN0U2VydmljZSwgZXhwYW5kU3RhdGVTZXJ2aWNlOiBFeHBhbmRTdGF0ZVNlcnZpY2UsIG9wdGlvbkNoYW5nZXM6IE9wdGlvbkNoYW5nZXNTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlLCBsb2NhbGl6YXRpb246IExvY2FsaXphdGlvblNlcnZpY2UpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2aWV3RmllbGRBY2Nlc3NvcigpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRGF0YUNoYW5nZSgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHtcbiAgICAgICAgW3Byb3BlcnR5TmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlO1xuICAgIH0pOiB2b2lkO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpOiB2b2lkO1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYXR0YWNoU2Nyb2xsU3luYygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSBzcGVjaWZpZWQgdGFibGUgcm93IGluIHRoZSBlZGl0IG1vZGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX3RyZWVsaXN0ICV9I3RvYy1lZGl0aW5nLXJlY29yZHMpKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSByb3cgaW5kZXggdGhhdCB3aWxsIGJlIHN3aXRjaGVkIGluIHRoZSBlZGl0IG1vZGUuXG4gICAgICogQHBhcmFtIGdyb3VwIC0gVGhlIFtgRm9ybUdyb3VwYF0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnZm9ybWdyb3VwYXBpJ10gfX0pXG4gICAgICogdGhhdCBkZXNjcmliZXMgdGhlIGVkaXQgZm9ybS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy4gVXNlIHNraXBGb2N1cyB0byBkZXRlcm1pbmUgaWYgdGhlIHJvdydzIGVkaXQgZWxlbWVudCBzaG91bGQgYmUgZm9jdXNlZC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgKi9cbiAgICBlZGl0Um93KGl0ZW06IGFueSwgZ3JvdXA/OiBhbnksIG9wdGlvbnM/OiB7XG4gICAgICAgIFtza2lwRm9jdXM6IHN0cmluZ106IGJvb2xlYW47XG4gICAgfSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBlZGl0b3IgZm9yIGEgZ2l2ZW4gcm93IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2MtY2FuY2VsbGluZy1lZGl0aW5nKSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgcm93IGluZGV4IHRoYXQgd2lsbCBiZSBzd2l0Y2hlZCBvdXQgb2YgdGhlIGVkaXQgbW9kZS4gSWYgbm8gaW5kZXggaXMgcHJvdmlkZWQsIGl0IGlzIGFzc3VtZWRcbiAgICAgKiB0aGF0IHRoZSBuZXcgaXRlbSBlZGl0b3Igd2lsbCBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgY2xvc2VSb3coaXRlbTogYW55LCBpc05ldzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByb3cgZWRpdG9yIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2MtYWRkaW5nLXJlY29yZHMpKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Rm9ybUdyb3VwfSBncm91cCAtIFRoZSBbYEZvcm1Hcm91cGBdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ2Zvcm1ncm91cGFwaSddIH19KSB0aGF0IGRlc2NyaWJlc1xuICAgICAqIHRoZSBlZGl0IGZvcm0uIElmIGNhbGxlZCB3aXRoIGEgZGF0YSBpdGVtLCBpdCB3aWxsIGJ1aWxkIHRoZSBgRm9ybUdyb3VwYCBmcm9tIHRoZSBkYXRhIGl0ZW0gZmllbGRzLlxuICAgICAqL1xuICAgIGFkZFJvdyhncm91cDogYW55LCBwYXJlbnQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFB1dHMgdGhlIGNlbGwgdGhhdCBpcyBzcGVjaWZpZWQgYnkgdGhlIHRhYmxlIHJvdyBhbmQgY29sdW1uIGluIGVkaXQgbW9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSBkYXRhIHJvdyBpbmRleCB0aGF0IHdpbGwgYmUgc3dpdGNoZWQgaW4gdGhlIGVkaXQgbW9kZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8YW55fSBjb2x1bW4gLSBUaGUgbGVhZiBjb2x1bW4gaW5kZXgsIG9yIHRoZSBmaWVsZCBuYW1lIG9yIHRoZSBjb2x1bW4gaW5zdGFuY2UgdGhhdCBzaG91bGQgYmUgZWRpdGVkLlxuICAgICAqIEBwYXJhbSB7Rm9ybUdyb3VwfSBncm91cCAtIFRoZSBbYEZvcm1Hcm91cGBdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ2Zvcm1ncm91cGFwaSddIH19KVxuICAgICAqIHRoYXQgZGVzY3JpYmVzIHRoZSBlZGl0IGZvcm0uXG4gICAgICovXG4gICAgZWRpdENlbGwoZGF0YUl0ZW06IGFueSwgY29sdW1uOiBudW1iZXIgfCBzdHJpbmcgfCBhbnksIGdyb3VwPzogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgY2VsbCBpbiBlZGl0IG1vZGUgYW5kIGZpcmVzXG4gICAgICogdGhlIFtgY2VsbENsb3NlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfdHJlZWxpc3Rjb21wb25lbnQgJX0jdG9jLWNlbGxjbG9zZSkgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZWRpdGVkIGNlbGwgd2FzIGNsb3NlZC5cbiAgICAgKiBBIGBmYWxzZWAgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlXG4gICAgICogW2BjZWxsQ2xvc2VgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF90cmVlbGlzdGNvbXBvbmVudCAlfSN0b2MtY2VsbGNsb3NlKSBldmVudCB3YXMgcHJldmVudGVkLlxuICAgICAqL1xuICAgIGNsb3NlQ2VsbCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY3VycmVudCBjZWxsIGluIGVkaXQgbW9kZS5cbiAgICAgKi9cbiAgICBjYW5jZWxDZWxsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGEgcm93IG9yIGEgY2VsbCBpcyBjdXJyZW50bHkgZWRpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQSBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhIHJvdyBvciBhIGNlbGwgaXMgY3VycmVudGx5IGVkaXRlZC5cbiAgICAgKi9cbiAgICBpc0VkaXRpbmcoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYSBjZWxsIGlzIGN1cnJlbnRseSBlZGl0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBBIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGEgY2VsbCBpcyBjdXJyZW50bHkgYmVpbmcgZWRpdGVkLlxuICAgICAqL1xuICAgIGlzRWRpdGluZ0NlbGwoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgdGhlIFBERiBleHBvcnQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwZGZleHBvcnRfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBzYXZlQXNQREYoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBUcmVlTGlzdCBlbGVtZW50IHRvIGEgRHJhd2luZyBbYEdyb3VwYF0oeyUgc2x1ZyBhcGlfa2VuZG8tZHJhd2luZ19ncm91cCAlfSkgYnkgdXNpbmcgdGhlIGBrZW5kby10cmVlbGlzdC1wZGZgIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGRmZXhwb3J0X3RyZWVsaXN0ICV9I3RvYy1leHBvcnRpbmctbXVsdGlwbGUtdHJlZWxpc3RzLXRvLXRoZS1zYW1lLXBkZikpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIERyYXdpbmcgYEdyb3VwYC5cbiAgICAgKi9cbiAgICBkcmF3UERGKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgdGhlIEV4Y2VsIGV4cG9ydCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV4Y2VsZXhwb3J0X3RyZWVsaXN0ICV9KSkuXG4gICAgICovXG4gICAgc2F2ZUFzRXhjZWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBtaW5pbXVtIHBvc3NpYmxlIHdpZHRoIGZvciB0aGUgc3BlY2lmaWVkIGNvbHVtbixcbiAgICAgKiBzbyB0aGF0IHRoZSB3aG9sZSB0ZXh0IGZpdHMgd2l0aG91dCB3cmFwcGluZy4gVGhpcyBtZXRob2QgZXhwZWN0cyB0aGUgVHJlZUxpc3RcbiAgICAgKiB0byBiZSByZXNpemFibGUgKHNldCBgcmVzaXphYmxlYCB0byBgdHJ1ZWApLlxuICAgICAqIE1ha2VzIHNlbnNlIHRvIGV4ZWN1dGUgdGhpcyBtZXRob2Qgb25seVxuICAgICAqIGFmdGVyIHRoZSBUcmVlTGlzdCBpcyBhbHJlYWR5IHBvcHVsYXRlZCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICAgICA8a2VuZG8tdHJlZWxpc3RcbiAgICAgKiAgICAgICAgICAgICN0cmVlbGlzdFxuICAgICAqICAgICAgICAgICAgW2RhdGFdPVwidHJlZWxpc3REYXRhXCJcbiAgICAgKiAgICAgICAgICAgIFtyZXNpemFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMzAwcHhcIj5cbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0VG9vbGJhclRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiay1idXR0b25cIiAoY2xpY2spPVwidHJlZWxpc3QuYXV0b0ZpdENvbHVtbihncm91cENvbHVtbilcIj5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIEF1dG8tZml0IHRoZSBncm91cCBjb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbi1ncm91cCAjZ3JvdXBDb2x1bW4gdGl0bGU9XCJQcm9kdWN0IEluZm9cIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICAgIGZpZWxkPVwiUHJvZHVjdElEXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgW3dpZHRoXT1cIjUwXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgW21pblJlc2l6YWJsZVdpZHRoXT1cIjMwXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJJRFwiPlxuICAgICAqICAgICAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3ROYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uLWdyb3VwPlxuICAgICAqXG4gICAgICogICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJVbml0UHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiVW5pdCBQcmljZVwiXG4gICAgICogICAgICAgICAgICAgICAgW3dpZHRoXT1cIjE4MFwiXG4gICAgICogICAgICAgICAgICAgICAgZmlsdGVyPVwibnVtZXJpY1wiXG4gICAgICogICAgICAgICAgICAgICAgZm9ybWF0PVwiezA6Y31cIj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqICAgICAgICA8L2tlbmRvLXRyZWVsaXN0PlxuICAgICAqICAgIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgcHVibGljIHRyZWVsaXN0RGF0YTogYW55W10gPSBwcm9kdWN0cztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBwcm9kdWN0cyA9IFt7XG4gICAgICogICAgXCJQcm9kdWN0SURcIjogMSxcbiAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gICAgICogICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICAgICAqICB9LCB7XG4gICAgICogICAgXCJQcm9kdWN0SURcIjogMixcbiAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBdO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGF1dG9GaXRDb2x1bW4oY29sdW1uOiBDb2x1bW5CYXNlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSB3aWR0aCBvZiB0aGUgc3BlY2lmaWVkIGNvbHVtbnMgdG8gZml0IHRoZSBlbnRpcmUgY29udGVudCwgaW5jbHVkaW5nIGhlYWRlcnMsIHdpdGhvdXQgd3JhcHBpbmcuXG4gICAgICogSWYgbm8gY29sdW1ucyBhcmUgc3BlY2lmaWVkLCBgYXV0b0ZpdENvbHVtbnNgIGlzIGFwcGxpZWQgdG8gYWxsIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXF1aXJlcyB0aGUgVHJlZUxpc3QgdG8gYmUgcmVzaXphYmxlIChzZXQgYHJlc2l6YWJsZWAgdG8gYHRydWVgKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICA8a2VuZG8tdHJlZWxpc3RcbiAgICAgKiAgICAgICAgICAjdHJlZWxpc3RcbiAgICAgKiAgICAgICAgICBbZGF0YV09XCJ0cmVlbGlzdERhdGFcIlxuICAgICAqICAgICAgICAgIFtyZXNpemFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDMwMHB4XCI+XG4gICAgICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RUb29sYmFyVGVtcGxhdGU+XG4gICAgICogICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJrLWJ1dHRvblwiIChjbGljayk9XCJ0cmVlbGlzdC5hdXRvRml0Q29sdW1ucyhbZmlyc3RDb2x1bW4sIGxhc3RDb2x1bW5dKVwiPlxuICAgICAqICAgICAgICAgICAgICAgICAgQXV0by1maXQgdGhlIGZpcnN0IGFuZCBsYXN0IGNvbHVtblxuICAgICAqICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgKiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cInRyZWVsaXN0LmF1dG9GaXRDb2x1bW5zKClcIj5cbiAgICAgKiAgICAgICAgICAgICAgICAgIEF1dG8tZml0IGFsbCBjb2x1bW5zXG4gICAgICogICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbi1ncm91cCB0aXRsZT1cIlByb2R1Y3QgSW5mb1wiPlxuICAgICAqICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICAjZmlyc3RDb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgIGZpZWxkPVwiUHJvZHVjdElEXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgIFt3aWR0aF09XCI1MFwiXG4gICAgICogICAgICAgICAgICAgICAgICBbbWluUmVzaXphYmxlV2lkdGhdPVwiMzBcIlxuICAgICAqICAgICAgICAgICAgICAgICAgdGl0bGU9XCJJRFwiPlxuICAgICAqICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3ROYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgID5cbiAgICAgKiAgICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICogICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4tZ3JvdXA+XG4gICAgICpcbiAgICAgKiAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICNsYXN0Q29sdW1uXG4gICAgICogICAgICAgICAgICAgIGZpZWxkPVwiVW5pdFByaWNlXCJcbiAgICAgKiAgICAgICAgICAgICAgdGl0bGU9XCJVbml0IFByaWNlXCJcbiAgICAgKiAgICAgICAgICAgICAgW3dpZHRoXT1cIjE4MFwiXG4gICAgICogICAgICAgICAgICAgIGZpbHRlcj1cIm51bWVyaWNcIlxuICAgICAqICAgICAgICAgICAgICBmb3JtYXQ9XCJ7MDpjfVwiPlxuICAgICAqICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqICAgICAgPC9rZW5kby10cmVlbGlzdD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyB0cmVlbGlzdERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhdXRvRml0Q29sdW1ucyhjb2x1bW5zPzogQXJyYXk8Q29sdW1uQmFzZT4gfCBRdWVyeUxpc3Q8Q29sdW1uQmFzZT4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBub3RpZnlQYWdlQ2hhbmdlKHNvdXJjZTogc3RyaW5nLCBldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbm90aWZ5U2Nyb2xsQm90dG9tKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGZvY3VzRWRpdEVsZW1lbnQoY29udGFpbmVyU2VsZWN0b3I6ICgpID0+IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbGFzdCBhY3RpdmUgb3IgdGhlIGZpcnN0IGNlbGwgb2YgdGhlIFRyZWVMaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge05hdmlnYXRpb25DZWxsfSBUaGUgZm9jdXNlZCBjZWxsLlxuICAgICAqL1xuICAgIGZvY3VzKCk6IE5hdmlnYXRpb25DZWxsO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGNlbGwgd2l0aCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uIGluZGV4LlxuICAgICAqXG4gICAgICogVGhlIHJvdyBpbmRleCBpcyBiYXNlZCBvbiB0aGUgbG9naWNhbCBzdHJ1Y3R1cmUgb2YgdGhlIFRyZWVMaXN0IGFuZCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBkYXRhIGl0ZW0gaW5kZXg6XG4gICAgICogKiBIZWFkZXIgcm93cyBhcmUgaW5jbHVkZWQsIHN0YXJ0aW5nIGF0IGluZGV4IDAuXG4gICAgICogKiBUaGUgcm93IGluZGV4aW5nIGlzIGFic29sdXRlIGFuZCBkb2VzIG5vdCBjaGFuZ2Ugd2l0aCBwYWdpbmcuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVHJlZUxpc3QgaXMgY29uZmlndXJlZCBmb3Igc2Nyb2xsaW5nLCBpbmNsdWRpbmcgdmlydHVhbCBzY3JvbGxpbmcsIHRoZSBzY3JvbGwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkLlxuICAgICAqIElmIHRoZSByb3cgaXMgbm90IHByZXNlbnQgb24gdGhlIGN1cnJlbnQgcGFnZSwgdGhlIG1ldGhvZCB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0luZGV4IC0gVGhlIGxvZ2ljYWwgcm93IGluZGV4IHRvIGZvY3VzLiBUaGUgdG9wIGhlYWRlciByb3cgaGFzIGFuIGluZGV4IDAuXG4gICAgICogQHBhcmFtIGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCB0byBmb2N1cy5cbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuXG4gICAgICpcbiAgICAgKi9cbiAgICBmb2N1c0NlbGwocm93SW5kZXg6IG51bWJlciwgY29sSW5kZXg6IG51bWJlcik6IE5hdmlnYXRpb25DZWxsO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG5leHQgY2VsbCwgb3B0aW9uYWxseSB3cmFwcGluZyB0byB0aGUgbmV4dCByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd3JhcCAtIEEgQm9vbGVhbiB2YWx1ZSB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGZvY3VzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCByb3cuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuIElmIHRoZSBmb2N1cyBpcyBhbHJlYWR5IG9uIHRoZSBsYXN0IGNlbGwsIHJldHVybnMgYG51bGxgLlxuICAgICAqL1xuICAgIGZvY3VzTmV4dENlbGwod3JhcD86IGJvb2xlYW4pOiBOYXZpZ2F0aW9uQ2VsbDtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBwcmV2aW91cyBjZWxsLiBPcHRpb25hbGx5IHdyYXBzIHRvIHRoZSBwcmV2aW91cyByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd3JhcCAtIEEgQm9vbGVhbiB2YWx1ZSB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGZvY3VzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCByb3cuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuIElmIHRoZSBmb2N1cyBpcyBhbHJlYWR5IG9uIHRoZSBmaXJzdCBjZWxsLCByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cbiAgICBmb2N1c1ByZXZDZWxsKHdyYXA/OiBib29sZWFuKTogTmF2aWdhdGlvbkNlbGw7XG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXG4gICAgICovXG4gICAgc2Nyb2xsVG8ocmVxdWVzdDogU2Nyb2xsUmVxdWVzdCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNwZWNpZmllZCBjb2x1bW4uXG4gICAgICogVGhlIHJlb3JkZXJpbmcgb2YgY29sdW1ucyBvcGVyYXRlcyBvbmx5IG9uIHRoZSBsZXZlbFxuICAgICAqIHdoaWNoIGlzIGluZmVycmVkIGJ5IHRoZSBzb3VyY2UgY29sdW1uLlxuICAgICAqIEZvciB0aGUgYHJlb3JkZXJDb2x1bW5gIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LFxuICAgICAqIHRoZSBgc291cmNlYCBjb2x1bW4gaGFzIHRvIGJlIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbHVtbkJhc2V9IHNvdXJjZSAtIFRoZSBjb2x1bW4gd2hvc2UgcG9zaXRpb24gd2lsbCBiZSBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0SW5kZXggLSBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtDb2x1bW5SZW9yZGVyQ29uZmlnfSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgICAgPGtlbmRvLXRyZWVsaXN0XG4gICAgICogICAgICAgICAgICAjdHJlZWxpc3RcbiAgICAgKiAgICAgICAgICAgIFtkYXRhXT1cInRyZWVsaXN0RGF0YVwiXG4gICAgICogICAgICAgICAgICBbcmVvcmRlcmFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMzAwcHhcIj5cbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0VG9vbGJhclRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiay1idXR0b25cIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRyZWVsaXN0LnJlb3JkZXJDb2x1bW4oZ3JvdXBDb2x1bW4sIDIsIHsgYmVmb3JlOiB0cnVlIH0pXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgICBNb3ZlIHRoZSBncm91cCBjb2x1bW4gYmVmb3JlIHRoZSBsYXN0IG9uZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbi1ncm91cCAjZ3JvdXBDb2x1bW4gdGl0bGU9XCJQcm9kdWN0IEluZm9cIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICAgIGZpZWxkPVwiUHJvZHVjdElEXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgW3dpZHRoXT1cIjUwXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJJRFwiPlxuICAgICAqICAgICAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3ROYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uLWdyb3VwPlxuICAgICAqXG4gICAgICogICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJVbml0UHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiVW5pdCBQcmljZVwiXG4gICAgICogICAgICAgICAgICAgICAgW3dpZHRoXT1cIjE4MFwiXG4gICAgICogICAgICAgICAgICAgICAgZm9ybWF0PVwiezA6Y31cIj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJEaXNjb250aW51ZWRcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiRGlzY29udGludWVkXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbd2lkdGhdPVwiMTAwXCI+XG4gICAgICogICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgPC9rZW5kby10cmVlbGlzdD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyB0cmVlbGlzdERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZW9yZGVyQ29sdW1uKHNvdXJjZTogQ29sdW1uQmFzZSwgZGVzdEluZGV4OiBudW1iZXIsIG9wdGlvbnM/OiBDb2x1bW5SZW9yZGVyQ29uZmlnKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGFscmVhZHkgbG9hZGVkIGNoaWxkcmVuIGZvciB0aGUgZGF0YUl0ZW0gc28gdGhhdCB0aGUgVHJlZUxpc3Qgd2lsbCBmZXRjaCB0aGVtIGFnYWluIHRoZSBuZXh0IHRpbWUgaXQgaXMgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVsb2FkKGRhdGFJdGVtOiBhbnksIHJlbG9hZENoaWxkcmVuPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldyB3aXRob3V0IHJlbG9hZGluZyB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIENoZWNrcyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGl0ZW1zIGZvciBjaGFuZ2VzIGFuZFxuICAgICAqIHRyaWdnZXJzIHJlLWV2YWx1YXRpb24gb2YgdGhlIHRoZSBbaXNFeHBhbmRlZF0oI3RvYy1pc2V4cGFuZGVkKSBhbmRcbiAgICAgKiBbaXNTZWxlY3RlZF0oI3RvYy1pc1NlbGVjdGVkKSBjYWxsYmFja3MuXG4gICAgICovXG4gICAgdXBkYXRlVmlldygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIHJvdyBmb3IgdGhlIHNwZWNpZmllZCBkYXRhSXRlbS5cbiAgICAgKi9cbiAgICBleHBhbmQoZGF0YUl0ZW06IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSByb3cgZm9yIHRoZSBzcGVjaWZpZWQgZGF0YUl0ZW0uXG4gICAgICovXG4gICAgY29sbGFwc2UoZGF0YUl0ZW06IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgcmVvcmRlcjtcbiAgICBwcml2YXRlIHVwZGF0ZUNvbHVtbkluZGljZXM7XG4gICAgcHJpdmF0ZSB1cGRhdGVJbmRpY2VzRm9yTGV2ZWw7XG4gICAgcHJpdmF0ZSBjb2x1bW5zRm9yTGV2ZWw7XG4gICAgcHJpdmF0ZSBzZXRFZGl0Rm9jdXM7XG4gICAgcHJpdmF0ZSBjb2x1bW5JbnN0YW5jZTtcbiAgICBwcml2YXRlIHZlcmlmeVNldHRpbmdzO1xuICAgIHByaXZhdGUgYXV0b0dlbmVyYXRlQ29sdW1ucztcbiAgICBwcml2YXRlIGF0dGFjaFN0YXRlQ2hhbmdlc0VtaXR0ZXI7XG4gICAgcHJpdmF0ZSBhdHRhY2hFZGl0SGFuZGxlcnM7XG4gICAgcHJpdmF0ZSBlbWl0Q1JVREV2ZW50O1xuICAgIHByaXZhdGUgYXR0YWNoRG9tRXZlbnRIYW5kbGVycztcbiAgICBwcml2YXRlIGF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzO1xuICAgIHByaXZhdGUgbWF0Y2hlc01lZGlhO1xuICAgIHByaXZhdGUgcmVzaXplQ2hlY2s7XG4gICAgcHJpdmF0ZSBlbWl0UERGRXhwb3J0RXZlbnQ7XG4gICAgcHJpdmF0ZSBzeW5jSGVhZGVySGVpZ2h0O1xuICAgIHByaXZhdGUgY29sdW1uc0NvbnRhaW5lckNoYW5nZTtcbiAgICBwcml2YXRlIGhhbmRsZUNvbHVtblJlc2l6ZTtcbiAgICBwcml2YXRlIG5vdGlmeVJlc2l6ZTtcbiAgICBwcml2YXRlIGFzc2VydE5hdmlnYWJsZTtcbiAgICBwcml2YXRlIF9yb3dDbGFzcztcbiAgICBwcml2YXRlIG5hdmlnYXRpb25NZXRhZGF0YTtcbiAgICBwcml2YXRlIHVwZGF0ZU5hdmlnYXRpb25NZXRhZGF0YTtcbiAgICBwcml2YXRlIGFwcGx5QXV0b1NpemU7XG4gICAgcHJpdmF0ZSBvbkNvbHVtblJhbmdlQ2hhbmdlO1xuICAgIHByaXZhdGUgZGF0YUxvYWRlZDtcbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlRGF0YUxvYWRlZDtcbn1cbiJdfQ==