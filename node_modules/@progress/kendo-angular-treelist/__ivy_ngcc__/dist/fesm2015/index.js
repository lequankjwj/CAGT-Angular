/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, TemplateRef, Optional, QueryList, Input, ContentChildren, ContentChild, InjectionToken, EventEmitter, Injectable, Component, forwardRef, SkipSelf, Host, NgZone, ChangeDetectorRef, isDevMode, Renderer2, SecurityContext, ElementRef, ChangeDetectionStrategy, ViewEncapsulation, Output, HostBinding, ViewChild, ViewChildren, Inject, Self, ViewContainerRef, Pipe, NgModule, ComponentFactoryResolver, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { merge, of, fromEvent, BehaviorSubject, Subscription, isObservable, Subject, zip, from, interval, Observable } from 'rxjs';
import { auditTime, take, switchMap, map, distinctUntilChanged, filter, tap, throttleTime, takeUntil, switchMapTo, delay, debounceTime, bufferCount } from 'rxjs/operators';
import { isDocumentAvailable, Keys, hasObservers, anyChanged, isChanged, ResizeSensorComponent, DraggableModule, EventsModule, DraggableDirective, guid, ResizeSensorModule } from '@progress/kendo-angular-common';
import { orderBy, isCompositeFilterDescriptor, process, aggregateBy } from '@progress/kendo-data-query';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
import { DomSanitizer } from '@angular/platform-browser';
import { getter, setter } from '@progress/kendo-common';
import { DropDownListModule, AutoCompleteModule } from '@progress/kendo-angular-dropdowns';
import { InputsModule, NumericTextBoxComponent, NumericTextBoxModule } from '@progress/kendo-angular-inputs';
import { DatePickerModule } from '@progress/kendo-angular-dateinputs';
import { IntlService } from '@progress/kendo-angular-intl';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { Button } from '@progress/kendo-angular-buttons';
import { PDFMarginComponent, PDFTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';
import { saveAs } from '@progress/kendo-file-saver';
import { workbookOptions, toDataURL, ColumnBase, ExcelExportModule } from '@progress/kendo-angular-excel-export';

/**
 * Represents the column cell template of the TreeList ([more information and example]({% slug templates_columns_treelist %}#toc-cell-template)).
 * Helps to customize the content of the cells. To define the cell template, nest an `<ng-template>` tag
 * with the `kendoTreeListCellTemplate` directive inside a `<kendo-treelist-column>` tag.
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex="columnIndex"` syntax.
 * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `dataItem`&mdash;The current data item. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-dataItem`.
 * - `cellContext`&mdash;An object used to pass context information to built-in directives.
 * - `hasChildren`&mdash;Specifies if the item has children.
 * - `isExpanded`&mdash;Specifies if the item is expanded.
 * - `level`&mdash;The hierarchy level of the item.
 * - `loading`&mdash;Specifies if the item children are currently loading.
 * - `rowIndex`&mdash;The current row index. Use it as an alias for a template variable by utilizing the `let-rowIndex="rowIndex"` syntax.
 *
 * {% meta height:470 %}
 * {% embed_file data-binding/hierarchy/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/filesystem.ts %}
 * {% endmeta %}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-popup';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@angular/platform-browser';
import * as ɵngcc4 from '@angular/common';
import * as ɵngcc5 from '@progress/kendo-angular-common';
import * as ɵngcc6 from '@progress/kendo-angular-inputs';
import * as ɵngcc7 from '@angular/forms';
import * as ɵngcc8 from '@progress/kendo-angular-dropdowns';
import * as ɵngcc9 from '@progress/kendo-angular-dateinputs';
import * as ɵngcc10 from '@progress/kendo-angular-intl';

const _c0 = ["lockedHeader"];
const _c1 = ["header"];
const _c2 = ["ariaRoot"];
const _c3 = ["footer"];
var I18N_4;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label visible in the TreeList when there are no records
     * @meaning kendo.treelist.noRecords
     */ 
    const MSG_EXTERNAL_4488616105599925321$$DIST_FESM2015_INDEX_JS_5 = goog.getMsg("No records available.");
    I18N_4 = MSG_EXTERNAL_4488616105599925321$$DIST_FESM2015_INDEX_JS_5;
}
else {
    I18N_4 = $localize `:kendo.treelist.noRecords|The label visible in the TreeList when there are no records␟a79c1279afcbf136c3ddefd1a201af99f4a3c7b5␟4488616105599925321:No records available.`;
}
var I18N_6;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label for the first page button in TreeList pager
     * @meaning kendo.treelist.pagerFirstPage
     */ 
    const MSG_EXTERNAL_4515787389193761237$$DIST_FESM2015_INDEX_JS_7 = goog.getMsg("Go to the first page");
    I18N_6 = MSG_EXTERNAL_4515787389193761237$$DIST_FESM2015_INDEX_JS_7;
}
else {
    I18N_6 = $localize `:kendo.treelist.pagerFirstPage|The label for the first page button in TreeList pager␟0b5adc1a84b662963928aa73f7941cf2a502ca9c␟4515787389193761237:Go to the first page`;
}
var I18N_8;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label for the previous page button in TreeList pager
     * @meaning kendo.treelist.pagerPreviousPage
     */ 
    const MSG_EXTERNAL_225278396462374957$$DIST_FESM2015_INDEX_JS_9 = goog.getMsg("Go to the previous page");
    I18N_8 = MSG_EXTERNAL_225278396462374957$$DIST_FESM2015_INDEX_JS_9;
}
else {
    I18N_8 = $localize `:kendo.treelist.pagerPreviousPage|The label for the previous page button in TreeList pager␟09781b4cad65124a1087c4b05c4f9ec3ae88e165␟225278396462374957:Go to the previous page`;
}
var I18N_10;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label for the next page button in TreeList pager
     * @meaning kendo.treelist.pagerNextPage
     */ 
    const MSG_EXTERNAL_362811891869346548$$DIST_FESM2015_INDEX_JS_11 = goog.getMsg("Go to the next page");
    I18N_10 = MSG_EXTERNAL_362811891869346548$$DIST_FESM2015_INDEX_JS_11;
}
else {
    I18N_10 = $localize `:kendo.treelist.pagerNextPage|The label for the next page button in TreeList pager␟1bda5b0e26236ea09a0fc371fcbdb7688d09a509␟362811891869346548:Go to the next page`;
}
var I18N_12;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label for the last page button in TreeList pager
     * @meaning kendo.treelist.pagerLastPage
     */ 
    const MSG_EXTERNAL_4075698388586880260$$DIST_FESM2015_INDEX_JS_13 = goog.getMsg("Go to the last page");
    I18N_12 = MSG_EXTERNAL_4075698388586880260$$DIST_FESM2015_INDEX_JS_13;
}
else {
    I18N_12 = $localize `:kendo.treelist.pagerLastPage|The label for the last page button in TreeList pager␟cdf1ad243b2890940fe26b3e419ba71ddbd8aa5a␟4075698388586880260:Go to the last page`;
}
var I18N_14;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label before the current page number in the TreeList pager
     * @meaning kendo.treelist.pagerPage
     */ 
    const MSG_EXTERNAL_8196982688037137027$$DIST_FESM2015_INDEX_JS_15 = goog.getMsg("Page");
    I18N_14 = MSG_EXTERNAL_8196982688037137027$$DIST_FESM2015_INDEX_JS_15;
}
else {
    I18N_14 = $localize `:kendo.treelist.pagerPage|The label before the current page number in the TreeList pager␟287412bc1246aad2b6fd05d0853a2fe6877b801b␟8196982688037137027:Page`;
}
var I18N_16;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label before the total pages number in the TreeList pager
     * @meaning kendo.treelist.pagerOf
     */ 
    const MSG_EXTERNAL_1811180862331482009$$DIST_FESM2015_INDEX_JS_17 = goog.getMsg("of");
    I18N_16 = MSG_EXTERNAL_1811180862331482009$$DIST_FESM2015_INDEX_JS_17;
}
else {
    I18N_16 = $localize `:kendo.treelist.pagerOf|The label before the total pages number in the TreeList pager␟4cc4f3c66a1233dee14e6f8655494e08eb81e191␟1811180862331482009:of`;
}
var I18N_18;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label for the pager input in the Treelist pager
     * @meaning kendo.treelist.pagerPageNumberInputTitle
     */ 
    const MSG_EXTERNAL_6224954911111282995$$DIST_FESM2015_INDEX_JS_19 = goog.getMsg("Page Number");
    I18N_18 = MSG_EXTERNAL_6224954911111282995$$DIST_FESM2015_INDEX_JS_19;
}
else {
    I18N_18 = $localize `:kendo.treelist.pagerPageNumberInputTitle|The label for the pager input in the Treelist pager␟88fb15e4549b4adb3ed3ddb24c62e63abfb883f9␟6224954911111282995:Page Number`;
}
var I18N_20;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label for the page size chooser in the TreeList pager
     * @meaning kendo.treelist.pagerItemsPerPage
     */ 
    const MSG_EXTERNAL_169404885310234585$$DIST_FESM2015_INDEX_JS_21 = goog.getMsg("items per page");
    I18N_20 = MSG_EXTERNAL_169404885310234585$$DIST_FESM2015_INDEX_JS_21;
}
else {
    I18N_20 = $localize `:kendo.treelist.pagerItemsPerPage|The label for the page size chooser in the TreeList pager␟7a7b68e92a1ec505004d2bbeec0a8e0c4a47e227␟169404885310234585:items per page`;
}
var I18N_22;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label after the total items count in the TreeList pager
     * @meaning kendo.treelist.pagerItemsTotal
     */ 
    const MSG_EXTERNAL_1753107422391150665$$DIST_FESM2015_INDEX_JS_23 = goog.getMsg("items total");
    I18N_22 = MSG_EXTERNAL_1753107422391150665$$DIST_FESM2015_INDEX_JS_23;
}
else {
    I18N_22 = $localize `:kendo.treelist.pagerItemsTotal|The label after the total items count in the TreeList pager␟dcb6cf7542066728344725c1ae16bfd6b9b57ac1␟1753107422391150665:items total`;
}
var I18N_24;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label of the filter cell or icon
     * @meaning kendo.treelist.filter
     */ 
    const MSG_EXTERNAL_6743437097952949232$$DIST_FESM2015_INDEX_JS_25 = goog.getMsg("Filter");
    I18N_24 = MSG_EXTERNAL_6743437097952949232$$DIST_FESM2015_INDEX_JS_25;
}
else {
    I18N_24 = $localize `:kendo.treelist.filter|The label of the filter cell or icon␟3ab4d93d98979483ce91931db991a6bb104d11c9␟6743437097952949232:Filter`;
}
var I18N_26;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the equal filter operator
     * @meaning kendo.treelist.filterEqOperator
     */ 
    const MSG_EXTERNAL_3309736504466492065$$DIST_FESM2015_INDEX_JS_27 = goog.getMsg("Is equal to");
    I18N_26 = MSG_EXTERNAL_3309736504466492065$$DIST_FESM2015_INDEX_JS_27;
}
else {
    I18N_26 = $localize `:kendo.treelist.filterEqOperator|The text of the equal filter operator␟0cd1adb5c835c05e298bc5568c02b39baa74d4a9␟3309736504466492065:Is equal to`;
}
var I18N_28;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the not equal filter operator
     * @meaning kendo.treelist.filterNotEqOperator
     */ 
    const MSG_EXTERNAL_1753256984779294984$$DIST_FESM2015_INDEX_JS_29 = goog.getMsg("Is not equal to");
    I18N_28 = MSG_EXTERNAL_1753256984779294984$$DIST_FESM2015_INDEX_JS_29;
}
else {
    I18N_28 = $localize `:kendo.treelist.filterNotEqOperator|The text of the not equal filter operator␟4765862efa585fb5c4e1adf5db9b38eebabe051d␟1753256984779294984:Is not equal to`;
}
var I18N_30;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the is null filter operator
     * @meaning kendo.treelist.filterIsNullOperator
     */ 
    const MSG_EXTERNAL_1667207238130268361$$DIST_FESM2015_INDEX_JS_31 = goog.getMsg("Is null");
    I18N_30 = MSG_EXTERNAL_1667207238130268361$$DIST_FESM2015_INDEX_JS_31;
}
else {
    I18N_30 = $localize `:kendo.treelist.filterIsNullOperator|The text of the is null filter operator␟a00ed88d352ccdb637ce675dc521f5e4e5ab0c63␟1667207238130268361:Is null`;
}
var I18N_32;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the is not null filter operator
     * @meaning kendo.treelist.filterIsNotNullOperator
     */ 
    const MSG_EXTERNAL_4060216360862930601$$DIST_FESM2015_INDEX_JS_33 = goog.getMsg("Is not null");
    I18N_32 = MSG_EXTERNAL_4060216360862930601$$DIST_FESM2015_INDEX_JS_33;
}
else {
    I18N_32 = $localize `:kendo.treelist.filterIsNotNullOperator|The text of the is not null filter operator␟7a1a67a28283daea42755cba9a7cdefe16ecaf8b␟4060216360862930601:Is not null`;
}
var I18N_34;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the is empty filter operator
     * @meaning kendo.treelist.filterIsEmptyOperator
     */ 
    const MSG_EXTERNAL_1316606741979394259$$DIST_FESM2015_INDEX_JS_35 = goog.getMsg("Is empty");
    I18N_34 = MSG_EXTERNAL_1316606741979394259$$DIST_FESM2015_INDEX_JS_35;
}
else {
    I18N_34 = $localize `:kendo.treelist.filterIsEmptyOperator|The text of the is empty filter operator␟f97b8102d63bef513a269c6f237bb1ecd66b45d6␟1316606741979394259:Is empty`;
}
var I18N_36;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the is not empty filter operator
     * @meaning kendo.treelist.filterIsNotEmptyOperator
     */ 
    const MSG_EXTERNAL_3389119634823892087$$DIST_FESM2015_INDEX_JS_37 = goog.getMsg("Is not empty");
    I18N_36 = MSG_EXTERNAL_3389119634823892087$$DIST_FESM2015_INDEX_JS_37;
}
else {
    I18N_36 = $localize `:kendo.treelist.filterIsNotEmptyOperator|The text of the is not empty filter operator␟09b1b3a5f812dc75afb4d3d37bb368c522db362c␟3389119634823892087:Is not empty`;
}
var I18N_38;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the starts with filter operator
     * @meaning kendo.treelist.filterStartsWithOperator
     */ 
    const MSG_EXTERNAL_4099253670171117396$$DIST_FESM2015_INDEX_JS_39 = goog.getMsg("Starts with");
    I18N_38 = MSG_EXTERNAL_4099253670171117396$$DIST_FESM2015_INDEX_JS_39;
}
else {
    I18N_38 = $localize `:kendo.treelist.filterStartsWithOperator|The text of the starts with filter operator␟2890d20b61276813d24bcac9decdab6e193c924c␟4099253670171117396:Starts with`;
}
var I18N_40;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the contains filter operator
     * @meaning kendo.treelist.filterContainsOperator
     */ 
    const MSG_EXTERNAL_4661302216992372675$$DIST_FESM2015_INDEX_JS_41 = goog.getMsg("Contains");
    I18N_40 = MSG_EXTERNAL_4661302216992372675$$DIST_FESM2015_INDEX_JS_41;
}
else {
    I18N_40 = $localize `:kendo.treelist.filterContainsOperator|The text of the contains filter operator␟914e690a4cb74e8c65363b458a6c9b48dfea1da7␟4661302216992372675:Contains`;
}
var I18N_42;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the does not contain filter operator
     * @meaning kendo.treelist.filterNotContainsOperator
     */ 
    const MSG_EXTERNAL_1855331005589896114$$DIST_FESM2015_INDEX_JS_43 = goog.getMsg("Does not contain");
    I18N_42 = MSG_EXTERNAL_1855331005589896114$$DIST_FESM2015_INDEX_JS_43;
}
else {
    I18N_42 = $localize `:kendo.treelist.filterNotContainsOperator|The text of the does not contain filter operator␟c70b6d3fc752b2c6b26dfce75bd19d8599b93033␟1855331005589896114:Does not contain`;
}
var I18N_44;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the ends with filter operator
     * @meaning kendo.treelist.filterEndsWithOperator
     */ 
    const MSG_EXTERNAL_3824801369984866617$$DIST_FESM2015_INDEX_JS_45 = goog.getMsg("Ends with");
    I18N_44 = MSG_EXTERNAL_3824801369984866617$$DIST_FESM2015_INDEX_JS_45;
}
else {
    I18N_44 = $localize `:kendo.treelist.filterEndsWithOperator|The text of the ends with filter operator␟cd9a432b859c491a7723ef12fda786b62053cc1d␟3824801369984866617:Ends with`;
}
var I18N_46;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the greater than or equal filter operator
     * @meaning kendo.treelist.filterGteOperator
     */ 
    const MSG_EXTERNAL_5569366978126546291$$DIST_FESM2015_INDEX_JS_47 = goog.getMsg("Is greater than or equal to");
    I18N_46 = MSG_EXTERNAL_5569366978126546291$$DIST_FESM2015_INDEX_JS_47;
}
else {
    I18N_46 = $localize `:kendo.treelist.filterGteOperator|The text of the greater than or equal filter operator␟289e58555a6d803c3450dd399b9cf67a1a2e98c8␟5569366978126546291:Is greater than or equal to`;
}
var I18N_48;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the greater than filter operator
     * @meaning kendo.treelist.filterGtOperator
     */ 
    const MSG_EXTERNAL_5307908556710927147$$DIST_FESM2015_INDEX_JS_49 = goog.getMsg("Is greater than");
    I18N_48 = MSG_EXTERNAL_5307908556710927147$$DIST_FESM2015_INDEX_JS_49;
}
else {
    I18N_48 = $localize `:kendo.treelist.filterGtOperator|The text of the greater than filter operator␟b9278f5f3160545b330f162aa7e82066dbed9607␟5307908556710927147:Is greater than`;
}
var I18N_50;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the less than or equal filter operator
     * @meaning kendo.treelist.filterLteOperator
     */ 
    const MSG_EXTERNAL_5402539774964195763$$DIST_FESM2015_INDEX_JS_51 = goog.getMsg("Is less than or equal to");
    I18N_50 = MSG_EXTERNAL_5402539774964195763$$DIST_FESM2015_INDEX_JS_51;
}
else {
    I18N_50 = $localize `:kendo.treelist.filterLteOperator|The text of the less than or equal filter operator␟6918259000dbe30cd78e8860b9fdaafbabcb9a25␟5402539774964195763:Is less than or equal to`;
}
var I18N_52;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the less than filter operator
     * @meaning kendo.treelist.filterLtOperator
     */ 
    const MSG_EXTERNAL_2453651298993567099$$DIST_FESM2015_INDEX_JS_53 = goog.getMsg("Is less than");
    I18N_52 = MSG_EXTERNAL_2453651298993567099$$DIST_FESM2015_INDEX_JS_53;
}
else {
    I18N_52 = $localize `:kendo.treelist.filterLtOperator|The text of the less than filter operator␟ae4bbdfc3ee897f028841eca04a5d91ec2d4ee61␟2453651298993567099:Is less than`;
}
var I18N_54;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the IsTrue boolean filter option
     * @meaning kendo.treelist.filterIsTrue
     */ 
    const MSG_EXTERNAL_3820735177054693083$$DIST_FESM2015_INDEX_JS_55 = goog.getMsg("Is True");
    I18N_54 = MSG_EXTERNAL_3820735177054693083$$DIST_FESM2015_INDEX_JS_55;
}
else {
    I18N_54 = $localize `:kendo.treelist.filterIsTrue|The text of the IsTrue boolean filter option␟16e9e2209633a80112df7c3b37bc56c938b27f8b␟3820735177054693083:Is True`;
}
var I18N_56;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the IsFalse boolean filter option
     * @meaning kendo.treelist.filterIsFalse
     */ 
    const MSG_EXTERNAL_5795301429975209443$$DIST_FESM2015_INDEX_JS_57 = goog.getMsg("Is False");
    I18N_56 = MSG_EXTERNAL_5795301429975209443$$DIST_FESM2015_INDEX_JS_57;
}
else {
    I18N_56 = $localize `:kendo.treelist.filterIsFalse|The text of the IsFalse boolean filter option␟cdce58174b115a53dff112da82858d631f5a9be3␟5795301429975209443:Is False`;
}
var I18N_58;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the (All) boolean filter option
     * @meaning kendo.treelist.filterBooleanAll
     */ 
    const MSG_EXTERNAL_3872856356698042967$$DIST_FESM2015_INDEX_JS_59 = goog.getMsg("(All)");
    I18N_58 = MSG_EXTERNAL_3872856356698042967$$DIST_FESM2015_INDEX_JS_59;
}
else {
    I18N_58 = $localize `:kendo.treelist.filterBooleanAll|The text of the (All) boolean filter option␟ff1da0738702670621d008d4902f0ab704b4faa4␟3872856356698042967:(All)`;
}
var I18N_60;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the after or equal date filter operator
     * @meaning kendo.treelist.filterAfterOrEqualOperator
     */ 
    const MSG_EXTERNAL_3938654797495966170$$DIST_FESM2015_INDEX_JS_61 = goog.getMsg("Is after or equal to");
    I18N_60 = MSG_EXTERNAL_3938654797495966170$$DIST_FESM2015_INDEX_JS_61;
}
else {
    I18N_60 = $localize `:kendo.treelist.filterAfterOrEqualOperator|The text of the after or equal date filter operator␟ddd875fe8ef7c06a5abb4de1e13dc7be0fb0419b␟3938654797495966170:Is after or equal to`;
}
var I18N_62;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the after date filter operator
     * @meaning kendo.treelist.filterAfterOperator
     */ 
    const MSG_EXTERNAL_908881762330632660$$DIST_FESM2015_INDEX_JS_63 = goog.getMsg("Is after");
    I18N_62 = MSG_EXTERNAL_908881762330632660$$DIST_FESM2015_INDEX_JS_63;
}
else {
    I18N_62 = $localize `:kendo.treelist.filterAfterOperator|The text of the after date filter operator␟d8c6140d38d89b5ce364f175030a23939049d0f1␟908881762330632660:Is after`;
}
var I18N_64;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the before date filter operator
     * @meaning kendo.treelist.filterBeforeOperator
     */ 
    const MSG_EXTERNAL_7228583510261541252$$DIST_FESM2015_INDEX_JS_65 = goog.getMsg("Is before");
    I18N_64 = MSG_EXTERNAL_7228583510261541252$$DIST_FESM2015_INDEX_JS_65;
}
else {
    I18N_64 = $localize `:kendo.treelist.filterBeforeOperator|The text of the before date filter operator␟572298b8e8959a35e49a469aa0f9afba2cffe5b2␟7228583510261541252:Is before`;
}
var I18N_66;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the before or equal date filter operator
     * @meaning kendo.treelist.filterBeforeOrEqualOperator
     */ 
    const MSG_EXTERNAL_1212144889311868888$$DIST_FESM2015_INDEX_JS_67 = goog.getMsg("Is before or equal to");
    I18N_66 = MSG_EXTERNAL_1212144889311868888$$DIST_FESM2015_INDEX_JS_67;
}
else {
    I18N_66 = $localize `:kendo.treelist.filterBeforeOrEqualOperator|The text of the before or equal date filter operator␟45178126c830dd074321fa50cdb0d1c1a3a10fe7␟1212144889311868888:Is before or equal to`;
}
var I18N_68;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the filter button
     * @meaning kendo.treelist.filterFilterButton
     */ 
    const MSG_EXTERNAL_2985997669375940253$$DIST_FESM2015_INDEX_JS_69 = goog.getMsg("Filter");
    I18N_68 = MSG_EXTERNAL_2985997669375940253$$DIST_FESM2015_INDEX_JS_69;
}
else {
    I18N_68 = $localize `:kendo.treelist.filterFilterButton|The text of the filter button␟e44cdcd935db42c36a8914bd77afd7ec86297630␟2985997669375940253:Filter`;
}
var I18N_70;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the clear filter button
     * @meaning kendo.treelist.filterClearButton
     */ 
    const MSG_EXTERNAL_6485460801571243063$$DIST_FESM2015_INDEX_JS_71 = goog.getMsg("Clear");
    I18N_70 = MSG_EXTERNAL_6485460801571243063$$DIST_FESM2015_INDEX_JS_71;
}
else {
    I18N_70 = $localize `:kendo.treelist.filterClearButton|The text of the clear filter button␟5c9958de639ddffc476be23653f805d868a4484f␟6485460801571243063:Clear`;
}
var I18N_72;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the And filter logic
     * @meaning kendo.treelist.filterAndLogic
     */ 
    const MSG_EXTERNAL_6958472532316937971$$DIST_FESM2015_INDEX_JS_73 = goog.getMsg("And");
    I18N_72 = MSG_EXTERNAL_6958472532316937971$$DIST_FESM2015_INDEX_JS_73;
}
else {
    I18N_72 = $localize `:kendo.treelist.filterAndLogic|The text of the And filter logic␟9259e5d506e88328eb347535e1d224e931ed50d9␟6958472532316937971:And`;
}
var I18N_74;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text of the Or filter logic
     * @meaning kendo.treelist.filterOrLogic
     */ 
    const MSG_EXTERNAL_5738400583273636043$$DIST_FESM2015_INDEX_JS_75 = goog.getMsg("Or");
    I18N_74 = MSG_EXTERNAL_5738400583273636043$$DIST_FESM2015_INDEX_JS_75;
}
else {
    I18N_74 = $localize `:kendo.treelist.filterOrLogic|The text of the Or filter logic␟30f792cf0c2dd03a72dcc124a681b3271a0b4b92␟5738400583273636043:Or`;
}
var I18N_76;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The loading text
     * @meaning kendo.treelist.loading
     */ 
    const MSG_EXTERNAL_7305029005172604829$$DIST_FESM2015_INDEX_JS_77 = goog.getMsg("Loading");
    I18N_76 = MSG_EXTERNAL_7305029005172604829$$DIST_FESM2015_INDEX_JS_77;
}
else {
    I18N_76 = $localize `:kendo.treelist.loading|The loading text␟77f5d6685cf38119ed85876d6d04a79a2b67cb86␟7305029005172604829:Loading`;
}
var I18N_78;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The title of the column menu icon
     * @meaning kendo.treelist.columnMenu
     */ 
    const MSG_EXTERNAL_8752393834003132712$$DIST_FESM2015_INDEX_JS_79 = goog.getMsg("Column Menu");
    I18N_78 = MSG_EXTERNAL_8752393834003132712$$DIST_FESM2015_INDEX_JS_79;
}
else {
    I18N_78 = $localize `:kendo.treelist.columnMenu|The title of the column menu icon␟b5b3d64e4b293fea9e936086a3d6c2d87b805442␟8752393834003132712:Column Menu`;
}
var I18N_80;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu for the columns item
     * @meaning kendo.treelist.columns
     */ 
    const MSG_EXTERNAL_6876209255755903651$$DIST_FESM2015_INDEX_JS_81 = goog.getMsg("Columns");
    I18N_80 = MSG_EXTERNAL_6876209255755903651$$DIST_FESM2015_INDEX_JS_81;
}
else {
    I18N_80 = $localize `:kendo.treelist.columns|The text shown in the column menu for the columns item␟652dc1976e2e0ae414f459df4f18f36774dd6128␟6876209255755903651:Columns`;
}
var I18N_82;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu for the lock item
     * @meaning kendo.treelist.lock
     */ 
    const MSG_EXTERNAL_6358792984026695308$$DIST_FESM2015_INDEX_JS_83 = goog.getMsg("Lock");
    I18N_82 = MSG_EXTERNAL_6358792984026695308$$DIST_FESM2015_INDEX_JS_83;
}
else {
    I18N_82 = $localize `:kendo.treelist.lock|The text shown in the column menu for the lock item␟e8924b69d5c28ae3a1f11f8b1f0a725788837e8d␟6358792984026695308:Lock`;
}
var I18N_84;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu for the unlock item
     * @meaning kendo.treelist.unlock
     */ 
    const MSG_EXTERNAL_6589642946890266776$$DIST_FESM2015_INDEX_JS_85 = goog.getMsg("Unlock");
    I18N_84 = MSG_EXTERNAL_6589642946890266776$$DIST_FESM2015_INDEX_JS_85;
}
else {
    I18N_84 = $localize `:kendo.treelist.unlock|The text shown in the column menu for the unlock item␟bcc1c4161452d1e5d4ce53d6d059b5880a50d311␟6589642946890266776:Unlock`;
}
var I18N_86;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The label of the sort icon
     * @meaning kendo.treelist.sortable
     */ 
    const MSG_EXTERNAL_6592620729437850513$$DIST_FESM2015_INDEX_JS_87 = goog.getMsg("Sortable");
    I18N_86 = MSG_EXTERNAL_6592620729437850513$$DIST_FESM2015_INDEX_JS_87;
}
else {
    I18N_86 = $localize `:kendo.treelist.sortable|The label of the sort icon␟0c76fe494d951c73c1d993cc0c54c687a179d23b␟6592620729437850513:Sortable`;
}
var I18N_88;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu for the sort ascending item
     * @meaning kendo.treelist.sortAscending
     */ 
    const MSG_EXTERNAL_521638511049933359$$DIST_FESM2015_INDEX_JS_89 = goog.getMsg("Sort Ascending");
    I18N_88 = MSG_EXTERNAL_521638511049933359$$DIST_FESM2015_INDEX_JS_89;
}
else {
    I18N_88 = $localize `:kendo.treelist.sortAscending|The text shown in the column menu for the sort ascending item␟181d125337591b17ca3d8612e307b06e761ad467␟521638511049933359:Sort Ascending`;
}
var I18N_90;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu for the sort descending item
     * @meaning kendo.treelist.sortDescending
     */ 
    const MSG_EXTERNAL_9197441556182563035$$DIST_FESM2015_INDEX_JS_91 = goog.getMsg("Sort Descending");
    I18N_90 = MSG_EXTERNAL_9197441556182563035$$DIST_FESM2015_INDEX_JS_91;
}
else {
    I18N_90 = $localize `:kendo.treelist.sortDescending|The text shown in the column menu for the sort descending item␟e39fc1d5c36be50d813af6c976ea732e4487d157␟9197441556182563035:Sort Descending`;
}
var I18N_92;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The status announcement when a column is sorted ascending
     * @meaning kendo.treelist.sortedAscending
     */ 
    const MSG_EXTERNAL_6408293483009020153$$DIST_FESM2015_INDEX_JS_93 = goog.getMsg("Sorted Ascending");
    I18N_92 = MSG_EXTERNAL_6408293483009020153$$DIST_FESM2015_INDEX_JS_93;
}
else {
    I18N_92 = $localize `:kendo.treelist.sortedAscending|The status announcement when a column is sorted ascending␟ba92b061442dc5087e47b98a1df883bb6041e633␟6408293483009020153:Sorted Ascending`;
}
var I18N_94;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The status announcement when a column is sorted descending
     * @meaning kendo.treelist.sortedDescending
     */ 
    const MSG_EXTERNAL_3468262282152409183$$DIST_FESM2015_INDEX_JS_95 = goog.getMsg("Sorted Descending");
    I18N_94 = MSG_EXTERNAL_3468262282152409183$$DIST_FESM2015_INDEX_JS_95;
}
else {
    I18N_94 = $localize `:kendo.treelist.sortedDescending|The status announcement when a column is sorted descending␟537d1f5cfa893932e71b5a0bc7a0f642b1b7c44f␟3468262282152409183:Sorted Descending`;
}
var I18N_96;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The status announcement when a column is no longer sorted
     * @meaning kendo.treelist.sortedDefault
     */ 
    const MSG_EXTERNAL_3847969058314425851$$DIST_FESM2015_INDEX_JS_97 = goog.getMsg("Not Sorted");
    I18N_96 = MSG_EXTERNAL_3847969058314425851$$DIST_FESM2015_INDEX_JS_97;
}
else {
    I18N_96 = $localize `:kendo.treelist.sortedDefault|The status announcement when a column is no longer sorted␟8faff57f906be135c4f091be815d9b90ad5bfe5f␟3847969058314425851:Not Sorted`;
}
var I18N_98;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu or column chooser for the columns apply button
     * @meaning kendo.treelist.columnsApply
     */ 
    const MSG_EXTERNAL_1737998738259077132$$DIST_FESM2015_INDEX_JS_99 = goog.getMsg("Apply");
    I18N_98 = MSG_EXTERNAL_1737998738259077132$$DIST_FESM2015_INDEX_JS_99;
}
else {
    I18N_98 = $localize `:kendo.treelist.columnsApply|The text shown in the column menu or column chooser for the columns apply button␟ebf5078ae6c56ef46a575cad90e1055f6ee3da82␟1737998738259077132:Apply`;
}
var I18N_100;
if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
    /**
     * @desc The text shown in the column menu or column chooser for the columns reset button
     * @meaning kendo.treelist.columnsReset
     */ 
    const MSG_EXTERNAL_2276845195425928676$$DIST_FESM2015_INDEX_JS_101 = goog.getMsg("Reset");
    I18N_100 = MSG_EXTERNAL_2276845195425928676$$DIST_FESM2015_INDEX_JS_101;
}
else {
    I18N_100 = $localize `:kendo.treelist.columnsReset|The text shown in the column menu or column chooser for the columns reset button␟e4172c14ea54835be3d301ac88a2c1a5d2a39a92␟2276845195425928676:Reset`;
}
const _c102 = ["noRecords", I18N_4, "pagerFirstPage", I18N_6, "pagerPreviousPage", I18N_8, "pagerNextPage", I18N_10, "pagerLastPage", I18N_12, "pagerPage", I18N_14, "pagerOf", I18N_16, "pagerPageNumberInputTitle", I18N_18, "pagerItemsPerPage", I18N_20, "pagerItemsTotal", I18N_22, "filter", I18N_24, "filterEqOperator", I18N_26, "filterNotEqOperator", I18N_28, "filterIsNullOperator", I18N_30, "filterIsNotNullOperator", I18N_32, "filterIsEmptyOperator", I18N_34, "filterIsNotEmptyOperator", I18N_36, "filterStartsWithOperator", I18N_38, "filterContainsOperator", I18N_40, "filterNotContainsOperator", I18N_42, "filterEndsWithOperator", I18N_44, "filterGteOperator", I18N_46, "filterGtOperator", I18N_48, "filterLteOperator", I18N_50, "filterLtOperator", I18N_52, "filterIsTrue", I18N_54, "filterIsFalse", I18N_56, "filterBooleanAll", I18N_58, "filterAfterOrEqualOperator", I18N_60, "filterAfterOperator", I18N_62, "filterBeforeOperator", I18N_64, "filterBeforeOrEqualOperator", I18N_66, "filterFilterButton", I18N_68, "filterClearButton", I18N_70, "filterAndLogic", I18N_72, "filterOrLogic", I18N_74, "loading", I18N_76, "columnMenu", I18N_78, "columns", I18N_80, "lock", I18N_82, "unlock", I18N_84, "sortable", I18N_86, "sortAscending", I18N_88, "sortDescending", I18N_90, "sortedAscending", I18N_92, "sortedDescending", I18N_94, "sortedDefault", I18N_96, "columnsApply", I18N_98, "columnsReset", I18N_100];
function TreeListComponent_kendo_treelist_toolbar_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-toolbar", 7);
} }
function TreeListComponent_ng_template_5_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 18, 19);
    ɵngcc0.ɵɵelementStart(2, "table", 20);
    ɵngcc0.ɵɵelement(3, "colgroup", 15);
    ɵngcc0.ɵɵelement(4, "thead", 21);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵstyleProp("width", ctx_r7.lockedWidth, "px");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r7.lockedWidth, "px");
    ɵngcc0.ɵɵproperty("locked", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r7.lockedLeafColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("resizable", ctx_r7.resizable)("scrollable", true)("columns", ctx_r7.lockedColumns)("totalColumnLevels", ctx_r7.totalColumnLevels)("sort", ctx_r7.sort)("filter", ctx_r7.filter)("filterable", ctx_r7.filterable)("reorderable", ctx_r7.reorderable)("sortable", ctx_r7.sortable)("columnMenu", ctx_r7.columnMenuOptions)("columnMenuTemplate", ctx_r7.columnMenuTemplate)("totalColumnsCount", ctx_r7.leafColumns.length);
} }
function TreeListComponent_ng_template_5_div_0_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 22);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", ctx_r9.columnsContainer.unlockedWidth, "px");
} }
function TreeListComponent_ng_template_5_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, TreeListComponent_ng_template_5_div_0_div_1_Template, 5, 18, "div", 11);
    ɵngcc0.ɵɵelementStart(2, "div", 12, 13);
    ɵngcc0.ɵɵelementStart(4, "table", 14);
    ɵngcc0.ɵɵelement(5, "colgroup", 15);
    ɵngcc0.ɵɵelement(6, "thead", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, TreeListComponent_ng_template_5_div_0_div_7_Template, 2, 2, "div", 17);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("padding", ctx_r6.headerPadding);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.isLocked);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("kendoTreeListResizableContainer", ctx_r6.lockedLeafColumns.length)("lockedWidth", ctx_r6.lockedWidth + ctx_r6.scrollbarWidth + 2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r6.nonLockedWidth, "px");
    ɵngcc0.ɵɵproperty("virtualColumns", ctx_r6.virtualColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r6.headerLeafColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("resizable", ctx_r6.resizable)("scrollable", true)("columns", ctx_r6.headerColumns)("totalColumnLevels", ctx_r6.totalColumnLevels)("sort", ctx_r6.sort)("filter", ctx_r6.filter)("filterable", ctx_r6.filterable)("reorderable", ctx_r6.reorderable)("sortable", ctx_r6.sortable)("columnMenu", ctx_r6.columnMenuOptions)("columnMenuTemplate", ctx_r6.columnMenuTemplate)("lockedColumnsCount", ctx_r6.lockedLeafColumns.length)("totalColumnsCount", ctx_r6.leafColumns.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.virtualColumns);
} }
function TreeListComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, TreeListComponent_ng_template_5_div_0_Template, 8, 23, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "kendo-treelist-list", 9);
    ɵngcc0.ɵɵlistener("pageChange", function TreeListComponent_ng_template_5_Template_kendo_treelist_list_pageChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.notifyPageChange("list", $event); })("scrollBottom", function TreeListComponent_ng_template_5_Template_kendo_treelist_list_scrollBottom_1_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.notifyScrollBottom(); })("contentScroll", function TreeListComponent_ng_template_5_Template_kendo_treelist_list_contentScroll_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.contentScroll.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.hideHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("view", ctx_r2.view)("loading", ctx_r2.showLoading)("rowHeight", ctx_r2.rowHeight)("total", ctx_r2.totalCount)("take", ctx_r2.pageSize)("skip", ctx_r2.skip)("trackBy", ctx_r2.trackBy)("columns", ctx_r2.columnsContainer)("filterable", ctx_r2.filterable)("noRecordsTemplate", ctx_r2.noRecordsTemplate)("rowClass", ctx_r2.rowClass)("isVirtual", ctx_r2.isVirtual)("virtualColumns", ctx_r2.virtualColumns)("expandIcons", ctx_r2.expandIcons)("enableDrag", ctx_r2.marqueeSelection);
} }
function TreeListComponent_ng_template_6_thead_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "thead", 27);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("resizable", ctx_r15.resizable)("scrollable", false)("columns", ctx_r15.visibleColumns)("totalColumnLevels", ctx_r15.totalColumnLevels)("reorderable", ctx_r15.reorderable)("sort", ctx_r15.sort)("sortable", ctx_r15.sortable)("filter", ctx_r15.filter)("filterable", ctx_r15.filterable)("columnMenu", ctx_r15.columnMenuOptions)("columnMenuTemplate", ctx_r15.columnMenuTemplate);
} }
function TreeListComponent_ng_template_6_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 28);
} }
function TreeListComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table");
    ɵngcc0.ɵɵelement(1, "colgroup", 23);
    ɵngcc0.ɵɵtemplate(2, TreeListComponent_ng_template_6_thead_2_Template, 1, 11, "thead", 24);
    ɵngcc0.ɵɵelement(3, "tbody", 25);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, TreeListComponent_ng_template_6_div_4_Template, 1, 0, "div", 26);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("table-layout", ctx_r3.resizable ? "fixed" : null);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r3.leafColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r3.hideHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("view", ctx_r3.view)("skip", ctx_r3.skip)("columns", ctx_r3.leafColumns)("filterable", ctx_r3.filterable)("noRecordsTemplate", ctx_r3.noRecordsTemplate)("trackBy", ctx_r3.trackBy)("rowClass", ctx_r3.rowClass)("expandIcons", ctx_r3.expandIcons)("enableDrag", ctx_r3.marqueeSelection);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showLoading);
} }
function TreeListComponent_kendo_treelist_pager_7_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-treelist-pager", 29);
    ɵngcc0.ɵɵlistener("pageChange", function TreeListComponent_kendo_treelist_pager_7_Template_kendo_treelist_pager_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.notifyPageChange("pager", $event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("template", ctx_r4.pagerTemplate)("pageSize", ctx_r4.pageSize)("total", ctx_r4.view.totalVisible)("allCount", ctx_r4.view.total)("skip", ctx_r4.skip)("options", ctx_r4.pageable);
} }
function TreeListComponent_kendo_treelist_toolbar_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-toolbar", 30);
} }
const _c103 = ["container"];
const _c104 = ["lockedContainer"];
const _c105 = ["lockedTable"];
const _c106 = ["table"];
function ListComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12, 13);
    ɵngcc0.ɵɵelementStart(2, "div", 3);
    ɵngcc0.ɵɵelementStart(3, "table", 14, 15);
    ɵngcc0.ɵɵelement(5, "colgroup", 6);
    ɵngcc0.ɵɵelement(6, "tbody", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(7, "kendo-resize-sensor");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "div", 9);
    ɵngcc0.ɵɵelement(9, "div");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵngcc0.ɵɵproperty("locked", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("columns", ctx_r0.lockedLeafColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("isLocked", true)("view", ctx_r0.view)("noRecordsText", "")("columns", ctx_r0.lockedLeafColumns)("totalColumnsCount", ctx_r0.leafColumns.length)("skip", ctx_r0.skip)("trackBy", ctx_r0.trackBy)("filterable", ctx_r0.filterable)("rowClass", ctx_r0.rowClass)("expandIcons", ctx_r0.expandIcons);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵstyleProp("height", ctx_r0.totalHeight, "px");
} }
function ListComponent_kendo_resize_sensor_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-resize-sensor");
} }
function ListComponent_kendo_resize_sensor_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-resize-sensor");
} }
function ListComponent_div_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", ctx_r5.totalWidth, "px");
} }
function ListComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 18);
} }
const _c107 = ["kendoTreeListFilterRow", ""];
function FilterRowComponent_td_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 1);
} if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const columnIndex_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", column_r1)("filter", ctx_r0.filter)("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", ctx_r0.lockedColumnsCount + columnIndex_r2)("column", column_r1)("colIndex", columnIndex_r2);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.filterLabel);
} }
const _c108 = ["kendoTreeListFilterCell", ""];
function FilterCellComponent_ng_template_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainer(1, 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("column", ctx_r1.column)("filter", ctx_r1.filter);
} }
function FilterCellComponent_ng_template_0_ng_container_2_1_ng_template_0_Template(rf, ctx) { }
function FilterCellComponent_ng_template_0_ng_container_2_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, FilterCellComponent_ng_template_0_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.column.filterCellTemplateRef)("ngTemplateOutletContext", ctx_r3.templateContext);
} }
function FilterCellComponent_ng_template_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FilterCellComponent_ng_template_0_ng_container_2_1_Template, 1, 2, undefined, 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.column.filterCellTemplateRef);
} }
function FilterCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 1);
    ɵngcc0.ɵɵtemplate(1, FilterCellComponent_ng_template_0_ng_container_1_Template, 2, 2, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, FilterCellComponent_ng_template_0_ng_container_2_Template, 2, 1, "ng-container", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r0.hasTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
} }
const _c109 = ["*"];
const _c110 = ["dropdown"];
const _c111 = function () { return { width: "auto" }; };
function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3, 4);
    ɵngcc0.ɵɵlistener("valueChange", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onChange($event); })("keydown", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.dropdownKeydown($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", ctx_r0.operators)("value", ctx_r0.value)("valuePrimitive", true)("popupSettings", ɵngcc0.ɵɵpureFunction0(4, _c111));
} }
const _c112 = function (a0) { return { "k-clear-button-visible": a0 }; };
const _c113 = ["kendoTreeListColGroup", ""];
function ColGroupComponent_col_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "col");
} if (rf & 2) {
    const column_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("width", column_r1.width, "px");
} }
const _c114 = ["kendoTreeListLoading", ""];
function PagerComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.template.templateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
} }
function PagerComponent_ng_container_1_kendo_treelist_pager_prev_buttons_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-pager-prev-buttons");
} }
function PagerComponent_ng_container_1_kendo_treelist_pager_numeric_buttons_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-pager-numeric-buttons", 5);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("buttonCount", ctx_r3.settings.buttonCount);
} }
function PagerComponent_ng_container_1_kendo_treelist_pager_input_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-pager-input");
} }
function PagerComponent_ng_container_1_kendo_treelist_pager_next_buttons_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-pager-next-buttons");
} }
function PagerComponent_ng_container_1_kendo_treelist_pager_info_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-pager-info");
} }
function PagerComponent_ng_container_1_kendo_treelist_pager_page_sizes_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-pager-page-sizes", 6);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("pageSizes", ctx_r7.settings.pageSizes);
} }
function PagerComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, PagerComponent_ng_container_1_kendo_treelist_pager_prev_buttons_1_Template, 1, 0, "kendo-treelist-pager-prev-buttons", 1);
    ɵngcc0.ɵɵtemplate(2, PagerComponent_ng_container_1_kendo_treelist_pager_numeric_buttons_2_Template, 1, 1, "kendo-treelist-pager-numeric-buttons", 3);
    ɵngcc0.ɵɵtemplate(3, PagerComponent_ng_container_1_kendo_treelist_pager_input_3_Template, 1, 0, "kendo-treelist-pager-input", 1);
    ɵngcc0.ɵɵtemplate(4, PagerComponent_ng_container_1_kendo_treelist_pager_next_buttons_4_Template, 1, 0, "kendo-treelist-pager-next-buttons", 1);
    ɵngcc0.ɵɵtemplate(5, PagerComponent_ng_container_1_kendo_treelist_pager_info_5_Template, 1, 0, "kendo-treelist-pager-info", 1);
    ɵngcc0.ɵɵtemplate(6, PagerComponent_ng_container_1_kendo_treelist_pager_page_sizes_6_Template, 1, 1, "kendo-treelist-pager-page-sizes", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.settings.previousNext);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.settings.type === "numeric");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.settings.type === "input");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.settings.previousNext);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.settings.info);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.settings.pageSizes);
} }
const _c115 = function (a2) { return { "k-link": true, "k-pager-nav": true, "k-state-disabled": a2, "k-pager-first": true }; };
const _c116 = function () { return { "k-icon": true, "k-i-seek-w": true }; };
const _c117 = function (a2) { return { "k-link": true, "k-pager-nav": true, "k-state-disabled": a2, "": true }; };
const _c118 = function () { return { "k-icon": true, "k-i-arrow-w": true }; };
const _c119 = function () { return { "k-icon": true, "k-i-arrow-e": true }; };
const _c120 = function (a2) { return { "k-link": true, "k-pager-nav": true, "k-state-disabled": a2, "k-pager-last": true }; };
const _c121 = function () { return { "k-icon": true, "k-i-seek-e": true }; };
function PagerNumericButtonsComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "a", 3);
    ɵngcc0.ɵɵlistener("click", function PagerNumericButtonsComponent_li_1_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.changePage(ctx_r3.start - 2); });
    ɵngcc0.ɵɵtext(2, "...");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.pageLabel(ctx_r0.start - 1));
} }
const _c122 = function (a1) { return { "k-link": true, "k-state-selected": a1 }; };
function PagerNumericButtonsComponent_li_2_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "a", 4);
    ɵngcc0.ɵɵlistener("click", function PagerNumericButtonsComponent_li_2_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r7); const num_r5 = ctx.$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.changePage(num_r5 - 1); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const num_r5 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c122, ctx_r1.currentPage == num_r5));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", num_r5, " ");
} }
function PagerNumericButtonsComponent_li_3_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "a", 3);
    ɵngcc0.ɵɵlistener("click", function PagerNumericButtonsComponent_li_3_Template_a_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.changePage(ctx_r8.end); });
    ɵngcc0.ɵɵtext(2, "...");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.pageLabel(ctx_r2.end + 1));
} }
const _c123 = function () { return { "k-pager-numbers": true, "k-reset": true }; };
const _c124 = function () { return { "k-pager-input": true, "k-label": true }; };
const _c125 = function (a0, a1) { return { keydown: a0, focusout: a1 }; };
function PagerPageSizesComponent_option_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r1.pageSize);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.pageSize);
} }
function PagerPageSizesComponent_option_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const page_r3 = ctx.$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r2.getValue(page_r3))("selected", ctx_r2.getSelectedState(page_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", page_r3["text"], " ");
} }
const _c126 = ["kendoTreeListHeader", ""];
function HeaderComponent_tr_0_ng_template_1_th_0_kendo_treelist_filter_menu_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-filter-menu", 12);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", column_r5)("filter", ctx_r10.filter);
} }
function HeaderComponent_tr_0_ng_template_1_th_0_kendo_treelist_column_menu_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-column-menu", 13);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("standalone", false)("settings", ctx_r11.columnMenu)("column", column_r5)("columnMenuTemplate", ctx_r11.columnMenuTemplate)("sort", ctx_r11.sort)("filter", ctx_r11.filter)("sortable", ctx_r11.sortable);
} }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_3_ng_template_0_Template(rf, ctx) { }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵtextInterpolate(column_r5.displayTitle);
} }
const _c127 = function (a0, a1, a2, a3) { return { templateRef: a0, columnIndex: a1, column: a2, $implicit: a3 }; };
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_3_ng_template_0_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_3_ng_template_1_Template, 1, 1, "ng-template", 9);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(2, _c127, column_r5.headerTemplateRef, column_r5.leafIndex, column_r5, column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !column_r5.headerTemplateRef);
} }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_ng_template_2_Template(rf, ctx) { }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵtextInterpolate(column_r5.displayTitle);
} }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 20);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(3).$implicit;
    const ctx_r25 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r25.sortOrder(column_r5.field));
} }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 15, 16);
    ɵngcc0.ɵɵlistener("click", function HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r30); const _r22 = ɵngcc0.ɵɵreference(1); const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r28 = ɵngcc0.ɵɵnextContext(2); return ctx_r28.sortColumn(column_r5, $event, _r22); });
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_ng_template_2_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_ng_template_3_Template, 1, 1, "ng-template", 9);
    ɵngcc0.ɵɵelement(4, "span", 17);
    ɵngcc0.ɵɵtemplate(5, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_span_5_Template, 2, 1, "span", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(6, "span", 19);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(6, _c127, column_r5.headerTemplateRef, column_r5.leafIndex, column_r5, column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !column_r5.headerTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r13.sortIcon(column_r5.field));
    ɵngcc0.ɵɵattribute("aria-label", ctx_r13.sortableLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r13.showSortNumbering(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHtml", ctx_r13.sortStatus(column_r5), ɵngcc0.ɵɵsanitizeHtml);
} }
function HeaderComponent_tr_0_ng_template_1_th_0_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "input", 21);
    ɵngcc0.ɵɵlistener("click", function HeaderComponent_tr_0_ng_template_1_th_0_ng_container_5_Template_input_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(4); return ctx_r32.selectAllClick($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} }
function HeaderComponent_tr_0_ng_template_1_th_0_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 22);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", column_r5)("columns", ctx_r15.columns);
} }
const _c128 = function (a0, a2, a3, a4) { return { field: a0, type: "column", column: a2, hint: a3, lastColumn: a4 }; };
function HeaderComponent_tr_0_ng_template_1_th_0_Template(rf, ctx) { if (rf & 1) {
    const _r37 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 6);
    ɵngcc0.ɵɵlistener("keydown", function HeaderComponent_tr_0_ng_template_1_th_0_Template_th_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r37); const column_r5 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r35 = ɵngcc0.ɵɵnextContext(2); return ctx_r35.onHeaderKeydown(column_r5, $event); });
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_tr_0_ng_template_1_th_0_kendo_treelist_filter_menu_1_Template, 1, 2, "kendo-treelist-filter-menu", 7);
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_tr_0_ng_template_1_th_0_kendo_treelist_column_menu_2_Template, 1, 7, "kendo-treelist-column-menu", 8);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_3_Template, 2, 7, "ng-template", 9);
    ɵngcc0.ɵɵtemplate(4, HeaderComponent_tr_0_ng_template_1_th_0_ng_template_4_Template, 7, 11, "ng-template", 9);
    ɵngcc0.ɵɵtemplate(5, HeaderComponent_tr_0_ng_template_1_th_0_ng_container_5_Template, 2, 0, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(6, HeaderComponent_tr_0_ng_template_1_th_0_span_6_Template, 1, 2, "span", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r38 = ɵngcc0.ɵɵnextContext();
    const column_r5 = ctx_r38.$implicit;
    const columnIndex_r6 = ctx_r38.index;
    const last_r7 = ctx_r38.last;
    const levelIndex_r3 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-filterable", ctx_r8.showFilterMenu && ctx_r8.isFilterable(column_r5) || ctx_r8.showColumnMenu(column_r5))("k-first", ctx_r8.isFirstOnRow(column_r5, columnIndex_r6));
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r3)("logicalColIndex", ctx_r8.logicalColumnIndex(column_r5))("colSpan", column_r5.colspan)("rowSpan", column_r5.rowspan(ctx_r8.totalColumnLevels))("enableDrag", ctx_r8.shouldActivate(column_r5))("context", ɵngcc0.ɵɵpureFunction4(21, _c128, column_r5.field, column_r5, column_r5.title || column_r5.field, last_r7 && columnIndex_r6 === 0))("ngClass", column_r5.headerClass)("ngStyle", column_r5.headerStyle);
    ɵngcc0.ɵɵattribute("aria-sort", ctx_r8.sortState(column_r5))("rowspan", column_r5.rowspan(ctx_r8.totalColumnLevels))("colspan", column_r5.colspan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.showFilterMenu && ctx_r8.isFilterable(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.showColumnMenu(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r8.isSortable(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.isSortable(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.renderSelectAll(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.resizable);
} }
function HeaderComponent_tr_0_ng_template_1_th_1_kendo_treelist_column_menu_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-column-menu", 25);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r40 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("standalone", false)("settings", ctx_r40.columnMenu)("column", column_r5)("columnMenuTemplate", ctx_r40.columnMenuTemplate);
} }
function HeaderComponent_tr_0_ng_template_1_th_1_ng_template_2_Template(rf, ctx) { }
function HeaderComponent_tr_0_ng_template_1_th_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵtextInterpolate(column_r5.displayTitle);
} }
function HeaderComponent_tr_0_ng_template_1_th_1_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 22);
} if (rf & 2) {
    const column_r5 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r43 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", column_r5)("columns", ctx_r43.columns);
} }
const _c129 = function (a1, a2, a3) { return { type: "columnGroup", column: a1, hint: a2, lastColumn: a3 }; };
function HeaderComponent_tr_0_ng_template_1_th_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 23);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_tr_0_ng_template_1_th_1_kendo_treelist_column_menu_1_Template, 1, 4, "kendo-treelist-column-menu", 24);
    ɵngcc0.ɵɵtemplate(2, HeaderComponent_tr_0_ng_template_1_th_1_ng_template_2_Template, 0, 0, "ng-template", 14);
    ɵngcc0.ɵɵtemplate(3, HeaderComponent_tr_0_ng_template_1_th_1_ng_template_3_Template, 1, 1, "ng-template", 9);
    ɵngcc0.ɵɵtemplate(4, HeaderComponent_tr_0_ng_template_1_th_1_span_4_Template, 1, 2, "span", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext();
    const column_r5 = ctx_r47.$implicit;
    const columnIndex_r6 = ctx_r47.index;
    const last_r7 = ctx_r47.last;
    const levelIndex_r3 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-first", ctx_r9.isFirstOnRow(column_r5, columnIndex_r6))("k-filterable", ctx_r9.showColumnMenu(column_r5));
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r3)("logicalColIndex", ctx_r9.logicalColumnIndex(column_r5))("rowSpan", column_r5.rowspan(ctx_r9.totalColumnLevels))("colSpan", column_r5.colspan)("enableDrag", ctx_r9.shouldActivate(column_r5))("context", ɵngcc0.ɵɵpureFunction3(18, _c129, column_r5, column_r5.title, last_r7 && columnIndex_r6 === 0))("ngClass", column_r5.headerClass)("ngStyle", column_r5.headerStyle);
    ɵngcc0.ɵɵattribute("rowspan", column_r5.rowspan(ctx_r9.totalColumnLevels))("colspan", column_r5.colspan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r9.showColumnMenu(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("templateContext", ɵngcc0.ɵɵpureFunction4(22, _c127, column_r5.headerTemplateRef, ctx_r9.lockedColumnsCount + columnIndex_r6, column_r5, column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !column_r5.headerTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r9.resizable);
} }
function HeaderComponent_tr_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, HeaderComponent_tr_0_ng_template_1_th_0_Template, 7, 26, "th", 4);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_tr_0_ng_template_1_th_1_Template, 5, 27, "th", 5);
} if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r4.isColumnGroupComponent(column_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.isColumnGroupComponent(column_r5));
} }
function HeaderComponent_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 2);
    ɵngcc0.ɵɵtemplate(1, HeaderComponent_tr_0_ng_template_1_Template, 2, 2, "ng-template", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const levelIndex_r3 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", levelIndex_r3)("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.columnsForLevel(levelIndex_r3))("ngForTrackBy", ctx_r0.trackByIndex);
} }
function HeaderComponent_tr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "tr", 26);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("columns", ctx_r1.leafColumns)("filter", ctx_r1.filter)("lockedColumnsCount", ctx_r1.lockedColumnsCount)("logicalRowIndex", ctx_r1.totalColumnLevels + 1)("logicalSlaveRow", ctx_r1.lockedColumnsCount > 0)("logicalCellsCount", ctx_r1.columns.length)("logicalSlaveCellsCount", ctx_r1.unlockedColumnsCount);
} }
function FilterMenuComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-menu-container", 4);
    ɵngcc0.ɵɵlistener("close", function FilterMenuComponent_ng_template_3_Template_kendo_treelist_filter_menu_container_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.close(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r2.column)("filter", ctx_r2.filter);
} }
const _c130 = function (a1) { return { "k-grid-filter": true, "k-state-active": a1 }; };
function FilterMenuContainerComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementContainer(1, 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("filterService", ctx_r0.childService)("column", ctx_r0.column)("filter", ctx_r0.childFilter);
} }
function FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) { }
function FilterMenuContainerComponent_ng_container_4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.column.filterMenuTemplateRef)("ngTemplateOutletContext", ctx_r2.templateContext);
} }
function FilterMenuContainerComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, FilterMenuContainerComponent_ng_container_4_1_Template, 1, 2, undefined, 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.column.filterMenuTemplateRef);
} }
function StringFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵngcc0.ɵɵlistener("valueChange", function StringFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.logicChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", ctx_r0.logicOperators)("valuePrimitive", true)("value", ctx_r0.filter == null ? null : ctx_r0.filter.logic);
} }
function StringFilterMenuComponent_kendo_treelist_string_filter_menu_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-string-filter-menu-input", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter);
} }
function NumericFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵngcc0.ɵɵlistener("valueChange", function NumericFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.logicChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", ctx_r0.logicOperators)("valuePrimitive", true)("value", ctx_r0.filter == null ? null : ctx_r0.filter.logic);
} }
function NumericFilterMenuComponent_kendo_treelist_numeric_filter_menu_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-numeric-filter-menu-input", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("format", ctx_r1.format)("decimals", ctx_r1.decimals)("spinners", ctx_r1.spinners)("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step);
} }
function DateFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵngcc0.ɵɵlistener("valueChange", function DateFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.logicChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", ctx_r0.logicOperators)("valuePrimitive", true)("value", ctx_r0.filter == null ? null : ctx_r0.filter.logic);
} }
function DateFilterMenuComponent_kendo_treelist_date_filter_menu_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-date-filter-menu-input", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView)("topView", ctx_r1.topView)("format", ctx_r1.format)("formatPlaceholder", ctx_r1.formatPlaceholder)("placeholder", ctx_r1.placeholder)("min", ctx_r1.min)("max", ctx_r1.max)("weekNumber", ctx_r1.weekNumber);
} }
function BooleanFilterMenuComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li");
    ɵngcc0.ɵɵelementStart(1, "input", 2);
    ɵngcc0.ɵɵlistener("change", function BooleanFilterMenuComponent_li_1_Template_input_change_1_listener() { ɵngcc0.ɵɵrestoreView(_r3); const item_r1 = ctx.$implicit; const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onChange(item_r1.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "label", 3);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.idPrefix)("checked", ctx_r0.isSelected(item_r1.value));
    ɵngcc0.ɵɵattribute("id", ctx_r0.radioId(item_r1.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("for", ctx_r0.radioId(item_r1.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(item_r1.text);
} }
function ColumnListComponent_label_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 3);
    ɵngcc0.ɵɵelement(1, "input", 4);
    ɵngcc0.ɵɵelementStart(2, "span", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("checked", !column_r2.hidden)("disabled", ctx_r0.isDisabled(column_r2));
    ɵngcc0.ɵɵattribute("data-index", index_r3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(column_r2.displayTitle);
} }
function ColumnListComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelementStart(1, "button", 7);
    ɵngcc0.ɵɵlistener("click", function ColumnListComponent_div_2_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.cancelChanges(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 8);
    ɵngcc0.ɵɵlistener("click", function ColumnListComponent_div_2_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.applyChanges(); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.actionsClass);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.resetText);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.applyText);
} }
function ColumnChooserComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "kendo-treelist-columnlist", 5);
    ɵngcc0.ɵɵlistener("apply", function ColumnChooserComponent_ng_template_3_Template_kendo_treelist_columnlist_apply_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onApply($event); })("columnChange", function ColumnChooserComponent_ng_template_3_Template_kendo_treelist_columnlist_columnChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.onChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.localization.get("columns"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("columns", ctx_r2.columns)("applyText", ctx_r2.localization.get("columnsApply"))("resetText", ctx_r2.localization.get("columnsReset"))("autoSync", ctx_r2.autoSync)("allowHideAll", ctx_r2.allowHideAll);
} }
function ColumnMenuChooserComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnlist", 2);
    ɵngcc0.ɵɵlistener("apply", function ColumnMenuChooserComponent_ng_template_1_Template_kendo_treelist_columnlist_apply_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.onApply($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("applyText", ctx_r0.localization.get("columnsApply"))("resetText", ctx_r0.localization.get("columnsReset"))("columns", ctx_r0.columns)("autoSync", false)("allowHideAll", false)("actionsClass", ctx_r0.actionsClass);
} }
function ColumnMenuFilterComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-menu-container", 2);
    ɵngcc0.ɵɵlistener("close", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_treelist_filter_menu_container_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.close(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r0.service.column)("filter", ctx_r0.service.filter)("actionsClass", ctx_r0.actionsClass);
} }
function ColumnMenuItemComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 3);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.iconClass);
} }
function ColumnMenuItemComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementContainer(1, 5);
    ɵngcc0.ɵɵelement(2, "div");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@state", ctx_r1.contentState);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.contentTemplate.templateRef);
} }
const _c131 = function (a0, a1) { return { service: a0, column: a1 }; };
function ColumnMenuComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 5);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.column.columnMenuTemplateRef || ctx_r2.columnMenuTemplate || _r3)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c131, ctx_r2.service, ctx_r2.column));
} }
function ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_sort_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-columnmenu-sort", 8);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("service", ctx_r5.service);
} }
function ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_lock_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-treelist-columnmenu-lock", 8);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("service", ctx_r6.service);
} }
function ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_chooser_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnmenu-chooser", 9);
    ɵngcc0.ɵɵlistener("expand", function ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_chooser_2_Template_kendo_treelist_columnmenu_chooser_expand_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(2); return ctx_r9.onColumnsExpand(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("service", ctx_r7.service)("expanded", ctx_r7.expandedColumns);
} }
function ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_filter_3_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnmenu-filter", 9);
    ɵngcc0.ɵɵlistener("expand", function ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_filter_3_Template_kendo_treelist_columnmenu_filter_expand_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.onFilterExpand(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("service", ctx_r8.service)("expanded", ctx_r8.expandedFilter);
} }
function ColumnMenuComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_sort_0_Template, 1, 1, "kendo-treelist-columnmenu-sort", 6);
    ɵngcc0.ɵɵtemplate(1, ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_lock_1_Template, 1, 1, "kendo-treelist-columnmenu-lock", 6);
    ɵngcc0.ɵɵtemplate(2, ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_chooser_2_Template, 1, 2, "kendo-treelist-columnmenu-chooser", 7);
    ɵngcc0.ɵɵtemplate(3, ColumnMenuComponent_ng_template_5_kendo_treelist_columnmenu_filter_3_Template, 1, 2, "kendo-treelist-columnmenu-filter", 7);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasLock);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.hasFilter);
} }
const _c132 = function (a0) { return { "k-state-active": a0 }; };
const _c133 = ["kendoTreeListTableBody", ""];
function TableBodyComponent_tr_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 5);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.noRecordsTemplate.templateRef);
} }
function TableBodyComponent_tr_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.noRecordsText, " ");
} }
function TableBodyComponent_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 2);
    ɵngcc0.ɵɵelementStart(1, "td");
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_tr_0_ng_container_2_Template, 1, 1, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(3, TableBodyComponent_tr_0_ng_container_3_Template, 2, 1, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("colspan", ctx_r0.colSpan);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef));
} }
function TableBodyComponent_ng_container_1_tr_1_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 10);
} if (rf & 2) {
    const column_r9 = ctx.$implicit;
    const columnIndex_r10 = ctx.index;
    const item_r4 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-grid-edit-cell", ctx_r8.isEditingCell(item_r4, column_r9))("k-state-selected", ctx_r8.isCellSelected(item_r4.data, column_r9, ctx_r8.lockedColumnsCount + columnIndex_r10));
    ɵngcc0.ɵɵproperty("columnIndex", ctx_r8.lockedColumnsCount + columnIndex_r10)("column", column_r9)("viewItem", item_r4)("dataItem", item_r4.data)("level", item_r4.level)("hasChildren", item_r4.hasChildren)("isExpanded", item_r4.expanded)("loading", item_r4.loading)("isNew", item_r4.isNew)("selected", item_r4.selected)("expandIcons", ctx_r8.expandIcons)("logicalRowIndex", ctx_r8.logicalRowIndex(item_r4.rowIndex))("logicalColIndex", ctx_r8.logicalColIndex(column_r9))("dataRowIndex", item_r4.index)("column", column_r9)("colIndex", columnIndex_r10)("colSpan", column_r9.colspan)("expandable", column_r9.expandable)("ngClass", column_r9.cssClass)("ngStyle", column_r9.style);
    ɵngcc0.ɵɵattribute("aria-expanded", ctx_r8.ariaExpanded(item_r4, column_r9))("aria-selected", ctx_r8.ariaSelected(item_r4, column_r9, ctx_r8.lockedColumnsCount + columnIndex_r10))("colspan", column_r9.colspan);
} }
const _c134 = function (a0, a1) { return { dataItem: a0, index: a1 }; };
function TableBodyComponent_ng_container_1_tr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 8);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_container_1_tr_1_td_1_Template, 1, 27, "td", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    const item_r4 = ctx_r12.$implicit;
    const rowIndex_r5 = ctx_r12.index;
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-alt", ctx_r6.isOdd(item_r4))("k-grid-edit-row", ctx_r6.isEditingRow(item_r4))("k-grid-add-row", item_r4.isNew)("k-state-selected", item_r4.selected);
    ɵngcc0.ɵɵproperty("dataRowIndex", item_r4.index)("dataItem", item_r4.data)("logicalRowIndex", ctx_r6.logicalRowIndex(item_r4.rowIndex))("logicalSlaveRow", ctx_r6.lockedColumnsCount > 0)("logicalCellsCount", ctx_r6.columns.length)("logicalSlaveCellsCount", ctx_r6.unlockedColumnsCount)("isNew", item_r4.isNew)("ngClass", ctx_r6.rowClass(ɵngcc0.ɵɵpureFunction2(19, _c134, item_r4.data, item_r4.index)));
    ɵngcc0.ɵɵattribute("data-treelist-view-index", rowIndex_r5);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r6.columns)("ngForTrackBy", ctx_r6.trackByColumns);
} }
function TableBodyComponent_ng_container_1_tr_2_td_1_ng_container_1_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 16);
} }
function TableBodyComponent_ng_container_1_tr_2_td_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_container_1_tr_2_td_1_ng_container_1_span_1_Template, 1, 0, "span", 15);
    ɵngcc0.ɵɵpipe(2, "levelItems");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r4 = ɵngcc0.ɵɵnextContext(3).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, item_r4.level));
} }
const _c135 = function (a0, a1, a2, a3, a4, a5) { return { items: a0, field: a1, column: a2, columnIndex: a3, aggregates: a4, $implicit: a5 }; };
function TableBodyComponent_ng_container_1_tr_2_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 13);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_container_1_tr_2_td_1_ng_container_1_Template, 3, 3, "ng-container", 4);
    ɵngcc0.ɵɵelementContainer(2, 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r14 = ctx.$implicit;
    const columnIndex_r15 = ctx.index;
    const item_r4 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r13.logicalRowIndex(item_r4.rowIndex))("logicalColIndex", ctx_r13.logicalColIndex(column_r14))("column", column_r14)("colIndex", columnIndex_r15)("ngClass", column_r14.footerClass)("ngStyle", column_r14.footerStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", column_r14.expandable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", column_r14.footerTemplateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction6(9, _c135, item_r4.items, column_r14.field, column_r14, columnIndex_r15, item_r4.aggregates, item_r4.aggregates));
} }
function TableBodyComponent_ng_container_1_tr_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 11);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_container_1_tr_2_td_1_Template, 3, 16, "td", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext();
    const item_r4 = ctx_r21.$implicit;
    const rowIndex_r5 = ctx_r21.index;
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("logicalRowIndex", ctx_r7.logicalRowIndex(item_r4.rowIndex))("logicalSlaveRow", ctx_r7.lockedColumnsCount > 0)("logicalCellsCount", ctx_r7.columns.length)("logicalSlaveCellsCount", ctx_r7.unlockedColumnsCount);
    ɵngcc0.ɵɵattribute("data-treelist-view-index", rowIndex_r5);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r7.footerColumns)("ngForTrackBy", ctx_r7.trackByColumns);
} }
function TableBodyComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_container_1_tr_1_Template, 2, 22, "tr", 6);
    ɵngcc0.ɵɵtemplate(2, TableBodyComponent_ng_container_1_tr_2_Template, 2, 7, "tr", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r4.type === "data");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r4.type === "footer" && ctx_r1.hasFooter);
} }
const _c136 = ["kendoTreeListCell", ""];
function CellComponent_ng_container_1_ng_container_1_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
const _c137 = function (a0, a1, a2) { return { "k-i-collapse": a0, "k-i-expand": a1, "k-i-loading": a2 }; };
function CellComponent_ng_container_1_ng_container_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction3(1, _c137, ctx_r8.isExpanded && !ctx_r8.loading, !ctx_r8.isExpanded && !ctx_r8.loading, ctx_r8.loading));
} }
function CellComponent_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_span_1_Template, 1, 0, "span", 5);
    ɵngcc0.ɵɵpipe(2, "levelItems");
    ɵngcc0.ɵɵtemplate(3, CellComponent_ng_container_1_ng_container_1_span_3_Template, 1, 5, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind2(2, 2, ctx_r2.level, ctx_r2.hasChildren && ctx_r2.expandIcons));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.hasChildren && ctx_r2.expandIcons);
} }
function CellComponent_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 9);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.column.templateRef)("ngTemplateOutletContext", ctx_r3.templateContext);
} }
function CellComponent_ng_container_1_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "valueOf");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const childColumn_r11 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind3(2, 1, ctx_r10.dataItem, childColumn_r11.field, childColumn_r11.format), " ");
} }
function CellComponent_ng_container_1_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_3_ng_container_1_Template, 3, 5, "ng-container", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.childColumns);
} }
function CellComponent_ng_container_1_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "valueOf");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind3(2, 1, ctx_r5.dataItem, ctx_r5.column.field, ctx_r5.column.format));
} }
function CellComponent_ng_container_1_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 11);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("checked", ctx_r6.selected);
} }
function CellComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_Template, 4, 5, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_1_ng_container_2_Template, 1, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(3, CellComponent_ng_container_1_ng_container_3_Template, 2, 1, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(4, CellComponent_ng_container_1_ng_container_4_Template, 3, 5, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(5, CellComponent_ng_container_1_ng_template_5_Template, 1, 1, "ng-template", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.column.expandable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.column.templateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isSpanColumn);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isBoundColumn);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.column.isCheckboxColumn && !ctx_r0.isNew);
} }
function CellComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 9);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r12.column.editTemplateRef)("ngTemplateOutletContext", ctx_r12.editTemplateContext);
} }
function CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-numerictextbox", 16);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("format", ctx_r14.format)("formControl", ctx_r14.formGroup.get(ctx_r14.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-datepicker", 16);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("format", ctx_r15.format)("formControl", ctx_r15.formGroup.get(ctx_r15.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_input_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 17);
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("formControl", ctx_r16.formGroup.get(ctx_r16.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_input_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "input", 18);
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("formControl", ctx_r17.formGroup.get(ctx_r17.column.field));
} }
function CellComponent_ng_container_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0, 0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template, 1, 2, "kendo-numerictextbox", 13);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template, 1, 2, "kendo-datepicker", 13);
    ɵngcc0.ɵɵtemplate(3, CellComponent_ng_container_2_ng_container_2_input_3_Template, 1, 1, "input", 14);
    ɵngcc0.ɵɵtemplate(4, CellComponent_ng_container_2_ng_container_2_input_4_Template, 1, 1, "input", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r13.column.editor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "numeric");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "date");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "boolean");
} }
function CellComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_2_ng_container_1_Template, 1, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_2_ng_container_2_Template, 5, 4, "ng-container", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.column.editTemplateRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.column.editTemplateRef);
} }
function ToolbarComponent_0_ng_template_0_Template(rf, ctx) { }
function ToolbarComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ToolbarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplateRef)("ngTemplateOutletContext", ctx_r0.context);
} }
class CellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) { return new (t || CellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
CellTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CellTemplateDirective, selectors: [["", "kendoTreeListCellTemplate", ""]] });
/** @nocollapse */
CellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the column edit-cell template of the TreeList ([see example]({% slug editing_template_forms_treelist %})).
 * Helps to customize the content of the edited cells. To define the cell template, nest an `<ng-template>`
 * tag with the `kendoTreeListEditTemplate` directive inside a `<kendo-treelist-column>` tag.
 *
 * The template context contains the following fields:
 * - `column`&mdash;The current column instance.
 * - `dataItem`&mdash;The current data item.
 * - `cellContext`&mdash;An object used to pass context information to built-in directives.
 * - `formGroup`&mdash;The current [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }}).
 * If you use the TreeList inside [Template-Driven Forms]({{ site.data.urls.angular['forms'] }}), it will be `undefined`.
 * - `isNew`&mdash;The state of the current item.
 * - `rowIndex`&mdash;The current row index. If inside a new item row, `rowIndex` is `-1`.
 */
class EditTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
EditTemplateDirective.ɵfac = function EditTemplateDirective_Factory(t) { return new (t || EditTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
EditTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EditTemplateDirective, selectors: [["", "kendoTreeListEditTemplate", ""]] });
/** @nocollapse */
EditTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EditTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListEditTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the column header cell template of the TreeList
 * ([more information and example]({% slug templates_columns_treelist %}#toc-header-template)).
 * Helps to customize the table header cell for the column.
 * To define a header template, nest an `<ng-template>` tag with the
 * [`kendoTreeListHeaderTemplate`]({% slug api_treelist_headertemplatedirective %}) directive inside the `<kendo-treelist-column>` tag.
 *
 *  The template context is set to the current column and then the following additional fields are passed:
 * * `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_treelist_columncomponent %}) option.
 * * `columnIndex`&mdash;Defines the current column index.
 *
 * {% meta height:533 %}
 * {% embed_file configuration/header-template/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class HeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
HeaderTemplateDirective.ɵfac = function HeaderTemplateDirective_Factory(t) { return new (t || HeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
HeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HeaderTemplateDirective, selectors: [["", "kendoTreeListHeaderTemplate", ""]] });
/** @nocollapse */
HeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the column footer cell template of the TreeList
 * ([more information and example]({% slug templates_columns_treelist %}#toc-footer-template)).
 * Helps to customize the table footer cell for the column.
 * To define a footer template, nest an `<ng-template>` tag with the
 * [`kendoTreeListFooterTemplate`]({% slug api_treelist_footertemplatedirective %}) directive inside the `<kendo-treelist-column>` tag.
 *
 * The template context is set to the aggregate values and the following additional fields are passed:
 * * `aggregates`&mdash;The aggregates for the level items.
 * * `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_treelist_columncomponent %}) option.
 * * `columnIndex`&mdash;Defines the current column index.
 * * `field`&mdash;The name of the column field, if set.
 *
 *
 * {% meta height:500 %}
 * {% embed_file configuration/footer-template/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoTreeListFooterTemplate", ""]] });
/** @nocollapse */
FooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/* tslint:disable:max-line-length */
/**
 * Represents the template for the column menu in the TreeList. Provides an option for
 * customizing the content of the column menu for all or for specific columns.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoTreeListColumnMenuTemplate` directive inside the `kendo-treelist` or the `<kendo-treelist-column>` component.
 *
 * The template context is passes through the following fields:
 * - `service`&mdash;Represents the [ColumnMenuService]({% slug api_treelist_columnmenuservice %}).
 * - `column`&mdash;Represents the TreeList column.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ColumnMenuTemplateDirective.ɵfac = function ColumnMenuTemplateDirective_Factory(t) { return new (t || ColumnMenuTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ColumnMenuTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuTemplateDirective, selectors: [["", "kendoTreeListColumnMenuTemplate", ""]] });
/** @nocollapse */
ColumnMenuTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListColumnMenuTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
const isSpanColumn = column => column.isSpanColumn;
const isColumnContainer = column => column.isColumnGroup || isSpanColumn(column);
/**
 * The base class for the column components of the TreeList.
 */
class ColumnBase$1 {
    /**
     * @hidden
     */
    constructor(parent, optionChanges) {
        this.parent = parent;
        this.optionChanges = optionChanges;
        /**
         * @hidden
         */
        this.matchesMedia = true;
        /**
         * The column index after reordering.
         *
         * > `orderIndex` is a read-only property. Setting this field does not affect column order.
         */
        this.orderIndex = 0;
        /**
         * @hidden
         */
        this.isColumnGroup = false;
        /**
         * @hidden
         */
        this.isSpanColumn = false;
        /**
         * Indicates whether the column is resizable.
         * @default true
         */
        this.resizable = true;
        /**
         * Indicates whether the column is reorderable.
         * @default true
         */
        this.reorderable = true;
        /**
         * The width (in pixels) below which the user is not able to resize the column by using the UI.
         */
        this.minResizableWidth = 10;
        /**
         * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_treelist %})).
         *
         * @default false
         *
         * @example
         * ```ts
         * _@Component({
         *    selector: 'my-app',
         *    template: `
         *        <kendo-treelist [data]="treelistData" [scrollable]="scrollable" style="height: 200px">
         *          <kendo-treelist-column field="ProductID" title="Product ID" width="120" [locked]="true">
         *          </kendo-treelist-column>
         *          <kendo-treelist-column field="ProductName" title="Product Name" width="200">
         *          </kendo-treelist-column>
         *          <kendo-treelist-column field="UnitPrice" title="Unit Price" width="230">
         *          </kendo-treelist-column>
         *        </kendo-treelist>
         *    `
         * })
         *
         * class AppComponent {
         *    public treelistData: any[];
         *
         *    constructor() {
         *        this.treelistData = products;
         *    }
         * }
         *
         * const products = [{
         *    "ProductID": 1,
         *    "ProductName": "Chai",
         *    "UnitPrice": 18.0000,
         *    "Discontinued": true
         *  }, {
         *    "ProductID": 2,
         *    "ProductName": "Chang",
         *    "UnitPrice": 19.0000,
         *    "Discontinued": false
         *  }
         * ];
         *
         * ```
         */
        this.locked = false;
        /**
         * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.
         */
        this.lockable = true;
        /**
         * Specifies if the column menu will be shown for the column.
         */
        this.columnMenu = true;
        /**
         * Specifies if the column will be included in the column-chooser list.
         */
        this.includeInChooser = true;
        /**
         * @hidden
         */
        this.headerTemplates = new QueryList();
        /**
         * @hidden
         */
        this.columnMenuTemplates = new QueryList();
        if (parent && !isColumnContainer(parent)) {
            throw new Error('Columns can be nested only inside ColumnGroupComponent');
        }
    }
    /**
     * The width of the column (in pixels).
     */
    set width(value) {
        this._width = parseInt(value, 10);
    }
    get width() { return this._width; }
    /**
     * @hidden
     */
    get level() {
        if (this.parent && isSpanColumn(this.parent)) {
            return this.parent.level;
        }
        return this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.parent ? this.parent.isLocked : this.locked;
    }
    /**
     * @hidden
     */
    get colspan() {
        return 1;
    }
    /**
     * @hidden
     */
    rowspan(totalColumnLevels) {
        return this.level < totalColumnLevels ? (totalColumnLevels - this.level) + 1 : 1;
    }
    /**
     * @hidden
     */
    get headerTemplateRef() {
        const template = this.headerTemplates.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get footerTemplateRef() {
        return this.footerTemplate ? this.footerTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get columnMenuTemplateRef() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    /**
     * @hidden
     */
    get displayTitle() {
        return this.title;
    }
    /**
     * @hidden
     */
    get isVisible() {
        return !this.hidden && this.matchesMedia;
    }
    /**
     * @hidden
     */
    get isEditable() {
        return false;
    }
    ngOnChanges(_changes) {
        if (this.optionChanges) {
            this.optionChanges.columnChanged();
        }
    }
}
ColumnBase$1.ɵfac = function ColumnBase$1_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ColumnBase$1.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnBase$1, contentQueries: function ColumnBase$1_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
    } }, inputs: { resizable: "resizable", reorderable: "reorderable", minResizableWidth: "minResizableWidth", locked: "locked", lockable: "lockable", columnMenu: "columnMenu", includeInChooser: "includeInChooser", width: "width", title: "title", autoSize: "autoSize", hidden: "hidden", media: "media", style: "style", headerStyle: "headerStyle", footerStyle: "footerStyle", cssClass: ["class", "cssClass"], headerClass: "headerClass", footerClass: "footerClass" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
ColumnBase$1.propDecorators = {
    resizable: [{ type: Input }],
    reorderable: [{ type: Input }],
    minResizableWidth: [{ type: Input }],
    title: [{ type: Input }],
    width: [{ type: Input }],
    autoSize: [{ type: Input }],
    locked: [{ type: Input }],
    hidden: [{ type: Input }],
    media: [{ type: Input }],
    lockable: [{ type: Input }],
    columnMenu: [{ type: Input }],
    includeInChooser: [{ type: Input }],
    style: [{ type: Input }],
    headerStyle: [{ type: Input }],
    footerStyle: [{ type: Input }],
    cssClass: [{ type: Input, args: ['class',] }],
    headerClass: [{ type: Input }],
    footerClass: [{ type: Input }],
    headerTemplates: [{ type: ContentChildren, args: [HeaderTemplateDirective, { descendants: false },] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }],
    columnMenuTemplates: [{ type: ContentChildren, args: [ColumnMenuTemplateDirective,] }]
};


const EMPTY_REGEX = /^\s*$/;
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isTruthy = (value) => !!value;
/**
 * @hidden
 */
const isNullOrEmptyString = (value) => isBlank(value) || EMPTY_REGEX.test(value);
/**
 * @hidden
 */
const observe = (list) => merge(of(list), list.changes);
/**
 * @hidden
 */
const isUniversal = () => typeof document === 'undefined';
/**
 * @hidden
 */
const isString = (value) => typeof value === 'string';
/**
 * @hidden
 */
const isNumber = (value) => typeof value === "number" && !isNaN(value);
/**
 * @hidden
 */
const extractFormat = (format) => {
    if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {
        return format.slice(3, format.length - 1);
    }
    return format;
};
/**
 * @hidden
 */
const not = (fn) => (...args) => !fn.apply(null, args);
/**
 * @hidden
 */
const or = (...conditions) => (value) => conditions.reduce((acc, x) => acc || x(value), false);
/**
 * @hidden
 */
const and = (...conditions) => (value) => conditions.reduce((acc, x) => acc && x(value), true);
/**
 * @hidden
 */
const Skip = new InjectionToken("Skip"); // tslint:disable-line:variable-name
/**
 * @hidden
 */
const createPromise = () => {
    let resolveFn, rejectFn;
    const promise = new Promise((resolve, reject) => {
        resolveFn = (data) => {
            resolve(data);
            return promise;
        };
        rejectFn = (data) => {
            reject(data);
            return promise;
        };
    });
    promise.resolve = resolveFn;
    promise.reject = rejectFn;
    return promise;
};
/** @hidden */
const iterator = getIterator();
// TODO: Move to kendo-common
function getIterator() {
    if (typeof Symbol === 'function' && Symbol.iterator) {
        return Symbol.iterator;
    }
    const keys = Object.getOwnPropertyNames(Map.prototype);
    const proto = Map.prototype;
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {
            return key;
        }
    }
}
const FRAME_DURATION = 1000 / 60;
const wnd = typeof window !== 'undefined' ? window : {};
/** @hidden */
const requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));
/** @hidden */
const cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
/** @hidden */
const isColumnEditable = (column, formGroup) => column.isEditable !== false &&
    (column.editTemplate || (formGroup && column.field && formGroup.get(column.field)));

/**
 * Represents the filter-cell template ([see example]({% slug builtinfiltertemplate_treelist %}#toc-customizing-filter-rows)).
 *
 * The template context is set to the filter descriptor and the following additional fields are passed:
 * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `filter`&mdash;The filter descriptor.
 * - `cellContext`&mdash;An object used to pass context information to built-in directives.
 */
class FilterCellTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FilterCellTemplateDirective.ɵfac = function FilterCellTemplateDirective_Factory(t) { return new (t || FilterCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FilterCellTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterCellTemplateDirective, selectors: [["", "kendoTreeListFilterCellTemplate", ""]] });
/** @nocollapse */
FilterCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListFilterCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the filter-menu template
 * ([see example]({% slug builtinfiltertemplate_treelist %}#toc-customizing-filter-menus)).
 */
class FilterMenuTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FilterMenuTemplateDirective.ɵfac = function FilterMenuTemplateDirective_Factory(t) { return new (t || FilterMenuTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FilterMenuTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterMenuTemplateDirective, selectors: [["", "kendoTreeListFilterMenuTemplate", ""]] });
/** @nocollapse */
FilterMenuTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListFilterMenuTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class OptionChangesService {
    constructor() {
        this.columns = new EventEmitter();
        this.options = new EventEmitter();
    }
    optionChanged() {
        this.options.emit();
    }
    columnChanged() {
        this.columns.emit();
    }
}
OptionChangesService.ɵfac = function OptionChangesService_Factory(t) { return new (t || OptionChangesService)(); };
OptionChangesService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: OptionChangesService, factory: OptionChangesService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OptionChangesService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
function isColumnComponent(column) {
    return isPresent(column.field);
}
/**
 * Represents the columns of the [Angular TreeList]({% slug getstarted_treelist %}).
 *
 * {% meta height:470 %}
 * {% embed_file basic-usage/app.component.ts preview %}
 * {% embed_file basic-usage/app.module.ts %}
 * {% embed_file basic-usage/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnComponent extends ColumnBase$1 {
    constructor(parent, optionChanges) {
        super(parent, optionChanges);
        /**
         * Allows the column headers to be clicked and the `sortChange` event emitted.
         * You have to handle the `sortChange` event yourself and sort the data.
         */
        this.sortable = true;
        /**
         * Defines the editor type ([see example]({% slug editing_reactive_forms_treelist %}#toc-setup)).
         * Used when the column enters the edit mode. The default value is `text`.
         *
         * @example
         * ```html-no-run
         * <kendo-treelist>
         *    <kendo-treelist-column field="UnitPrice" editor="numeric">
         *    </kendo-treelist-column>
         * </kendo-treelist>
         * ```
         */
        this.editor = 'text';
        /**
         * Defines the filter type that is displayed inside the filter row. The default value is `text`.
         *
         * @example
         * ```html-no-run
         * <kendo-treelist>
         *    <kendo-treelist-column field="UnitPrice" filter="numeric">
         *    </kendo-treelist-column>
         * </kendo-treelist>
         * ```
         */
        this.filter = 'text';
        /**
         * Defines if a filter UI will be displayed for this column. The default value is `true`.
         *
         * @example
         * ```html-no-run
         * <kendo-treelist>
         *    <kendo-treelist-column field="UnitPrice" [filterable]="false">
         *    </kendo-treelist-column>
         * </kendo-treelist>
         * ```
         */
        this.filterable = true;
        /**
         * Defines whether the column is editable. The default value is `true`.
         *
         * @example
         * ```html-no-run
         * <kendo-treelist>
         *    <kendo-treelist-column field="UnitPrice" [editable]="false">
         *    </kendo-treelist-column>
         * </kendo-treelist>
         * ```
         */
        this.editable = true;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    get editTemplateRef() {
        return this.editTemplate ? this.editTemplate.templateRef : undefined;
    }
    get filterCellTemplateRef() {
        return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;
    }
    get filterMenuTemplateRef() {
        return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;
    }
    get displayTitle() {
        return this.title === undefined ? this.field : this.title;
    }
    /**
     * @hidden
     */
    get isEditable() {
        return this.editable !== false;
    }
}
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) { return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(OptionChangesService)); };
ColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnComponent, selectors: [["kendo-treelist-column"]], contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterCellTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterMenuTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);
    } }, inputs: { sortable: "sortable", editor: "editor", filter: "filter", filterable: "filterable", editable: "editable", expandable: "expandable", field: "field", format: "format" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => ColumnComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnComponent.ctorParameters = () => [
    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
    { type: OptionChangesService }
];
ColumnComponent.propDecorators = {
    expandable: [{ type: Input }],
    field: [{ type: Input }],
    format: [{ type: Input }],
    sortable: [{ type: Input }],
    editor: [{ type: Input }],
    filter: [{ type: Input }],
    filterable: [{ type: Input }],
    editable: [{ type: Input }],
    template: [{ type: ContentChild, args: [CellTemplateDirective,] }],
    editTemplate: [{ type: ContentChild, args: [EditTemplateDirective,] }],
    filterCellTemplate: [{ type: ContentChild, args: [FilterCellTemplateDirective,] }],
    filterMenuTemplate: [{ type: ContentChild, args: [FilterMenuTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => ColumnComponent)
                    }
                ],
                selector: 'kendo-treelist-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: OptionChangesService }]; }, { sortable: [{
            type: Input
        }], editor: [{
            type: Input
        }], filter: [{
            type: Input
        }], filterable: [{
            type: Input
        }], editable: [{
            type: Input
        }], expandable: [{
            type: Input
        }], field: [{
            type: Input
        }], format: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [CellTemplateDirective]
        }], editTemplate: [{
            type: ContentChild,
            args: [EditTemplateDirective]
        }], filterCellTemplate: [{
            type: ContentChild,
            args: [FilterCellTemplateDirective]
        }], filterMenuTemplate: [{
            type: ContentChild,
            args: [FilterMenuTemplateDirective]
        }] }); })();

/**
 * @hidden
 */
function isSpanColumnComponent(column) {
    return column.isSpanColumn;
}
/**
 * Represents a column which can be spanned over multiple data cells while the individual
 * header and footer cells are retained ([see example]({% slug spanned_columns_treelist %})).
 * Enables you to achieve more flexible layout while keeping the built-in UI element for
 * [sorting]({% slug sorting_treelist %}) and [filtering]({% slug filtering_treelist %}). Wrap the columns that will be
 * merged inside the `<kendo-treelist-span-column>` tag.
 *
 * {% meta height:570 %}
 * {% embed_file configuration/span-column/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 *
 * By default, the data cell displays the data for the specified fields. To further customize
 * the span-column functionality, use a [cell template]({% slug api_treelist_celltemplatedirective %}).
 *
 * ```html-no-run
 * <kendo-treelist-span-column>
 *  <kendo-treelist-column field="field1" title="Field 1"></kendo-treelist-column>
 *  <kendo-treelist-column field="field2" title="Field 2"></kendo-treelist-column>
 *    <ng-template kendoTreeListCellTemplate let-dataItem>
 *        <h5>{{ dataItem.field1 }}</h5>
 *        <p>{{ dataItem.field2 }}</p>
 *    </ng-template>
 *  </kendo-treelist-span-column>
 * ```
 */
class SpanColumnComponent extends ColumnBase$1 {
    constructor(parent, optionChanges) {
        super(parent, optionChanges);
        /*
         * @hidden
         */
        this.isSpanColumn = true;
        this.template = new QueryList();
        this.editTemplate = new QueryList();
        /**
         * @hidden
         */
        this.childColumns = new QueryList();
        /**
         * @hidden
         */
        this.includeInChooser = false;
        this._editable = true;
        this._locked = false;
        if (parent && parent.isSpanColumn) {
            throw new Error('SpanColumn cannot be nested inside another SpanColumn');
        }
    }
    /**
     * Defines whether the edit template of the column will be rendered. The default value is `false`.
     *
     * > To enable the editing functionality for a spanned column, set an edit template for it.
     *
     * @example
     * ```html-no-run
     * <kendo-treelist>
     *    <kendo-treelist-span-column [editable]="false">
     *      <kendo-treelist-column field="UnitPrice">
     *      </kendo-treelist-column>
     *      <kendo-treelist-column field="ProductName">
     *      </kendo-treelist-column>
     *      <ng-template kendoTreeListEditTemplate>
     *         .....
     *      </ng-template>
     *    </kendo-treelist-span-column>
     * </kendo-treelist>
     * ```
     */
    set editable(value) {
        this._editable = value;
    }
    get editable() {
        return isPresent(this.editTemplateRef) && this._editable;
    }
    /**
     * @hidden
     * added for backwards compitability
     */
    set width(_value) {
    }
    get width() {
        return this.childColumns.reduce((total, column) => total + column.width, 0);
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.childColumns.first.leafIndex;
    }
    /**
     * @hidden
     */
    get templateRef() {
        const template = this.template.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get editTemplateRef() {
        const editTemplate = this.editTemplate.first;
        return editTemplate ? editTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get colspan() {
        return this.childColumns.filter(c => c.isVisible).length;
    }
    /**
     * Toggles the locked (frozen) state of the columns. Locked columns are visible
     * at all times during the horizontal scrolling of the TreeList.
     *
     * For the option to work properly, make sure that:
     * - Scrolling is enabled.
     * - The `height` option of the TreeList is set.
     * - The widths of all TreeList columns are explicitly set in pixels. In this way,
     * the TreeList adjusts the layout of the locked and unlocked columns.
     *
     * @default false
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-treelist [data]="treelistData" [scrollable]="scrollable" style="height: 200px">
     *          <kendo-treelist-span-column [locked]="true">
     *             <kendo-treelist-column field="ProductID" title="Product ID" width="120">
     *             </kendo-treelist-column>
     *             <kendo-treelist-column field="ProductName" title="Product Name" width="200">
     *             </kendo-treelist-column>
     *          </kendo-treelist-span-column>
     *          <kendo-treelist-column field="UnitPrice" title="Unit Price" width="230">
     *          </kendo-treelist-column>
     *        </kendo-treelist>
     *    `
     * })
     *
     * class AppComponent {
     *    public treelistData: any[];
     *
     *    constructor() {
     *        this.treelistData = products;
     *    }
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     *
     * ```
     */
    set locked(value) {
        this._locked = value;
    }
    get locked() {
        return this._locked || this.childColumns.some(c => c.locked);
    }
    get isEditable() {
        return Boolean(this.editTemplateRef);
    }
    get childrenArray() {
        return this.childColumns.toArray();
    }
    get hasChildren() {
        return this.childColumns.length > 0;
    }
}
SpanColumnComponent.ɵfac = function SpanColumnComponent_Factory(t) { return new (t || SpanColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(OptionChangesService)); };
SpanColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SpanColumnComponent, selectors: [["kendo-treelist-span-column"]], contentQueries: function SpanColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, EditTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editTemplate = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childColumns = _t);
    } }, inputs: { editable: "editable", locked: "locked", expandable: "expandable" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => SpanColumnComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SpanColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
SpanColumnComponent.ctorParameters = () => [
    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
    { type: OptionChangesService }
];
SpanColumnComponent.propDecorators = {
    expandable: [{ type: Input }],
    template: [{ type: ContentChildren, args: [CellTemplateDirective, { descendants: false },] }],
    editTemplate: [{ type: ContentChildren, args: [EditTemplateDirective, { descendants: false },] }],
    childColumns: [{ type: ContentChildren, args: [ColumnComponent,] }],
    editable: [{ type: Input }],
    locked: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SpanColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => SpanColumnComponent)
                    }
                ],
                selector: 'kendo-treelist-span-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: OptionChangesService }]; }, { template: [{
            type: ContentChildren,
            args: [CellTemplateDirective, { descendants: false }]
        }], editTemplate: [{
            type: ContentChildren,
            args: [EditTemplateDirective, { descendants: false }]
        }], childColumns: [{
            type: ContentChildren,
            args: [ColumnComponent]
        }], editable: [{
            type: Input
        }], locked: [{
            type: Input
        }], expandable: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
const expandColumns = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []) // tslint:disable-line:align
);
/**
 * @hidden
 */
const expandColumnsWithSpan = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ?
    [column].concat(column.childrenArray) :
    [column]), []) // tslint:disable-line:align
);
/**
 * @hidden
 */
const columnsToRender = (columns) => (expandColumns(columns).filter(x => x.isVisible));
const sumProp = (prop) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);
/**
 * @hidden
 */
const sumColumnWidths = sumProp('width');
/**
 * @hidden
 */
const columnsSpan = sumProp('colspan');
// tslint:disable-next-line:max-line-length
const validField = new RegExp(`^[$A-Z\_a-z][$A-Z\_a-z0-9\\.]*$`);
/**
 * @hidden
 */
const isValidFieldName = (fieldName) => !isNullOrEmptyString(fieldName) && validField.test(fieldName) &&
    fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
/**
 * @hidden
 */
const children = column => column.children.filter(child => child !== column);
/**
 * @hidden
 */
const leafColumns = columns => {
    return columns.reduce((acc, column) => {
        if (column.isColumnGroup) {
            acc = acc.concat(leafColumns(children(column)));
        }
        else if (column.isSpanColumn) {
            acc = acc.concat(column.childrenArray);
        }
        else {
            acc.push(column);
        }
        return acc;
    }, []).filter(x => x.isVisible); // tslint:disable-line:align
};
/**
 * @hidden
 */
const someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
/**
 * @hidden
 */
const resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);
/**
 * @hidden
 */
const sortColumns = (columns) => orderBy(columns, [{ field: 'orderIndex', dir: 'asc' }]);
/**
 * @hidden
 */
const isInSpanColumn = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);

/**
 * @hidden
 */
function isColumnGroupComponent(column) {
    return column.isColumnGroup;
}
/**
 * Represents the column group header of the TreeList
 * ([more information and examples]({% slug multicolumnheaders_columns_treelist %})).
 *
 * {% meta height:533 %}
 * {% embed_file configuration/multi-column-headers/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/filesystem.ts %}
 * {% endmeta %}
 */
class ColumnGroupComponent extends ColumnBase$1 {
    constructor(parent, optionChanges) {
        super(parent, optionChanges);
        /**
         * @hidden
         */
        this.includeInChooser = false;
        /**
         * @hidden
         */
        this.isColumnGroup = true;
        /**
         * @hidden
         */
        this.minResizableWidth = 10;
        if (parent && parent.isSpanColumn) {
            throw new Error('ColumnGroupComponent cannot be nested inside SpanColumnComponent');
        }
    }
    /**
     * @hidden
     */
    rowspan() {
        return 1;
    }
    /**
     * @hidden
     */
    get colspan() {
        if (!this.children || this.children.length === 1) {
            return 1;
        }
        return columnsSpan(this.children
            .filter(child => child !== this && child.isVisible));
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.children ? (this.firstChild || {}).leafIndex : -1;
    }
    get childrenArray() {
        return this.children.filter(c => c !== this);
    }
    get hasChildren() {
        return Boolean(this.firstChild);
    }
    get firstChild() {
        return this.children.find(column => column !== this);
    }
}
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) { return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(OptionChangesService)); };
ColumnGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnGroupComponent, selectors: [["kendo-treelist-column-group"]], contentQueries: function ColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase$1, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => ColumnGroupComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnGroupComponent.ctorParameters = () => [
    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
    { type: OptionChangesService }
];
ColumnGroupComponent.propDecorators = {
    children: [{ type: ContentChildren, args: [ColumnBase$1,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnGroupComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => ColumnGroupComponent)
                    }
                ],
                selector: 'kendo-treelist-column-group',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: OptionChangesService }]; }, { children: [{
            type: ContentChildren,
            args: [ColumnBase$1]
        }] }); })();

const canCreateElement = () => isDocumentAvailable() && document.createElement;
let cachedScrollbarWidth = null;
let cachedPixelRatio;
let cachedRtlScrollLeft = null;
function scrollbarWidth() {
    if (cachedScrollbarWidth === null && canCreateElement()) {
        cachedPixelRatio = window.devicePixelRatio || 1;
        const div = document.createElement("div");
        div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
        div.innerHTML = "&nbsp;";
        document.body.appendChild(div);
        cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;
        document.body.removeChild(div);
    }
    return cachedScrollbarWidth;
}
function rtlScrollLeft() {
    if (cachedRtlScrollLeft === null && canCreateElement()) {
        const div = document.createElement("div");
        div.style.cssText = "overflow:scroll;zoom:1;clear:both;display:block;width:100px;visibility:hidden;position:absolute;left:-10000px;direction:rtl;";
        div.innerHTML = "<div style='width:200px;height:1px;'</div>";
        document.body.appendChild(div);
        const initial = div.scrollLeft;
        div.scrollLeft = -1;
        cachedRtlScrollLeft = div.scrollLeft < 0 ? div.scrollLeft : initial;
        document.body.removeChild(div);
    }
    return cachedRtlScrollLeft;
}
/**
 * @hidden
 * move to kendo-common
 */
class BrowserSupportService {
    constructor(zone, changeDetector) {
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.changes = new EventEmitter();
        if (typeof window !== 'undefined') {
            this.zone.runOutsideAngular(() => {
                fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {
                    if (cachedPixelRatio !== window.devicePixelRatio) {
                        zone.run(() => {
                            cachedScrollbarWidth = null;
                            this.changes.emit();
                            this.changeDetector.markForCheck();
                        });
                    }
                });
            });
        }
    }
    get scrollbarWidth() {
        return scrollbarWidth();
    }
    get rtlScrollLeft() {
        return rtlScrollLeft();
    }
}
BrowserSupportService.ɵfac = function BrowserSupportService_Factory(t) { return new (t || BrowserSupportService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef)); };
BrowserSupportService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BrowserSupportService, factory: BrowserSupportService.ɵfac });
/** @nocollapse */
BrowserSupportService.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BrowserSupportService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

/**
 * @hidden
 */
const EXPANDED_STATE = {
    isExpanded: () => true
};
/**
 * @hidden
 */
const UNSELECTED_STATE = {
    isRowSelected: () => false
};
/**
 * @hidden
 */
const NOT_EDITED_STATE = {
    hasNew: () => false,
    context: () => null
};
const identity = item => item;
function loadView(view, subject) {
    view.loadData();
    if (view.loading) {
        view.dataLoaded.pipe(take(1)).subscribe(() => {
            loadView(view, subject);
        });
    }
    else {
        subject.next(view);
    }
}
const LOADING = 'loading';
class ViewRange {
    constructor(skip, pageSize) {
        this.skip = skip;
        this.pageSize = pageSize;
    }
    static create(options) {
        const { skip, pageSize, pageable, isVirtual } = options;
        let rangeType = ViewRange;
        if (pageSize) {
            if (pageable) {
                rangeType = PagerRange;
            }
            else if (isVirtual) {
                rangeType = VirtualRange;
            }
        }
        return new rangeType(skip, pageSize);
    }
    inRange(_index, _rowIndex) {
        return true;
    }
    levelInRange(_parent, _items, _rowIndex) {
        return true;
    }
    includeParents(_children) {
    }
}
class PagerRange extends ViewRange {
    constructor() {
        super(...arguments);
        this.expandAll = true;
    }
    inRange(index, _rowIndex) {
        return this.skip <= index && index < this.skip + this.pageSize;
    }
    levelInRange(parent, items, _rowIndex) {
        return parent.level === -1 ||
            (this.skip <= parent.index + items.length && parent.index + 1 < this.skip + this.pageSize);
    }
    includeParents(children) {
        let parentLevel = children.parentLevel;
        while (parentLevel && !parentLevel.inRange) {
            parentLevel.inRange = true;
            parentLevel = parentLevel.parentLevel;
        }
    }
}
class VirtualRange extends ViewRange {
    inRange(_index, rowIndex) {
        return this.skip <= rowIndex && rowIndex < this.skip + this.pageSize;
    }
    levelInRange(parent, _items, rowIndex) {
        return this.inRange(parent.index, rowIndex);
    }
}
/**
 * @hidden
 */
class ViewItemFactory {
    constructor(expandState, editState, selectionState, loaded, fieldAccessor, rootItem) {
        this.expandState = expandState;
        this.editState = editState;
        this.selectionState = selectionState;
        this.loaded = loaded;
        this.fieldAccessor = fieldAccessor;
        this.observables = [];
        this.rowIndex = 0;
        const options = this.fieldAccessor();
        this.fetchChildren = options.fetchChildren;
        this.hasChildren = options.hasChildren;
        this.idGetter = options.idGetter;
        this.hasFooter = options.hasFooter;
        this.viewRange = ViewRange.create(options);
        if (rootItem) {
            this.rootLevel = this.loadChildren(rootItem);
        }
        else {
            this.rootLevel = this.dataLevel({
                level: -1,
                id: null,
                expanded: true
            }, options.data);
        }
    }
    // try to stop iteration if cached total and viewRange ends
    generate() {
        const result = [];
        const dataLevels = [this.rootLevel];
        let itemIndex = 0;
        let itemCount = 0;
        this.addNew(result);
        while (dataLevels.length) {
            while (dataLevels[0] && dataLevels[0].idx >= dataLevels[0].items.length) {
                const dataLevel = dataLevels.shift();
                if (this.hasFooter && dataLevel.expanded && dataLevel.items.length) {
                    if (dataLevel.inRange || this.viewRange.levelInRange(dataLevel.parent, dataLevel.items, this.rowIndex)) {
                        result.push({
                            type: 'footer',
                            items: dataLevel.items,
                            aggregates: dataLevel.aggregates,
                            level: dataLevel.level,
                            parentIndex: dataLevel.parentIndex,
                            rowIndex: this.rowIndex
                        });
                        this.viewRange.includeParents(dataLevel);
                    }
                    this.rowIndex++;
                }
            }
            if (!dataLevels.length) {
                break;
            }
            const currentLevel = dataLevels[0];
            const dataItem = currentLevel.items[currentLevel.idx++];
            const viewItem = {
                type: 'data',
                data: dataItem,
                id: this.idGetter(dataItem),
                rowIndex: this.rowIndex,
                index: itemIndex,
                level: currentLevel.level,
                hasChildren: this.hasChildren(dataItem),
                parent: currentLevel.parent
            };
            if (currentLevel.expanded) {
                this.rowIndex++;
                if (this.viewRange.inRange(itemIndex, viewItem.rowIndex)) {
                    if (this.offsetFirst) {
                        viewItem.rowIndex++;
                        this.rowIndex++;
                        this.offsetFirst = false;
                    }
                    result.push(viewItem);
                    viewItem.editContext = this.editState.context(viewItem.data);
                    viewItem.selected = this.selectionState.isRowSelected(dataItem);
                    this.addNew(result, dataItem);
                }
                itemIndex++;
            }
            itemCount++;
            const expanded = viewItem.hasChildren && this.expandState.isExpanded(viewItem.data);
            if (viewItem.hasChildren && (expanded || this.viewRange.expandAll)) {
                viewItem.expanded = expanded && currentLevel.expanded;
                const children = this.loadChildren(viewItem);
                if (children) {
                    dataLevels.unshift(children);
                    children.parentLevel = currentLevel;
                }
            }
        }
        return {
            items: result,
            observables: this.observables,
            total: itemCount,
            totalVisible: itemIndex,
            totalRows: this.rowIndex
        };
    }
    loadChildren(parent) {
        const parentId = parent.id;
        if (this.loaded.has(parentId)) {
            const children = this.loaded.get(parentId);
            if (children === LOADING) {
                parent.loading = true;
            }
            else {
                return this.dataLevel(parent, children);
            }
        }
        else {
            const children = this.fetchChildren(parent.data);
            if (isObservable(children)) {
                this.observables.push({
                    observable: children,
                    parentId: parentId
                });
                parent.loading = true;
            }
            else if (children) {
                this.loaded.set(parentId, children);
                return this.dataLevel(parent, children);
            }
        }
    }
    dataLevel(parent, children) {
        children = children || {};
        const data = children.data || children;
        const items = data && data.length ? data : [];
        return {
            idx: 0,
            level: parent.level + 1,
            items: items,
            aggregates: children.aggregates,
            expanded: parent.expanded,
            parentIndex: parent.index,
            parent: parent
        };
    }
    addNew(result, parent) {
        if (this.editState.hasNew(parent)) {
            const inRange = this.viewRange.inRange(0, this.rowIndex);
            const rowIndex = parent || inRange ? this.rowIndex : this.viewRange.skip;
            result.push({
                parent: parent,
                isNew: true,
                type: 'data',
                data: this.editState.newItem.dataItem,
                editContext: this.editState.newItem,
                rowIndex: rowIndex
            });
            if (parent || inRange) {
                this.rowIndex++;
            }
            else {
                this.offsetFirst = true;
            }
        }
    }
}
/**
 * @hidden
 */
class ViewCollection {
    constructor(fieldAccessor, expandState, editState, selectionState) {
        this.fieldAccessor = fieldAccessor;
        this.expandState = expandState;
        this.editState = editState;
        this.selectionState = selectionState;
        this.childrenLoaded = new EventEmitter();
        this.dataLoaded = new EventEmitter();
        this.resetPage = new EventEmitter();
        this.total = 0;
        this.totalVisible = 0;
        this.loaded = new Map();
        this.loading = false;
        this._totalRows = 0;
        this.loadingCount = 0;
    }
    static loadView(options) {
        const subject = new BehaviorSubject(null);
        const viewFields = () => Object.assign({
            idGetter: identity,
            pageable: false,
            isVirtual: false,
            skip: 0
        }, options.fields);
        const childrenView = new ViewCollection(viewFields, options.expandState || EXPANDED_STATE, options.editState || NOT_EDITED_STATE, options.selectionState || UNSELECTED_STATE);
        if (options.loaded) {
            childrenView.loaded = options.loaded;
        }
        loadView(childrenView, subject);
        return subject;
    }
    get totalRows() {
        if (!this._data) {
            this.loadData();
        }
        return this._totalRows;
    }
    get data() {
        if (!this._data) {
            this.loadData();
        }
        return this._data;
    }
    get length() { return this.data.length; }
    get first() { return this.data[0]; }
    get firstItem() {
        return this.find(item => item.type === 'data');
    }
    get last() { return this.data[this.data.length - 1]; }
    at(index) {
        return this.data[index];
    }
    itemIndex(item) {
        const idGetter = this.fieldAccessor().idGetter;
        return this.data.findIndex(i => i.id === idGetter(item));
    }
    map(fn) { return this.data.map(fn); }
    filter(fn) {
        return this.data.filter(fn);
    }
    findIndex(fn) {
        return this.data.findIndex(fn);
    }
    reduce(fn, init) {
        return this.data.reduce(fn, init);
    }
    forEach(fn) {
        this.data.forEach(fn);
    }
    some(fn) {
        return this.data.some(fn);
    }
    find(fn) {
        return this.data.find(fn);
    }
    toString() { return this.data.toString(); }
    updateSelectedState() {
        this.forEach(item => {
            if (item.type === 'data') {
                item.selected = this.selectionState.isRowSelected(item.data);
            }
        });
    }
    updateEditedState() {
        this.forEach(item => {
            if (item.type === 'data') {
                item.editContext = this.editState.context(item.data);
            }
        });
    }
    reset() {
        this.loaded.clear();
        this.clear();
        this.unsubscribeChildren();
    }
    resetItem(item, resetChildren) {
        const idGetter = this.fieldAccessor().idGetter;
        const toReset = [item];
        while (toReset.length) {
            const current = toReset.shift();
            const id = idGetter(current);
            if (this.loaded.has(id)) {
                const children = this.loaded.get(id);
                this.loaded.delete(id);
                if (resetChildren) {
                    toReset.push.apply(toReset, children.data || children);
                }
            }
        }
        this.clear();
    }
    clear() {
        this._data = null;
    }
    loadData() {
        const itemFactory = new ViewItemFactory(this.expandState, this.editState, this.selectionState, this.loaded, this.fieldAccessor);
        let result = itemFactory.generate();
        if (!result.loading && result.total && (!result.items.length || !result.items.some(i => i.type === 'data'))) {
            this.resetPage.emit();
            result = new ViewItemFactory(this.expandState, this.editState, this.selectionState, this.loaded, this.fieldAccessor).generate();
        }
        this._data = result.items;
        this.total = result.total;
        this.totalVisible = result.totalVisible;
        this._totalRows = result.totalRows;
        if (result.observables && result.observables.length) {
            this.loading = true;
            this.loadingCount += result.observables.length;
            if (!this.childrenSubscription) {
                this.childrenSubscription = new Subscription();
            }
            result.observables.forEach(o => {
                this.loaded.set(o.parentId, LOADING);
                this.childrenSubscription.add(o.observable.subscribe(children => {
                    this.clear();
                    this.loaded.set(o.parentId, children);
                    this.childrenLoaded.emit();
                    this.loadingCount--;
                    if (this.loadingCount === 0) {
                        this.loading = false;
                        this.unsubscribeChildren();
                        this.dataLoaded.emit();
                    }
                }));
            });
        }
        else {
            this.dataLoaded.emit();
        }
    }
    unsubscribeChildren() {
        if (this.childrenSubscription) {
            this.childrenSubscription.unsubscribe();
            this.childrenSubscription = null;
            this.loadingCount = 0;
        }
    }
}

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `cellClose` event.
 */
class CellCloseEvent extends PreventableEvent {
    constructor(options) {
        super();
        /**
         * @hidden
         */
        this.action = 'cellClose';
        Object.assign(this, options);
    }
}

const identity$1 = item => item;
/**
 * @hidden
 */
class EditService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new EventEmitter();
        this.idGetter = identity$1;
        // Maps IDs to edited rows
        this.edited = new Map();
        this.keepEditCell = false;
        this.closingCell = false;
        this.changedSource = new Subject();
        this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
    }
    get newItemGroup() {
        return this.newItem ? this.newItem.group : null;
    }
    editRow(dataItem, group = undefined) {
        this.edited.set(this.idGetter(dataItem), {
            group,
            item: dataItem
        });
        this.onChanged();
    }
    addRow(parent, group) {
        this.newItem = { parent, group, dataItem: group ? group.value : null };
        this.onChanged();
    }
    editCell(item, column, group) {
        if (!isColumnEditable(column, group)) {
            return;
        }
        this.preventCellClose();
        if (!this.closeCell()) {
            this.editRow(item, group);
            this.column = column;
            this.onChanged();
        }
    }
    isEditing() {
        return this.edited.size > 0;
    }
    isEdited(dataItem) {
        return (this.newItem && this.newItem.dataItem === dataItem) ||
            this.edited.has(this.idGetter(dataItem));
    }
    isEditingCell() {
        return isPresent(this.column);
    }
    isEditingColumn(column) {
        return this.column === column;
    }
    isEditedColumn(column) {
        return !this.column || this.column === column;
    }
    hasNew(parent) {
        return Boolean(this.newItem && ((!this.newItem.parent && !parent) ||
            this.idGetter(this.newItem.parent) === this.idGetter(parent)));
    }
    get newDataItem() {
        if (this.newItem) {
            return this.newItem.group.value;
        }
    }
    close(item, isNew) {
        if (isNew) { // parent
            this.newItem = undefined;
            return;
        }
        this.edited.delete(this.idGetter(item));
        delete this.column;
        this.onChanged();
    }
    closeCell(originalEvent) {
        if (this.column && !this.closingCell) {
            return this.ngZone.run(() => {
                const { item, group } = this.first;
                const args = new CellCloseEvent({
                    column: this.column,
                    formGroup: group,
                    originalEvent: originalEvent,
                    dataItem: item
                });
                this.closingCell = true;
                this.changes.emit(args);
                this.closingCell = false;
                if (!args.isDefaultPrevented()) {
                    this.cancelCell();
                }
                return args.isDefaultPrevented();
            });
        }
    }
    cancelCell() {
        if (this.column) {
            this.edited.clear();
            this.column = null;
            this.onChanged();
        }
    }
    shouldCloseCell() {
        return this.column && !this.keepEditCell;
    }
    preventCellClose() {
        this.ngZone.runOutsideAngular(() => {
            window.clearTimeout(this.keepCellTimeout);
            this.keepEditCell = true;
            this.keepCellTimeout = window.setTimeout(() => {
                this.keepEditCell = false;
            }, 0); // tslint:disable-line:align
        });
    }
    context(dataItem) {
        return this.edited.get(this.idGetter(dataItem));
    }
    beginEdit(item) {
        this.changes.emit({ action: 'edit', dataItem: item });
    }
    beginAdd(parent) {
        this.changes.emit({ action: 'add', parent });
    }
    endEdit(dataItem, isNew) {
        const formGroup = isNew ? this.newItemGroup : this.context(dataItem).group;
        this.changes.emit({ action: 'cancel', dataItem, formGroup, isNew });
    }
    save(item, isNew) {
        const args = { action: 'save', isNew: isNew };
        if (isNew) {
            args.parent = this.newItem.parent;
            args.formGroup = this.newItem.group;
            args.dataItem = item;
        }
        else {
            args.dataItem = item;
            args.formGroup = this.context(item).group;
        }
        this.changes.emit(args);
    }
    remove(dataItem, parent) {
        this.changes.emit({ action: 'remove', dataItem, parent });
    }
    onChanged() {
        this.ngZone.runOutsideAngular(() => {
            this.changedSource.next();
        });
    }
    get first() {
        if (this.isEditing()) {
            return this.edited.values().next().value;
        }
    }
}
EditService.ɵfac = function EditService_Factory(t) { return new (t || EditService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
EditService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: EditService, factory: EditService.ɵfac });
/** @nocollapse */
EditService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EditService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

const reset = (...lists) => {
    let diff = false;
    for (let idx = 0; idx < lists.length; idx++) {
        const [list, columns] = lists[idx];
        diff = diff || list.length !== columns.length;
        list.reset(columns);
    }
    return diff;
};
/**
 * @hidden
 */
class ColumnsContainer {
    constructor(columns) {
        this.columns = columns;
        this.allColumns = new QueryList();
        this.leafColumns = new QueryList();
        this.lockedColumns = new QueryList();
        this.nonLockedColumns = new QueryList();
        this.lockedLeafColumns = new QueryList();
        this.nonLockedLeafColumns = new QueryList();
        this.totalLevels = 0;
        this.changes = new EventEmitter();
        this.leafColumnsToRender = [];
        this.lockedColumnsToRender = [];
        this.nonLockedColumnsToRender = [];
        this.hasFooter = false;
        this.unlockedWidth = 0;
    }
    refresh() {
        const currentLevels = this.totalLevels;
        const leafColumns$$1 = new Array();
        const lockedLeafColumns = new Array();
        const nonLockedLeafColumns = new Array();
        const lockedColumns = new Array();
        const nonLockedColumns = new Array();
        const allColumns = new Array();
        const leafColumnsToRender = new Array();
        const lockedColumnsToRender = new Array();
        const nonLockedColumnsToRender = new Array();
        let hasFooter = false;
        let unlockedWidth = 0;
        let leafIndex = 0;
        this.totalLevels = 0;
        this.columns().forEach(column => {
            const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
            const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
            const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
            if (!isColumnGroupComponent(column)) {
                containerLeafColumns.push(column);
                leafColumns$$1.push(column);
                leafColumnsToRender.push.apply(leafColumnsToRender, columnsToRender([column]));
                toRenderContainer.push.apply(toRenderContainer, columnsToRender([column]));
                hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);
                if (!column.isLocked) {
                    unlockedWidth += column.width || 0;
                }
                if (column.isSpanColumn) {
                    column.childColumns.forEach(c => {
                        c.leafIndex = leafIndex++;
                    });
                }
                else {
                    column.leafIndex = leafIndex++;
                }
            }
            containerColumns.push(column);
            allColumns.push(column);
            this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
        });
        this.hasFooter = hasFooter;
        this.leafColumnsToRender = leafColumnsToRender;
        this.lockedColumnsToRender = lockedColumnsToRender;
        this.nonLockedColumnsToRender = nonLockedColumnsToRender;
        this.unlockedWidth = unlockedWidth;
        const changes = reset([this.leafColumns, leafColumns$$1], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
        if (changes) {
            this.changes.emit();
        }
        return changes;
    }
}

/**
 * @hidden
 */
class ChangeNotificationService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new EventEmitter();
    }
    notify() {
        if (!this.subscription || this.subscription.closed) {
            this.subscription = this.ngZone.onStable
                .asObservable().pipe(take(1))
                .subscribe(() => this.changes.emit());
        }
    }
}
ChangeNotificationService.ɵfac = function ChangeNotificationService_Factory(t) { return new (t || ChangeNotificationService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ChangeNotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ChangeNotificationService, factory: ChangeNotificationService.ɵfac });
/** @nocollapse */
ChangeNotificationService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChangeNotificationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * Represents the no-records template of the TreeList. Provides an option to customize the
 * appearance of the item that is displayed when no data is present. To define the no-records template,
 * nest an `<ng-template>` tag with the `kendoTreeListNoRecordsTemplate` directive inside `<kendo-treelist>`.
 *
 * > When the locked columns of the TreeList are in use, the template is displayed in the non-locked part of the content.
 *
 * {% meta height:533 %}
 * {% embed_file configuration/no-records-template/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class NoRecordsTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NoRecordsTemplateDirective.ɵfac = function NoRecordsTemplateDirective_Factory(t) { return new (t || NoRecordsTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
NoRecordsTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NoRecordsTemplateDirective, selectors: [["", "kendoTreeListNoRecordsTemplate", ""]] });
/** @nocollapse */
NoRecordsTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NoRecordsTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListNoRecordsTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

const set = value => pair => pair.forEach(x => x.style.height = value);
const clearHeight = pairs => pairs
    .filter(([left, right]) => left.style.height || right.style.height)
    .forEach(set(""));
const zip$1 = (arr1, arr2) => {
    const result = [];
    for (let idx = 0, len = arr1.length; idx < len; idx++) {
        if (!arr2[idx]) {
            break;
        }
        result.push([arr1[idx], arr2[idx]]);
    }
    return result;
};
const setHeight = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);
const getHeights = rows => rows.map(([left, right]) => {
    const height = left.offsetHeight;
    const offsetHeight2 = right.offsetHeight;
    if (height < offsetHeight2) {
        return offsetHeight2;
    }
    return height;
});
/**
 * @hidden
 */
const syncRowsHeight = (table1, table2) => {
    const activeElement = document.activeElement;
    const rows = zip$1(table1.rows, table2.rows);
    clearHeight(rows);
    const heights = getHeights(rows);
    [table1, table2].forEach(x => x.style.display = 'none');
    rows.forEach(setHeight(heights));
    [table1, table2].forEach(x => x.style.display = '');
    if (document.activeElement !== activeElement &&
        (table1.contains(activeElement) || table2.contains(activeElement))) {
        activeElement.focus();
    }
};

/**
 * Represents a service to set the filter descriptor
 * ([see example]({% slug reusablecustomfilters_treelist %})).
 */
class FilterService {
    constructor() {
        /**
         * Fires when the filter descriptors is set.
         */
        this.changes = new Subject();
    }
    /**
     * Sets the filter descriptor.
     *
     * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.
     */
    filter(value) {
        this.changes.next(value);
    }
}
FilterService.ɵfac = function FilterService_Factory(t) { return new (t || FilterService)(); };
FilterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FilterService, factory: FilterService.ɵfac });


/**
 * Represents the pager template which helps to customize the pager appearance in the TreeList. To define a pager
 * template, nest an `<ng-template>` tag with the `kendoTreeListPagerTemplate` directive inside `<kendo-treelist>`.
 *
 * The template context provides the following fields:
 * * `currentPage`&mdash;The index of the displayed page.
 * * `pageSize`&mdash;The value of the current `pageSize`.
 * * `skip`&mdash;The current skip value.
 * * `total`&mdash;The total number of records.
 * * `totalPages`&mdash;The total number of available pages.
 *
 * {% meta height:470 %}
 * {% embed_file configuration/pager-template-all/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/filesystem.ts %}
 * {% endmeta %}
 */
class PagerTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PagerTemplateDirective.ɵfac = function PagerTemplateDirective_Factory(t) { return new (t || PagerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PagerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PagerTemplateDirective, selectors: [["", "kendoTreeListPagerTemplate", ""]] });
/** @nocollapse */
PagerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListPagerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class PagerContextService {
    constructor() {
        this.changes = new Subject();
        this.pageChange = new Subject();
    }
    get currentPage() {
        return this.skip / this.pageSize;
    }
    notifyChanges(changes) {
        this.total = changes.total;
        this.pageSize = changes.pageSize;
        this.skip = changes.skip;
        this.allCount = changes.allCount;
        this.changes.next(changes);
    }
    changePage(page) {
        this.pageChange.next({ skip: page * this.pageSize, take: this.pageSize });
    }
    changePageSize(value) {
        this.pageChange.next({ skip: 0, take: value });
    }
    nextPage() {
        const nextPage = this.currentPage + 1;
        if (nextPage * this.pageSize <= this.total) {
            this.changePage(nextPage);
        }
    }
    prevPage() {
        const prevPage = this.currentPage - 1;
        if (prevPage * this.pageSize >= 0) {
            this.changePage(prevPage);
        }
    }
}
PagerContextService.ɵfac = function PagerContextService_Factory(t) { return new (t || PagerContextService)(); };
PagerContextService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PagerContextService, factory: PagerContextService.ɵfac });


/**
 * @hidden
 */
class PDFService {
    constructor() {
        this.savePDF = new EventEmitter();
        this.drawPDF = new EventEmitter();
        this.exportClick = new EventEmitter();
        this.dataChanged = new EventEmitter();
    }
    save(component) {
        this.emitEvent(this.savePDF, component);
    }
    draw(component, promise) {
        this.emitEvent(this.drawPDF, { component, promise });
    }
    emitEvent(emitter, args) {
        if (emitter.observers.length === 0) {
            if (isDevMode()) {
                throw new Error('Creating PDF requires including the PDFModule and adding the <kendo-treelist-pdf> component.');
            }
        }
        else {
            emitter.emit(args);
        }
    }
}
PDFService.ɵfac = function PDFService_Factory(t) { return new (t || PDFService)(); };
PDFService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PDFService, factory: PDFService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Arguments for the `pdfExport` event.
 */
class PDFExportEvent extends PreventableEvent {
}

/**
 * @hidden
 */
class SuspendService {
    constructor() {
        this.scroll = false;
    }
}
SuspendService.ɵfac = function SuspendService_Factory(t) { return new (t || SuspendService)(); };
SuspendService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SuspendService, factory: SuspendService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SuspendService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/* tslint:disable: object-literal-sort-keys */
const bootstrapToMedia = (media) => (({
    "xs": "(max-width: 576px)",
    "sm": "(min-width: 576px)",
    "md": "(min-width: 768px)",
    "lg": "(min-width: 992px)",
    "xl": "(min-width: 1200px)"
})[media] || media);
/* tslint:enable: object-literal-sort-keys */
const browserMatchMedia = (media) => window.matchMedia(media).matches;
/**
 * @hidden
 */
class ResponsiveService {
    constructor() {
        /**
         * @hidden
         */
        this.matchMedia = browserMatchMedia;
    }
    /**
     * @hidden
     */
    matchesMedia(media) {
        return !media || this.matchMedia(bootstrapToMedia(media));
    }
}
ResponsiveService.ɵfac = function ResponsiveService_Factory(t) { return new (t || ResponsiveService)(); };
ResponsiveService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ResponsiveService, factory: ResponsiveService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResponsiveService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class ExcelService {
    constructor() {
        this.saveToExcel = new EventEmitter();
        this.exportClick = new EventEmitter();
        this.loadingChange = new EventEmitter();
    }
    save(component) {
        if (this.saveToExcel.observers.length === 0) {
            if (isDevMode()) {
                throw new Error('Saving excel requires including the ExcelModule and adding the <kendo-treelist-excel> component.');
            }
        }
        else {
            this.saveToExcel.emit(component);
        }
    }
    toggleLoading(value) {
        this.loading = value;
        this.loadingChange.emit();
    }
}
ExcelService.ɵfac = function ExcelService_Factory(t) { return new (t || ExcelService)(); };
ExcelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ExcelService, factory: ExcelService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const forEachColumn = (list, callback) => {
    list.forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachColumn(column.childrenArray, callback);
        }
    });
};
const forEachLevel = (list, callback) => {
    sortColumns(list)
        .forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachLevel(column.childrenArray, callback);
        }
    });
};
const filterHierarchy = (list, predicate) => {
    const result = [];
    sortColumns(list)
        .forEach((column) => {
        if (predicate(column)) {
            if (column.isColumnGroup) {
                const children$$1 = filterHierarchy(column.childrenArray, predicate);
                if (children$$1.length) {
                    result.push(column, ...children$$1);
                }
            }
            else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
                result.push(column);
            }
        }
    });
    return result;
};
/**
 * @hidden
 */
class ColumnList {
    constructor(columns) {
        this.columns = columns;
    }
    static empty() {
        return new ColumnList(new QueryList());
    }
    forEach(callback) {
        forEachColumn(this.columns, callback);
    }
    filter(callback) {
        const result = [];
        forEachColumn(this.columns, (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    filterHierarchy(predicate) {
        return filterHierarchy(this.columns.toArray(), predicate);
    }
    filterSort(callback) {
        const result = [];
        forEachLevel(this.columns.toArray(), (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    toArray() {
        const result = [];
        forEachColumn(this.columns, (column) => {
            result.push(column);
        });
        return result;
    }
    rootColumns() {
        return this.columns.toArray();
    }
}

/**
 * Represents the toolbar template of the TreeList.
 *
 * The template context has the following field:
 * - `position`&mdash;The position at which the toolbar template is rendered. The possible values are "top" and "bottom".
 *
 * @example
 * {% meta height:470 %}
 * {% embed_file configuration/toolbar-template/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ToolbarTemplateDirective {
    constructor(templateRef, optionChanges) {
        this.templateRef = templateRef;
        this.optionChanges = optionChanges;
        this._position = "top";
    }
    /**
     * The position of the toolbar ([see example]({% slug toolbartemplate_treelist %})).
     *
     * The possible values are:
     * - `top`&mdash;Positions the toolbar above the group panel or header.
     * - `bottom`&mdash;Positions the toolbar below the pager.
     * - `both`&mdash;Displays two toolbar instances. Positions the first one above
     * the group panel or header and the second one below the pager.
     */
    set position(position) {
        this._position = position;
        this.optionChanges.optionChanged();
    }
    get position() {
        return this._position;
    }
}
ToolbarTemplateDirective.ɵfac = function ToolbarTemplateDirective_Factory(t) { return new (t || ToolbarTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8), ɵngcc0.ɵɵdirectiveInject(OptionChangesService)); };
ToolbarTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ToolbarTemplateDirective, selectors: [["", "kendoTreeListToolbarTemplate", ""]], inputs: { position: "position" } });
/** @nocollapse */
ToolbarTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] },
    { type: OptionChangesService }
];
ToolbarTemplateDirective.propDecorators = {
    position: [{ type: Input, args: ["position",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToolbarTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListToolbarTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }, { type: OptionChangesService }]; }, { position: [{
            type: Input,
            args: ["position"]
        }] }); })();

/**
 * @hidden
 */
class ScrollSyncService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new Subject();
        this.elements = [];
        this.subscriptions = new Subscription();
        this.headerSubscription = new Subscription();
        this.bodySubscription = new Subscription();
        this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));
    }
    registerEmitter(el, sourceType) {
        this.unregister(sourceType);
        this.elements.push({ element: el, sourceType });
        if (sourceType === "body" || sourceType === "header") {
            this.ngZone.runOutsideAngular(() => {
                const obs = fromEvent(el, "scroll").pipe(map(({ target: { scrollLeft } }) => ({
                    scrollLeft,
                    sourceType
                })));
                const subscription = obs.pipe(distinctUntilChanged((x, y) => (x.scrollLeft === y.scrollLeft)), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType))
                    .subscribe((x) => this.changes.next(x));
                subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType))
                    .subscribe(() => this.source = undefined));
                if (sourceType === "body") {
                    this.bodySubscription.add(subscription);
                }
                else {
                    this.headerSubscription.add(subscription);
                }
            });
        }
    }
    /**
     * destroy
     */
    destroy() {
        this.subscriptions.unsubscribe();
        this.headerSubscription.unsubscribe();
        this.bodySubscription.unsubscribe();
    }
    scrollLeft({ scrollLeft, sourceType }) {
        this.ngZone.runOutsideAngular(() => {
            this.elements
                .filter(x => sourceType !== x.sourceType)
                .forEach(({ element }) => element.scrollLeft = scrollLeft);
        });
    }
    unregister(sourceType) {
        const index = this.elements.findIndex(x => x.sourceType === sourceType);
        if (index > -1) {
            if (sourceType === "header") {
                this.headerSubscription.unsubscribe();
                this.headerSubscription = new Subscription();
            }
            else if (sourceType === "body") {
                this.bodySubscription.unsubscribe();
                this.bodySubscription = new Subscription();
            }
            this.elements.splice(index, 1);
        }
    }
}
ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) { return new (t || ScrollSyncService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ScrollSyncService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScrollSyncService, factory: ScrollSyncService.ɵfac });
/** @nocollapse */
ScrollSyncService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScrollSyncService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * @hidden
 */
class ResizeService {
    constructor() {
        this.resizeSubscription = new Subscription(() => { });
        this.dispatcher = new Subject();
        // tslint:disable-next-line:member-ordering
        this.changes = this.dispatcher.asObservable().pipe(throttleTime(100));
    }
    connect(resizes) {
        this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
    }
    destroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
}
ResizeService.ɵfac = function ResizeService_Factory(t) { return new (t || ResizeService)(); };
ResizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ResizeService, factory: ResizeService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const NODE_NAME_PREDICATES = {};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
/**
 * @hidden
 */
const matchesNodeName = (nodeName) => {
    if (!NODE_NAME_PREDICATES[nodeName]) {
        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
    }
    return NODE_NAME_PREDICATES[nodeName];
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const contains = (parent, node, matchSelf = false) => {
    const outside = !closest(node, (child) => child === parent);
    if (outside) {
        return false;
    }
    const el = closest(node, (child) => child === node);
    return el && (matchSelf || el !== parent);
};
/**
 * @hidden
 */
const isVisible = (element) => {
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they will still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (!element.tagName) {
        return false;
    }
    const tagName = element.tagName.toLowerCase();
    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));
    const focusable = !element.disabled && focusableRegex.test(tagName);
    return focusable || hasTabIndex;
};
/**
 * @hidden
 */
const isFocusableWithTabKey = (element, checkVisibility = true) => {
    if (!isFocusable(element)) {
        return false;
    }
    const tabIndex = element.getAttribute('tabIndex');
    const visible = !checkVisibility || isVisible(element);
    return visible && tabIndex !== '-1';
};
/**
 * @hidden
 */
const findElement = (node, predicate, matchSelf = true) => {
    if (!node) {
        return;
    }
    if (matchSelf && predicate(node)) {
        return node;
    }
    node = node.firstChild;
    while (node) {
        if (node.nodeType === 1) {
            const element = findElement(node, predicate);
            if (element) {
                return element;
            }
        }
        node = node.nextSibling;
    }
};
/**
 * @hidden
 */
const findFocusable = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
/**
 * @hidden
 */
const findFocusableChild = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
function rtlScrollPosition(position, element, initial) {
    let result = position;
    if (initial < 0) {
        result = -position;
    }
    else if (initial > 0) {
        result = element.scrollWidth - element.offsetWidth - position;
    }
    return result;
}

/**
 * @hidden
 */
class DomEventsService {
    constructor() {
        this.cellClick = new EventEmitter();
        this.cellMousedown = new EventEmitter();
        this.click = new EventEmitter();
        this.keydown = new EventEmitter();
        this.focus = new EventEmitter();
        this.focusIn = new EventEmitter();
        this.focusOut = new EventEmitter();
        this.windowBlur = new EventEmitter();
    }
}
DomEventsService.ɵfac = function DomEventsService_Factory(t) { return new (t || DomEventsService)(); };
DomEventsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DomEventsService, factory: DomEventsService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DomEventsService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
const isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;
/**
 * @hidden
 */
const resizeArgs = (column, extra) => Object.assign({
    columns: leafColumns([column]),
    locked: isLocked(column)
}, extra); // tslint:disable-line:align
/**
 * @hidden
 */
class ColumnResizingService {
    constructor() {
        this.changes = new EventEmitter();
        this.tables = [];
        this.batch = null;
    }
    start(column) {
        this.trackColumns(column);
        const columns = (this.column.isColumnGroup ? [column] : [])
            .concat(leafColumns([column]));
        this.changes.emit({
            columns: columns,
            locked: isLocked(this.column),
            type: 'start'
        });
    }
    resizeColumns(deltaPercent) {
        const action = resizeArgs(this.column, {
            deltaPercent,
            type: 'resizeColumn'
        });
        this.changes.emit(action);
    }
    resizeTable(column, delta) {
        const action = resizeArgs(column, {
            delta,
            type: 'resizeTable'
        });
        this.changes.emit(action);
    }
    resizedColumn(state$$1) {
        this.resizedColumns.push(state$$1);
    }
    end() {
        this.changes.emit({
            columns: [],
            resizedColumns: this.resizedColumns,
            type: 'end'
        });
    }
    registerTable(tableMetadata) {
        this.tables.push(tableMetadata);
        const unregisterTable = () => {
            this.tables.splice(this.tables.indexOf(tableMetadata), 1);
        };
        return unregisterTable;
    }
    measureColumns(info) {
        if (this.batch !== null) {
            this.batch.push(...info);
        }
        else {
            this.autoFitBatch(info, () => this.end());
        }
    }
    autoFit(...columns) {
        const nonLockedColumns = columns.filter(column => !column.isLocked);
        this.autoFitStart(nonLockedColumns);
        this.autoFitBatch(this.batch, () => {
            if (nonLockedColumns.length < columns.length) {
                const lockedColumns = columns.filter(column => column.isLocked);
                this.autoFitStart(lockedColumns);
                this.autoFitBatch(this.batch, () => this.end());
            }
            else {
                this.end();
            }
        });
    }
    trackColumns(column) {
        this.resizedColumns = [];
        this.column = column;
    }
    autoFitStart(columns) {
        this.batch = [];
        this.resizedColumns = [];
        if (columns.length === 0) {
            return;
        }
        const locked = columns[0].isLocked;
        this.changes.emit({
            type: 'start',
            columns,
            locked
        });
        this.changes.emit({
            type: 'triggerAutoFit',
            columns,
            locked
        });
    }
    autoFitBatch(info, onComplete) {
        const locked = info.length > 0 ? info[0].column.isLocked : false;
        const observables = this.tables
            .filter(table => table.locked === locked)
            .map(table => table.autoFit(info));
        zip(...observables)
            .pipe(take(1))
            .subscribe(widths => {
            this.changes.emit({
                columns: info.map(i => i.column),
                type: 'autoFitComplete',
                widths,
                locked
            });
            if (onComplete) {
                onComplete();
            }
        });
        this.batch = null;
    }
}
ColumnResizingService.ɵfac = function ColumnResizingService_Factory(t) { return new (t || ColumnResizingService)(); };
ColumnResizingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnResizingService, factory: ColumnResizingService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnResizingService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
/**
 * @hidden
 */
const hasFilterMenu = (settings) => typeof settings === 'string' && settings.indexOf('menu') > -1;
/**
 * @hidden
 */
const hasFilterRow = (settings) => settings === true || (typeof settings === 'string' && settings.indexOf('row') > -1);

const contains$1 = (node, predicate) => {
    while (node) {
        if (predicate(node)) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
};
/**
 * Arguments for the `close` event of the filter and column-menu popup.
 */
class PopupCloseEvent extends PreventableEvent {
    constructor(e) {
        super();
        this.originalEvent = e;
    }
}
const DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';
/**
 * The service that is used for the popups of the filter and column menus
 * ([see example]({% slug reusablecustomfilters_treelist %}#toc-filter-menu-with-popup)).
 */
class SinglePopupService {
    constructor(popupService, renderer, ngZone, scrollSyncService, localization) {
        this.popupService = popupService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.localization = localization;
        /**
         * Fires when the filter or column menus are about to close because the user clicked outside their popups.
         * Used to prevent the popup from closing.
         */
        this.onClose = new Subject();
        this.scrollSubscription = scrollSyncService.changes.subscribe(() => this.destroy());
    }
    /**
     * @hidden
     */
    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
        const toggle = isPresent(popupRef) && this.popupRef === popupRef;
        this.destroy();
        if (!toggle) {
            const direction = this.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction },
                anchor: anchor,
                popupClass: popupClass,
                content: template,
                positionMode: "absolute"
            });
            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');
            this.attachClose(anchor);
        }
        return this.popupRef;
    }
    /**
     * @hidden
     */
    destroy() {
        if (this.popupRef) {
            this.detachClose();
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    ngOnDestroy() {
        this.destroy();
        this.scrollSubscription.unsubscribe();
    }
    detachClose() {
        if (this.removeClick) {
            this.removeClick();
        }
    }
    attachClose(skipElement) {
        this.detachClose();
        this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen("document", "click", (e) => {
            if (!contains$1(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {
                const args = new PopupCloseEvent(e);
                this.onClose.next(args);
                if (!args.isDefaultPrevented()) {
                    this.destroy();
                }
            }
        }));
    }
}
SinglePopupService.ɵfac = function SinglePopupService_Factory(t) { return new (t || SinglePopupService)(ɵngcc0.ɵɵinject(ɵngcc1.PopupService), ɵngcc0.ɵɵinject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ScrollSyncService), ɵngcc0.ɵɵinject(ɵngcc2.LocalizationService)); };
SinglePopupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SinglePopupService, factory: SinglePopupService.ɵfac });
/** @nocollapse */
SinglePopupService.ctorParameters = () => [
    { type: PopupService },
    { type: Renderer2 },
    { type: NgZone },
    { type: ScrollSyncService },
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SinglePopupService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.PopupService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: ScrollSyncService }, { type: ɵngcc2.LocalizationService }]; }, null); })();

/* tslint:disable: no-bitwise */
/**
 * @hidden
 */
const append = (element) => {
    let appended = false;
    return () => {
        if (!appended) {
            document.body.appendChild(element);
            appended = true;
        }
        return element;
    };
};
/**
 * @hidden
 */
const getDocument = element => element.ownerDocument.documentElement;
/**
 * @hidden
 */
const getWindow = element => element.ownerDocument.defaultView;
/**
 * @hidden
 */
const offset = element => {
    const { clientTop, clientLeft } = getDocument(element);
    const { pageYOffset, pageXOffset } = getWindow(element);
    const { top, left } = element.getBoundingClientRect();
    return {
        top: top + pageYOffset - clientTop,
        left: left + pageXOffset - clientLeft
    };
};
/**
 * @hidden
 * If the target is before the draggable element, returns `true`.
 *
 * DOCUMENT_POSITION_FOLLOWING = 4
 */
const isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
/**
 * @hidden
 * If the container and the element are the same
 * or if the container holds (contains) the element, returns `true`.
 *
 * DOCUMENT_POSITION_CONTAINED_BY = 16
 */
const contains$2 = (element, container) => element === container ||
    (container.compareDocumentPosition(element) & 16) !== 0;
/**
 * @hidden
 */
const position = (target, before) => {
    const targetRect = offset(target);
    const { offsetWidth, offsetHeight } = target;
    const left = targetRect.left + (before ? 0 : offsetWidth);
    const top = targetRect.top;
    const height = offsetHeight;
    return { left, top, height };
};

/**
 * @hidden
 */
class DragAndDropService {
    constructor() {
        this.changes = new EventEmitter();
        this.register = [];
        this.lastTarget = null;
    }
    add(target) {
        this.register.push(target);
    }
    remove(target) {
        this.register = this.register.filter(current => current !== target);
    }
    notifyDrag(draggable, element, mouseEvent) {
        const target = this.targetFor(element);
        if (this.lastTarget === target) {
            return;
        }
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'leave'
        });
        if (target) {
            this.changes.next({
                draggable,
                mouseEvent,
                target,
                type: 'enter'
            });
        }
        this.lastTarget = target;
    }
    notifyDrop(draggable, mouseEvent) {
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'drop'
        });
        this.lastTarget = null;
    }
    targetFor(element) {
        const comparer = contains$2.bind(null, element);
        return this.register.find(({ element: { nativeElement } }) => comparer(nativeElement));
    }
}
DragAndDropService.ɵfac = function DragAndDropService_Factory(t) { return new (t || DragAndDropService)(); };
DragAndDropService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DragAndDropService, factory: DragAndDropService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragAndDropService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const updateClass = (element, valid) => {
    const icon = element.querySelector('.k-icon');
    icon.className = icon.className
        .replace(/(plus|cancel)/, valid ? 'plus' : 'cancel');
};
const updateLock = (element, locked = null) => {
    const icon = element.querySelectorAll('.k-icon')[1];
    const value = locked == null ? '' : (locked ? 'k-i-lock' : 'k-i-unlock');
    icon.className = icon.className
        .replace(/(k-i-unlock|k-i-lock)/, '') + ` ${value}`;
};
const decorate = (element, target) => {
    const targetStyles = getComputedStyle(target);
    element.className = 'k-header k-drag-clue';
    element.style.position = 'absolute';
    element.style.zIndex = '20000';
    element.style.paddingLeft = targetStyles.paddingLeft;
    element.style.paddingTop = targetStyles.paddingTop;
    element.style.paddingBottom = targetStyles.paddingBottom;
    element.style.paddingRight = targetStyles.paddingRight;
    element.style.width = targetStyles.width;
    element.style.height = targetStyles.height;
};
/**
 * @hidden
 */
class DragHintService {
    constructor(santizer) {
        this.santizer = santizer;
    }
    create(down, target, title) {
        this.initCoords(down);
        this.dom = document.createElement("div");
        decorate(this.dom, target);
        const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);
        this.dom.innerHTML = `
            <span class="k-icon k-drag-status k-i-cancel k-icon-with-modifier">
                <span class="k-icon k-icon-modifier"></span>
            </span>
            ${safeTitle}
        `;
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentNode) {
            (function (el) {
                setTimeout(() => document.body.removeChild(el));
            })(this.dom); // hack for IE + pointer events!
            this.dom = null;
        }
    }
    show() {
        this.dom.style.display = "";
    }
    hide() {
        this.dom.style.display = "none";
    }
    enable() {
        updateClass(this.dom, true);
    }
    disable() {
        updateClass(this.dom, false);
    }
    removeLock() {
        updateLock(this.dom);
    }
    toggleLock(locked) {
        updateLock(this.dom, locked);
    }
    move(move) {
        this.dom.style.top = this.initialTop + move.pageY + 'px';
        this.dom.style.left = this.initialLeft + move.pageX + 'px';
    }
    initCoords(down) {
        const { top, left } = offset(down.originalEvent.target);
        this.initialTop = top - down.pageY;
        this.initialLeft = left - down.pageX;
    }
}
DragHintService.ɵfac = function DragHintService_Factory(t) { return new (t || DragHintService)(ɵngcc0.ɵɵinject(ɵngcc3.DomSanitizer)); };
DragHintService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DragHintService, factory: DragHintService.ɵfac });
/** @nocollapse */
DragHintService.ctorParameters = () => [
    { type: DomSanitizer }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragHintService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc3.DomSanitizer }]; }, null); })();

/**
 * @hidden
 */
class DropCueService {
    create() {
        this.dom = document.createElement("div");
        this.dom.className = 'k-grouping-dropclue';
        this.hide();
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentElement) {
            document.body.removeChild(this.dom);
            this.dom = null;
        }
    }
    hide() {
        this.dom.style.display = "none";
    }
    position({ left, top, height }) {
        this.dom.style.display = 'block';
        this.dom.style.height = height + 'px';
        this.dom.style.top = top + 'px';
        const width = this.dom.offsetWidth / 2;
        this.dom.style.left = left - width + 'px';
    }
}
DropCueService.ɵfac = function DropCueService_Factory(t) { return new (t || DropCueService)(); };
DropCueService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DropCueService, factory: DropCueService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropCueService, [{
        type: Injectable
    }], null, null); })();

/**
 * @hidden
 */
class ColumnReorderService {
    constructor() {
        this.changes = new EventEmitter();
    }
    reorder(e) {
        this.changes.emit(e);
    }
}
ColumnReorderService.ɵfac = function ColumnReorderService_Factory(t) { return new (t || ColumnReorderService)(); };
ColumnReorderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnReorderService, factory: ColumnReorderService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnReorderService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Arguments for the `columnReorder` event.
 */
class ColumnReorderEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor({ column, newIndex, oldIndex }) {
        super();
        this.column = column;
        this.newIndex = newIndex;
        this.oldIndex = oldIndex;
    }
}

/**
 * @hidden
 */
class FocusRoot {
    constructor() {
        this.groups = new Set();
    }
    registerGroup(group) {
        if (this.alive) {
            this.groups.add(group);
        }
    }
    unregisterGroup(group) {
        if (this.alive) {
            this.groups.delete(group);
        }
    }
    activate() {
        if (this.alive) {
            this.groups.forEach(f => f.activate());
        }
    }
    deactivate() {
        if (this.alive) {
            this.groups.forEach(f => f.deactivate());
        }
    }
}
FocusRoot.ɵfac = function FocusRoot_Factory(t) { return new (t || FocusRoot)(); };
FocusRoot.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FocusRoot, factory: FocusRoot.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusRoot, [{
        type: Injectable
    }], function () { return []; }, null); })();

const isButton = matchesNodeName('button');
const isInputTag = matchesNodeName('input');
const navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
const isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);
const isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element));
/**
 * @hidden
 */
class DefaultFocusableElement {
    constructor(host, renderer) {
        this.renderer = renderer;
        this.element = host.nativeElement;
        this.focusable = findFocusable(this.element, false) || this.element;
    }
    get enabled() {
        return this.focusable && !this.focusable.disabled;
    }
    get visible() {
        return this.focusable && isVisible(this.focusable);
    }
    isNavigable() {
        return this.canFocus() && isNavigable(this.element);
    }
    toggle(active) {
        this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');
    }
    focus() {
        if (this.focusable) {
            this.focusable.focus();
        }
    }
    canFocus() {
        return this.visible && this.enabled;
    }
    hasFocus() {
        return document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);
    }
}

/**
 * Represents group of components that can be activated or focused.
 *
 * A focus group may contain focusable elements, such as rows, cells and input elements.
 *
 * Elements are added to the focus group by tagging them with the `kendoTreeListFocusable` directive.
 * See [Controlling the Focus]({% slug keyboard_navigation_treelist %}#toc-controlling-the-focus).
 *
 * @hidden
 */
class FocusGroup {
    /**
     * @hidden
     */
    constructor(root) {
        this.root = root;
        this.active = true;
        this.children = [];
        this.root.registerGroup(this);
    }
    get focusableChildren() {
        return this.children.filter(el => el.canFocus());
    }
    get isActive() {
        return this.active;
    }
    ngOnDestroy() {
        this.root.unregisterGroup(this);
    }
    /**
     * @hidden
     */
    registerElement(element) {
        this.unregisterElement(element);
        this.children.push(element);
    }
    /**
     * @hidden
     */
    unregisterElement(element) {
        this.children = this.children.filter(f => f !== element);
    }
    /**
     * Returns a boolean value which indicates if the group will receive focus when the cell is focused.
     * Evaluates to `true` when the focus group has a single focusable element such as a button or a checkbox.
     *
     * @returns A boolean value which indicates if the group will receive focus when the cell is focused.
     */
    isNavigable() {
        const focusable = this.focusableChildren;
        return focusable.length === 1 && focusable[0].isNavigable();
    }
    /**
     * Returns a boolean value which indicates if the focus group contains focusable component.
     *
     * @returns A boolean value which indicates if the focus group contains focusable component.
     */
    canFocus() {
        return this.focusableChildren.length > 0;
    }
    /**
     * Focuses the first focusable component, if any.
     */
    focus() {
        if (this.canFocus() && !this.hasFocus()) {
            this.focusableChildren[0].focus();
        }
    }
    /**
     * @hidden
     */
    activate() {
        this.toggleState(true);
    }
    /**
     * @hidden
     */
    deactivate() {
        this.toggleState(false);
    }
    hasFocus() {
        return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
    }
    toggleState(active) {
        if (this.active !== active) {
            this.active = active;
            this.children.forEach(f => f.toggle(active));
        }
    }
}
FocusGroup.ɵfac = function FocusGroup_Factory(t) { return new (t || FocusGroup)(ɵngcc0.ɵɵinject(FocusRoot)); };
FocusGroup.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FocusGroup, factory: FocusGroup.ɵfac });
/** @nocollapse */
FocusGroup.ctorParameters = () => [
    { type: FocusRoot }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusGroup, [{
        type: Injectable
    }], function () { return [{ type: FocusRoot }]; }, null); })();

/**
 * A directive that controls the way focusable cell elements receive
 * [focus in a navigable TreeList]({% slug keyboard_navigation_treelist %}).
 *
 * The directive takes as input the `cellContext` from the cell template.
 *
 * ```ts-no-run
 * <kendo-treelist-column>
 *   <ng-template kendoTreeListCellTemplate let-cellContext="cellContext">
 *     <input type="button" class="k-button" [kendoTreeListFocusable]="cellContext" value="Focus me!" />
 *   </ng-template>
 * </kendo-treelist-column>
 * ```
 */
class FocusableDirective {
    constructor(hostElement, renderer, group) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.group = group;
        this.active = true;
    }
    /**
     * @hidden
     */
    set addCellContext(value) { this.cellContext = value; }
    /**
     * @hidden
     */
    set editCellContext(value) { this.cellContext = value; }
    /**
     * @hidden
     */
    set removeCellContext(value) { this.cellContext = value; }
    /**
     * @hidden
     */
    set saveCellContext(value) { this.cellContext = value; }
    /**
     * @hidden
     */
    set cancelCellContext(value) { this.cellContext = value; }
    ngOnInit() {
        if (this.cellContext && this.cellContext.focusGroup) {
            this.group = this.cellContext.focusGroup;
        }
        if (this.group) {
            this.group.registerElement(this);
        }
    }
    ngAfterViewInit() {
        if (!this.element) {
            this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
        }
        if (this.group) {
            const isActive = this.group.isActive;
            this.toggle(isActive);
        }
    }
    ngOnDestroy() {
        if (this.group) {
            this.group.unregisterElement(this);
        }
    }
    /**
     * @hidden
     */
    toggle(active) {
        if (this.element && active !== this.active) {
            this.active = active;
            this.element.toggle(active);
        }
    }
    /**
     * @hidden
     */
    canFocus() {
        return this.element && this.element.canFocus();
    }
    /**
     * @hidden
     */
    isNavigable() {
        return this.element && this.element.isNavigable();
    }
    /**
     * @hidden
     */
    focus() {
        if (this.element) {
            this.element.focus();
        }
    }
    /**
     * @hidden
     */
    hasFocus() {
        return this.element && this.element.hasFocus();
    }
    /**
     * @hidden
     */
    registerElement(element) {
        this.element = element;
    }
}
FocusableDirective.ɵfac = function FocusableDirective_Factory(t) { return new (t || FocusableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(FocusGroup, 8)); };
FocusableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FocusableDirective, selectors: [["", "kendoTreeListFocusable", ""], ["", "kendoTreeListAddCommand", ""], ["", "kendoTreeListEditCommand", ""], ["", "kendoTreeListRemoveCommand", ""], ["", "kendoTreeListSaveCommand", ""], ["", "kendoTreeListCancelCommand", ""]], inputs: { addCellContext: ["kendoTreeListAddCommand", "addCellContext"], cellContext: ["kendoTreeListFocusable", "cellContext"], editCellContext: ["kendoTreeListEditCommand", "editCellContext"], removeCellContext: ["kendoTreeListRemoveCommand", "removeCellContext"], saveCellContext: ["kendoTreeListSaveCommand", "saveCellContext"], cancelCellContext: ["kendoTreeListCancelCommand", "cancelCellContext"] } });
/** @nocollapse */
FocusableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: FocusGroup, decorators: [{ type: Optional }] }
];
FocusableDirective.propDecorators = {
    cellContext: [{ type: Input, args: ['kendoTreeListFocusable',] }],
    addCellContext: [{ type: Input, args: ['kendoTreeListAddCommand',] }],
    editCellContext: [{ type: Input, args: ['kendoTreeListEditCommand',] }],
    removeCellContext: [{ type: Input, args: ['kendoTreeListRemoveCommand',] }],
    saveCellContext: [{ type: Input, args: ['kendoTreeListSaveCommand',] }],
    cancelCellContext: [{ type: Input, args: ['kendoTreeListCancelCommand',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListFocusable]' + `,
        [kendoTreeListAddCommand],
        [kendoTreeListEditCommand],
        [kendoTreeListRemoveCommand],
        [kendoTreeListSaveCommand],
        [kendoTreeListCancelCommand]
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: FocusGroup, decorators: [{
                type: Optional
            }] }]; }, { addCellContext: [{
            type: Input,
            args: ['kendoTreeListAddCommand']
        }], cellContext: [{
            type: Input,
            args: ['kendoTreeListFocusable']
        }], editCellContext: [{
            type: Input,
            args: ['kendoTreeListEditCommand']
        }], removeCellContext: [{
            type: Input,
            args: ['kendoTreeListRemoveCommand']
        }], saveCellContext: [{
            type: Input,
            args: ['kendoTreeListSaveCommand']
        }], cancelCellContext: [{
            type: Input,
            args: ['kendoTreeListCancelCommand']
        }] }); })();

/**
 * @hidden
 */
class NavigationCursor {
    constructor(model) {
        this.model = model;
        this.changes = new Subject();
        this.activeRow = 0;
        this.activeCol = 0;
        this.virtualCol = 0;
        this.virtualRow = 0;
    }
    get row() {
        return this.model.findRow(this.activeRow);
    }
    get cell() {
        const row = this.row;
        if (row) {
            return this.model.findCell(this.activeCol, row);
        }
    }
    get dataRowIndex() {
        const row = this.row;
        if (row) {
            return row.dataRowIndex;
        }
        return -1;
    }
    /**
     * Assumes and announces a new cursor position.
     */
    reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
        if (this.activate(rowIndex, colIndex, force)) {
            this.virtualRow = rowIndex;
            this.virtualCol = colIndex;
        }
    }
    activate(rowIndex, colIndex, force) {
        if (!force && this.isActiveRange(rowIndex, colIndex)) {
            return false;
        }
        const prevColIndex = this.activeCol;
        const prevRowIndex = this.activeRow;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
        this.changes.next({
            colIndex,
            prevColIndex,
            prevRowIndex,
            rowIndex
        });
        return true;
    }
    isActiveRange(rowIndex, colIndex) {
        if (this.activeRow !== rowIndex) {
            return false;
        }
        const cell = this.cell;
        const { start, end } = this.model.cellRange(cell);
        return !Boolean(cell) || (start <= colIndex && colIndex <= end);
    }
    /**
     * Assumes a new cursor position without announcing it.
     */
    assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
        this.virtualRow = rowIndex;
        this.virtualCol = colIndex;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
    }
    /**
     * Announces a current cursor position to subscribers.
     */
    announce() {
        this.changes.next({
            colIndex: this.activeCol,
            prevColIndex: this.activeCol,
            prevRowIndex: this.activeRow,
            rowIndex: this.activeRow
        });
    }
    activateVirtualCell(cell) {
        const rowRange = this.model.rowRange(cell);
        const cellRange = this.model.cellRange(cell);
        const activeCol = this.activeCol;
        const activeRow = this.activeRow;
        if (rowRange.start <= activeRow && activeRow <= rowRange.end &&
            cellRange.start <= activeCol && activeCol <= cellRange.end) {
            this.activeRow = cell.rowIndex;
            this.activeCol = cell.colIndex;
            return true;
        }
    }
    isActive(rowIndex, colIndex) {
        return this.activeCol === colIndex && this.activeRow === rowIndex;
    }
    moveUp(offset = 1) {
        return this.offsetRow(-offset);
    }
    moveDown(offset = 1) {
        return this.offsetRow(offset);
    }
    moveLeft(offset = 1) {
        return this.offsetCol(-offset);
    }
    moveRight(offset = 1) {
        return this.offsetCol(offset);
    }
    lastCellIndex() {
        return this.metadata.columns.leafColumnsToRender.length - 1;
    }
    offsetCol(offset) {
        const prevRow = this.model.findRow(this.virtualRow);
        const lastIndex = this.lastCellIndex();
        const virtualCol = this.virtualCol;
        this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));
        let nextColIndex = this.virtualCol;
        let nextRowIndex = this.virtualRow;
        let cell = this.model.findCell(this.virtualCol, prevRow);
        if (!cell && this.metadata.virtualColumns) {
            return this.activate(nextRowIndex, nextColIndex);
        }
        if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {
            nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);
            const nextCell = this.model.findCell(nextColIndex, prevRow);
            if (cell !== nextCell) {
                cell = nextCell;
                this.virtualCol = cell.colIndex;
            }
            else {
                this.virtualCol = virtualCol;
            }
        }
        return this.activate(cell.rowIndex, cell.colIndex);
    }
    offsetRow(offset) {
        let nextColIndex = this.virtualCol;
        if (this.metadata && this.metadata.isVirtual) {
            const maxIndex = this.metadata.maxLogicalRowIndex;
            let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));
            const nextRow = this.model.findRow(nextIndex);
            if (nextRow) {
                // remove duplication
                let cell = this.model.findCell(this.virtualCol, nextRow);
                if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {
                    cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));
                }
                nextIndex = cell.rowIndex;
                nextColIndex = cell.colIndex;
            }
            this.virtualRow = nextIndex;
            return this.activate(nextIndex, nextColIndex);
        }
        const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);
        if (!nextRow) {
            return false;
        }
        let cell = this.model.findCell(this.virtualCol, nextRow);
        if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) { // spanned cell go to next
            const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;
            cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
        }
        if (!cell && this.metadata.virtualColumns) {
            return this.activate(this.virtualRow + offset, this.virtualCol);
        }
        this.virtualRow = cell.rowIndex;
        return this.activate(this.virtualRow, cell.colIndex);
    }
}

/**
 * @hidden
 */
class ItemMap {
    constructor() {
        this.count = 0;
        this.items = {};
    }
    get first() {
        if (this.count > 0) {
            let result;
            this.forEach(item => {
                result = item;
                return true;
            });
            return result;
        }
    }
    get last() {
        if (this.count > 0) {
            const keys = Object.keys(this.items);
            return this.items[keys[keys.length - 1]];
        }
    }
    removeItem(key) {
        if (this.items[key]) {
            delete this.items[key];
            this.count--;
        }
    }
    setItem(key, item) {
        if (!this.items[key]) {
            this.count++;
        }
        this.items[key] = item;
    }
    getItem(key) {
        return this.items[key];
    }
    toArray() {
        const result = [];
        this.forEach(item => {
            result.push(item);
        });
        return result;
    }
    forEach(callback) {
        for (let key in this.items) {
            if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
                return this.items[key];
            }
        }
    }
    find(callback) {
        return this.forEach(callback);
    }
}

/**
 * @hidden
 */
class ModelCell {
    constructor(modelRow, cell) {
        this.uid = cell.uid;
        this.column = cell.column;
        this.colIndex = cell.logicalColIndex;
        this.rowIndex = modelRow.index;
        this.colSpan = cell.colSpan;
        this.rowSpan = cell.rowSpan;
        this.dataItem = modelRow.dataItem;
        this.dataRowIndex = modelRow.dataRowIndex;
        this.focusGroup = cell.focusGroup;
        this.expandable = cell.expandable;
    }
    focusContent() {
        if (this.focusGroup) {
            this.focusGroup.focus();
        }
    }
}

/**
 * @hidden
 *
 * Contains information for the currently rendered rows and cells.
 */
class NavigationModel {
    constructor() {
        this.rows = new ItemMap();
    }
    get firstRow() {
        return this.rows.first;
    }
    get lastRow() {
        return this.rows.last;
    }
    registerCell(cell) {
        const row = this.rows.getItem(cell.logicalRowIndex);
        if (!row) {
            return;
        }
        const modelCell = new ModelCell(row, cell);
        row.cells.setItem(cell.logicalColIndex, modelCell);
        return modelCell;
    }
    unregisterCell(index, rowIndex, cell) {
        const row = this.rows.getItem(rowIndex);
        if (row) {
            const match = row.cells.getItem(index);
            if (match && match.uid === cell.uid) {
                row.cells.removeItem(index);
            }
        }
    }
    registerRow(row) {
        const modelRow = {
            uid: row.uid,
            index: row.logicalRowIndex,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            cells: new ItemMap(),
            isNew: row.isNew
        };
        this.rows.setItem(row.logicalRowIndex, modelRow);
    }
    updateRow(row) {
        const current = this.rows.getItem(row.logicalRowIndex);
        if (current) {
            Object.assign(current, {
                dataItem: row.dataItem,
                dataRowIndex: row.dataRowIndex
            });
        }
    }
    unregisterRow(index, row) {
        const match = this.rows.getItem(index);
        if (match && match.uid === row.uid) {
            this.rows.removeItem(index);
        }
    }
    cellRange(cell) {
        if (cell) {
            const start = cell.colIndex;
            const end = cell.colIndex + (cell.colSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    rowRange(cell) {
        if (cell) {
            const start = cell.rowIndex;
            const end = cell.rowIndex + (cell.rowSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    nextRow(rowIndex, offset) {
        const rows = this.rows.toArray();
        const row = this.rows.getItem(rowIndex);
        const position = rows.indexOf(row);
        const next = rows[position + offset];
        return next;
    }
    findRow(index) {
        return this.rows.getItem(index);
    }
    findCell(index, row) {
        if (!row) {
            return;
        }
        const rowIndex = row.index;
        let cell = row.cells.getItem(index);
        let currentIndex = rowIndex;
        while (!cell && row) {
            row = this.rows.getItem(currentIndex);
            cell = this.rowCell(index, row);
            currentIndex--;
        }
        if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {
            return cell;
        }
    }
    rowCell(index, row) {
        if (!row || !row.cells.count) {
            return;
        }
        const firstCell = row.cells.first;
        let cell, currentIndex = index;
        while (!cell && currentIndex >= firstCell.colIndex) {
            cell = row.cells.getItem(currentIndex);
            currentIndex--;
        }
        if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {
            return cell;
        }
    }
}

/**
 * @hidden
 */
class TreeListFocusableElement {
    constructor(navigationService) {
        this.navigationService = navigationService;
    }
    focus() {
        this.navigationService.focusCell();
    }
    toggle(active) {
        this.navigationService.toggle(active);
    }
    canFocus() {
        return true;
    }
    hasFocus() {
        return this.navigationService.hasFocus();
    }
    isNavigable() {
        return false;
    }
}

/**
 * Arguments for the TreeList expand and collapse events.
 */
class ExpandEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(args) {
        super();
        this.expand = args.expand;
        this.dataItem = args.dataItem;
    }
}

/**
 * @hidden
 */
const defaultExpanded = (_item) => true;
/**
 * @hidden
 */
class ExpandStateService {
    constructor() {
        this.changes = new Subject();
        this.isExpanded = defaultExpanded;
    }
    toggleState(dataItem) {
        const isExpanded = this.isExpanded(dataItem);
        this.changes.next(new ExpandEvent({ dataItem: dataItem, expand: !isExpanded }));
    }
    expand(dataItem) {
        if (!this.isExpanded(dataItem)) {
            this.changes.next(new ExpandEvent({ dataItem: dataItem, expand: true }));
        }
    }
    collapse(dataItem) {
        if (this.isExpanded(dataItem)) {
            this.changes.next(new ExpandEvent({ dataItem: dataItem, expand: false }));
        }
    }
}
ExpandStateService.ɵfac = function ExpandStateService_Factory(t) { return new (t || ExpandStateService)(); };
ExpandStateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ExpandStateService, factory: ExpandStateService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandStateService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class ScrollRequestService {
    constructor() {
        this.requests = new Subject();
    }
    scrollTo(request) {
        this.requests.next(request);
    }
}
ScrollRequestService.ɵfac = function ScrollRequestService_Factory(t) { return new (t || ScrollRequestService)(); };
ScrollRequestService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScrollRequestService, factory: ScrollRequestService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScrollRequestService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Arguments for the TreeList `selectionChange` event.
 */
class SelectionChangeEvent {
    /**
     * @hidden
     */
    constructor(action, items) {
        this.action = action;
        this.items = items;
    }
}

/**
 * @hidden
 */
const defaultSelected = (_item) => false;
const noop = () => false;
/**
 * @hidden
 */
class SelectionService {
    constructor() {
        this.changes = new Subject();
        this.isSelected = defaultSelected;
        this.isRowSelected = noop;
        this.isCellSelected = noop;
        this.enabled = false;
        this._settings = {};
        this.tables = [];
        this.subscriptions = new Subscription();
    }
    set settings(value) {
        if (typeof value === 'object') {
            this._settings = value;
        }
        else {
            this._settings = {
                enabled: value
            };
        }
        this.enabled = this._settings.enabled !== false;
        if (this.enabled) {
            if (this._settings.mode === 'cell') {
                this.isCellSelected = this.cellSelected;
                this.isRowSelected = noop;
            }
            else {
                this.isCellSelected = noop;
                this.isRowSelected = this.rowSelected;
            }
        }
        else {
            this.isCellSelected = noop;
            this.isRowSelected = noop;
        }
    }
    get settings() {
        return this._settings;
    }
    get enableMarquee() {
        return this.enabled && this.settings.drag !== false && this.settings.multiple;
    }
    get enableMultiple() {
        return this.enabled && this.settings.multiple;
    }
    get rowSelection() {
        return this.enabled && this.settings.mode !== 'cell';
    }
    init(treelist) {
        this.view = treelist.view;
        this.columnsContainer = treelist.columnsContainer;
        this.subscriptions.add(merge(treelist.pageChange, treelist.dataStateChange).subscribe(() => {
            this.selectionOrigin = null;
        }));
        this.subscriptions.add(treelist.domEvents.cellMousedown.subscribe((args) => {
            if (this.enabled && this._settings.multiple && args.originalEvent.shiftKey) {
                args.originalEvent.preventDefault();
            }
        }));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    registerTable(table) {
        this.tables.push(table);
    }
    unregisterTable(table) {
        this.tables = this.tables.filter(t => t !== table);
    }
    click(args, toggle) {
        const { dataItem, column, columnIndex, originalEvent } = args;
        if (originalEvent.keyCode === Keys.Enter) {
            return;
        }
        const selected = this.isSelected(dataItem, column, columnIndex);
        const toggleSelected = originalEvent.ctrlKey || toggle;
        if (this._settings.multiple) {
            if (originalEvent.shiftKey) {
                const origin = this.selectionOrigin || {
                    columnIndex: 0,
                    column: this.leafColumns[0],
                    item: this.view.firstItem.data
                };
                this.selectRange({ item: dataItem, column, columnIndex }, origin);
            }
            else {
                this.selectionOrigin = {
                    item: dataItem,
                    column,
                    columnIndex
                };
                const action = toggleSelected ? (selected ? 'remove' : 'add') : 'select';
                this.changes.next(new SelectionChangeEvent(action, [{
                        dataItem,
                        column,
                        columnIndex
                    }]));
            }
        }
        else if (!selected || toggleSelected) {
            const action = selected && toggleSelected ? 'remove' : 'select';
            this.changes.next(new SelectionChangeEvent(action, [{
                    dataItem,
                    column,
                    columnIndex
                }]));
        }
        if (originalEvent.ctrlKey) {
            originalEvent.preventDefault();
        }
    }
    checkboxClick(args) {
        if (args.column.checkChildren && args.viewItem.hasChildren && !args.originalEvent.shiftKey && !args.originalEvent.ctrlKey) {
            const data = [args.dataItem];
            const selected = Boolean(args.viewItem.selected);
            ViewCollection.loadView({
                fields: Object.assign({}, this.view.fieldAccessor(), {
                    data: data,
                    hasFooter: false,
                    pageable: false,
                    isVirtual: false
                }),
                loaded: this.view.loaded,
                selectionState: this.view.selectionState
            }).subscribe(view => {
                if (!view) {
                    return;
                }
                const selectedItems = view.data.filter(item => Boolean(item.selected) === selected).map(item => ({
                    dataItem: item.data
                }));
                this.changes.next(new SelectionChangeEvent(selected ? 'remove' : 'add', selectedItems));
            });
        }
        else {
            this.click(args, true);
        }
    }
    toggleAll(select) {
        ViewCollection.loadView({
            fields: Object.assign({}, this.view.fieldAccessor(), {
                hasFooter: false,
                pageable: false,
                isVirtual: false
            }),
            loaded: this.view.loaded,
            selectionState: this.view.selectionState
        }).subscribe(view => {
            if (!view) {
                return;
            }
            const selectedItems = view.data.filter(item => Boolean(item.selected) !== select).map(item => ({
                dataItem: item.data
            }));
            this.changes.next(new SelectionChangeEvent(select ? 'add' : 'remove', selectedItems));
        });
    }
    selectRange(firstPoint, secondPoint) {
        const rangeItems = this.rangeItems(firstPoint, secondPoint);
        this.changes.next(new SelectionChangeEvent('select', rangeItems));
    }
    rangeItems(firstPoint, secondPoint) {
        const firstIndex = this.view.findIndex(item => item.data === firstPoint.item || item === firstPoint.item);
        const secondIndex = this.view.findIndex(item => item.data === secondPoint.item || item === secondPoint.item);
        const startIndex = Math.min(firstIndex, secondIndex);
        const endIndex = Math.max(firstIndex, secondIndex);
        const rangeItems = this.view.data.slice(startIndex, endIndex + 1).filter(item => item.type === 'data');
        if (this._settings.mode === 'cell') {
            const leafColumns = this.leafColumns;
            const startColumnIndex = Math.min(firstPoint.columnIndex, secondPoint.columnIndex);
            const endColumnIndex = Math.max(firstPoint.columnIndex, secondPoint.columnIndex);
            const selectedItems = [];
            for (let idx = 0; idx < rangeItems.length; idx++) {
                for (let columnIdx = startColumnIndex; columnIdx <= endColumnIndex; columnIdx++) {
                    selectedItems.push({
                        dataItem: rangeItems[idx].data,
                        column: leafColumns[columnIdx],
                        columnIndex: columnIdx
                    });
                }
            }
            return selectedItems;
        }
        return rangeItems.map(item => ({
            dataItem: item.data
        }));
    }
    updateSelectedState() {
        if (this.rowSelection) {
            this.view.updateSelectedState();
        }
    }
    targetArgs(target, skipFocusable) {
        let result;
        this.tables.some(t => {
            result = t.targetArgs(target, skipFocusable);
            return result;
        });
        return result;
    }
    rowSelected(dataItem) {
        return this.isSelected(dataItem);
    }
    cellSelected(dataItem, column, columnIndex) {
        return this.isSelected(dataItem, column, columnIndex);
    }
    // expose in the treelist?
    get leafColumns() {
        return this.columnsContainer.lockedLeafColumns.toArray().concat(this.columnsContainer.nonLockedLeafColumns.toArray());
    }
}
SelectionService.ɵfac = function SelectionService_Factory(t) { return new (t || SelectionService)(); };
SelectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SelectionService, factory: SelectionService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectionService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const isInSameTreeList = (element, treelistElement) => closest(element, matchesNodeName('kendo-treelist')) === treelistElement;
const matchHeaderCell = matchesNodeName('th');
const matchDataCell = matchesNodeName('td');
const matchCell = (element) => matchDataCell(element) || matchHeaderCell(element);
const treelistCell = (element, treelistElement) => {
    let target = closest(element, matchCell);
    while (target && !isInSameTreeList(target, treelistElement)) {
        target = closest(target.parentElement, matchCell);
    }
    return target;
};
const targetCell = (target, treelistElement) => {
    const cell = treelistCell(target, treelistElement);
    const row = closest(cell, matchesNodeName('tr'));
    if (cell && row) {
        let rowIndex = row.getAttribute('aria-rowindex');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
        let colIndex = cell.getAttribute('aria-colindex');
        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
        if (rowIndex !== null && colIndex !== null) {
            return { colIndex, rowIndex, element: cell };
        }
    }
};
const isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight ||
    keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
const isNavigationKey = keyCode => isArrowKey(keyCode) ||
    keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
    keyCode === Keys.Home || keyCode === Keys.End;
const isInput = matchesNodeName('input');
const isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';
const isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
/**
 * @hidden
 */
class NavigationViewport {
    constructor(firstItemIndex, lastItemIndex) {
        this.firstItemIndex = firstItemIndex;
        this.lastItemIndex = lastItemIndex;
    }
    containsRow(dataRowIndex) {
        const headerRow = dataRowIndex < 0;
        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex);
    }
    intersects(start, end) {
        return (start <= this.firstItemIndex && this.lastItemIndex <= end) ||
            (this.firstItemIndex <= start && start <= this.lastItemIndex) ||
            (this.firstItemIndex <= end && end <= this.lastItemIndex);
    }
}
/**
 * @hidden
 */
class NavigationService {
    constructor(zone, domEvents, pagerContextService, scrollRequestService, focusRoot, editService, localization, expandState, selectionService, changeDetector, focusableParent) {
        this.zone = zone;
        this.domEvents = domEvents;
        this.pagerContextService = pagerContextService;
        this.scrollRequestService = scrollRequestService;
        this.focusRoot = focusRoot;
        this.editService = editService;
        this.localization = localization;
        this.expandState = expandState;
        this.selectionService = selectionService;
        this.changeDetector = changeDetector;
        this.focusableParent = focusableParent;
        this.cellKeydown = new EventEmitter();
        this.activeRowIndex = 0;
        this.alive = false;
        this.active = true;
        this.mode = 0 /* Standby */;
        this.model = new NavigationModel();
        this.cursor = new NavigationCursor(this.model);
        this.changes = this.cursor.changes;
    }
    set metadata(value) {
        this.meta = value;
        this.cursor.metadata = value;
    }
    get metadata() {
        return this.meta;
    }
    get enabled() {
        return this.alive;
    }
    get activeCell() {
        if (this.mode !== 0 /* Standby */) {
            return this.cursor.cell;
        }
    }
    get activeRow() {
        if (this.mode !== 0 /* Standby */) {
            return Object.assign({}, this.cursor.row, {
                cells: this.cursor.row.cells.toArray()
            });
        }
    }
    get activeDataRow() {
        return Math.max(0, this.activeRowIndex - this.meta.headerRows);
    }
    init(meta) {
        this.alive = true;
        this.focusRoot.alive = true;
        this.metadata = meta;
        const onStableSubscriber = (...operators) => (args) => this.zone.isStable ?
            from([true]).pipe(map(() => args)) :
            this.zone.onStable.pipe(take(1), map(() => args), ...operators);
        const onStable = onStableSubscriber();
        this.subs = new Subscription();
        this.subs.add(this.cursor.changes
            .subscribe(args => this.onCursorChanges(args)));
        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable))
            .subscribe((args) => this.navigateTo(args.target)));
        this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* Standby */), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus))))
            .subscribe(args => this.onFocusOut(args)));
        this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* Standby */))
            .subscribe(() => this.onWindowBlur()));
        this.subs.add(
        // Closing the editor will not always trigger focusout in Firefox.
        // To get around this, we ensure that the cell is closed after editing.
        this.editService.changes.pipe(filter((e) => {
            if (e instanceof CellCloseEvent) {
                return !e.isDefaultPrevented();
            }
            return e.action !== 'edit' && this.mode === 2 /* Content */;
        }), switchMap(onStable))
            .subscribe(() => this.leaveCell()));
        this.subs.add(this.pagerContextService.pageChange
            .subscribe(() => this.cursor.reset(0, 0)));
        this.subs.add(this.domEvents.keydown
            .subscribe(args => this.onKeydown(args)));
        this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === Keys.Tab && this.mode === 2 /* Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
        // Timeout if focusOut doesn't fire very soon
        interval(0).pipe(take(1))))))
            .subscribe(() => this.onTabout()));
        if (this.focusableParent) {
            const element = new TreeListFocusableElement(this);
            this.focusableParent.registerElement(element);
        }
        this.deactivateElements();
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        this.alive = false;
    }
    registerCell(cell) {
        if (cell.logicalRowIndex !== this.pendingRowIndex) {
            const modelCell = this.model.registerCell(cell);
            if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
                this.virtualCell = false;
            }
        }
    }
    registerCellOnCurrentRow(cell) {
        if (cell.logicalRowIndex === this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    }
    unregisterCell(index, rowIndex, cell) {
        this.model.unregisterCell(index, rowIndex, cell);
    }
    registerRow(row) {
        this.model.registerRow(row);
        this.pendingRowIndex = row.logicalRowIndex;
    }
    updateRow(row) {
        this.model.updateRow(row);
    }
    unregisterRow(index, row) {
        this.model.unregisterRow(index, row);
    }
    isCellFocusable(cell) {
        return this.alive &&
            this.active &&
            this.mode !== 2 /* Content */ &&
            this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);
    }
    isCellFocused(cell) {
        return this.mode === 1 /* Cursor */ && this.isCellFocusable(cell);
    }
    navigateTo(el) {
        if (!this.alive) {
            return;
        }
        const cell = targetCell(el, this.meta.treelistElement.nativeElement);
        if (!cell) {
            return;
        }
        const oldMode = this.mode;
        const focusInCell = contains(cell.element, document.activeElement);
        const focusInActiveRowContent = this.mode === 2 /* Content */ &&
            this.activeRowIndex === cell.rowIndex &&
            el !== cell.element;
        if (focusInCell) {
            this.mode = 2 /* Content */;
            this.cursor.reset(cell.rowIndex, cell.colIndex);
            this.activateRow();
        }
        else if (!focusInActiveRowContent) {
            this.mode = 1 /* Cursor */;
            this.deactivateElements();
            const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);
            const isCursor = oldMode === 1 /* Cursor */ && alreadyActive;
            if (!isCursor) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
            }
        }
    }
    tryFocus(el) {
        this.activateElements();
        const focusable = findFocusableChild(el);
        if (focusable) {
            const cell = targetCell(focusable, this.meta.treelistElement.nativeElement);
            if (cell) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
                this.deactivateElements();
                this.enterCell();
            }
            focusable.focus();
        }
        else {
            this.deactivateElements();
        }
        return !!focusable;
    }
    needsViewport() {
        return this.meta && this.meta.isVirtual;
    }
    setViewport(firstItemIndex, lastItemIndex) {
        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.enabled && this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
            const dataRowIndex = this.activeDataRow;
            const ahead = firstItemIndex - dataRowIndex;
            const behind = dataRowIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(firstItemIndex + this.meta.headerRows);
            }
            else if (behind > 0) {
                this.cursor.reset(lastItemIndex - this.meta.headerRows);
            }
        }
    }
    setColumnViewport(firstItemIndex, lastItemIndex) {
        this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    }
    focusCell(rowIndex = undefined, colIndex = undefined) {
        this.mode = 1 /* Cursor */;
        this.cursor.reset(rowIndex, colIndex);
        return this.activeCell;
    }
    focusNextCell(wrap = true) {
        return this.focusAdjacentCell(true, wrap);
    }
    focusPrevCell(wrap = true) {
        return this.focusAdjacentCell(false, wrap);
    }
    toggle(active) {
        this.active = active;
        this.cursor.announce();
    }
    hasFocus() {
        return this.mode === 1 /* Cursor */ || this.mode === 2 /* Content */;
    }
    autoFocusCell(start, end) {
        return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);
    }
    focusAdjacentCell(fwd, wrap) {
        this.focusCell();
        let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
        if (wrap && !success) {
            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
            if (success) {
                const row = this.cursor.row;
                const colIdx = fwd ? 0 : this.cursor.lastCellIndex();
                this.cursor.reset(row.index, colIdx);
            }
        }
        if (success) {
            return this.activeCell;
        }
        else {
            this.mode = 0 /* Standby */;
            this.cursor.announce();
        }
        return null;
    }
    enterCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        this.mode = focusable ? 2 /* Content */ : 1 /* Cursor */;
        this.cursor.announce();
        if (focusable) {
            this.activateRow();
            group.focus();
        }
    }
    leaveCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        if (!focusable) {
            this.deactivateElements();
        }
        this.mode = 1 /* Cursor */;
        this.cursor.announce();
    }
    activateElements() {
        this.focusRoot.activate();
    }
    deactivateElements() {
        this.focusRoot.deactivate();
    }
    activateRow() {
        this.cursor.row.cells
            .forEach(cell => cell.focusGroup && cell.focusGroup.activate());
    }
    moveCursorFwd() {
        return this.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
    }
    moveCursorBwd() {
        return this.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
    }
    updateSelection(args) {
        if (this.selectionService.enabled) {
            this.selectionService.click({
                dataItem: this.cursor.row.dataItem,
                column: this.cursor.cell.column,
                columnIndex: this.cursor.cell.colIndex,
                originalEvent: args
            });
        }
    }
    onCursorKeydown(args) {
        let preventDefault = false;
        const modifier = args.ctrlKey || args.metaKey;
        const step = modifier ? 5 : 1;
        if (!this.onCellKeydown(args)) {
            return;
        }
        const row = this.cursor.row;
        switch (args.keyCode) {
            case Keys.Space:
                this.updateSelection(args);
                preventDefault = this.selectionService.enabled;
                break;
            case Keys.KeyA:
                if (args.ctrlKey && this.selectionService.enabled) {
                    this.zone.run(() => this.selectionService.toggleAll(true));
                    preventDefault = true;
                }
                break;
            case Keys.ArrowDown:
                preventDefault = this.cursor.moveDown(step);
                if (preventDefault && args.shiftKey) {
                    this.updateSelection(args);
                }
                break;
            case Keys.ArrowUp:
                preventDefault = this.cursor.moveUp(step);
                if (preventDefault && args.shiftKey) {
                    this.updateSelection(args);
                }
                break;
            case Keys.ArrowRight:
                if (args.altKey) {
                    this.zone.run(() => {
                        this.expandState.expand(row.dataItem);
                    });
                    preventDefault = true;
                }
                else {
                    preventDefault = this.moveCursorFwd();
                    if (preventDefault && args.shiftKey) {
                        this.updateSelection(args);
                    }
                }
                break;
            case Keys.ArrowLeft:
                if (args.altKey) {
                    this.zone.run(() => {
                        this.expandState.collapse(row.dataItem);
                    });
                    preventDefault = true;
                }
                else {
                    preventDefault = this.moveCursorBwd();
                    if (preventDefault && args.shiftKey) {
                        this.updateSelection(args);
                    }
                }
                break;
            case Keys.PageDown:
                if (this.metadata.isVirtual && this.viewport) {
                    let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
                    nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.nextPage());
                    preventDefault = true;
                }
                break;
            case Keys.PageUp:
                if (this.metadata.isVirtual && this.viewport) {
                    let viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
                    let firstItemIndex = this.viewport.firstItemIndex;
                    let nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.prevPage());
                    preventDefault = true;
                }
                break;
            case Keys.Home:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        this.cursor.reset(this.meta.headerRows, 0, false);
                    }
                    else {
                        this.cursor.reset(this.model.firstRow.index, 0, false);
                    }
                }
                else {
                    this.cursor.reset(row.index, 0, false);
                }
                preventDefault = true;
                break;
            case Keys.End:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        let lastRowIndex = this.meta.maxLogicalRowIndex;
                        this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
                    }
                    else {
                        this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(), false);
                    }
                }
                else {
                    const lastIndex = this.cursor.lastCellIndex();
                    const cell = this.model.findCell(lastIndex, row);
                    if (cell) {
                        this.cursor.reset(cell.rowIndex, cell.colIndex);
                    }
                    else {
                        this.cursor.reset(row.index, lastIndex);
                    }
                }
                preventDefault = true;
                break;
            case Keys.Enter:
                if (!args.ctrlKey && !args.shiftKey) {
                    const editing = this.editService.isEditingCell();
                    const cell = this.cursor.cell;
                    if (!editing && cell.expandable === true) {
                        this.zone.run(() => {
                            this.expandState.toggleState(row.dataItem);
                        });
                    }
                    else {
                        this.enterCell();
                        if (!cell.focusGroup.isNavigable()) {
                            preventDefault = true;
                        }
                    }
                }
                break;
            default:
                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
                    this.enterCell();
                }
        }
        if (preventDefault) {
            args.preventDefault();
        }
    }
    onContentKeydown(args) {
        if (!this.onCellKeydown(args)) {
            return;
        }
        const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);
        if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {
            this.leaveCell();
            this.cursor.reset();
            args.stopPropagation();
        }
        else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
            this.onCursorKeydown(args);
            if (args.defaultPrevented) {
                this.leaveCell();
            }
        }
    }
    onCellKeydown(args) {
        if (this.editService.isEditingCell()) {
            const confirm = args.keyCode === Keys.Enter;
            const cancel = args.keyCode === Keys.Escape;
            const navigate = isNavigationKey(args.keyCode);
            if (confirm) {
                return !this.editService.closeCell(args);
            }
            else if (cancel) {
                this.editService.cancelCell();
                this.meta.view.updateEditedState();
                this.changeDetector.detectChanges();
            }
            else if (navigate) {
                return false;
            }
        }
        this.cellKeydown.emit(args);
        return true;
    }
    onCursorChanges(args) {
        this.activeRowIndex = args.rowIndex;
        const dataRowIndex = this.activeDataRow;
        if (this.meta && (this.meta.isVirtual && this.viewport &&
            !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1)) {
            this.scrollRequestService.scrollTo({ row: dataRowIndex });
        }
        if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
            const cell = this.activeCell;
            const { start, end } = this.model.cellRange(cell);
            if (!cell) {
                this.virtualCell = true;
            }
            if ((!cell && this.mode !== 0 /* Standby */) || (cell && !this.columnViewport.intersects(start, end))) {
                this.scrollRequestService.scrollTo({ column: args.colIndex });
            }
        }
    }
    onFocusOut(args) {
        if (isVisible(args.target)) {
            this.mode = 0 /* Standby */;
        }
        else {
            // Focused target is no longer visible,
            // reset to cursor mode and recapture focus.
            this.mode = 1 /* Cursor */;
        }
        this.deactivateElements();
        this.cursor.announce();
    }
    onWindowBlur() {
        this.mode = 0 /* Standby */;
        this.deactivateElements();
        this.cursor.announce();
    }
    onKeydown(args) {
        if (this.mode === 1 /* Cursor */) {
            this.onCursorKeydown(args);
        }
        else if (this.mode === 2 /* Content */) {
            this.onContentKeydown(args);
        }
    }
    onTabout() {
        // Tabbed out of the last focusable content element
        // reset to cursor mode and recapture focus.
        if (this.cursor.cell.focusGroup.isNavigable()) {
            // Unless the cell has a single focusable element,
            // otherwise we'd return to Content mode and enter an endless loop
            return;
        }
        this.leaveCell();
        this.cursor.reset();
    }
}
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DomEventsService), ɵngcc0.ɵɵinject(PagerContextService), ɵngcc0.ɵɵinject(ScrollRequestService), ɵngcc0.ɵɵinject(FocusRoot), ɵngcc0.ɵɵinject(EditService), ɵngcc0.ɵɵinject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵinject(ExpandStateService), ɵngcc0.ɵɵinject(SelectionService), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinject(FocusableDirective, 8)); };
NavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: NavigationService.ɵfac });
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: NgZone },
    { type: DomEventsService },
    { type: PagerContextService },
    { type: ScrollRequestService },
    { type: FocusRoot },
    { type: EditService },
    { type: LocalizationService },
    { type: ExpandStateService },
    { type: SelectionService },
    { type: ChangeDetectorRef },
    { type: FocusableDirective, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: DomEventsService }, { type: PagerContextService }, { type: ScrollRequestService }, { type: FocusRoot }, { type: EditService }, { type: ɵngcc2.LocalizationService }, { type: ExpandStateService }, { type: SelectionService }, { type: ɵngcc0.ChangeDetectorRef }, { type: FocusableDirective, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class NavigationMetadata {
    constructor(view, headerRows, isVirtual, hasPager, treelistElement, virtualColumns, columns) {
        this.view = view;
        this.headerRows = headerRows;
        this.isVirtual = isVirtual;
        this.hasPager = hasPager;
        this.treelistElement = treelistElement;
        this.virtualColumns = virtualColumns;
        this.columns = columns;
    }
    get maxLogicalRowIndex() {
        return this.headerRows + this.dataRows - 1;
    }
    get dataRows() {
        return this.view.totalRows;
    }
}

// Incremented each time the service is instantiated.
let sequence = 0;
/**
 * @hidden
 */
class IdService {
    constructor() {
        this.prefix = `k-treelist${sequence++}`;
    }
    cellId(rowIndex, colIndex) {
        return `${this.prefix}-r${rowIndex}c${colIndex}`;
    }
}
IdService.ɵfac = function IdService_Factory(t) { return new (t || IdService)(); };
IdService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IdService, factory: IdService.ɵfac });
/** @nocollapse */
IdService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IdService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class ColumnInfoService {
    constructor() {
        this.visibilityChange = new EventEmitter();
        this.lockedChange = new EventEmitter();
        this.columnRangeChange = new EventEmitter();
        this.columnsContainer = new ColumnsContainer(() => []);
    }
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    get totalLevels() {
        return this.columnsContainer.totalLevels;
    }
    get leafNamedColumns() {
        const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup))
            .filter(column => column.matchesMedia && column.displayTitle);
        return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
    }
    get unlockedRootCount() {
        return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;
    }
    init(columns, list) {
        this.columnsContainer = columns;
        this.list = list;
    }
    changeVisibility(columns) {
        this.visibilityChange.emit(columns);
    }
    changeLocked(columns) {
        this.lockedChange.emit(columns);
    }
}
ColumnInfoService.ɵfac = function ColumnInfoService_Factory(t) { return new (t || ColumnInfoService)(); };
ColumnInfoService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnInfoService, factory: ColumnInfoService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnInfoService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class SortService {
    constructor() {
        this.changes = new Subject();
    }
    sort(value) {
        this.changes.next(value);
    }
}
SortService.ɵfac = function SortService_Factory(t) { return new (t || SortService)(); };
SortService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SortService, factory: SortService.ɵfac });


/**
 * Arguments for the `columnVisibilityChange` event.
 */
class ColumnVisibilityChangeEvent {
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * Arguments for the `columnLockedChange` event.
 */
class ColumnLockedChangeEvent {
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * @hidden
 */
function defaultTrackBy(index, item) {
    if (item.type === 'data' && item.isEditing) {
        return item.data;
    }
    return index;
}

/**
 * @hidden
 */
class LocalEditService {
    create(_item, _parent, _id) {
        this.throwUnsupportedError();
    }
    update(_item) {
        // noop
    }
    remove(_item) {
        this.throwUnsupportedError();
    }
    assignValues(target, source) {
        Object.assign(target, source);
    }
    throwUnsupportedError() {
        if (isDevMode()) {
            throw new Error('The default edit service of the editing directives can only update the items.' +
                'Please provide an editService.');
        }
    }
}

/**
 * @hidden
 */
class LocalDataChangesService {
    constructor() {
        this.changes = new EventEmitter();
    }
}
LocalDataChangesService.ɵfac = function LocalDataChangesService_Factory(t) { return new (t || LocalDataChangesService)(); };
LocalDataChangesService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LocalDataChangesService, factory: LocalDataChangesService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalDataChangesService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const createControl = (source) => (acc, key) => {
    acc[key] = new FormControl(source[key]);
    return acc;
};
const validateColumnsField = (columns) => expandColumns(columns.toArray())
    .filter(isColumnComponent)
    .filter(({ field }) => !isValidFieldName(field))
    .forEach(({ field }) => console.warn(`
                TreeList column field name '${field}' does not look like a valid JavaScript identifier.
                Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
                Please use only valid identifier names to ensure error-free operation.
            `));
const isInEditedCell = (element, treelistElement) => closest(element, matchesClasses('k-grid-edit-cell')) &&
    closest(element, matchesNodeName('kendo-treelist')) === treelistElement;
/**
 * Represents the Kendo UI TreeList component for Angular.
 *
 * {% meta height:470 %}
 * {% embed_file data-binding/flat/app.component.ts preview %}
 * {% embed_file shared/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class TreeListComponent {
    constructor(supportService, wrapper, changeNotification, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, expandStateService, optionChanges, selectionService, localization) {
        this.supportService = supportService;
        this.wrapper = wrapper;
        this.changeNotification = changeNotification;
        this.editService = editService;
        this.filterService = filterService;
        this.pdfService = pdfService;
        this.responsiveService = responsiveService;
        this.renderer = renderer;
        this.excelService = excelService;
        this.ngZone = ngZone;
        this.scrollSyncService = scrollSyncService;
        this.domEvents = domEvents;
        this.columnResizingService = columnResizingService;
        this.changeDetectorRef = changeDetectorRef;
        this.columnReorderService = columnReorderService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.sortService = sortService;
        this.scrollRequestService = scrollRequestService;
        this.expandStateService = expandStateService;
        this.optionChanges = optionChanges;
        this.selectionService = selectionService;
        /**
         * Defines the page size used by the TreeList when [paging]({% slug paging_treelist %}) is enabled.
         *
         * @default 10
         */
        this.pageSize = 10;
        /**
         * Defines the scroll mode used by the TreeList.
         *
         * The available options are:
         *  - `none`&mdash;Renders no scrollbar.
         *  - `scrollable`&mdash;The default scroll mode. It requires the setting of the `height` option.
         */
        this.scrollable = 'scrollable';
        /**
         * A function that defines how to track changes for the data rows.
         *
         * By default, the TreeList tracks changes by the index of the data item.
         * Edited rows are tracked by reference.
         * In some cases, you might need to override the default behavior,
         * for example, when you implement editing with immutable data items.
         *
         * The following example demonstrates how to track items only by index.
         *
         * @example
         * ```ts
         * import { Component } from '@angular/core';
         * import { TreeListItem } from '@progress/kendo-angular-treelist';
         *
         * _@Component({
         *    selector: 'my-app',
         *    template: `
         *        <kendo-treelist [data]="treelistData" [trackBy]="trackBy">
         *        </kendo-treelist>
         *    `
         * })
         * class AppComponent {
         *    public treelistData: any[] = products;
         *
         *    public trackBy(index: number, item: TreeListItem): any {
         *        console.log(item);
         *        return index;
         *    }
         * }
         *
         * const products = [{
         *    "ProductID": 1,
         *    "ProductName": "Chai",
         *    "UnitPrice": 18.0000,
         *    "Discontinued": true
         *  }, {
         *    "ProductID": 2,
         *    "ProductName": "Chang",
         *    "UnitPrice": 19.0000,
         *    "Discontinued": false
         *  }
         * ];
         * ```
         */
        this.trackBy = defaultTrackBy;
        /**
         * If set to `true`, the treelist will render only the columns in the current viewport.
         */
        this.virtualColumns = false;
        /**
         * Enables the [filtering]({% slug filtering_treelist %}) of the TreeList columns that have their `field` option set.
         */
        this.filterable = false;
        /**
         * Enables the [sorting]({% slug sorting_treelist %}) of the TreeList columns that have their `field` option set.
         */
        this.sortable = false;
        /**
         * Configures the pager of the TreeList ([see example]({% slug paging_treelist %})).
         *
         * The available options are:
         * - `buttonCount: Number`&mdash;Sets the maximum numeric buttons count before the buttons are collapsed.
         * - `info: Boolean`&mdash;Toggles the information about the current page and the total number of records.
         * - `type: PagerType`&mdash;Accepts the `numeric` (buttons with numbers) and `input` (input for typing the page number) values.
         * - `pageSizes: Boolean` or `Array<number>`&mdash;Shows a menu for selecting the page size.
         * - `previousNext: Boolean`&mdash;Toggles the **Previous** and **Next** buttons.
         */
        this.pageable = false;
        /**
         * If set to `true`, the user can use dedicated shortcuts to interact with the TreeList.
         * By default, navigation is disabled and the TreeList content is accessible in the normal tab sequence.
         */
        this.navigable = false;
        /**
         * Indicates whether the TreeList columns will be resized during initialization so that
         * they fit their headers and row content. Defaults to `false`.
         * Columns with `autoSize` set to `false` are excluded.
         * To dynamically update the column width to match the new content,
         * refer to [this example]({% slug resizing_columns_treelist %}).
         */
        this.autoSize = false;
        /**
         * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells
         * ([see example]({% slug resizing_columns_treelist %})).
         *
         * @default false
         */
        this.resizable = false;
        /**
         * If set to `true`, the user can reorder columns by dragging their header cells
         * ([see example]({% slug reordering_columns_treelist %})).
         *
         * @default false
         */
        this.reorderable = false;
        /**
         * Specifies if the loading indicator of the TreeList will be displayed ([see example]({% slug databinding_treelist %})).
         *
         * @default false
         */
        this.loading = false;
        /**
         * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_treelist %})).
         *
         * @default false
         */
        this.columnMenu = false;
        /**
         * Specifies if the header of the treelist will be hidden. The header is visible by default.
         *
         * > The header includes column headers and the [filter row]({% slug filtering_treelist %}#toc-filter-row).
         */
        this.hideHeader = false;
        /**
         * Fires when the TreeList selection is changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when the TreeList filter is modified through the UI.
         * You have to handle the event yourself and filter the data.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires when the page of the TreeList is changed ([see example]({% slug paging_treelist %})).
         * You have to handle the event yourself and page the data.
         */
        this.pageChange = new EventEmitter();
        /**
         * Fires when the sorting of the TreeList is changed ([see example]({% slug sorting_treelist %})).
         * You have to handle the event yourself and sort the data.
         */
        this.sortChange = new EventEmitter();
        /**
         * Fires when the data state of the TreeList is changed.
         */
        this.dataStateChange = new EventEmitter();
        /**
         * Fires when the user clicks the **Edit** command button to edit a row
         * ([see example]({% slug editing_template_forms_treelist %}#toc-editing-records)).
         */
        this.edit = new EventEmitter();
        /**
         * Fires when the user clicks the **Cancel** command button to close a row
         * ([see example]({% slug editing_template_forms_treelist %}#toc-cancelling-editing)).
         */
        this.cancel = new EventEmitter();
        /**
         * Fires when the user clicks the **Save** command button to save changes in a row
         * ([see example]({% slug editing_template_forms_treelist %}#toc-saving-records)).
         */
        this.save = new EventEmitter();
        /**
         * Fires when the user clicks the **Remove** command button to remove a row
         * ([see example]({% slug editing_template_forms_treelist %}#toc-removing-records)).
         */
        this.remove = new EventEmitter();
        /**
         * Fires when the user clicks the **Add** command button to add a new row
         * ([see example]({% slug editing_template_forms_treelist %}#toc-adding-records)).
         */
        this.add = new EventEmitter();
        /**
         * Fires when the user leaves an edited cell ([see example]({% slug editing_incell_treelist %}#toc-basic-concepts)).
         */
        this.cellClose = new EventEmitter();
        /**
         * Fires when the user clicks a cell ([see example]({% slug editing_incell_treelist %}#toc-basic-concepts)).
         */
        this.cellClick = new EventEmitter();
        /**
         * Fires when the user clicks the **Export to PDF** command button.
         */
        this.pdfExport = new EventEmitter();
        /**
         * Fires when the user clicks the **Export to Excel** command button.
         */
        this.excelExport = new EventEmitter();
        /**
         * Fires when the user completes the resizing of the column.
         */
        this.columnResize = new EventEmitter();
        /**
         * Fires when the user completes the reordering of the column.
         */
        this.columnReorder = new EventEmitter();
        /**
         * Fires when the user changes the visibility of the columns from the column menu or column chooser.
         */
        this.columnVisibilityChange = new EventEmitter();
        /**
         * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.
         */
        this.columnLockedChange = new EventEmitter();
        /**
         * Fires when the user scrolls to the last record on the page and enables endless scrolling
         * ([see example]({% slug scrollmmodes_treelist %}#toc-endless-scrolling)).
         * You have to handle the event yourself and page the data.
         */
        this.scrollBottom = new EventEmitter();
        /**
         * Fires when the treelist content is scrolled.
         * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.
         */
        this.contentScroll = new EventEmitter();
        /**
         * Fires when an item is expanded.
         */
        this.expandEvent = new EventEmitter();
        /**
         * Fires when an item is collapsed.
         */
        this.collapseEvent = new EventEmitter();
        /**
         * @hidden
         */
        this.expandStateChange = new EventEmitter();
        /**
         * @hidden
         */
        this.columnOrderChange = new EventEmitter();
        /**
         * A query list of all declared columns.
         */
        this.columns = new QueryList();
        this.footer = new QueryList();
        this.columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy(column => {
            column.matchesMedia = this.matchesMedia(column);
            return column.isVisible;
        }));
        this.idGetter = getter(undefined);
        this.localEditService = new LocalEditService();
        this.view = new ViewCollection(this.viewFieldAccessor.bind(this), this.expandStateService, this.editService, this.selectionService);
        this.dataChanged = false;
        this._hasChildren = (() => false);
        this.subscriptions = new Subscription();
        this.rtl = false;
        this.shouldGenerateColumns = true;
        this._data = [];
        this._sort = new Array();
        this._skip = 0;
        this.cachedWindowWidth = 0;
        this._rowClass = () => null;
        this.subscriptions.add(localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        }));
        this.selectionService.init(this);
        this.subscriptions.add(this.selectionService.changes.subscribe((args) => {
            if (hasObservers(this.selectionChange)) {
                this.ngZone.run(() => {
                    args.sender = this;
                    this.selectionChange.emit(args);
                    this.selectionService.updateSelectedState();
                    this.changeDetectorRef.markForCheck();
                });
            }
        }));
        this.columnInfoService.init(this.columnsContainer, () => this.columnList);
        this.subscriptions.add(this.columnInfoService.visibilityChange.subscribe((changed) => {
            this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
            this.changeDetectorRef.markForCheck();
        }));
        this.subscriptions.add(this.columnInfoService.lockedChange.subscribe((changed) => {
            this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
            this.changeDetectorRef.markForCheck();
        }));
        this.subscriptions.add(merge(this.optionChanges.columns, this.optionChanges.options).subscribe(() => {
            this.changeDetectorRef.markForCheck();
        }));
        this.subscriptions.add(this.filterService.changes.subscribe(x => {
            this.filterChange.emit(x);
        }));
        this.subscriptions.add(this.sortService.changes.subscribe(x => {
            this.sortChange.emit(x);
        }));
        this.attachStateChangesEmitter();
        this.attachEditHandlers();
        this.attachDomEventHandlers();
        this.subscriptions.add(this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this)));
        this.subscriptions.add(this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this)));
        this.subscriptions.add(this.excelService.loadingChange.subscribe(() => {
            this.changeDetectorRef.detectChanges();
        }));
        this.columnsContainerChange();
        this.handleColumnResize();
        this.columnList = new ColumnList(this.columns);
        this.subscriptions.add(this.columnReorderService
            .changes.subscribe(this.reorder.bind(this)));
        this.subscriptions.add(this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this)));
        this.subscriptions.add(this.expandStateService.changes.subscribe((args) => {
            if (args.expand) {
                this.expandEvent.emit(args);
            }
            else {
                this.collapseEvent.emit(args);
            }
            if (!args.isDefaultPrevented()) {
                this.changeDetectorRef.markForCheck();
                this.view.clear();
                this.expandStateChange.emit(args);
            }
        }));
        this.subscriptions.add(this.view.childrenLoaded.subscribe(() => {
            this.changeDetectorRef.detectChanges();
        }));
        this.subscriptions.add(this.view.resetPage.subscribe(() => {
            if (this.skip > 0 && hasObservers(this.pageChange)) {
                // don't think there is a way to avoid this
                // every callback in which the view can be computed is already passed the change detection
                // computing the current page in advance also does not seem feasible for such a rare case
                this.pageChangeTimeout = setTimeout(() => {
                    this.pageChange.emit({ skip: 0, take: this.pageSize });
                }, 0);
            }
            this.skip = 0;
        }));
        this.dataLoaded = this.dataLoaded.bind(this);
        this.editService.idGetter = this.idGetter;
    }
    /**
     * Sets the data of the TreeList. If an array is provided, the TreeList automatically gets the total count
     * ([more information and example]({% slug databinding_treelist %})).
     */
    set data(value) {
        this.view.reset();
        this._data = value;
        this.loadedData = null;
        this.unsubscribeDataLoaded();
        if (isObservable(value)) {
            this.dataLoadedSubscription = value.subscribe(this.dataLoaded); // handle error
        }
        else {
            this.dataLoaded(value);
        }
    }
    get data() {
        return this.loadedData;
    }
    /**
     * Defines the number of records to be skipped by the pager.
     * Required by the [paging]({% slug paging_treelist %}) functionality.
     */
    get skip() {
        return this._skip;
    }
    set skip(value) {
        if (value >= 0) {
            this._skip = value;
            this.view.clear();
        }
    }
    /**
     * The descriptors by which the data will be sorted ([see example]({% slug sorting_treelist %})).
     */
    set sort(value) {
        if (isArray(value)) {
            this._sort = value;
        }
    }
    get sort() {
        return this._sort;
    }
    /**
     * @hidden
     */
    get showTopToolbar() {
        return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomToolbar() {
        return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    /**
     * @hidden
     */
    get showPager() {
        return !this.isVirtual && this.pageable !== false;
    }
    get marqueeSelection() {
        return this.selectionService.enableMarquee;
    }
    /**
     * @hidden
     *
     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.
     */
    set navigatable(value) {
        this.navigable = value;
    }
    /**
     * @hidden
     */
    get navigatable() {
        return this.navigable;
    }
    /**
     * Defines a function that is executed for every data row in the component.
     *
     * @example
     * ```ts
     * import { Component, ViewEncapsulation } from '@angular/core';
     * import { RowClassArgs } from '@progress/kendo-angular-treelist';
     *
     * _@Component({
     *    selector: 'my-app',
     *    encapsulation: ViewEncapsulation.None,
     *    styles: [`
     *        .k-treelist tr.even { background-color: #f45c42; }
     *        .k-treelist tr.odd { background-color: #41f4df; }
     *    `],
     *    template: `
     *        <kendo-treelist [data]="treelistData" [rowClass]="rowCallback">
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     *
     *    public rowCallback(context: RowClassArgs) {
     *        const isEven = context.index % 2 == 0;
     *        return {
     *            even: isEven,
     *            odd: !isEven
     *        };
     *    }
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    set rowClass(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`rowClass must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._rowClass = fn;
    }
    get rowClass() {
        return this._rowClass;
    }
    /**
     * Returns the currently focused cell (if any).
     */
    get activeCell() {
        return this.navigationService.activeCell;
    }
    /**
     * Returns the currently focused row (if any).
     */
    get activeRow() {
        return this.navigationService.activeRow;
    }
    /**
     * The name of the field which contains the unique identifier of the node.
     *
     * @default "id"
     */
    set idField(value) {
        if (typeof value === "function") {
            this.idGetter = value;
        }
        else {
            this.idGetter = getter(value);
        }
        this.editService.idGetter = this.idGetter;
    }
    /**
     * Specified the treelist selection settings
     */
    set selectable(value) {
        this.selectionService.settings = value;
    }
    /**
     * Provides a callback that determines if the given row / cell is selected.
     */
    set isSelected(value) {
        if (typeof value !== 'function' && isDevMode()) {
            throw new Error(`isSelected must be a function, but received "${JSON.stringify(value)}".`);
        }
        this.selectionService.isSelected = value;
        this.selectionService.settings = this.selectionService.settings;
    }
    get dir() {
        return this.direction;
    }
    get hostClasses() {
        return true;
    }
    get lockedClasses() {
        return this.lockedLeafColumns.length > 0;
    }
    get virtualClasses() {
        return this.isVirtual;
    }
    get noScrollbarClass() {
        return this.scrollbarWidth === 0;
    }
    get noRecordsTemplate() {
        if (this._customNoRecordsTemplate) {
            return this._customNoRecordsTemplate;
        }
        return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;
    }
    set noRecordsTemplate(customNoRecordsTemplate) {
        this._customNoRecordsTemplate = customNoRecordsTemplate;
    }
    get pagerTemplate() {
        if (this._customPagerTemplate) {
            return this._customPagerTemplate;
        }
        return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;
    }
    set pagerTemplate(customPagerTemplate) {
        this._customPagerTemplate = customPagerTemplate;
    }
    get toolbarTemplate() {
        if (this._customToolbarTemplate) {
            return this._customToolbarTemplate;
        }
        return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;
    }
    set toolbarTemplate(customToolbarTemplate) {
        this._customToolbarTemplate = customToolbarTemplate;
    }
    get scrollbarWidth() {
        return this.supportService.scrollbarWidth;
    }
    get headerPadding() {
        if (isUniversal()) {
            return "";
        }
        const padding = Math.max(0, this.scrollbarWidth - 1) + 'px';
        const right = this.rtl ? 0 : padding;
        const left = this.rtl ? padding : 0;
        return `0 ${right} 0 ${left}`;
    }
    get showLoading() {
        return this.loading || (isObservable(this._data) && !this.loadedData) || this.excelService.loading;
    }
    get showFooter() {
        return this.columnsContainer.hasFooter;
    }
    get ariaRowCount() {
        return this.totalColumnLevels + 1 + this.totalCount;
    }
    get ariaColCount() {
        return this.columnsContainer.leafColumnsToRender.length;
    }
    get ariaMultiselectable() {
        if (this.selectionService.enabled) {
            return this.selectionService.enableMultiple;
        }
    }
    get isVirtual() {
        return this.scrollable === 'virtual';
    }
    get isScrollable() {
        return this.scrollable !== 'none';
    }
    get visibleColumns() {
        return this.columnsContainer.allColumns;
    }
    get lockedColumns() {
        return this.columnsContainer.lockedColumns;
    }
    get nonLockedColumns() {
        return this.columnsContainer.nonLockedColumns;
    }
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columnsContainer.leafColumns;
    }
    get totalColumnLevels() {
        return this.columnsContainer.totalLevels;
    }
    get headerColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedColumns;
    }
    get headerLeafColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.leafViewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get lockedWidth() {
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), 0);
    }
    get nonLockedWidth() {
        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {
            return !this.virtualColumns ? this.columnsContainer.unlockedWidth :
                this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
        }
        return undefined;
    }
    get columnMenuTemplate() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    get totalCount() {
        return this.view.totalRows;
    }
    /**
     * Gets or sets the callback function that retrieves the child nodes for a particular node.
     */
    set fetchChildren(value) {
        this._fetchChildren = value;
    }
    get fetchChildren() {
        return this._fetchChildren;
    }
    /**
     * Gets or sets the callback function that indicates if a particular node has child nodes.
     */
    set hasChildren(value) {
        this._hasChildren = value;
    }
    get hasChildren() {
        return this._hasChildren;
    }
    /**
     * Sets the callback function that indicates if a particular item is expanded.
     */
    set isExpanded(value) {
        this.expandStateService.isExpanded = value || defaultExpanded;
        this.expandIcons = Boolean(value);
    }
    /**
     * @hidden
     */
    viewFieldAccessor() {
        return {
            fetchChildren: this.fetchChildren,
            hasChildren: this.hasChildren,
            idGetter: this.idGetter,
            skip: this.skip,
            pageSize: this.pageSize,
            pageable: this.pageable,
            isVirtual: this.isVirtual,
            data: this.loadedData,
            hasFooter: this.columnsContainer.hasFooter
        };
    }
    /**
     * @hidden
     */
    onDataChange() {
        this.autoGenerateColumns();
        this.changeNotification.notify();
        this.pdfService.dataChanged.emit();
        this.updateNavigationMetadata();
    }
    ngOnChanges(changes) {
        if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort"], changes)) {
            this.changeNotification.notify();
        }
        if (anyChanged(["pageSize", "scrollable", 'virtualColumns'], changes)) {
            this.updateNavigationMetadata();
        }
        if (isChanged("virtualColumns", changes)) {
            this.viewportColumns = this.leafViewportColumns = null;
        }
        if (isChanged("height", changes, false)) {
            this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);
        }
        if (isChanged("filterable", changes) && this.lockedColumns.length) {
            this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
        }
        if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
            this.columnMenuOptions = this.columnMenu && Object.assign({
                filter: Boolean(this.filterable),
                sort: Boolean(this.sortable)
            }, this.columnMenu); // tslint:disable-line:align
        }
        if (isChanged("scrollable", changes) && this.isScrollable) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
        }
    }
    ngAfterViewInit() {
        this.attachScrollSync();
        this.attachElementEventHandlers();
        this.updateNavigationMetadata();
        this.applyAutoSize();
    }
    ngAfterContentChecked() {
        if (this.dataChanged) {
            this.dataChanged = false;
            this.onDataChange();
        }
        this.columnsContainer.refresh();
        this.verifySettings();
    }
    ngAfterContentInit() {
        this.shouldGenerateColumns = !this.columns.length;
        this.autoGenerateColumns();
        this.columnList = new ColumnList(this.columns);
        // is this needed? after content checked already does this
        this.subscriptions.add(this.columns.changes.subscribe(() => {
            this.verifySettings();
            this.optionChanges.columnChanged();
        }));
    }
    ngOnInit() {
        if (this.navigable) {
            this.navigationService.init(this.navigationMetadata());
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        if (this.detachElementEventHandlers) {
            this.detachElementEventHandlers();
        }
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        this.unsubscribeDataLoaded();
        this.ngZone = null;
        clearTimeout(this.pageChangeTimeout);
    }
    /**
     * @hidden
     */
    attachScrollSync() {
        if (isUniversal()) {
            return;
        }
        if (this.header) {
            this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
        }
        if (this.footer) {
            this.subscriptions.add(observe(this.footer)
                .subscribe(footers => footers
                .map(footer => footer.nativeElement)
                .filter(isPresent)
                .forEach(element => this.scrollSyncService.registerEmitter(element, "footer"))));
        }
    }
    /**
     * Switches the specified table row in the edit mode ([see example]({% slug editing_template_forms_treelist %}#toc-editing-records)).
     *
     * @param index - The row index that will be switched in the edit mode.
     * @param group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }})
     * that describes the edit form.
     * @param options - Additional options. Use skipFocus to determine if the row's edit element should be focused. Defaults to `false`.
     */
    editRow(item, group, options) {
        this.editService.editRow(item, group);
        this.view.updateEditedState();
        this.changeDetectorRef.markForCheck();
        if (options && options.skipFocus) {
            return;
        }
        this.focusEditElement(() => {
            return `tr[data-treelist-view-index="${this.view.itemIndex(item)}"]`;
        });
    }
    /**
     * Closes the editor for a given row ([see example]({% slug editing_template_forms_treelist %}#toc-cancelling-editing)).
     *
     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed
     * that the new item editor will be closed.
     */
    closeRow(item, isNew) {
        this.editService.close(item, isNew);
        this.changeDetectorRef.markForCheck();
        if (isNew) {
            this.view.clear();
        }
        else {
            this.view.updateEditedState();
        }
    }
    /**
     * Creates a new row editor ([see example]({% slug editing_template_forms_treelist %}#toc-adding-records)).
     *
     * @param {FormGroup} group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }}) that describes
     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.
     */
    addRow(group, parent) {
        const isFormGroup = group instanceof FormGroup;
        if (!isFormGroup) {
            const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?
            group = new FormGroup(fields);
        }
        if (this.isVirtual && !parent && this.skip) {
            const firstVisible = this.navigationService.viewport.firstItemIndex;
            if (firstVisible !== this.skip) {
                this.skip = firstVisible;
                this.pageChange.emit({
                    skip: this.skip,
                    take: this.pageSize
                });
            }
        }
        this.editService.addRow(parent, group);
        this.changeDetectorRef.markForCheck();
        this.view.clear();
        this.focusEditElement(() => {
            return parent ? `tr[data-treelist-view-index="${this.view.itemIndex(parent) + 1}"]` : '.k-grid-add-row';
        });
    }
    /**
     * Puts the cell that is specified by the table row and column in edit mode.
     *
     * @param {number} rowIndex - The data row index that will be switched in the edit mode.
     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.
     * @param {FormGroup} group - The [`FormGroup`]({{ site.data.urls.angular['formgroupapi'] }})
     * that describes the edit form.
     */
    editCell(dataItem, column, group) {
        const instance = this.columnInstance(column);
        this.editService.editCell(dataItem, instance, group);
        this.changeDetectorRef.markForCheck();
        this.view.updateEditedState();
        this.focusEditElement(() => '.k-grid-edit-cell');
    }
    /**
     * Closes the current cell in edit mode and fires
     * the [`cellClose`]({% slug api_treelist_treelistcomponent %}#toc-cellclose) event.
     *
     * @return {boolean} Indicates whether the edited cell was closed.
     * A `false` value indicates that the
     * [`cellClose`]({% slug api_treelist_treelistcomponent %}#toc-cellclose) event was prevented.
     */
    closeCell() {
        return !this.editService.closeCell();
    }
    /**
     * Closes the current cell in edit mode.
     */
    cancelCell() {
        this.editService.cancelCell();
        this.view.updateEditedState();
    }
    /**
     * Returns a flag which indicates if a row or a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a row or a cell is currently edited.
     */
    isEditing() {
        return this.editService.isEditing();
    }
    /**
     * Returns a flag which indicates if a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a cell is currently being edited.
     */
    isEditingCell() {
        return this.editService.isEditing() && this.editService.isEditingCell();
    }
    /**
     * Initiates the PDF export ([see example]({% slug pdfexport_treelist %})).
     */
    saveAsPDF() {
        this.pdfService.save(this);
    }
    /**
     * Exports the TreeList element to a Drawing [`Group`]({% slug api_kendo-drawing_group %}) by using the `kendo-treelist-pdf` component options.
     * ([see example]({% slug pdfexport_treelist %}#toc-exporting-multiple-treelists-to-the-same-pdf)).
     *
     * @return {Promise} - A promise that will be resolved with the Drawing `Group`.
     */
    drawPDF() {
        const promise = createPromise();
        this.pdfService.draw(this, promise);
        return promise;
    }
    /**
     * Initiates the Excel export ([see example]({% slug excelexport_treelist %})).
     */
    saveAsExcel() {
        this.excelService.save(this);
    }
    /**
     * Applies the minimum possible width for the specified column,
     * so that the whole text fits without wrapping. This method expects the TreeList
     * to be resizable (set `resizable` to `true`).
     * Makes sense to execute this method only
     * after the TreeList is already populated with data.
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-treelist
     *            #treelist
     *            [data]="treelistData"
     *            [resizable]="true"
     *            style="height: 300px">
     *            <ng-template kendoTreeListToolbarTemplate>
     *                 <button class="k-button" (click)="treelist.autoFitColumn(groupColumn)">
     *                     Auto-fit the group column
     *                 </button>
     *            </ng-template>
     *            <kendo-treelist-column-group #groupColumn title="Product Info">
     *                <kendo-treelist-column
     *                    field="ProductID"
     *                    [width]="50"
     *                    [minResizableWidth]="30"
     *                    title="ID">
     *                </kendo-treelist-column>
     *
     *                <kendo-treelist-column
     *                    field="ProductName"
     *                    title="Product Name">
     *                </kendo-treelist-column>
     *            </kendo-treelist-column-group>
     *
     *            <kendo-treelist-column
     *                field="UnitPrice"
     *                title="Unit Price"
     *                [width]="180"
     *                filter="numeric"
     *                format="{0:c}">
     *            </kendo-treelist-column>
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    autoFitColumn(column) {
        this.columnResizingService.autoFit(column);
    }
    /**
     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
     * If no columns are specified, `autoFitColumns` is applied to all columns.
     *
     * This method requires the TreeList to be resizable (set `resizable` to `true`).
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *      <kendo-treelist
     *          #treelist
     *          [data]="treelistData"
     *          [resizable]="true"
     *          style="height: 300px">
     *          <ng-template kendoTreeListToolbarTemplate>
     *              <button class="k-button" (click)="treelist.autoFitColumns([firstColumn, lastColumn])">
     *                  Auto-fit the first and last column
     *              </button>
     *              <button class="k-button" (click)="treelist.autoFitColumns()">
     *                  Auto-fit all columns
     *              </button>
     *          </ng-template>
     *          <kendo-treelist-column-group title="Product Info">
     *              <kendo-treelist-column
     *                  #firstColumn
     *                  field="ProductID"
     *                  [width]="50"
     *                  [minResizableWidth]="30"
     *                  title="ID">
     *              </kendo-treelist-column>
     *
     *              <kendo-treelist-column
     *                  field="ProductName"
     *                  title="Product Name"
     *                  >
     *              </kendo-treelist-column>
     *          </kendo-treelist-column-group>
     *
     *          <kendo-treelist-column
     *              #lastColumn
     *              field="UnitPrice"
     *              title="Unit Price"
     *              [width]="180"
     *              filter="numeric"
     *              format="{0:c}">
     *          </kendo-treelist-column>
     *      </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    autoFitColumns(columns = this.columns) {
        let cols;
        if (columns instanceof QueryList) {
            cols = columns.toArray();
        }
        else {
            cols = columns;
        }
        this.columnResizingService.autoFit(...cols);
    }
    /**
     * @hidden
     */
    notifyPageChange(source, event) {
        if (source === "list" && !this.isVirtual) {
            return;
        }
        this.skip = event.skip;
        this.pageSize = event.take;
        this.closeCell();
        this.cancelCell();
        this.changeDetectorRef.markForCheck();
        this.pageChange.emit(event);
    }
    /**
     * @hidden
     */
    notifyScrollBottom() {
        if (this.scrollable === 'none') {
            return;
        }
        if (hasObservers(this.scrollBottom)) {
            this.ngZone.run(() => this.scrollBottom.emit({ sender: this }));
        }
    }
    /**
     * @hidden
     */
    focusEditElement(containerSelector) {
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        this.ngZone.runOutsideAngular(() => {
            this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const wrapper = this.wrapper.nativeElement;
                const selector = containerSelector();
                if (!this.setEditFocus(wrapper.querySelector(selector)) && this.isLocked) {
                    this.setEditFocus(wrapper.querySelector(`.k-grid-content ${selector}`));
                }
                this.focusElementSubscription = null;
            });
        });
    }
    /**
     * Focuses the last active or the first cell of the TreeList.
     *
     * @returns {NavigationCell} The focused cell.
     */
    focus() {
        this.assertNavigable();
        return this.navigationService.focusCell();
    }
    /**
     * Focuses the cell with the specified row and column index.
     *
     * The row index is based on the logical structure of the TreeList and does not correspond to the data item index:
     * * Header rows are included, starting at index 0.
     * * The row indexing is absolute and does not change with paging.
     *
     * If the TreeList is configured for scrolling, including virtual scrolling, the scroll position will be updated.
     * If the row is not present on the current page, the method will have no effect.
     *
     * @param rowIndex - The logical row index to focus. The top header row has an index 0.
     * @param colIndex - The column index to focus.
     * @returns {NavigationCell} The focused cell.
     *
     */
    focusCell(rowIndex, colIndex) {
        this.assertNavigable();
        return this.navigationService.focusCell(rowIndex, colIndex);
    }
    /**
     * Focuses the next cell, optionally wrapping to the next row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
     */
    focusNextCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusNextCell(wrap);
    }
    /**
     * Focuses the previous cell. Optionally wraps to the previous row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
     */
    focusPrevCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusPrevCell(wrap);
    }
    /**
     * Scrolls to the specified row and column
     */
    scrollTo(request) {
        this.scrollRequestService.scrollTo(request);
    }
    /**
     * Changes the position of the specified column.
     * The reordering of columns operates only on the level
     * which is inferred by the source column.
     * For the `reorderColumn` method to work properly,
     * the `source` column has to be visible.
     *
     * @param {ColumnBase} source - The column whose position will be changed.
     * @param {number} destIndex - The new position of the column.
     * @param {ColumnReorderConfig} options - Additional options.
     *
     * @example
     * ```ts
     * _@Component({
     *    selector: 'my-app',
     *    template: `
     *        <kendo-treelist
     *            #treelist
     *            [data]="treelistData"
     *            [reorderable]="true"
     *            style="height: 300px">
     *            <ng-template kendoTreeListToolbarTemplate>
     *                 <button class="k-button"
     *                     (click)="treelist.reorderColumn(groupColumn, 2, { before: true })">
     *                     Move the group column before the last one.
     *                 </button>
     *            </ng-template>
     *            <kendo-treelist-column-group #groupColumn title="Product Info">
     *                <kendo-treelist-column
     *                    field="ProductID"
     *                    [width]="50"
     *                    title="ID">
     *                </kendo-treelist-column>
     *
     *                <kendo-treelist-column
     *                    field="ProductName"
     *                    title="Product Name">
     *                </kendo-treelist-column>
     *            </kendo-treelist-column-group>
     *
     *            <kendo-treelist-column
     *                field="UnitPrice"
     *                title="Unit Price"
     *                [width]="180"
     *                format="{0:c}">
     *            </kendo-treelist-column>
     *
     *            <kendo-treelist-column
     *                field="Discontinued"
     *                title="Discontinued"
     *                [width]="100">
     *            </kendo-treelist-column>
     *        </kendo-treelist>
     *    `
     * })
     * class AppComponent {
     *    public treelistData: any[] = products;
     * }
     *
     * const products = [{
     *    "ProductID": 1,
     *    "ProductName": "Chai",
     *    "UnitPrice": 18.0000,
     *    "Discontinued": true
     *  }, {
     *    "ProductID": 2,
     *    "ProductName": "Chang",
     *    "UnitPrice": 19.0000,
     *    "Discontinued": false
     *  }
     * ];
     * ```
     */
    reorderColumn(source, destIndex, options = { before: false }) {
        const columnsForLevel = this.columnsForLevel(source.level);
        let target = columnsForLevel[destIndex];
        if (!target) {
            return;
        }
        const lastNonLocked = target.isLocked &&
            !source.isLocked &&
            this.columnsContainer.nonLockedColumns.length === 1;
        if (lastNonLocked) {
            return;
        }
        if (isSpanColumnComponent(target) && !options.before) {
            target = target.childColumns.last;
        }
        this.reorder({
            before: options.before,
            source: source,
            target: target
        });
    }
    /**
     * Clears the already loaded children for the dataItem so that the TreeList will fetch them again the next time it is rendered.
     */
    reload(dataItem, reloadChildren) {
        if (dataItem) {
            this.view.resetItem(dataItem, reloadChildren);
            this.changeDetectorRef.markForCheck();
        }
    }
    /**
     * Updates the state of the current view without reloading the data.
     *
     * Checks all currently rendered items for changes and
     * triggers re-evaluation of the the [isExpanded](#toc-isexpanded) and
     * [isSelected](#toc-isSelected) callbacks.
     */
    updateView() {
        this.view.clear();
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Expands the row for the specified dataItem.
     */
    expand(dataItem) {
        this.expandStateService.expand(dataItem);
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Collapses the row for the specified dataItem.
     */
    collapse(dataItem) {
        this.expandStateService.collapse(dataItem);
        this.changeDetectorRef.markForCheck();
    }
    /**
     * @hidden
     */
    reorder({ target, source, before, changeContainer }) {
        this.ngZone.run(() => {
            const columnsForLevel = this.columnsForLevel(source.level);
            let newIndex = columnsForLevel.indexOf(target);
            if (target.parent && target.parent.isSpanColumn) {
                newIndex = columnsForLevel.indexOf(target.parent);
                if (before) {
                    target = target.parent;
                }
            }
            let oldIndex = columnsForLevel.indexOf(source);
            if (changeContainer) {
                if (before && 0 < newIndex && oldIndex < newIndex) { // dropped before the first not locked column
                    newIndex--;
                }
                else if (!before && oldIndex > newIndex) { // dropped after the last locked column
                    newIndex++;
                }
            }
            const args = new ColumnReorderEvent({
                column: source,
                oldIndex: oldIndex,
                newIndex: newIndex
            });
            this.columnReorder.emit(args);
            if (args.isDefaultPrevented()) {
                return;
            }
            if (changeContainer) {
                this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
            }
            this.updateColumnIndices({ source, target, before });
            if (source.locked !== target.locked) {
                source.locked = target.locked;
            }
            this.columnOrderChange.emit(args);
            //this.columnsContainer.refresh();  why force it here ??
            this.changeDetectorRef.markForCheck();
        });
    }
    updateColumnIndices({ source, target, before }) {
        const expandedColumns = expandColumnsWithSpan(this.columnsForLevel(source.level));
        const sourceColumnIndex = expandedColumns.indexOf(source);
        let nextSourceIndex = 0;
        let nextIndex = 0;
        let toSkip = 1;
        // Possible only when called from the API.
        if (source.isSpanColumn) {
            toSkip += source.childColumns.length;
        }
        let i = 0;
        while (i < expandedColumns.length) {
            let column = expandedColumns[i];
            if (column === target) {
                nextSourceIndex = before ? nextIndex : nextIndex + 1;
                nextIndex = before ? nextIndex + toSkip : nextIndex;
                column.orderIndex = nextIndex;
                if (nextSourceIndex === nextIndex + 1) {
                    nextIndex += toSkip;
                }
            }
            else if (column === source) {
                i += toSkip;
                continue;
            }
            else {
                column.orderIndex = nextIndex;
            }
            nextIndex++;
            i++;
        }
        for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
            expandedColumns[i].orderIndex = nextSourceIndex++;
        }
        this.updateIndicesForLevel(source.level + 1);
    }
    updateIndicesForLevel(level) {
        const colsForParentLevel = this.columnsForLevel(level - 1);
        const colsForLevel = [];
        sortColumns(colsForParentLevel).forEach((c) => {
            if (c.isColumnGroup) {
                colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
            }
        });
        expandColumnsWithSpan(colsForLevel).map((c, i) => c.orderIndex = i);
        if (level < this.columnsContainer.totalLevels) {
            this.updateIndicesForLevel(level + 1);
        }
    }
    columnsForLevel(level) {
        return this.columnsContainer
            .allColumns.filter(column => column.level === level);
    }
    setEditFocus(element) {
        if (element) {
            return this.navigationService.tryFocus(element);
        }
    }
    columnInstance(column) {
        let instance;
        if (typeof column === 'number') {
            instance = this.columnsContainer.lockedLeafColumns.toArray()
                .concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
        }
        else if (typeof column === 'string') {
            instance = this.columnList.filter((item) => item.field === column)[0];
        }
        else {
            instance = column;
        }
        if (!instance && isDevMode()) {
            throw new Error(`Invalid column ${column}`);
        }
        return instance;
    }
    verifySettings() {
        if (isDevMode()) {
            const locked = this.lockedLeafColumns.length || (this.columnMenu && this.columnMenu.lock);
            if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
                throw new Error('There should be at least one non-locked column');
            }
            if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                throw new Error((locked ? 'Locked' : 'Virtual') + ' columns feature requires all columns to have set width.');
            }
            if (locked && !this.isScrollable) {
                throw new Error('Locked columns are only supported when scrolling is enabled.');
            }
            if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
                throw new Error('ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.');
            }
            if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {
                throw new Error('Locked child columns require their parent columns to be locked.');
            }
            if ((this.rowHeight) && !this.isVirtual) {
                throw new Error('Row height setting requires virtual scrolling mode to be enabled.');
            }
            validateColumnsField(this.columnList);
        }
    }
    autoGenerateColumns() {
        if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
            const columns = Object.keys(this.view.at(0).data).map(field => {
                let column = new ColumnComponent();
                column.field = field;
                return column;
            });
            columns[0].expandable = true;
            this.columns.reset(columns);
        }
    }
    attachStateChangesEmitter() {
        this.subscriptions.add(merge(this.sortChange.pipe(map(sort => ({ filter: this.filter, skip: this.skip, sort: sort, take: this.pageSize }))), this.filterChange.pipe(map(filter$$1 => ({
            filter: filter$$1, skip: 0, sort: this.sort, take: this.pageSize
        }))))
            .subscribe(x => {
            this.closeCell();
            this.cancelCell();
            this.dataStateChange.emit(x);
        }));
    }
    attachEditHandlers() {
        if (!this.editService) {
            return;
        }
        this.subscriptions.add(this.editService
            .changes.subscribe(this.emitCRUDEvent.bind(this)));
    }
    emitCRUDEvent(args) {
        let { action, formGroup, dataItem } = args;
        if (action !== 'add' && !dataItem) {
            dataItem = formGroup.value;
        }
        this.view.clear();
        this.changeDetectorRef.markForCheck();
        this.closeCell();
        Object.assign(args, {
            dataItem: dataItem,
            sender: this
        });
        switch (action) {
            case 'add':
                this.add.emit(args);
                break;
            case 'cancel':
                this.cancel.emit(args);
                break;
            case 'edit':
                this.edit.emit(args);
                break;
            case 'remove':
                this.remove.emit(args);
                break;
            case 'save':
                this.save.emit(args);
                break;
            case 'cellClose':
                this.cellClose.emit(args);
                break;
            default: break;
        }
    }
    attachDomEventHandlers() {
        this.subscriptions.add(this.domEvents.cellClick.subscribe((args) => {
            if (hasObservers(this.cellClick) || this.selectionService.enabled) { // enabled only if isSelect is provided
                this.ngZone.run(() => {
                    this.cellClick.emit(Object.assign({ sender: this }, args));
                    this.selectionService.click(args);
                });
            }
        }));
    }
    attachElementEventHandlers() {
        if (isUniversal()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const ariaRoot = this.ariaRoot.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            const resizeCheck = this.resizeCheck.bind(this);
            const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);
            const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);
            const documentClickSubscription = this.renderer.listen('document', 'click', (args) => {
                const activeElement = document.activeElement;
                if (this.editService.shouldCloseCell() &&
                    !closest(args.target, matchesClasses('k-animation-container k-treelist-ignore-click')) &&
                    !(activeElement &&
                        (closest(activeElement, matchesClasses('k-animation-container')) ||
                            isInEditedCell(activeElement, this.wrapper.nativeElement)))) {
                    this.editService.closeCell(args);
                }
            });
            const windowBlurSubscription = this.renderer.listen('window', 'blur', (args) => {
                const activeElement = document.activeElement;
                if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' &&
                    isInEditedCell(activeElement, this.wrapper.nativeElement))) {
                    this.editService.closeCell(args);
                }
                this.domEvents.windowBlur.emit(args);
            });
            const clickSubscription = this.renderer.listen(wrapper, 'click', (args) => {
                this.domEvents.click.emit(args);
            });
            const keydownSubscription = this.renderer.listen(wrapper, 'keydown', (args) => {
                this.domEvents.keydown.emit(args);
            });
            // focusIn and focusOut are relative to the element with ARIA role "treegrid"
            let focused = false;
            const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', (args) => {
                this.domEvents.focus.emit(args);
                if (!focused) {
                    this.domEvents.focusIn.emit(args);
                    focused = true;
                }
            });
            const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', (args) => {
                const next = args.relatedTarget || document.activeElement;
                const outside = !closest(next, (node) => node === ariaRoot);
                if (outside) {
                    this.domEvents.focusOut.emit(args);
                    focused = false;
                }
            });
            this.detachElementEventHandlers = () => {
                resizeSubscription();
                orientationSubscription();
                documentClickSubscription();
                windowBlurSubscription();
                clickSubscription();
                keydownSubscription();
                focusInSubscription();
                focusOutSubscription();
            };
        });
    }
    matchesMedia(c) {
        return this.responsiveService.matchesMedia(c.media);
    }
    resizeCheck() {
        if (window.innerWidth !== this.cachedWindowWidth) {
            this.cachedWindowWidth = window.innerWidth;
            let hasChanges = false;
            this.columnList.filterHierarchy(column => {
                const matchesMedia = this.matchesMedia(column);
                if (column.matchesMedia !== matchesMedia) {
                    hasChanges = true;
                    column.matchesMedia = matchesMedia;
                }
                return column.isVisible;
            });
            if (hasChanges) {
                this.ngZone.run(() => {
                    this.changeDetectorRef.markForCheck();
                });
            }
        }
    }
    emitPDFExportEvent() {
        const args = new PDFExportEvent();
        this.pdfExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.saveAsPDF();
        }
    }
    syncHeaderHeight(observable) {
        return observable
            .pipe(filter(() => isPresent(this.lockedHeader)))
            .subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
    }
    columnsContainerChange() {
        this.subscriptions.add(this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))))));
    }
    handleColumnResize() {
        const resizes = this.columnResizingService.changes;
        this.subscriptions.add(resizes.pipe(tap(e => {
            if (e.type === 'start') {
                this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
            else if (e.type === 'end') {
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
        }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe(
        // tslint:disable-next-line: rxjs-no-unsafe-takeuntil
        takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end'))))
            .subscribe(this.notifyResize.bind(this)));
    }
    notifyResize(e) {
        const args = e.resizedColumns
            .filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup)
            .map(item => ({
            column: item.column,
            newWidth: item.column.width,
            oldWidth: item.oldWidth
        }));
        if (hasObservers(this.columnResize)) {
            this.ngZone.run(() => {
                this.columnResize.emit(args);
            });
        }
    }
    assertNavigable() {
        if (isDevMode() && !this.navigable) {
            throw new Error('The TreeList should be configured as [navigable]="true" to control focus');
        }
    }
    navigationMetadata() {
        const isVirtual = this.isVirtual;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRows = this.totalColumnLevels + 1 + filterRowOffset;
        return new NavigationMetadata(this.view, headerRows, isVirtual, this.showPager, this.wrapper, this.virtualColumns, this.columnsContainer);
    }
    updateNavigationMetadata() {
        this.navigationService.metadata = this.navigationMetadata();
    }
    applyAutoSize() {
        const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
        if (cols.length > 0) {
            this.ngZone.onStable.pipe(take(1)).subscribe(_ => this.autoFitColumns(cols));
        }
    }
    onColumnRangeChange(range) {
        const viewportColumns = this.viewportColumns = [];
        const leafViewportColumns = this.columnsContainer
            .nonLockedLeafColumns.toArray().slice(range.start, range.end + 1);
        for (let idx = 0; idx < leafViewportColumns.length; idx++) {
            let column = leafViewportColumns[idx];
            while (column.parent) {
                column = column.parent;
            }
            const toAdd = [column];
            while (toAdd.length) {
                column = toAdd.shift();
                viewportColumns.push(column);
                if (column.isColumnGroup) {
                    toAdd.unshift.apply(toAdd, column.childrenArray);
                }
            }
            const lastFromGroup = viewportColumns[viewportColumns.length - 1];
            column = leafViewportColumns[idx];
            while (column !== lastFromGroup && idx < leafViewportColumns.length) {
                idx++;
                column = leafViewportColumns[idx];
            }
        }
        if (range.start > 0) {
            const first = leafViewportColumns[0];
            let offset = range.offset;
            let current = viewportColumns[0];
            let index = 0;
            while (current !== first) {
                offset -= current.isColumnGroup ? 0 : current.width;
                index++;
                current = viewportColumns[index];
            }
            if (offset > 0) {
                const totalLevels = this.columnsContainer.totalLevels;
                let previous;
                for (let idx = 0; idx <= totalLevels; idx++) {
                    const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase$1(previous);
                    previous = offsetColumn;
                    offsetColumn.title = "\u00A0";
                    offsetColumn.width = offset;
                    viewportColumns.unshift(offsetColumn);
                }
            }
        }
        this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);
    }
    dataLoaded(result) {
        this.loadedData = result || [];
        this.view.reset();
        this.dataChanged = true;
        this.changeDetectorRef.markForCheck();
    }
    unsubscribeDataLoaded() {
        if (this.dataLoadedSubscription) {
            this.dataLoadedSubscription.unsubscribe();
            this.dataLoadedSubscription = null;
        }
    }
}
TreeListComponent.ɵfac = function TreeListComponent_Factory(t) { return new (t || TreeListComponent)(ɵngcc0.ɵɵdirectiveInject(BrowserSupportService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(ResponsiveService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ExcelService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ScrollSyncService), ɵngcc0.ɵɵdirectiveInject(DomEventsService), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ColumnReorderService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SortService), ɵngcc0.ɵɵdirectiveInject(ScrollRequestService), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(OptionChangesService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
TreeListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeListComponent, selectors: [["kendo-treelist"]], contentQueries: function TreeListComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase$1, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NoRecordsTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PagerTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
    } }, viewQuery: function TreeListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t);
    } }, hostVars: 13, hostBindings: function TreeListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.dir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-grid", ctx.hostClasses)("k-treelist", ctx.hostClasses)("k-grid-lockedcolumns", ctx.lockedClasses)("k-grid-virtual", ctx.virtualClasses)("k-grid-no-scrollbar", ctx.noScrollbarClass);
    } }, inputs: { pageSize: "pageSize", scrollable: "scrollable", trackBy: "trackBy", virtualColumns: "virtualColumns", filterable: "filterable", sortable: "sortable", pageable: "pageable", navigable: "navigable", autoSize: "autoSize", resizable: "resizable", reorderable: "reorderable", loading: "loading", columnMenu: "columnMenu", hideHeader: "hideHeader", skip: "skip", data: "data", sort: "sort", navigatable: "navigatable", rowClass: "rowClass", idField: "idField", selectable: "selectable", isSelected: "isSelected", fetchChildren: "fetchChildren", hasChildren: "hasChildren", isExpanded: "isExpanded", ariaLabel: ["aria-label", "ariaLabel"], height: "height", rowHeight: "rowHeight", filter: "filter" }, outputs: { selectionChange: "selectionChange", filterChange: "filterChange", pageChange: "pageChange", sortChange: "sortChange", dataStateChange: "dataStateChange", edit: "edit", cancel: "cancel", save: "save", remove: "remove", add: "add", cellClose: "cellClose", cellClick: "cellClick", pdfExport: "pdfExport", excelExport: "excelExport", columnResize: "columnResize", columnReorder: "columnReorder", columnVisibilityChange: "columnVisibilityChange", columnLockedChange: "columnLockedChange", scrollBottom: "scrollBottom", contentScroll: "contentScroll", expandEvent: "expand", collapseEvent: "collapse" }, exportAs: ["kendoTreeList"], features: [ɵngcc0.ɵɵProvidersFeature([
            BrowserSupportService,
            LocalizationService,
            ColumnInfoService,
            ChangeNotificationService,
            EditService,
            PDFService,
            SuspendService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.treelist'
            },
            FilterService,
            ResponsiveService,
            PagerContextService,
            ExcelService,
            ScrollSyncService,
            ResizeService,
            DomEventsService,
            ColumnResizingService,
            SinglePopupService,
            DragAndDropService,
            DragHintService,
            DropCueService,
            ColumnReorderService,
            NavigationService,
            FocusRoot,
            IdService,
            ScrollRequestService,
            SortService,
            ExpandStateService,
            LocalDataChangesService,
            OptionChangesService,
            SelectionService
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 9, consts: [["kendoTreeListLocalizedMessages", "", 6, "noRecords", "pagerFirstPage", "pagerPreviousPage", "pagerNextPage", "pagerLastPage", "pagerPage", "pagerOf", "pagerPageNumberInputTitle", "pagerItemsPerPage", "pagerItemsTotal", "filter", "filterEqOperator", "filterNotEqOperator", "filterIsNullOperator", "filterIsNotNullOperator", "filterIsEmptyOperator", "filterIsNotEmptyOperator", "filterStartsWithOperator", "filterContainsOperator", "filterNotContainsOperator", "filterEndsWithOperator", "filterGteOperator", "filterGtOperator", "filterLteOperator", "filterLtOperator", "filterIsTrue", "filterIsFalse", "filterBooleanAll", "filterAfterOrEqualOperator", "filterAfterOperator", "filterBeforeOperator", "filterBeforeOrEqualOperator", "filterFilterButton", "filterClearButton", "filterAndLogic", "filterOrLogic", "loading", "columnMenu", "columns", "lock", "unlock", "sortable", "sortAscending", "sortDescending", "sortedAscending", "sortedDescending", "sortedDefault", "columnsApply", "columnsReset"], ["position", "top", 4, "ngIf"], ["role", "treegrid", 1, "k-grid-aria-root"], ["ariaRoot", ""], [3, "ngIf"], [3, "template", "pageSize", "total", "allCount", "skip", "options", "pageChange", 4, "ngIf"], ["position", "bottom", 4, "ngIf"], ["position", "top"], ["class", "k-grid-header", "role", "presentation", 3, "padding", 4, "ngIf"], ["kendoDraggable", "", "kendoTreeListSelectionMarquee", "", 3, "view", "loading", "rowHeight", "total", "take", "skip", "trackBy", "columns", "filterable", "noRecordsTemplate", "rowClass", "isVirtual", "virtualColumns", "expandIcons", "enableDrag", "pageChange", "scrollBottom", "contentScroll"], ["role", "presentation", 1, "k-grid-header"], ["role", "presentation", "class", "k-grid-header-locked", 3, "width", 4, "ngIf"], ["role", "presentation", "data-scrollable", "", 1, "k-grid-header-wrap", 3, "kendoTreeListResizableContainer", "lockedWidth"], ["header", ""], ["role", "presentation", 3, "virtualColumns"], ["kendoTreeListColGroup", "", "role", "presentation", 3, "columns"], ["kendoTreeListHeader", "", "role", "presentation", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "filter", "filterable", "reorderable", "sortable", "columnMenu", "columnMenuTemplate", "lockedColumnsCount", "totalColumnsCount"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header-locked"], ["lockedHeader", ""], ["role", "presentation", 3, "locked"], ["kendoTreeListHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "filter", "filterable", "reorderable", "sortable", "columnMenu", "columnMenuTemplate", "totalColumnsCount"], ["role", "presentation", 1, "k-width-container"], ["kendoTreeListColGroup", "", 3, "columns"], ["kendoTreeListHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", 4, "ngIf"], ["kendoTreeListTableBody", "", "kendoDraggable", "", "kendoTreeListSelectionMarquee", "", 3, "view", "skip", "columns", "filterable", "noRecordsTemplate", "trackBy", "rowClass", "expandIcons", "enableDrag"], ["kendoTreeListLoading", "", 4, "ngIf"], ["kendoTreeListHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate"], ["kendoTreeListLoading", ""], [3, "template", "pageSize", "total", "allCount", "skip", "options", "pageChange"], ["position", "bottom"]], template: function TreeListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵi18nAttributes(1, _c102);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵtemplate(2, TreeListComponent_kendo_treelist_toolbar_2_Template, 1, 0, "kendo-treelist-toolbar", 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2, 3);
        ɵngcc0.ɵɵtemplate(5, TreeListComponent_ng_template_5_Template, 2, 16, "ng-template", 4);
        ɵngcc0.ɵɵtemplate(6, TreeListComponent_ng_template_6_Template, 5, 14, "ng-template", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, TreeListComponent_kendo_treelist_pager_7_Template, 1, 6, "kendo-treelist-pager", 5);
        ɵngcc0.ɵɵtemplate(8, TreeListComponent_kendo_treelist_toolbar_8_Template, 1, 0, "kendo-treelist-toolbar", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTopToolbar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("aria-rowcount", ctx.ariaRowCount)("aria-colcount", ctx.ariaColCount)("aria-multiselectable", ctx.ariaMultiselectable)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isScrollable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isScrollable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showPager);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showBottomToolbar);
    } }, directives: function () { return [LocalizedMessagesDirective, ɵngcc4.NgIf, ToolbarComponent,
        ListComponent, ɵngcc5.DraggableDirective, MarqueeDirective,
        ResizableContainerDirective,
        TableDirective,
        ColGroupComponent,
        HeaderComponent,
        TableBodyComponent,
        LoadingComponent,
        PagerComponent]; }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
TreeListComponent.ctorParameters = () => [
    { type: BrowserSupportService },
    { type: ElementRef },
    { type: ChangeNotificationService },
    { type: EditService },
    { type: FilterService },
    { type: PDFService },
    { type: ResponsiveService },
    { type: Renderer2 },
    { type: ExcelService },
    { type: NgZone },
    { type: ScrollSyncService },
    { type: DomEventsService },
    { type: ColumnResizingService },
    { type: ChangeDetectorRef },
    { type: ColumnReorderService },
    { type: ColumnInfoService },
    { type: NavigationService },
    { type: SortService },
    { type: ScrollRequestService },
    { type: ExpandStateService },
    { type: OptionChangesService },
    { type: SelectionService },
    { type: LocalizationService }
];
TreeListComponent.propDecorators = {
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    data: [{ type: Input }],
    pageSize: [{ type: Input }],
    height: [{ type: Input }],
    rowHeight: [{ type: Input }],
    skip: [{ type: Input }],
    scrollable: [{ type: Input }],
    sort: [{ type: Input }],
    trackBy: [{ type: Input }],
    filter: [{ type: Input }],
    virtualColumns: [{ type: Input }],
    filterable: [{ type: Input }],
    sortable: [{ type: Input }],
    pageable: [{ type: Input }],
    navigable: [{ type: Input }],
    navigatable: [{ type: Input }],
    autoSize: [{ type: Input }],
    rowClass: [{ type: Input }],
    resizable: [{ type: Input }],
    reorderable: [{ type: Input }],
    loading: [{ type: Input }],
    columnMenu: [{ type: Input }],
    hideHeader: [{ type: Input }],
    idField: [{ type: Input }],
    selectable: [{ type: Input }],
    isSelected: [{ type: Input }],
    selectionChange: [{ type: Output }],
    filterChange: [{ type: Output }],
    pageChange: [{ type: Output }],
    sortChange: [{ type: Output }],
    dataStateChange: [{ type: Output }],
    edit: [{ type: Output }],
    cancel: [{ type: Output }],
    save: [{ type: Output }],
    remove: [{ type: Output }],
    add: [{ type: Output }],
    cellClose: [{ type: Output }],
    cellClick: [{ type: Output }],
    pdfExport: [{ type: Output }],
    excelExport: [{ type: Output }],
    columnResize: [{ type: Output }],
    columnReorder: [{ type: Output }],
    columnVisibilityChange: [{ type: Output }],
    columnLockedChange: [{ type: Output }],
    scrollBottom: [{ type: Output }],
    contentScroll: [{ type: Output }],
    expandEvent: [{ type: Output, args: ['expand',] }],
    collapseEvent: [{ type: Output, args: ['collapse',] }],
    columns: [{ type: ContentChildren, args: [ColumnBase$1,] }],
    dir: [{ type: HostBinding, args: ['attr.dir',] }],
    hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-grid',] }, { type: HostBinding, args: ['class.k-treelist',] }],
    lockedClasses: [{ type: HostBinding, args: ['class.k-grid-lockedcolumns',] }],
    virtualClasses: [{ type: HostBinding, args: ['class.k-grid-virtual',] }],
    noScrollbarClass: [{ type: HostBinding, args: ['class.k-grid-no-scrollbar',] }],
    noRecordsTemplateChildren: [{ type: ContentChildren, args: [NoRecordsTemplateDirective,] }],
    pagerTemplateChildren: [{ type: ContentChildren, args: [PagerTemplateDirective,] }],
    toolbarTemplateChildren: [{ type: ContentChildren, args: [ToolbarTemplateDirective,] }],
    columnMenuTemplates: [{ type: ContentChildren, args: [ColumnMenuTemplateDirective,] }],
    lockedHeader: [{ type: ViewChild, args: ["lockedHeader",] }],
    header: [{ type: ViewChild, args: ["header",] }],
    footer: [{ type: ViewChildren, args: ["footer",] }],
    ariaRoot: [{ type: ViewChild, args: ['ariaRoot',] }],
    fetchChildren: [{ type: Input }],
    hasChildren: [{ type: Input }],
    isExpanded: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeListComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                exportAs: 'kendoTreeList',
                providers: [
                    BrowserSupportService,
                    LocalizationService,
                    ColumnInfoService,
                    ChangeNotificationService,
                    EditService,
                    PDFService,
                    SuspendService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.treelist'
                    },
                    FilterService,
                    ResponsiveService,
                    PagerContextService,
                    ExcelService,
                    ScrollSyncService,
                    ResizeService,
                    DomEventsService,
                    ColumnResizingService,
                    SinglePopupService,
                    DragAndDropService,
                    DragHintService,
                    DropCueService,
                    ColumnReorderService,
                    NavigationService,
                    FocusRoot,
                    IdService,
                    ScrollRequestService,
                    SortService,
                    ExpandStateService,
                    LocalDataChangesService,
                    OptionChangesService,
                    SelectionService
                ],
                selector: 'kendo-treelist',
                template: `
        <ng-container kendoTreeListLocalizedMessages

            i18n-noRecords="kendo.treelist.noRecords|The label visible in the TreeList when there are no records"
            noRecords="No records available."

            i18n-pagerFirstPage="kendo.treelist.pagerFirstPage|The label for the first page button in TreeList pager"
            pagerFirstPage="Go to the first page"

            i18n-pagerPreviousPage="kendo.treelist.pagerPreviousPage|The label for the previous page button in TreeList pager"
            pagerPreviousPage="Go to the previous page"

            i18n-pagerNextPage="kendo.treelist.pagerNextPage|The label for the next page button in TreeList pager"
            pagerNextPage="Go to the next page"

            i18n-pagerLastPage="kendo.treelist.pagerLastPage|The label for the last page button in TreeList pager"
            pagerLastPage="Go to the last page"

            i18n-pagerPage="kendo.treelist.pagerPage|The label before the current page number in the TreeList pager"
            pagerPage="Page"

            i18n-pagerOf="kendo.treelist.pagerOf|The label before the total pages number in the TreeList pager"
            pagerOf="of"

            i18n-pagerPageNumberInputTitle="kendo.treelist.pagerPageNumberInputTitle|The label for the pager input in the Treelist pager"
            pagerPageNumberInputTitle="Page Number"

            i18n-pagerItemsPerPage="kendo.treelist.pagerItemsPerPage|The label for the page size chooser in the TreeList pager"
            pagerItemsPerPage="items per page"

            i18n-pagerItemsTotal="kendo.treelist.pagerItemsTotal|The label after the total items count in the TreeList pager"
            pagerItemsTotal="items total"

            i18n-filter="kendo.treelist.filter|The label of the filter cell or icon"
            filter="Filter"

            i18n-filterEqOperator="kendo.treelist.filterEqOperator|The text of the equal filter operator"
            filterEqOperator="Is equal to"

            i18n-filterNotEqOperator="kendo.treelist.filterNotEqOperator|The text of the not equal filter operator"
            filterNotEqOperator="Is not equal to"

            i18n-filterIsNullOperator="kendo.treelist.filterIsNullOperator|The text of the is null filter operator"
            filterIsNullOperator="Is null"

            i18n-filterIsNotNullOperator="kendo.treelist.filterIsNotNullOperator|The text of the is not null filter operator"
            filterIsNotNullOperator="Is not null"

            i18n-filterIsEmptyOperator="kendo.treelist.filterIsEmptyOperator|The text of the is empty filter operator"
            filterIsEmptyOperator="Is empty"

            i18n-filterIsNotEmptyOperator="kendo.treelist.filterIsNotEmptyOperator|The text of the is not empty filter operator"
            filterIsNotEmptyOperator="Is not empty"

            i18n-filterStartsWithOperator="kendo.treelist.filterStartsWithOperator|The text of the starts with filter operator"
            filterStartsWithOperator="Starts with"

            i18n-filterContainsOperator="kendo.treelist.filterContainsOperator|The text of the contains filter operator"
            filterContainsOperator="Contains"

            i18n-filterNotContainsOperator="kendo.treelist.filterNotContainsOperator|The text of the does not contain filter operator"
            filterNotContainsOperator="Does not contain"

            i18n-filterEndsWithOperator="kendo.treelist.filterEndsWithOperator|The text of the ends with filter operator"
            filterEndsWithOperator="Ends with"

            i18n-filterGteOperator="kendo.treelist.filterGteOperator|The text of the greater than or equal filter operator"
            filterGteOperator="Is greater than or equal to"

            i18n-filterGtOperator="kendo.treelist.filterGtOperator|The text of the greater than filter operator"
            filterGtOperator="Is greater than"

            i18n-filterLteOperator="kendo.treelist.filterLteOperator|The text of the less than or equal filter operator"
            filterLteOperator="Is less than or equal to"

            i18n-filterLtOperator="kendo.treelist.filterLtOperator|The text of the less than filter operator"
            filterLtOperator="Is less than"

            i18n-filterIsTrue="kendo.treelist.filterIsTrue|The text of the IsTrue boolean filter option"
            filterIsTrue="Is True"

            i18n-filterIsFalse="kendo.treelist.filterIsFalse|The text of the IsFalse boolean filter option"
            filterIsFalse="Is False"

            i18n-filterBooleanAll="kendo.treelist.filterBooleanAll|The text of the (All) boolean filter option"
            filterBooleanAll="(All)"

            i18n-filterAfterOrEqualOperator="kendo.treelist.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
            filterAfterOrEqualOperator="Is after or equal to"

            i18n-filterAfterOperator="kendo.treelist.filterAfterOperator|The text of the after date filter operator"
            filterAfterOperator="Is after"

            i18n-filterBeforeOperator="kendo.treelist.filterBeforeOperator|The text of the before date filter operator"
            filterBeforeOperator="Is before"

            i18n-filterBeforeOrEqualOperator="kendo.treelist.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
            filterBeforeOrEqualOperator="Is before or equal to"

            i18n-filterFilterButton="kendo.treelist.filterFilterButton|The text of the filter button"
            filterFilterButton="Filter"

            i18n-filterClearButton="kendo.treelist.filterClearButton|The text of the clear filter button"
            filterClearButton="Clear"

            i18n-filterAndLogic="kendo.treelist.filterAndLogic|The text of the And filter logic"
            filterAndLogic="And"

            i18n-filterOrLogic="kendo.treelist.filterOrLogic|The text of the Or filter logic"
            filterOrLogic="Or"

            i18n-loading="kendo.treelist.loading|The loading text"
            loading="Loading"

            i18n-columnMenu="kendo.treelist.columnMenu|The title of the column menu icon"
            columnMenu="Column Menu"

            i18n-columns="kendo.treelist.columns|The text shown in the column menu for the columns item"
            columns="Columns"

            i18n-lock="kendo.treelist.lock|The text shown in the column menu for the lock item"
            lock="Lock"

            i18n-unlock="kendo.treelist.unlock|The text shown in the column menu for the unlock item"
            unlock="Unlock"

            i18n-sortable="kendo.treelist.sortable|The label of the sort icon"
            sortable="Sortable"

            i18n-sortAscending="kendo.treelist.sortAscending|The text shown in the column menu for the sort ascending item"
            sortAscending="Sort Ascending"

            i18n-sortDescending="kendo.treelist.sortDescending|The text shown in the column menu for the sort descending item"
            sortDescending="Sort Descending"

            i18n-sortedAscending="kendo.treelist.sortedAscending|The status announcement when a column is sorted ascending"
            sortedAscending="Sorted Ascending"

            i18n-sortedDescending="kendo.treelist.sortedDescending|The status announcement when a column is sorted descending"
            sortedDescending="Sorted Descending"

            i18n-sortedDefault="kendo.treelist.sortedDefault|The status announcement when a column is no longer sorted"
            sortedDefault="Not Sorted"

            i18n-columnsApply="kendo.treelist.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
            columnsApply="Apply"

            i18n-columnsReset="kendo.treelist.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
            columnsReset="Reset"
         >
        </ng-container>
        <kendo-treelist-toolbar *ngIf="showTopToolbar" position="top"></kendo-treelist-toolbar>
        <div #ariaRoot
            class="k-grid-aria-root"
            role="treegrid"
            [attr.aria-rowcount]="ariaRowCount"
            [attr.aria-colcount]="ariaColCount"
            [attr.aria-multiselectable]="ariaMultiselectable"
            [attr.aria-label]="ariaLabel"
            >
        <ng-template [ngIf]="isScrollable">
            <div *ngIf="!hideHeader"
                class="k-grid-header"
                role="presentation"
                [style.padding]="headerPadding">
                <div *ngIf="isLocked"
                     #lockedHeader
                     role="presentation"
                     class="k-grid-header-locked"
                     [style.width.px]="lockedWidth">
                    <table [locked]="true" role="presentation" [style.width.px]="lockedWidth">
                        <colgroup kendoTreeListColGroup
                            role="presentation"
                            [columns]="lockedLeafColumns">
                        </colgroup>
                        <thead kendoTreeListHeader
                            [resizable]="resizable"
                            [scrollable]="true"
                            [columns]="lockedColumns"
                            [totalColumnLevels]="totalColumnLevels"
                            [sort]="sort"
                            [filter]="filter"
                            [filterable]="filterable"
                            [reorderable]="reorderable"
                            [sortable]="sortable"
                            [columnMenu]="columnMenuOptions"
                            [columnMenuTemplate]="columnMenuTemplate"
                            [totalColumnsCount]="leafColumns.length">
                        </thead>
                    </table>
                </div><div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                    [kendoTreeListResizableContainer]="lockedLeafColumns.length"
                    [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                    <table role="presentation" [style.width.px]="nonLockedWidth" [virtualColumns]="virtualColumns">
                        <colgroup kendoTreeListColGroup
                            role="presentation"
                            [columns]="headerLeafColumns">
                        </colgroup>
                        <thead kendoTreeListHeader
                            [resizable]="resizable"
                            role="presentation"
                            [scrollable]="true"
                            [columns]="headerColumns"
                            [totalColumnLevels]="totalColumnLevels"
                            [sort]="sort"
                            [filter]="filter"
                            [filterable]="filterable"
                            [reorderable]="reorderable"
                            [sortable]="sortable"
                            [columnMenu]="columnMenuOptions"
                            [columnMenuTemplate]="columnMenuTemplate"
                            [lockedColumnsCount]="lockedLeafColumns.length"
                            [totalColumnsCount]="leafColumns.length">
                        </thead>
                    </table>
                    <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
                        <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                    </div>
                </div>
            </div>
            <kendo-treelist-list
                [view]="view"
                [loading]="showLoading"
                [rowHeight]="rowHeight"
                [total]="totalCount"
                [take]="pageSize"
                [skip]="skip"
                [trackBy]="trackBy"
                [columns]="columnsContainer"
                [filterable]="filterable"
                [noRecordsTemplate]="noRecordsTemplate"
                (pageChange)="notifyPageChange('list', $event)"
                [rowClass]="rowClass"
                [isVirtual]="isVirtual"
                [virtualColumns]="virtualColumns"
                [expandIcons]="expandIcons"
                (scrollBottom)="notifyScrollBottom()"
                (contentScroll)="contentScroll.emit($event)"

                kendoDraggable
                kendoTreeListSelectionMarquee
                [enableDrag]="marqueeSelection"
                >
            </kendo-treelist-list>
        </ng-template>
        <ng-template [ngIf]="!isScrollable">
            <table [style.table-layout]="resizable ? 'fixed' : null">
                <colgroup kendoTreeListColGroup
                    [columns]="leafColumns">
                </colgroup>
                <thead kendoTreeListHeader
                    *ngIf="!hideHeader"
                    [resizable]="resizable"
                    [scrollable]="false"
                    [columns]="visibleColumns"
                    [totalColumnLevels]="totalColumnLevels"
                    [reorderable]="reorderable"
                    [sort]="sort"
                    [sortable]="sortable"
                    [filter]="filter"
                    [filterable]="filterable"
                    [columnMenu]="columnMenuOptions"
                    [columnMenuTemplate]="columnMenuTemplate">
                </thead>
                <tbody kendoTreeListTableBody
                    [view]="view"
                    [skip]="skip"
                    [columns]="leafColumns"
                    [filterable]="filterable"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [trackBy]="trackBy"
                    [rowClass]="rowClass"
                    [expandIcons]="expandIcons"

                    kendoDraggable
                    kendoTreeListSelectionMarquee
                    [enableDrag]="marqueeSelection"
                    >
                </tbody>
            </table>
            <div *ngIf="showLoading" kendoTreeListLoading>
            </div>
        </ng-template>
        </div>
        <kendo-treelist-pager
            *ngIf="showPager"
            [template]="pagerTemplate"
            [pageSize]="pageSize"
            [total]="view.totalVisible"
            [allCount]="view.total"
            [skip]="skip"
            [options]="pageable"
            (pageChange)="notifyPageChange('pager', $event)">
        </kendo-treelist-pager>
        <kendo-treelist-toolbar *ngIf="showBottomToolbar" position="bottom"></kendo-treelist-toolbar>
    `
            }]
    }], function () { return [{ type: BrowserSupportService }, { type: ɵngcc0.ElementRef }, { type: ChangeNotificationService }, { type: EditService }, { type: FilterService }, { type: PDFService }, { type: ResponsiveService }, { type: ɵngcc0.Renderer2 }, { type: ExcelService }, { type: ɵngcc0.NgZone }, { type: ScrollSyncService }, { type: DomEventsService }, { type: ColumnResizingService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ColumnReorderService }, { type: ColumnInfoService }, { type: NavigationService }, { type: SortService }, { type: ScrollRequestService }, { type: ExpandStateService }, { type: OptionChangesService }, { type: SelectionService }, { type: ɵngcc2.LocalizationService }]; }, { pageSize: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], virtualColumns: [{
            type: Input
        }], filterable: [{
            type: Input
        }], sortable: [{
            type: Input
        }], pageable: [{
            type: Input
        }], navigable: [{
            type: Input
        }], autoSize: [{
            type: Input
        }], resizable: [{
            type: Input
        }], reorderable: [{
            type: Input
        }], loading: [{
            type: Input
        }], columnMenu: [{
            type: Input
        }], hideHeader: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], filterChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], sortChange: [{
            type: Output
        }], dataStateChange: [{
            type: Output
        }], edit: [{
            type: Output
        }], cancel: [{
            type: Output
        }], save: [{
            type: Output
        }], remove: [{
            type: Output
        }], add: [{
            type: Output
        }], cellClose: [{
            type: Output
        }], cellClick: [{
            type: Output
        }], pdfExport: [{
            type: Output
        }], excelExport: [{
            type: Output
        }], columnResize: [{
            type: Output
        }], columnReorder: [{
            type: Output
        }], columnVisibilityChange: [{
            type: Output
        }], columnLockedChange: [{
            type: Output
        }], scrollBottom: [{
            type: Output
        }], contentScroll: [{
            type: Output
        }], expandEvent: [{
            type: Output,
            args: ['expand']
        }], collapseEvent: [{
            type: Output,
            args: ['collapse']
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase$1]
        }], footer: [{
            type: ViewChildren,
            args: ["footer"]
        }], skip: [{
            type: Input
        }], data: [{
            type: Input
        }], sort: [{
            type: Input
        }], navigatable: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], idField: [{
            type: Input
        }], selectable: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], dir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-grid']
        }, {
            type: HostBinding,
            args: ['class.k-treelist']
        }], lockedClasses: [{
            type: HostBinding,
            args: ['class.k-grid-lockedcolumns']
        }], virtualClasses: [{
            type: HostBinding,
            args: ['class.k-grid-virtual']
        }], noScrollbarClass: [{
            type: HostBinding,
            args: ['class.k-grid-no-scrollbar']
        }], fetchChildren: [{
            type: Input
        }], hasChildren: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], height: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], filter: [{
            type: Input
        }], noRecordsTemplateChildren: [{
            type: ContentChildren,
            args: [NoRecordsTemplateDirective]
        }], pagerTemplateChildren: [{
            type: ContentChildren,
            args: [PagerTemplateDirective]
        }], toolbarTemplateChildren: [{
            type: ContentChildren,
            args: [ToolbarTemplateDirective]
        }], columnMenuTemplates: [{
            type: ContentChildren,
            args: [ColumnMenuTemplateDirective]
        }], lockedHeader: [{
            type: ViewChild,
            args: ["lockedHeader"]
        }], header: [{
            type: ViewChild,
            args: ["header"]
        }], ariaRoot: [{
            type: ViewChild,
            args: ['ariaRoot']
        }] }); })();

/**
 * @hidden
 */
class RowHeightService {
    constructor(total = 0, rowHeight) {
        this.total = total;
        this.rowHeight = rowHeight;
        this.rowHeight = rowHeight || 0;
    }
    index(position) {
        if (position < 0) {
            return undefined;
        }
        return Math.min(Math.floor(position / this.rowHeight), this.total - 1);
    }
    offset(rowIndex) {
        if (0 <= rowIndex && rowIndex < this.total) {
            return rowIndex * this.rowHeight;
        }
    }
    totalHeight() {
        return this.total * this.rowHeight;
    }
}

/**
 * @hidden
 */
class ScrollAction {
    constructor(offset) {
        this.offset = offset;
    }
}
/**
 * @hidden
 */
class PageAction {
    constructor(skip, take$$1) {
        this.skip = skip;
        this.take = take$$1;
    }
}
/**
 * @hidden
 */
class ScrollBottomAction {
}
const SCROLL_BOTTOM_THRESHOLD = 1;
/**
 * @hidden
 */
class ScrollerService {
    constructor(scrollObservable) {
        this.scrollObservable = scrollObservable;
        this.firstLoaded = 0;
    }
    create(rowHeightService, skip, take$$1, total) {
        this.rowHeightService = rowHeightService;
        this.firstLoaded = skip;
        this.lastLoaded = skip + take$$1;
        this.take = take$$1;
        this.total = total;
        this.lastScrollTop = 0;
        const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip)));
        this.subscription = Observable.create(observer => {
            this.unsubscribe();
            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));
        }).subscribe(x => subject.next(x));
        return subject;
    }
    destroy() {
        this.unsubscribe();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    onScroll({ scrollTop, offsetHeight, scrollHeight, clientHeight }, observer) {
        if (this.lastScrollTop === scrollTop) {
            return;
        }
        const up = this.lastScrollTop >= scrollTop;
        this.lastScrollTop = scrollTop;
        let firstItemIndex = this.rowHeightService.index(scrollTop);
        let firstItemOffset = this.rowHeightService.offset(firstItemIndex);
        const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
        if (!up) {
            if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
                const overflow = (firstItemIndex + this.take) - this.total;
                if (overflow > 0) {
                    firstItemIndex = firstItemIndex - overflow;
                    firstItemOffset = this.rowHeightService.offset(firstItemIndex);
                }
                this.firstLoaded = firstItemIndex;
                observer.next(new ScrollAction(firstItemOffset));
                let nextTake = this.firstLoaded + this.take;
                this.lastLoaded = Math.min(nextTake, this.total);
                nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;
                observer.next(new PageAction(this.firstLoaded, this.take));
            }
            else {
                const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
                if (atBottom) {
                    observer.next(new ScrollBottomAction());
                }
            }
        }
        if (up && firstItemIndex < this.firstLoaded) {
            const nonVisibleBuffer = Math.floor(this.take * 0.3);
            this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);
            observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));
            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
            observer.next(new PageAction(this.firstLoaded, this.take));
        }
    }
    unsubscribe() {
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
            this.scrollSubscription = undefined;
        }
    }
}

/**
 * @hidden
 */
const NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';
/**
 * @hidden
 */
const NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';
/**
 * @hidden
 */
const IGNORE_TARGET_CLASSSES = 'k-icon';
/**
 * @hidden
 */
const IGNORE_CONTAINER_CLASSES = 'k-widget k-treelist-ignore-click';

const elementAt = (index, elements, elementOffset) => {
    for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {
        const offset = elementOffset(elements[idx]);
        if (elementIdx <= index && index <= elementIdx + offset - 1) {
            return elements[idx];
        }
        elementIdx += offset;
    }
};
const rowAt = (index, rows) => elementAt(index, rows, row => row.hasAttribute('data-kendo-treelist-item-index') ? 1 : 0);
const cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);
const EMPTY_OBJECT = {};
/**
 * @hidden
 */
const SCROLLER_FACTORY_TOKEN = new InjectionToken('treelist-scroll-service-factory');
/**
 * @hidden
 */
function DEFAULT_SCROLLER_FACTORY(observable) {
    return new ScrollerService(observable);
}
const wheelDeltaY = (e) => {
    const deltaY = e.wheelDeltaY;
    if (e.wheelDelta && (deltaY === undefined || deltaY)) {
        return e.wheelDelta;
    }
    else if (e.detail && e.axis === e.VERTICAL_AXIS) {
        return (-e.detail) * 10;
    }
    return 0;
};
const preventLockedScroll = el => event => {
    const delta = wheelDeltaY(event);
    const scrollTop = el.scrollTop;
    const allowScroll = (scrollTop === 0 && 0 < delta) || (el.scrollHeight <= el.offsetHeight + scrollTop && delta < 0);
    if (!allowScroll) {
        event.preventDefault();
    }
};
const translateY = (renderer, value) => el => renderer.setStyle(el, "transform", `translateY(${value}px)`);
const maybeNativeElement = el => el ? el.nativeElement : null;
const hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
const setHeight$1 = renderer => ({ el, height }) => renderer.setStyle(el, "height", `${height}px`);
const bufferSize = 1;
/**
 * @hidden
 */
class ListComponent {
    constructor(scrollerFactory, changeNotification, suspendService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, localization, columnResizingService, changeDetector, pdfService, columnInfo) {
        this.changeNotification = changeNotification;
        this.suspendService = suspendService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.scrollSyncService = scrollSyncService;
        this.resizeService = resizeService;
        this.editService = editService;
        this.supportService = supportService;
        this.navigationService = navigationService;
        this.localization = localization;
        this.columnResizingService = columnResizingService;
        this.changeDetector = changeDetector;
        this.pdfService = pdfService;
        this.columnInfo = columnInfo;
        this.skip = 0;
        this.columns = new ColumnsContainer(() => []);
        this.trackBy = defaultTrackBy;
        this.contentScroll = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.scrollBottom = new EventEmitter();
        this.columnsStartIdx = 0;
        this.resizeSensors = new QueryList();
        this.subscriptions = new Subscription();
        this.dispatcher = new Subject();
        this.containerScrollTop = 0;
        this.scrollLeft = 0;
        this.rtl = false;
        this.scroller = scrollerFactory(this.dispatcher);
        this.subscriptions = scrollRequestService.requests.subscribe(x => this.scrollTo(x));
    }
    get hostClass() {
        return true;
    }
    get hostRole() {
        return 'presentation';
    }
    get totalWidth() {
        if (this.virtualColumns && this.columns.unlockedWidth) {
            return this.columns.unlockedWidth;
        }
    }
    get lockedLeafColumns() {
        return this.columns.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columns.nonLockedLeafColumns;
    }
    get nonLockedColumnsToRender() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columns.leafColumnsToRender;
    }
    get lockedWidth() {
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), 0);
    }
    get nonLockedWidth() {
        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {
            return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
        }
        return undefined;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    ngOnInit() {
        this.init();
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
        this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
            if (this.virtualColumns) {
                this.ngZone.run(() => {
                    this.updateViewportColumns();
                    this.changeDetector.markForCheck();
                });
            }
        }));
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnChanges(changes) {
        if (isChanged("skip", changes) && !this.rebind) {
            this.skipScroll = true;
            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
        }
        if (anyChanged(["total", "take"], changes)) {
            this.init();
        }
        this.rebind = false;
    }
    ngDoCheck() {
        if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
            this.updateViewportColumns();
        }
    }
    ngAfterViewInit() {
        if (this.skip && this.isVirtual) {
            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
        }
        this.resetNavigationViewport();
        this.attachContainerScroll();
        this.initResizeService();
    }
    syncRowsHeight() {
        if (this.lockedContainer) {
            syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.resizeService) {
            this.resizeService.destroy();
        }
        this.cleanupScroller();
    }
    init() {
        if (this.suspendService.scroll) {
            return;
        }
        this.rowHeightService = new RowHeightService(this.total, this.rowHeight);
        this.totalHeight = this.rowHeightService.totalHeight();
        if (!isUniversal()) {
            this.ngZone.runOutsideAngular(this.createScroller.bind(this));
        }
    }
    attachContainerScroll() {
        if (isUniversal()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map((event) => event.target), filter(() => !this.suspendService.scroll), tap((target) => {
                this.onContainerScroll(target);
                this.resetNavigationViewport();
                if (this.virtualColumns) {
                    this.handleColumnScroll();
                }
                const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
                const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
                this.contentScroll.emit({
                    scrollLeft: target.scrollLeft,
                    scrollTop: target.scrollTop,
                    startRow: rowViewport.firstItemIndex,
                    endRow: rowViewport.lastItemIndex,
                    startColumn: columnViewport.firstItemIndex,
                    endColumn: columnViewport.lastItemIndex
                });
            })).subscribe(this.dispatcher));
        });
        this.scrollSyncService.registerEmitter(this.container.nativeElement, "body");
        if (this.lockedContainer) {
            this.ngZone.runOutsideAngular(() => {
                this.subscriptions.add(merge(fromEvent(this.lockedContainer.nativeElement, 'mousewheel'), fromEvent(this.lockedContainer.nativeElement, 'DOMMouseScroll')).pipe(filter((event) => !event.ctrlKey), tap(preventLockedScroll(this.container.nativeElement)), map(wheelDeltaY))
                    .subscribe(x => this.container.nativeElement.scrollTop -= x));
                this.subscriptions.add(fromEvent(this.lockedContainer.nativeElement, 'scroll').pipe(filter(() => !this.suspendService.scroll))
                    .subscribe(() => {
                    const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
                    if (lockedScrollTop !== this.containerScrollTop) {
                        this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
                    }
                }));
                this.subscriptions.add(fromEvent(this.lockedContainer.nativeElement, 'keydown').pipe(filter((event) => event.keyCode === Keys.PageDown || event.keyCode === Keys.PageUp)).subscribe((event) => {
                    const dir = event.keyCode === Keys.PageDown ? 1 : -1;
                    const element = this.container.nativeElement;
                    element.scrollTop += element.offsetHeight * dir * 0.8;
                    event.preventDefault();
                }));
            });
            this.syncRowsHeight();
        }
    }
    createScroller() {
        this.cleanupScroller();
        const observable = this.scroller
            .create(this.rowHeightService, this.skip, this.take, this.total);
        this.skipScroll = false;
        this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction), filter(() => {
            const temp = this.skipScroll;
            this.skipScroll = false;
            return !temp;
        }), tap(() => this.rebind = true))
            .subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction))
            .subscribe(this.scroll.bind(this)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction))
            .subscribe(() => this.scrollBottom.emit()));
    }
    scroll({ offset = 0 }) {
        if (this.isVirtual) {
            [
                maybeNativeElement(this.table),
                maybeNativeElement(this.lockedTable)
            ].filter(isPresent).forEach(translateY(this.renderer, offset));
        }
        this.resetNavigationViewport();
    }
    onContainerScroll({ scrollTop }) {
        this.containerScrollTop = scrollTop;
        if (this.lockedContainer) {
            this.lockedContainer.nativeElement.scrollTop = scrollTop;
        }
    }
    handleRowSync() {
        const isLocked = () => isPresent(this.lockedContainer);
        return merge(this.changeNotification.changes, this.editService.changed, this.resizeService.changes, this.columnResizingService.changes
            .pipe(filter(change => change.type === 'end')), this.supportService.changes)
            .pipe(tap(() => this.resetNavigationViewport()), filter(isLocked))
            .subscribe(() => {
            const scrollTop = this.container.nativeElement.scrollTop;
            const scrollLeft = this.container.nativeElement.scrollLeft;
            this.syncRowsHeight();
            this.syncContainerHeight();
            this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
            // fixes scroll left position in IE when editing
            this.container.nativeElement.scrollLeft = scrollLeft;
            this.resizeSensors.forEach(sensor => sensor.acceptSize());
        });
    }
    handleRowNavigationLocked() {
        return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe((args) => {
            if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
                const cell = this.navigationService.activeCell;
                if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {
                    this.container.nativeElement.scrollLeft = 0;
                }
            }
        });
    }
    scrollToVirtualRow(itemIndex) {
        const offset = this.rowHeightService.offset(itemIndex);
        this.container.nativeElement.scrollTop = offset;
        this.resetNavigationViewport();
    }
    scrollTo({ row, column }) {
        if (isNumber(row)) {
            if (this.isVirtual) {
                this.scrollToVirtualRow(row);
            }
            else {
                const element = rowAt(row, this.table.nativeElement.rows);
                if (element) {
                    this.container.nativeElement.scrollTop = element.offsetTop;
                }
            }
        }
        if (isNumber(column)) {
            column -= this.lockedLeafColumns.length;
            if (this.virtualColumns) {
                const columns = this.columns.leafColumnsToRender;
                let offset = 0;
                for (let idx = 0; idx < column; idx++) {
                    offset += columns[idx].width || 0;
                }
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset);
            }
            else {
                const firstRow = rowAt(0, this.table.nativeElement.rows);
                if (firstRow) {
                    const element = cellAt(column, firstRow.cells);
                    if (element) {
                        this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
                    }
                }
            }
        }
    }
    resetNavigationViewport() {
        if (!this.container ||
            !this.navigationService.needsViewport() || this.view.length === 0) {
            return;
        }
        const { scrollTop, offsetHeight } = this.container.nativeElement;
        const scrollBottom = scrollTop + offsetHeight;
        const firstItemIndex = this.rowHeightService.index(scrollTop);
        let lastItemIndex = this.rowHeightService.index(scrollBottom);
        const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
        const lastItemOverflows = lastItemOffset + this.rowHeight > scrollBottom;
        if (lastItemIndex > 0 && lastItemOverflows) {
            lastItemIndex--;
        }
        this.navigationService.setViewport(firstItemIndex, lastItemIndex);
    }
    cleanupScroller() {
        if (this.scrollerSubscription) {
            this.scrollerSubscription.unsubscribe();
        }
        if (this.scroller) {
            this.scroller.destroy();
        }
    }
    initResizeService() {
        this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));
    }
    syncContainerHeight() {
        [maybeNativeElement(this.lockedContainer)]
            .filter(isPresent)
            .map(el => {
            el.style.height = '';
            let height = this.container.nativeElement.offsetHeight;
            if (hasScrollbar(this.table, this.container)) {
                height -= this.supportService.scrollbarWidth;
            }
            return { el, height };
        })
            .forEach(setHeight$1(this.renderer));
    }
    updateViewportColumns(range) {
        const columns = this.columns.nonLockedLeafColumns.toArray();
        let { startIdx, endIdx, offset } = range || this.calculateViewportColumns();
        const start = Math.max(0, startIdx - bufferSize);
        const end = Math.min(endIdx + bufferSize, columns.length - 1);
        if (start < startIdx) {
            for (let idx = startIdx - 1; idx >= start; idx--) {
                offset -= columns[idx].width;
            }
        }
        let currentColumns = columns.slice(start, end + 1);
        this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
        if (start > 0) {
            const offsetColumn = new ColumnBase$1();
            offsetColumn.width = offset;
            currentColumns.unshift(offsetColumn);
        }
        this.viewportColumns = new QueryList();
        this.viewportColumns.reset(currentColumns);
        this.columnsStartIdx = start;
        this.columnsEndIdx = end;
        this.columnInfo.columnRangeChange.emit({ start, end, offset });
        if (!range) {
            this.updateColumnViewport(startIdx, endIdx);
        }
    }
    handleColumnScroll() {
        const container = this.container.nativeElement;
        const scrollLeft = container.scrollLeft;
        if (this.scrollLeft !== scrollLeft) {
            this.scrollLeft = scrollLeft;
            const range = this.calculateViewportColumns();
            this.updateColumnViewport(range.startIdx, range.endIdx);
            if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {
                cancelAnimationFrame(this.columnUpdateFrame);
                this.columnUpdateFrame = requestAnimationFrame(() => {
                    this.ngZone.run(() => {
                        this.updateViewportColumns(range);
                        this.changeDetector.markForCheck();
                    });
                });
            }
        }
    }
    updateColumnViewport(startIdx, endIdx) {
        const lockedCount = this.lockedLeafColumns.length;
        const leafColumns$$1 = this.nonLockedLeafColumns.toArray();
        const viewportStart = lockedCount + startIdx;
        let viewportEnd = lockedCount + endIdx;
        for (let idx = 0; idx < leafColumns$$1.length; idx++) {
            const column = leafColumns$$1[idx];
            if (column.isSpanColumn) {
                viewportEnd += column.childColumns.length;
            }
        }
        this.navigationService.setColumnViewport(viewportStart, viewportEnd);
    }
    calculateViewportColumns() {
        const { scrollLeft, clientWidth } = this.container.nativeElement;
        const columns = this.columns.nonLockedLeafColumns.toArray();
        const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
        const viewportEnd = normalizedScrollLeft + clientWidth;
        let startIdx;
        let endIdx = 0;
        let current = 0;
        let offset = 0;
        let idx;
        for (idx = 0; idx < columns.length; idx++) {
            const column = columns[idx];
            current += column.width || 0;
            if (startIdx === undefined && current > normalizedScrollLeft) {
                startIdx = idx;
                offset = current - (column.width || 0);
            }
            if (current >= viewportEnd) {
                endIdx = idx;
                break;
            }
        }
        if (!endIdx && idx > 0) {
            endIdx = columns.length - 1;
        }
        return { startIdx, endIdx, offset };
    }
    viewportWidthChange() {
        const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
        return currentWidth !== this.viewportColumnsWidth;
    }
    normalizeScrollLeft(position) {
        return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;
    }
    elementScrollLeft(element) {
        if (this.rtl) {
            return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
        }
        return element.offsetLeft;
    }
}
ListComponent.ɵfac = function ListComponent_Factory(t) { return new (t || ListComponent)(ɵngcc0.ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵngcc0.ɵɵdirectiveInject(ChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(SuspendService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ScrollSyncService), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(BrowserSupportService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ScrollRequestService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService)); };
ListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ListComponent, selectors: [["kendo-treelist-list"]], viewQuery: function ListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c103, true);
        ɵngcc0.ɵɵviewQuery(_c104, true);
        ɵngcc0.ɵɵviewQuery(_c105, true);
        ɵngcc0.ɵɵviewQuery(_c106, true);
        ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lockedTable = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.table = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensors = _t);
    } }, hostVars: 3, hostBindings: function ListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole);
        ɵngcc0.ɵɵclassProp("k-grid-container", ctx.hostClass);
    } }, inputs: { skip: "skip", columns: "columns", trackBy: "trackBy", view: "view", total: "total", rowHeight: "rowHeight", take: "take", noRecordsTemplate: "noRecordsTemplate", filterable: "filterable", rowClass: "rowClass", loading: "loading", virtualColumns: "virtualColumns", isVirtual: "isVirtual", expandIcons: "expandIcons" }, outputs: { contentScroll: "contentScroll", pageChange: "pageChange", scrollBottom: "scrollBottom" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: SCROLLER_FACTORY_TOKEN,
                useValue: DEFAULT_SCROLLER_FACTORY
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 14, vars: 25, consts: [["class", "k-grid-content-locked", "role", "presentation", 3, "width", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content", "k-virtual-content", 3, "kendoTreeListResizableContainer", "lockedWidth"], ["container", ""], ["role", "presentation", 1, "k-grid-table-wrap"], ["role", "presentation", 1, "k-grid-table", 3, "virtualColumns"], ["table", ""], ["kendoTreeListColGroup", "", "role", "presentation", 3, "columns"], ["kendoTreeListTableBody", "", "role", "presentation", 3, "view", "columns", "allColumns", "noRecordsTemplate", "lockedColumnsCount", "totalColumnsCount", "skip", "trackBy", "filterable", "rowClass", "virtualColumns", "expandIcons"], [4, "ngIf"], ["role", "presentation", 1, "k-height-container"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["kendoTreeListLoading", "", 4, "ngIf"], ["role", "presentation", 1, "k-grid-content-locked"], ["lockedContainer", ""], ["role", "presentation", 1, "k-grid-table", 3, "locked"], ["lockedTable", ""], ["kendoTreeListTableBody", "", "role", "presentation", 3, "isLocked", "view", "noRecordsText", "columns", "totalColumnsCount", "skip", "trackBy", "filterable", "rowClass", "expandIcons"], ["role", "presentation", 1, "k-width-container"], ["kendoTreeListLoading", ""]], template: function ListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ListComponent_div_0_Template, 10, 18, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "table", 4, 5);
        ɵngcc0.ɵɵelement(6, "colgroup", 6);
        ɵngcc0.ɵɵelement(7, "tbody", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, ListComponent_kendo_resize_sensor_8_Template, 1, 0, "kendo-resize-sensor", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, ListComponent_kendo_resize_sensor_9_Template, 1, 0, "kendo-resize-sensor", 8);
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelement(11, "div");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, ListComponent_div_12_Template, 2, 2, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(13, ListComponent_div_13_Template, 1, 0, "div", 11);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isLocked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("kendoTreeListResizableContainer", ctx.lockedLeafColumns.length)("lockedWidth", ctx.lockedWidth + 1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("width", ctx.nonLockedWidth, "px");
        ɵngcc0.ɵɵproperty("virtualColumns", ctx.virtualColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("columns", ctx.nonLockedColumnsToRender);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("view", ctx.view)("columns", ctx.nonLockedColumnsToRender)("allColumns", ctx.nonLockedLeafColumns)("noRecordsTemplate", ctx.noRecordsTemplate)("lockedColumnsCount", ctx.lockedLeafColumns.length)("totalColumnsCount", ctx.leafColumns.length)("skip", ctx.skip)("trackBy", ctx.trackBy)("filterable", ctx.filterable)("rowClass", ctx.rowClass)("virtualColumns", ctx.virtualColumns)("expandIcons", ctx.expandIcons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isLocked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isLocked || ctx.virtualColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.virtualColumns);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loading);
    } }, directives: function () { return [ɵngcc4.NgIf, ResizableContainerDirective,
        TableDirective,
        ColGroupComponent,
        TableBodyComponent, ɵngcc5.ResizeSensorComponent, LoadingComponent]; }, encapsulation: 2 });
/** @nocollapse */
ListComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [SCROLLER_FACTORY_TOKEN,] }] },
    { type: ChangeNotificationService },
    { type: SuspendService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ScrollSyncService },
    { type: ResizeService },
    { type: EditService },
    { type: BrowserSupportService },
    { type: NavigationService },
    { type: ScrollRequestService },
    { type: LocalizationService },
    { type: ColumnResizingService },
    { type: ChangeDetectorRef },
    { type: PDFService },
    { type: ColumnInfoService }
];
ListComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ["class.k-grid-container",] }],
    hostRole: [{ type: HostBinding, args: ["attr.role",] }],
    view: [{ type: Input }],
    total: [{ type: Input }],
    rowHeight: [{ type: Input }],
    take: [{ type: Input }],
    skip: [{ type: Input }],
    columns: [{ type: Input }],
    noRecordsTemplate: [{ type: Input }],
    filterable: [{ type: Input }],
    rowClass: [{ type: Input }],
    loading: [{ type: Input }],
    trackBy: [{ type: Input }],
    virtualColumns: [{ type: Input }],
    isVirtual: [{ type: Input }],
    expandIcons: [{ type: Input }],
    contentScroll: [{ type: Output }],
    pageChange: [{ type: Output }],
    scrollBottom: [{ type: Output }],
    container: [{ type: ViewChild, args: ["container", { static: true },] }],
    lockedContainer: [{ type: ViewChild, args: ["lockedContainer",] }],
    lockedTable: [{ type: ViewChild, args: ["lockedTable",] }],
    table: [{ type: ViewChild, args: ["table",] }],
    resizeSensors: [{ type: ViewChildren, args: [ResizeSensorComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ListComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: SCROLLER_FACTORY_TOKEN,
                        useValue: DEFAULT_SCROLLER_FACTORY
                    }
                ],
                selector: 'kendo-treelist-list',
                template: `
    <div #lockedContainer class="k-grid-content-locked" role="presentation"
        *ngIf="isLocked" [style.width.px]="lockedWidth">
        <div role="presentation" class="k-grid-table-wrap">
            <table [locked]="true" #lockedTable class="k-grid-table" role="presentation" [style.width.px]="lockedWidth">
                <colgroup kendoTreeListColGroup
                    role="presentation"
                    [columns]="lockedLeafColumns">
                </colgroup>
                <tbody kendoTreeListTableBody
                    role="presentation"
                    [isLocked]="true"
                    [view]="view"
                    [noRecordsText]="''"
                    [columns]="lockedLeafColumns"
                    [totalColumnsCount]="leafColumns.length"
                    [skip]="skip"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [expandIcons]="expandIcons">
                </tbody>
            </table>
            <kendo-resize-sensor></kendo-resize-sensor>
        </div>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
    </div><div #container
               class="k-grid-content k-virtual-content"
               role="presentation" tabindex="-1"
               [kendoTreeListResizableContainer]="lockedLeafColumns.length"
               [lockedWidth]="lockedWidth + 1">
        <div role="presentation" class="k-grid-table-wrap">
            <table [style.width.px]="nonLockedWidth" #table [virtualColumns]="virtualColumns"
              class="k-grid-table" role="presentation">
                <colgroup kendoTreeListColGroup
                    role="presentation"
                    [columns]="nonLockedColumnsToRender">
                </colgroup>
                <tbody kendoTreeListTableBody
                    role="presentation"
                    [view]="view"
                    [columns]="nonLockedColumnsToRender"
                    [allColumns]="nonLockedLeafColumns"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [lockedColumnsCount]="lockedLeafColumns.length"
                    [totalColumnsCount]="leafColumns.length"
                    [skip]="skip"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [virtualColumns]="virtualColumns"
                    [expandIcons]="expandIcons">
                </tbody>
            </table>
            <kendo-resize-sensor *ngIf="isLocked"></kendo-resize-sensor>
        </div>
        <kendo-resize-sensor *ngIf="isLocked || virtualColumns"></kendo-resize-sensor>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
            <div [style.width.px]="totalWidth"></div>
        </div>
    </div>
    <div *ngIf="loading" kendoTreeListLoading>
    </div>
    `
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [SCROLLER_FACTORY_TOKEN]
            }] }, { type: ChangeNotificationService }, { type: SuspendService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ScrollSyncService }, { type: ResizeService }, { type: EditService }, { type: BrowserSupportService }, { type: NavigationService }, { type: ScrollRequestService }, { type: ɵngcc2.LocalizationService }, { type: ColumnResizingService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PDFService }, { type: ColumnInfoService }]; }, { skip: [{
            type: Input
        }], columns: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], contentScroll: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], scrollBottom: [{
            type: Output
        }], resizeSensors: [{
            type: ViewChildren,
            args: [ResizeSensorComponent]
        }], hostClass: [{
            type: HostBinding,
            args: ["class.k-grid-container"]
        }], hostRole: [{
            type: HostBinding,
            args: ["attr.role"]
        }], view: [{
            type: Input
        }], total: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], take: [{
            type: Input
        }], noRecordsTemplate: [{
            type: Input
        }], filterable: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], loading: [{
            type: Input
        }], virtualColumns: [{
            type: Input
        }], isVirtual: [{
            type: Input
        }], expandIcons: [{
            type: Input
        }], container: [{
            type: ViewChild,
            args: ["container", { static: true }]
        }], lockedContainer: [{
            type: ViewChild,
            args: ["lockedContainer"]
        }], lockedTable: [{
            type: ViewChild,
            args: ["lockedTable"]
        }], table: [{
            type: ViewChild,
            args: ["table"]
        }] }); })();

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = function Messages_Factory(t) { return ɵMessages_BaseFactory(t || Messages); };
Messages.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Messages, inputs: { groupPanelEmpty: "groupPanelEmpty", noRecords: "noRecords", pagerFirstPage: "pagerFirstPage", pagerLastPage: "pagerLastPage", pagerPreviousPage: "pagerPreviousPage", pagerNextPage: "pagerNextPage", pagerPage: "pagerPage", pagerPageNumberInputTitle: "pagerPageNumberInputTitle", pagerItemsPerPage: "pagerItemsPerPage", pagerOf: "pagerOf", pagerItemsTotal: "pagerItemsTotal", filter: "filter", filterEqOperator: "filterEqOperator", filterNotEqOperator: "filterNotEqOperator", filterIsNullOperator: "filterIsNullOperator", filterIsNotNullOperator: "filterIsNotNullOperator", filterIsEmptyOperator: "filterIsEmptyOperator", filterIsNotEmptyOperator: "filterIsNotEmptyOperator", filterStartsWithOperator: "filterStartsWithOperator", filterContainsOperator: "filterContainsOperator", filterNotContainsOperator: "filterNotContainsOperator", filterEndsWithOperator: "filterEndsWithOperator", filterGteOperator: "filterGteOperator", filterGtOperator: "filterGtOperator", filterLteOperator: "filterLteOperator", filterLtOperator: "filterLtOperator", filterIsTrue: "filterIsTrue", filterIsFalse: "filterIsFalse", filterBooleanAll: "filterBooleanAll", filterAfterOrEqualOperator: "filterAfterOrEqualOperator", filterAfterOperator: "filterAfterOperator", filterBeforeOperator: "filterBeforeOperator", filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator", filterFilterButton: "filterFilterButton", filterClearButton: "filterClearButton", filterAndLogic: "filterAndLogic", filterOrLogic: "filterOrLogic", loading: "loading", columnMenu: "columnMenu", columns: "columns", lock: "lock", unlock: "unlock", sortable: "sortable", sortAscending: "sortAscending", sortDescending: "sortDescending", sortedAscending: "sortedAscending", sortedDescending: "sortedDescending", sortedDefault: "sortedDefault", columnsApply: "columnsApply", columnsReset: "columnsReset" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
Messages.propDecorators = {
    groupPanelEmpty: [{ type: Input }],
    noRecords: [{ type: Input }],
    pagerFirstPage: [{ type: Input }],
    pagerLastPage: [{ type: Input }],
    pagerPreviousPage: [{ type: Input }],
    pagerNextPage: [{ type: Input }],
    pagerPage: [{ type: Input }],
    pagerPageNumberInputTitle: [{ type: Input }],
    pagerItemsPerPage: [{ type: Input }],
    pagerOf: [{ type: Input }],
    pagerItemsTotal: [{ type: Input }],
    filter: [{ type: Input }],
    filterEqOperator: [{ type: Input }],
    filterNotEqOperator: [{ type: Input }],
    filterIsNullOperator: [{ type: Input }],
    filterIsNotNullOperator: [{ type: Input }],
    filterIsEmptyOperator: [{ type: Input }],
    filterIsNotEmptyOperator: [{ type: Input }],
    filterStartsWithOperator: [{ type: Input }],
    filterContainsOperator: [{ type: Input }],
    filterNotContainsOperator: [{ type: Input }],
    filterEndsWithOperator: [{ type: Input }],
    filterGteOperator: [{ type: Input }],
    filterGtOperator: [{ type: Input }],
    filterLteOperator: [{ type: Input }],
    filterLtOperator: [{ type: Input }],
    filterIsTrue: [{ type: Input }],
    filterIsFalse: [{ type: Input }],
    filterBooleanAll: [{ type: Input }],
    filterAfterOrEqualOperator: [{ type: Input }],
    filterAfterOperator: [{ type: Input }],
    filterBeforeOperator: [{ type: Input }],
    filterBeforeOrEqualOperator: [{ type: Input }],
    filterFilterButton: [{ type: Input }],
    filterClearButton: [{ type: Input }],
    filterAndLogic: [{ type: Input }],
    filterOrLogic: [{ type: Input }],
    loading: [{ type: Input }],
    columnMenu: [{ type: Input }],
    columns: [{ type: Input }],
    lock: [{ type: Input }],
    unlock: [{ type: Input }],
    sortable: [{ type: Input }],
    sortAscending: [{ type: Input }],
    sortDescending: [{ type: Input }],
    sortedAscending: [{ type: Input }],
    sortedDescending: [{ type: Input }],
    sortedDefault: [{ type: Input }],
    columnsApply: [{ type: Input }],
    columnsReset: [{ type: Input }]
};
const ɵMessages_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(Messages);

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) { return new (t || LocalizedMessagesDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LocalizedMessagesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LocalizedMessagesDirective, selectors: [["", "kendoTreeListLocalizedMessages", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
LocalizedMessagesDirective.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedMessagesDirective, [{
        type: Directive,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => LocalizedMessagesDirective)
                    }
                ],
                selector: '[kendoTreeListLocalizedMessages]'
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Custom component messages override default component messages
 * ([see example]({% slug globalization_treelist %}#toc-localization)).
 */
class CustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) { return new (t || CustomMessagesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CustomMessagesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CustomMessagesComponent, selectors: [["kendo-treelist-messages"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: Messages,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CustomMessagesComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
CustomMessagesComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CustomMessagesComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: Messages,
                        useExisting: forwardRef(() => CustomMessagesComponent)
                    }
                ],
                selector: 'kendo-treelist-messages',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * @hidden
 */
class FilterRowComponent {
    constructor(localization) {
        this.localization = localization;
        this.columns = [];
        this.filterRowClass = true;
        this.filterLabel = this.localization.get('filter');
    }
}
FilterRowComponent.ɵfac = function FilterRowComponent_Factory(t) { return new (t || FilterRowComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
FilterRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterRowComponent, selectors: [["", "kendoTreeListFilterRow", ""]], hostVars: 2, hostBindings: function FilterRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filter-row", ctx.filterRowClass);
    } }, inputs: { columns: "columns", filter: "filter", logicalRowIndex: "logicalRowIndex", lockedColumnsCount: "lockedColumnsCount" }, attrs: _c107, decls: 1, vars: 1, consts: [["kendoTreeListFilterCell", "", "kendoTreeListLogicalCell", "", 3, "column", "filter", "logicalRowIndex", "logicalColIndex", "colIndex", 4, "ngFor", "ngForOf"], ["kendoTreeListFilterCell", "", "kendoTreeListLogicalCell", "", 3, "column", "filter", "logicalRowIndex", "logicalColIndex", "colIndex"]], template: function FilterRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FilterRowComponent_td_0_Template, 1, 7, "td", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columns);
    } }, directives: function () { return [ɵngcc4.NgForOf, FilterCellComponent,
        LogicalCellDirective]; }, encapsulation: 2 });
/** @nocollapse */
FilterRowComponent.ctorParameters = () => [
    { type: LocalizationService }
];
FilterRowComponent.propDecorators = {
    columns: [{ type: Input }],
    filter: [{ type: Input }],
    logicalRowIndex: [{ type: Input }],
    lockedColumnsCount: [{ type: Input }],
    filterRowClass: [{ type: HostBinding, args: ['class.k-filter-row',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterRowComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListFilterRow]',
                template: `
      <td *ngFor="let column of columns; let columnIndex = index"
          [attr.aria-label]="filterLabel"
          kendoTreeListFilterCell
            [column]="column"
            [filter]="filter"
          kendoTreeListLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="lockedColumnsCount + columnIndex"
            [column]="column"
            [colIndex]="columnIndex"
      ></td>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { columns: [{
            type: Input
        }], filterRowClass: [{
            type: HostBinding,
            args: ['class.k-filter-row']
        }], filter: [{
            type: Input
        }], logicalRowIndex: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }] }); })();

const copyObject = (obj) => {
    const result = {};
    Object.assign(result, obj);
    if (obj.constructor !== Object) {
        const proto = obj.constructor.prototype;
        Object.getOwnPropertyNames(proto).forEach((property) => {
            if (property !== 'constructor' && proto.hasOwnProperty(property)) {
                result[property] = obj[property];
            }
        });
    }
    return result;
};
const cloneFilter = (filter$$1) => copyObject(filter$$1);
/**
 * @hidden
 */
const cloneFilters = (filter$$1) => {
    if (!filter$$1) {
        return;
    }
    if (isCompositeFilterDescriptor(filter$$1)) {
        return {
            filters: cloneFilters(filter$$1.filters),
            logic: filter$$1.logic
        };
    }
    else if (Array.isArray(filter$$1)) {
        return filter$$1.map(cloneFilters);
    }
    return cloneFilter(filter$$1);
};

/**
 * @hidden
 */
class FilterCellComponent {
    constructor(focusGroup) {
        this.focusGroup = focusGroup;
        this._templateContext = {};
    }
    get filter() {
        return this._filter;
    }
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    get templateContext() {
        this._templateContext.$implicit = this.filter;
        this._templateContext.column = this.column;
        this._templateContext.filter = this.filter;
        this._templateContext.cellContext = { focusGroup: this.focusGroup };
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column.filterCellTemplateRef);
    }
    get isFilterable() {
        return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;
    }
}
FilterCellComponent.ɵfac = function FilterCellComponent_Factory(t) { return new (t || FilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FocusGroup)); };
FilterCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterCellComponent, selectors: [["", "kendoTreeListFilterCell", ""]], inputs: { filter: "filter", column: "column" }, attrs: _c108, decls: 1, vars: 1, consts: [[3, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["kendoFilterCellHost", "", 3, "column", "filter"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function FilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FilterCellComponent_ng_template_0_Template, 3, 3, "ng-template", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isFilterable);
    } }, directives: function () { return [ɵngcc4.NgIf, ɵngcc4.NgSwitch, ɵngcc4.NgSwitchCase, FilterCellHostDirective, ɵngcc4.NgTemplateOutlet]; }, encapsulation: 2 });
/** @nocollapse */
FilterCellComponent.ctorParameters = () => [
    { type: FocusGroup }
];
FilterCellComponent.propDecorators = {
    column: [{ type: Input }],
    filter: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterCellComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListFilterCell]',
                template: `
        <ng-template [ngIf]="isFilterable">
            <ng-container [ngSwitch]="hasTemplate">
                <ng-container *ngSwitchCase="false">
                    <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
                </ng-container>
                <ng-container *ngSwitchCase="true">
                    <ng-template
                        *ngIf="column.filterCellTemplateRef"
                        [ngTemplateOutlet]="column.filterCellTemplateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                </ng-container>
            </ng-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: FocusGroup }]; }, { filter: [{
            type: Input
        }], column: [{
            type: Input
        }] }); })();

const localizeOperators = operators => localization => Object.keys(operators).reduce((acc, key) => {
    acc[operators[key]] = localization.get(key);
    return acc;
}, {}); // tslint:disable-line:align
const operatorTexts = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty",
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterAfterOrEqualOperator": "after-eq",
    "filterAfterOperator": "after",
    "filterBeforeOrEqualOperator": "before-eq",
    "filterBeforeOperator": "before"
});
/**
 * @hidden
 */
const toJSON = (xs) => xs.map(x => x.toJSON());
/**
 * @hidden
 */
class FilterOperatorBase {
    constructor(operator, localization) {
        this.operator = operator;
        this.localization = localization;
        this.messages = operatorTexts(this.localization);
        this._text = this.messages[this.operator];
        this.localization.changes.subscribe(this.refreshText.bind(this));
    }
    /**
     * The text that will be displayed in the drop-down list.
     * @readonly
     * @type {string}
     * @memberOf FilterOperatorBase
     */
    get text() {
        return this._text;
    }
    /**
     *
     */
    set text(value) {
        this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;
    }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: this.operator
        };
    }
    refreshText() {
        const update = this._text === this.messages[this.operator];
        this.messages = operatorTexts(this.localization);
        if (update) {
            this._text = this.messages[this.operator];
        }
    }
}
FilterOperatorBase.ɵfac = function FilterOperatorBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilterOperatorBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterOperatorBase, inputs: { text: "text" } });
FilterOperatorBase.propDecorators = {
    text: [{ type: Input }]
};


const insertDefaultFilter = (index, rootFilter, filter$$1) => {
    rootFilter = (rootFilter || { filters: [], logic: "and" });
    rootFilter.filters[index] = filter$$1;
    return filter$$1;
};
/**
 * @hidden
 */
const setFilter = (index, filter$$1, field, defaultOperator) => {
    if (isPresent(filter$$1) && isPresent(filter$$1.filters) && filter$$1.filters.length > index) {
        return filter$$1.filters[index];
    }
    else {
        return insertDefaultFilter(index, filter$$1, {
            field,
            operator: defaultOperator
        });
    }
};
/**
 * @hidden
 */
const logicOperators = (localization) => [
    { text: localization.get("filterAndLogic"), value: "and" },
    { text: localization.get("filterOrLogic"), value: "or" }
];
/**
 * @hidden
 */
const flatten = (filter$$1) => {
    if (isPresent(filter$$1.filters)) {
        return filter$$1.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);
    }
    return [];
};
const trimFilterByField = (filter$$1, field) => {
    if (isPresent(filter$$1) && isPresent(filter$$1.filters)) {
        filter$$1.filters = filter$$1.filters.filter(x => {
            if (isCompositeFilterDescriptor(x)) {
                trimFilterByField(x, field);
                return x.filters.length;
            }
            else {
                return x.field !== field;
            }
        });
    }
};
/**
 * @hidden
 */
const filtersByField = (filter$$1, field) => flatten(filter$$1 || {}).filter(x => x.field === field);
/**
 * @hidden
 */
const filterByField = (filter$$1, field) => {
    let [currentFilter] = filtersByField(filter$$1, field);
    return currentFilter;
};
/**
 * @hidden
 */
const removeFilter = (filter$$1, field) => {
    trimFilterByField(filter$$1, field);
    return filter$$1;
};
/**
 * @hidden
 */
const localizeOperators$1 = operators => localization => Object.keys(operators).map(key => ({
    text: localization.get(key),
    value: operators[key]
}));
/**
 * An abstract base class for the filter-cell component ([see example]({% slug reusablecustomfilters_treelist %}#toc-filter-row)).
 */
class BaseFilterCellComponent {
    constructor(filterService) {
        this.filterService = filterService;
        this.operatorList = new QueryList();
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    get operators() {
        return this._operators.length ? this._operators : this.defaultOperators;
    }
    set operators(values) {
        this._operators = values;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.operationListSubscription = observe(this.operatorList)
            .pipe(map(q => q.toArray()), map(toJSON))
            .subscribe(x => {
            this.operators = x;
        });
    }
    ngOnDestroy() {
        if (this.operationListSubscription) {
            this.operationListSubscription.unsubscribe();
        }
    }
    filterByField(field) {
        return filterByField(this.filter, field);
    }
    filtersByField(field) {
        return filtersByField(this.filter, field);
    }
    removeFilter(field) {
        return removeFilter(this.filter, field);
    }
    updateFilter(filter$$1) {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        let [currentFilter] = flatten(root).filter(x => x.field === filter$$1.field);
        if (!isPresent(currentFilter)) {
            root.filters.push(filter$$1);
        }
        else {
            Object.assign(currentFilter, filter$$1);
        }
        return root;
    }
    applyFilter(filter$$1) {
        this.filterService.filter(filter$$1);
    }
}
BaseFilterCellComponent.ɵfac = function BaseFilterCellComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BaseFilterCellComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseFilterCellComponent, contentQueries: function BaseFilterCellComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterOperatorBase, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.operatorList = _t);
    } }, hostVars: 2, hostBindings: function BaseFilterCellComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } } });
BaseFilterCellComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],
    operatorList: [{ type: ContentChildren, args: [FilterOperatorBase,] }]
};


// tslint:disable:no-access-missing-member
const numericOperators = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * Represents a base numeric filter component.
 */
class NumericFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * The default filter operator. Defaults to `eq`.
         * @type {string}
         */
        this.operator = "eq";
        /**
         * Specifies the value that is used to increment or decrement the component value.
         * @type {numeric}
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered.
         * @type {boolean}
         */
        this.spinners = true;
        this.defaultOperators = numericOperators(this.localization);
    }
    /**
     * Specifies the number format used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    set format(value) {
        this._format = value;
    }
    /**
     * Specifies the number format used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     *
     * @readonly
     * @type {string}
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "n2";
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = numericOperators(this.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
}
NumericFilterComponent.ɵfac = function NumericFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NumericFilterComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NumericFilterComponent, inputs: { operator: "operator", step: "step", spinners: "spinners", format: "format", column: "column", filter: "filter", min: "min", max: "max", decimals: "decimals" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NumericFilterComponent.propDecorators = {
    column: [{ type: Input }],
    filter: [{ type: Input }],
    operator: [{ type: Input }],
    step: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    spinners: [{ type: Input }],
    decimals: [{ type: Input }],
    format: [{ type: Input }]
};


/**
 * Represents a numeric filter cell.
 *
 * @example
 *  ```html-no-run
 *      <kendo-treelist-column field="ProductName" title="Product Name">
 *          <ng-template kendoTreeListFilterCellTemplate let-filter let-column="column">
 *          <kendo-treelist-numeric-filter-cell
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-treelist-numeric-filter-cell>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class NumericFilterCellComponent extends NumericFilterComponent {
    constructor(filterService, localization) {
        super(filterService, localization);
        this.localization = localization;
        /**
         * Determines the delay time (in milliseconds) before the filter value is submitted.
         * A value of `0` indicates no delay. The default value is `500`.
         * @type {boolean}
         */
        this.filterDelay = 500;
        /**
         * Determines if the drop-down filter operators will be displayed.
         * The default value is `true`.
         * @type {boolean}
         */
        this.showOperators = true;
    }
}
NumericFilterCellComponent.ɵfac = function NumericFilterCellComponent_Factory(t) { return new (t || NumericFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
NumericFilterCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumericFilterCellComponent, selectors: [["kendo-treelist-numeric-filter-cell"]], inputs: { filterDelay: "filterDelay", showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 14, consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoTreeListFocusable", "", "kendoFilterInput", "", 3, "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "step"]], template: function NumericFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "kendo-numerictextbox", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("filterDelay", ctx.filterDelay)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step);
    } }, directives: function () { return [FilterCellWrapperComponent, ɵngcc6.NumericTextBoxComponent, FocusableDirective,
        FilterInputDirective]; }, encapsulation: 2 });
/** @nocollapse */
NumericFilterCellComponent.ctorParameters = () => [
    { type: FilterService },
    { type: LocalizationService }
];
NumericFilterCellComponent.propDecorators = {
    filterDelay: [{ type: Input }],
    showOperators: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-numeric-filter-cell',
                template: `
        <kendo-treelist-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-numerictextbox
                kendoTreeListFocusable
                kendoFilterInput
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step">
            </kendo-numerictextbox>
        </kendo-treelist-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc2.LocalizationService }]; }, { filterDelay: [{
            type: Input
        }], showOperators: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FilterInputDirective {
    constructor(valueAccessors, ngZone, element, renderer) {
        this.change = new EventEmitter();
        this.composing = false;
        this.filterDelay = 500;
        this.changeRequests = new Subject();
        this.accessor = valueAccessors[0];
        ngZone.runOutsideAngular(() => {
            const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);
            const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', () => this.composing = false);
            this.unsubscribeEvents = () => {
                unsubscribeStart();
                unsubscribeEnd();
            };
        });
    }
    set value(value) {
        this.accessor.writeValue(value);
    }
    set disabled(value) {
        this.accessor.setDisabledState(value);
    }
    ngAfterViewInit() {
        this.accessor.registerOnChange(x => this.filterDelay > 0 ?
            this.changeRequests.next(x) :
            this.change.emit(x));
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged('filterDelay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
        this.unsubscribeEvents();
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.changeRequests
            .pipe(debounceTime(this.filterDelay), filter(() => !this.composing))
            .subscribe(x => this.change.emit(x));
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
}
FilterInputDirective.ɵfac = function FilterInputDirective_Factory(t) { return new (t || FilterInputDirective)(ɵngcc0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FilterInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterInputDirective, selectors: [["", "kendoFilterInput", ""]], inputs: { filterDelay: "filterDelay", value: "value" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
FilterInputDirective.ctorParameters = () => [
    { type: Array, decorators: [{ type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR,] }] },
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
FilterInputDirective.propDecorators = {
    filterDelay: [{ type: Input }],
    value: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterInputDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFilterInput]'
            }]
    }], function () { return [{ type: Array, decorators: [{
                type: Self
            }, {
                type: Inject,
                args: [NG_VALUE_ACCESSOR]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { filterDelay: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();

const EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);
const isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
/**
 * @hidden
 */
class FilterInputWrapperComponent extends BaseFilterCellComponent {
    constructor(filterService) {
        super(filterService);
        this.operators = [];
    }
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        const filter$$1 = this.currentFilter;
        if (!this._operator) {
            this._operator = filter$$1 ? filter$$1.operator : this.defaultOperator;
        }
        return this._operator;
    }
    set currentOperator(value) {
        this._operator = value;
        const emptyValueOperator = isEmptyValueOperator(value);
        this.filterInputDisabled = emptyValueOperator;
        if (emptyValueOperator) {
            this.applyNoValueFilter(value);
        }
        else if (!isBlank(value) && isPresent(this.currentFilter)) {
            this.onChange(this.currentFilter.value);
        }
    }
    get defaultOperator() {
        if (!isNullOrEmptyString(this._defaultOperator)) {
            return this._defaultOperator;
        }
        else if (this.operators && this.operators.length) {
            return this.operators[0].value;
        }
        return "eq";
    }
    set defaultOperator(value) {
        this._defaultOperator = value;
    }
    set filterInputDisabled(disabled) {
        if (!this.input) {
            return;
        }
        this.input.disabled = disabled;
    }
    ngAfterContentInit() {
        if (isPresent(this.input)) {
            this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
    }
    onChange(value) {
        if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {
            this.filterChange(isNullOrEmptyString(value) ?
                this.removeFilter(this.column.field) :
                this.updateFilter({
                    field: this.column.field,
                    operator: this.currentOperator,
                    value: value
                }));
        }
    }
    onClear() {
        this.onChange(null);
        this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
    }
    applyNoValueFilter(operator) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: operator,
            value: null
        }));
    }
    ngOnChanges(changes) {
        if (isChanged("filter", changes, false)) {
            this._operator = null;
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
}
FilterInputWrapperComponent.ɵfac = function FilterInputWrapperComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilterInputWrapperComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterInputWrapperComponent, contentQueries: function FilterInputWrapperComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, FilterInputDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, inputs: { operators: "operators", defaultOperator: "defaultOperator", column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
FilterInputWrapperComponent.propDecorators = {
    operators: [{ type: Input }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    input: [{ type: ContentChild, args: [FilterInputDirective,] }],
    defaultOperator: [{ type: Input }]
};


const EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];
/**
 * @hidden
 */
class FilterCellWrapperComponent extends FilterInputWrapperComponent {
    constructor(filterService) {
        super(filterService);
        this.showOperators = true;
    }
    get hostClasses() {
        return true;
    }
    get overrideBaseClasses() {
        return false;
    }
    get showButton() {
        const filter$$1 = this.currentFilter;
        return isPresent(filter$$1) && (!isNullOrEmptyString(filter$$1.value) ||
            EMPTY_FILTER_OPERATORS.indexOf(String(filter$$1.operator)) >= 0);
    }
    filterChange(filter$$1) {
        this.applyFilter(filter$$1);
    }
}
FilterCellWrapperComponent.ɵfac = function FilterCellWrapperComponent_Factory(t) { return new (t || FilterCellWrapperComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService)); };
FilterCellWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterCellWrapperComponent, selectors: [["kendo-treelist-filter-wrapper-cell"]], hostVars: 4, hostBindings: function FilterCellWrapperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell-wrapper", ctx.hostClasses)("k-filtercell", ctx.overrideBaseClasses);
    } }, inputs: { showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c109, decls: 2, vars: 4, consts: [[3, "showOperators", "operators", "showButton", "value", "clear", "valueChange"]], template: function FilterCellWrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "kendo-treelist-filter-cell-operators", 0);
        ɵngcc0.ɵɵlistener("clear", function FilterCellWrapperComponent_Template_kendo_treelist_filter_cell_operators_clear_1_listener() { return ctx.onClear(); })("valueChange", function FilterCellWrapperComponent_Template_kendo_treelist_filter_cell_operators_valueChange_1_listener($event) { return ctx.currentOperator = $event; });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("showOperators", ctx.showOperators)("operators", ctx.operators)("showButton", ctx.showButton)("value", ctx.currentOperator);
    } }, directives: function () { return [FilterCellOperatorsComponent]; }, encapsulation: 2 });
/** @nocollapse */
FilterCellWrapperComponent.ctorParameters = () => [
    { type: FilterService }
];
FilterCellWrapperComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell-wrapper',] }],
    overrideBaseClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],
    showOperators: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterCellWrapperComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-filter-wrapper-cell',
                template: `
        <ng-content></ng-content>
        <kendo-treelist-filter-cell-operators
            [showOperators]="showOperators"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-treelist-filter-cell-operators>
    `
            }]
    }], function () { return [{ type: FilterService }]; }, { showOperators: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell-wrapper']
        }], overrideBaseClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }] }); })();

// tslint:disable:no-access-missing-member
const stringOperators = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * Represents a base string filter component.
 */
class StringFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * The default filter operator. Defaults to `contains`.
         * @type {string}
         */
        this.operator = "contains";
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField((this.column || {}).field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = stringOperators(this.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
}
StringFilterComponent.ɵfac = function StringFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
StringFilterComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StringFilterComponent, inputs: { operator: "operator", column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
StringFilterComponent.propDecorators = {
    column: [{ type: Input }],
    filter: [{ type: Input }],
    operator: [{ type: Input }]
};


/**
 * Represents a string-filter cell component
 * ([see example]({% slug builtinfiltertemplate_treelist %}#toc-configuration-components-for-filter-templates)).
 *
 * @example
 *
 *  ```html-no-run
 *      <kendo-treelist-column field="ProductName" title="Product Name">
 *          <ng-template kendoTreeListFilterCellTemplate let-filter let-column="column">
 *          <kendo-treelist-string-filter-cell
 *              [showOperators]="false"
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-treelist-string-filter-cell>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class StringFilterCellComponent extends StringFilterComponent {
    constructor(filterService, localization) {
        super(filterService, localization);
        /**
         * Determines the delay time (in milliseconds) before the filter value is submitted.
         * A value of `0` indicates no delay. The default value is `500`.
         * @type {boolean}
         */
        this.filterDelay = 500;
        /**
         * Determines if the drop-down filter operators will be displayed.
         * The default value is `true`.
         * @type {boolean}
         */
        this.showOperators = true;
    }
}
StringFilterCellComponent.ɵfac = function StringFilterCellComponent_Factory(t) { return new (t || StringFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
StringFilterCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StringFilterCellComponent, selectors: [["kendo-treelist-string-filter-cell"]], inputs: { filterDelay: "filterDelay", showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 7, consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoTreeListFocusable", "", "kendoFilterInput", "", 1, "k-textbox", 3, "filterDelay", "ngModel"]], template: function StringFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "input", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("filterDelay", ctx.filterDelay)("ngModel", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterCellWrapperComponent, ɵngcc7.DefaultValueAccessor, FocusableDirective,
        FilterInputDirective, ɵngcc7.NgControlStatus, ɵngcc7.NgModel], encapsulation: 2 });
/** @nocollapse */
StringFilterCellComponent.ctorParameters = () => [
    { type: FilterService },
    { type: LocalizationService }
];
StringFilterCellComponent.propDecorators = {
    filterDelay: [{ type: Input }],
    showOperators: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StringFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-string-filter-cell',
                template: `
        <kendo-treelist-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <input
                class="k-textbox"
                kendoTreeListFocusable
                kendoFilterInput
                [filterDelay]="filterDelay"
                [ngModel]="currentFilter?.value" />
        </kendo-treelist-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc2.LocalizationService }]; }, { filterDelay: [{
            type: Input
        }], showOperators: [{
            type: Input
        }] }); })();

/**
 * Represents a component which accommodates the filter operators.
 */
class FilterCellOperatorsComponent {
    constructor(localization) {
        this.localization = localization;
        this.clearText = 'Clear';
        /**
         * The filter operators that will be displayed.
         */
        this.operators = [];
        /**
         * Determines if the list of operators will be displayed.
         * @type {boolean}
         */
        this.showOperators = true;
        /**
         * Fires when the operator is selected.
         * @type {EventEmitter<string>}
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires when the **Clear** button is clicked.
         * @type {EventEmitter<{}>}
         */
        this.clear = new EventEmitter();
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    /**
     * @hidden
     */
    onChange(dataItem) {
        this.valueChange.emit(dataItem);
    }
    /**
     * @hidden
     */
    clearClick() {
        this.clear.emit();
        return false;
    }
    /**
     * @hidden
     */
    clearKeydown(args) {
        if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {
            this.clear.emit();
        }
    }
    /**
     * @hidden
     */
    dropdownKeydown(args) {
        if (args.defaultPrevented) {
            return;
        }
        if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {
            this.dropdown.toggle(true);
            args.preventDefault();
        }
    }
    ngOnInit() {
        this.localization.changes.subscribe(() => this.clearText = this.localization.get("filterClearButton"));
    }
}
FilterCellOperatorsComponent.ɵfac = function FilterCellOperatorsComponent_Factory(t) { return new (t || FilterCellOperatorsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
FilterCellOperatorsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterCellOperatorsComponent, selectors: [["kendo-treelist-filter-cell-operators"]], viewQuery: function FilterCellOperatorsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c110, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);
    } }, hostVars: 2, hostBindings: function FilterCellOperatorsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell-operator", ctx.hostClasses);
    } }, inputs: { operators: "operators", showOperators: "showOperators", showButton: "showButton", value: "value" }, outputs: { valueChange: "valueChange", clear: "clear" }, decls: 3, vars: 5, consts: [["kendoTreeListFocusable", "", "class", "k-dropdown-operator", "iconClass", "k-i-filter", "textField", "text", "valueField", "value", 3, "data", "value", "valuePrimitive", "popupSettings", "valueChange", "keydown", 4, "ngIf"], ["type", "button", "kendoTreeListFocusable", "", 1, "k-button", "k-button-icon", 3, "ngClass", "title", "click", "keydown"], [1, "k-icon", "k-i-filter-clear"], ["kendoTreeListFocusable", "", "iconClass", "k-i-filter", "textField", "text", "valueField", "value", 1, "k-dropdown-operator", 3, "data", "value", "valuePrimitive", "popupSettings", "valueChange", "keydown"], ["dropdown", ""]], template: function FilterCellOperatorsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, FilterCellOperatorsComponent_kendo_dropdownlist_0_Template, 2, 5, "kendo-dropdownlist", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function FilterCellOperatorsComponent_Template_button_click_1_listener() { return ctx.clearClick(); })("keydown", function FilterCellOperatorsComponent_Template_button_keydown_1_listener($event) { return ctx.clearKeydown($event); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c112, ctx.showButton))("title", ctx.clearText);
    } }, directives: [ɵngcc4.NgIf, FocusableDirective, ɵngcc4.NgClass, ɵngcc8.DropDownListComponent], encapsulation: 2 });
/** @nocollapse */
FilterCellOperatorsComponent.ctorParameters = () => [
    { type: LocalizationService }
];
FilterCellOperatorsComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell-operator',] }],
    dropdown: [{ type: ViewChild, args: ['dropdown',] }],
    operators: [{ type: Input }],
    showButton: [{ type: Input }],
    showOperators: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    clear: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterCellOperatorsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-filter-cell-operators',
                template: `
        <kendo-dropdownlist
            #dropdown
            *ngIf="showOperators"
            kendoTreeListFocusable
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            iconClass="k-i-filter"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            (keydown)="dropdownKeydown($event)">
        </kendo-dropdownlist>
        <button type="button"
            kendoTreeListFocusable
            [ngClass]="{'k-clear-button-visible': showButton}"
            class="k-button k-button-icon"
            [title]="clearText"
            (click)="clearClick()"
            (keydown)="clearKeydown($event)">
                <span class="k-icon k-i-filter-clear"></span>
        </button>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { operators: [{
            type: Input
        }], showOperators: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], clear: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell-operator']
        }], dropdown: [{
            type: ViewChild,
            args: ['dropdown']
        }], showButton: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();

// tslint:disable:no-access-missing-member
const stringOperators$1 = localizeOperators$1({
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * @hidden
 */
class AutoCompleteFilterCellComponent extends BaseFilterCellComponent {
    constructor(filterService, column, localization) {
        super(filterService);
        this.localization = localization;
        this.showOperators = true;
        this.defaultOperators = stringOperators$1(this.localization);
        this.column = column;
    }
    set valueField(value) {
        this._valueField = value;
    }
    get valueField() {
        return this._valueField ? this._valueField : this.column.field;
    }
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : "contains";
    }
}
AutoCompleteFilterCellComponent.ɵfac = function AutoCompleteFilterCellComponent_Factory(t) { return new (t || AutoCompleteFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ColumnComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
AutoCompleteFilterCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AutoCompleteFilterCellComponent, selectors: [["kendo-treelist-autocomplete-filter-cell"]], inputs: { showOperators: "showOperators", column: "column", valueField: "valueField", filter: "filter", data: "data" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 7, consts: [[3, "column", "filter", "operators", "showOperators"], ["kendoFilterInput", "", 3, "data", "valueField", "value"]], template: function AutoCompleteFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "kendo-autocomplete", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.data)("valueField", ctx.valueField)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterCellWrapperComponent, ɵngcc8.AutoCompleteComponent, FilterInputDirective], encapsulation: 2 });
/** @nocollapse */
AutoCompleteFilterCellComponent.ctorParameters = () => [
    { type: FilterService },
    { type: ColumnComponent },
    { type: LocalizationService }
];
AutoCompleteFilterCellComponent.propDecorators = {
    showOperators: [{ type: Input }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    data: [{ type: Input }],
    valueField: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AutoCompleteFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-autocomplete-filter-cell',
                template: `
        <kendo-treelist-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-treelist-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ColumnComponent }, { type: ɵngcc2.LocalizationService }]; }, { showOperators: [{
            type: Input
        }], column: [{
            type: Input
        }], valueField: [{
            type: Input
        }], filter: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();

// tslint:disable:no-access-missing-member
/**
 * @hidden
 */
class BooleanFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * @hidden
         */
        this.operator = "eq";
        /**
         * @hidden
         */
        this.items = [
            { text: this.localization.get("filterIsTrue"), value: true },
            { text: this.localization.get("filterIsFalse"), value: false }
        ];
        /**
         * @hidden
         */
        this.defaultItem = { text: this.localization.get("filterBooleanAll"), value: null };
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.items = [
            { text: this.localization.get("filterIsTrue"), value: true },
            { text: this.localization.get("filterIsFalse"), value: false }
        ];
        this.defaultItem = { text: this.localization.get("filterBooleanAll"), value: null };
    }
}
BooleanFilterComponent.ɵfac = function BooleanFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BooleanFilterComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BooleanFilterComponent, hostVars: 2, hostBindings: function BooleanFilterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell-boolean", ctx.hostClasses);
    } }, inputs: { column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
BooleanFilterComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell-boolean',] }],
    column: [{ type: Input }],
    filter: [{ type: Input }]
};


/**
 * Represents a Boolean filter-cell component.
 *
 * @example
 *
 *  ```html-no-run
 *      <kendo-treelist-column field="ProductName" title="Product Name">
 *          <ng-template kendoTreeListFilterCellTemplate let-filter let-column="column">
 *          <kendo-treelist-boolean-filter-cell
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-treelist-boolean-filter-cell>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class BooleanFilterCellComponent extends BooleanFilterComponent {
    constructor(filterService, localization, cd) {
        super(filterService, localization);
        this.cd = cd;
    }
    localizationChange() {
        super.localizationChange();
        this.cd.markForCheck();
    }
}
BooleanFilterCellComponent.ɵfac = function BooleanFilterCellComponent_Factory(t) { return new (t || BooleanFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
BooleanFilterCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BooleanFilterCellComponent, selectors: [["kendo-treelist-boolean-filter-cell"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 10, consts: [[3, "column", "filter", "showOperators", "defaultOperator"], ["kendoFilterInput", "", "textField", "text", "valueField", "value", 3, "defaultItem", "data", "popupSettings", "valuePrimitive", "value"]], template: function BooleanFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("showOperators", false)("defaultOperator", ctx.operator);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("defaultItem", ctx.defaultItem)("data", ctx.items)("popupSettings", ɵngcc0.ɵɵpureFunction0(9, _c111))("valuePrimitive", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterCellWrapperComponent, ɵngcc8.DropDownListComponent, FilterInputDirective], encapsulation: 2 });
/** @nocollapse */
BooleanFilterCellComponent.ctorParameters = () => [
    { type: FilterService },
    { type: LocalizationService },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BooleanFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-boolean-filter-cell',
                template: `
        <kendo-treelist-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-treelist-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

// tslint:disable:no-access-missing-member
const dateOperators = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    // tslint:disable-next-line:object-literal-sort-keys
    "filterAfterOrEqualOperator": "gte",
    "filterAfterOperator": "gt",
    "filterBeforeOrEqualOperator": "lte",
    "filterBeforeOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * @hidden
 */
class DateFilterComponent extends BaseFilterCellComponent {
    constructor(filterService, localization) {
        super(filterService);
        this.localization = localization;
        /**
         * The default filter operator. Defaults to `contains`.
         * @type {string}
         */
        this.operator = "gte";
        /**
         * Defines the active view that the calendar initially renders.
         * By default, the active view is `month`.
         *
         * > You have to set `activeView` within the `topView`-`bottomView` range.
         */
        this.activeView = "month";
        /**
         * Defines the bottommost calendar view, to which the user can navigate.
         */
        this.bottomView = "month";
        /**
         * Defines the topmost calendar view, to which the user can navigate.
         */
        this.topView = "century";
        /**
         * Determines whether to display a week number column in the `month` view of the Calendar.
         */
        this.weekNumber = false;
        this.defaultOperators = dateOperators(this.localization);
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * Specifies the date format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    set format(value) {
        this._format = value;
    }
    /**
     * Specifies the date format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     *
     * @readonly
     * @type {string}
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "d";
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    ngOnInit() {
        this.subscription = this.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = dateOperators(this.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
}
DateFilterComponent.ɵfac = function DateFilterComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
DateFilterComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DateFilterComponent, inputs: { operator: "operator", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber", format: "format", column: "column", filter: "filter", min: "min", max: "max", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
DateFilterComponent.propDecorators = {
    column: [{ type: Input }],
    filter: [{ type: Input }],
    operator: [{ type: Input }],
    format: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    formatPlaceholder: [{ type: Input }],
    placeholder: [{ type: Input }],
    activeView: [{ type: Input }],
    bottomView: [{ type: Input }],
    topView: [{ type: Input }],
    weekNumber: [{ type: Input }]
};


/**
 * Represents a date-filter cell component.
 *
 * @example
 *
 *  ```html-no-run
 *      <kendo-treelist-column field="OrderDate" title="Order Date">
 *          <ng-template kendoTreeListFilterCellTemplate let-filter let-column="column">
 *          <kendo-treelist-date-filter-cell
 *              [showOperators]="false"
 *              [column]="column"
 *              [filter]="filter">
 *          </kendo-treelist-date-filter-cell>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class DateFilterCellComponent extends DateFilterComponent {
    constructor(filterService, localization) {
        super(filterService, localization);
        this.localization = localization;
        /**
         * Determines if the drop-down filter operators will be displayed. The default value is `true`.
         * @type {boolean}
         */
        this.showOperators = true;
    }
}
DateFilterCellComponent.ɵfac = function DateFilterCellComponent_Factory(t) { return new (t || DateFilterCellComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
DateFilterCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DateFilterCellComponent, selectors: [["kendo-treelist-date-filter-cell"]], inputs: { showOperators: "showOperators" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 15, consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoFilterInput", "", 3, "value", "format", "formatPlaceholder", "placeholder", "activeView", "bottomView", "topView", "min", "max", "weekNumber"]], template: function DateFilterCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-wrapper-cell", 0);
        ɵngcc0.ɵɵelement(1, "kendo-datepicker", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber);
    } }, directives: [FilterCellWrapperComponent, ɵngcc9.DatePickerComponent, FilterInputDirective], encapsulation: 2 });
/** @nocollapse */
DateFilterCellComponent.ctorParameters = () => [
    { type: FilterService },
    { type: LocalizationService }
];
DateFilterCellComponent.propDecorators = {
    showOperators: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateFilterCellComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-date-filter-cell',
                template: `
        <kendo-treelist-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
            >
            <kendo-datepicker
                kendoFilterInput
                [value]="currentFilter?.value"
                [format]="format"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber"
                >
            </kendo-datepicker>
        </kendo-treelist-filter-wrapper-cell>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: ɵngcc2.LocalizationService }]; }, { showOperators: [{
            type: Input
        }] }); })();

/**
 * Represents the checkbox for selecting rows in the TreeList.
 */
class CheckboxColumnComponent extends ColumnBase$1 {
    constructor(parent) {
        super(parent);
        this.parent = parent;
        /*
         * @hidden
         */
        this.isCheckboxColumn = true;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
}
CheckboxColumnComponent.ɵfac = function CheckboxColumnComponent_Factory(t) { return new (t || CheckboxColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13)); };
CheckboxColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CheckboxColumnComponent, selectors: [["kendo-treelist-checkbox-column"]], contentQueries: function CheckboxColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, inputs: { showSelectAll: "showSelectAll", checkChildren: "checkChildren", expandable: "expandable" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => CheckboxColumnComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CheckboxColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
CheckboxColumnComponent.ctorParameters = () => [
    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
CheckboxColumnComponent.propDecorators = {
    showSelectAll: [{ type: Input }],
    checkChildren: [{ type: Input }],
    expandable: [{ type: Input }],
    template: [{ type: ContentChild, args: [CellTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckboxColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => CheckboxColumnComponent)
                    }
                ],
                selector: 'kendo-treelist-checkbox-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, { showSelectAll: [{
            type: Input
        }], checkChildren: [{
            type: Input
        }], expandable: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [CellTemplateDirective]
        }] }); })();

/**
 * @hidden
 */
class ColGroupComponent {
    constructor() {
        this.columns = [];
    }
    get columnsToRender() {
        return columnsToRender(this.columns);
    }
    trackBy(index, _item) {
        return index;
    }
}
ColGroupComponent.ɵfac = function ColGroupComponent_Factory(t) { return new (t || ColGroupComponent)(); };
ColGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColGroupComponent, selectors: [["", "kendoTreeListColGroup", ""]], inputs: { columns: "columns" }, attrs: _c113, decls: 1, vars: 2, consts: [[3, "width", 4, "ngFor", "ngForOf", "ngForTrackBy"]], template: function ColGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ColGroupComponent_col_0_Template, 1, 2, "col", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columnsToRender)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc4.NgForOf], encapsulation: 2 });
ColGroupComponent.propDecorators = {
    columns: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColGroupComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListColGroup]',
                template: `
        <col *ngFor="let column of columnsToRender; trackBy: trackBy;" [style.width.px]="column.width"/>
    `
            }]
    }], function () { return []; }, { columns: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class LoadingComponent {
    constructor(localization) {
        this.localization = localization;
        this.hostClass = true;
    }
    get loadingText() {
        return this.localization.get('loading');
    }
}
LoadingComponent.ɵfac = function LoadingComponent_Factory(t) { return new (t || LoadingComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LoadingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LoadingComponent, selectors: [["", "kendoTreeListLoading", ""]], hostVars: 2, hostBindings: function LoadingComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-loading-mask", ctx.hostClass);
    } }, attrs: _c114, decls: 4, vars: 1, consts: [[1, "k-loading-text"], [1, "k-loading-image"], [1, "k-loading-color"]], template: function LoadingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "div", 1);
        ɵngcc0.ɵɵelement(3, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.loadingText);
    } }, encapsulation: 2 });
/** @nocollapse */
LoadingComponent.ctorParameters = () => [
    { type: LocalizationService }
];
LoadingComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-loading-mask',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadingComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListLoading]',
                template: `
        <span class="k-loading-text">{{ loadingText }}</span>
        <div class="k-loading-image"></div>
        <div class="k-loading-color"></div>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-loading-mask']
        }] }); })();

/**
 * @hidden
 */
class ResizableContainerDirective {
    constructor(el, renderer, resizeService, treelist) {
        this.el = el;
        this.renderer = renderer;
        this.resizeService = resizeService;
        this.treelist = treelist;
        this.enabled = false;
    }
    set lockedWidth(value) {
        this._lockedWidth = value;
        if (this.enabled) {
            this.attachResize();
            this.resize();
        }
    }
    set kendoTreeListResizableContainer(enabled) {
        const refresh = enabled !== this.enabled;
        this.enabled = enabled;
        if (refresh) {
            this.attachResize();
            this.resize();
        }
    }
    ngOnDestroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    attachResize() {
        if (this.resizeSubscription && !this.enabled) {
            this.resizeSubscription.unsubscribe();
            this.resizeSubscription = null;
        }
        if (!this.resizeSubscription && this.enabled) {
            this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
        }
    }
    resize() {
        if (this.treelist && this.treelist.wrapper) {
            const containerElement = this.treelist.wrapper.nativeElement;
            const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
            if (this.enabled && width > 0) {
                this.renderer.setStyle(this.el.nativeElement, "width", width + "px");
            }
            else {
                this.renderer.setStyle(this.el.nativeElement, "width", "");
            }
        }
    }
}
ResizableContainerDirective.ɵfac = function ResizableContainerDirective_Factory(t) { return new (t || ResizableContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(TreeListComponent, 8)); };
ResizableContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ResizableContainerDirective, selectors: [["", "kendoTreeListResizableContainer", ""]], inputs: { lockedWidth: "lockedWidth", kendoTreeListResizableContainer: "kendoTreeListResizableContainer" } });
/** @nocollapse */
ResizableContainerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ResizeService },
    { type: TreeListComponent, decorators: [{ type: Optional }] }
];
ResizableContainerDirective.propDecorators = {
    lockedWidth: [{ type: Input, args: ['lockedWidth',] }],
    kendoTreeListResizableContainer: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizableContainerDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListResizableContainer]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ResizeService }, { type: TreeListComponent, decorators: [{
                type: Optional
            }] }]; }, { lockedWidth: [{
            type: Input,
            args: ['lockedWidth']
        }], kendoTreeListResizableContainer: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class TemplateContextDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    set templateContext(context) {
        this.removeView();
        if (context.templateRef) {
            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
        }
    }
    ngOnDestroy() {
        this.removeView();
    }
    removeView() {
        if (this.insertedViewRef) {
            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
            this.insertedViewRef = undefined;
        }
    }
}
TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) { return new (t || TemplateContextDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
TemplateContextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TemplateContextDirective, selectors: [["", "templateContext", ""]], inputs: { templateContext: "templateContext" } });
/** @nocollapse */
TemplateContextDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
TemplateContextDirective.propDecorators = {
    templateContext: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateContextDirective, [{
        type: Directive,
        args: [{
                selector: '[templateContext]' // tslint:disable-line:directive-selector
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { templateContext: [{
            type: Input
        }] }); })();

let id = 0;
function nextId() {
    return id++;
}
/**
 * @hidden
 */
class LogicalCellDirective {
    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone) {
        this.focusGroup = focusGroup;
        this.element = element;
        this.columnInfoService = columnInfoService;
        this.idService = idService;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.zone = zone;
        this.logicalSlaveCell = false;
        this.colSpan = 1;
        this.rowSpan = 1;
        this.dataRowIndex = -1;
        this.expandable = false;
        this.uid = nextId();
    }
    get id() {
        if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
            return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
        }
    }
    get ariaColIndex() {
        if (this.logicalSlaveCell || this.logicalColIndex === -1) {
            return undefined;
        }
        return this.logicalColIndex + 1;
    }
    ngOnInit() {
        if (!this.navigationService.enabled) {
            return;
        }
        this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
    }
    ngDoCheck() {
        if (!this.navigationService.enabled || this.logicalColIndex === -1) {
            return;
        }
        this.registerNoChanges();
    }
    ngOnChanges(changes) {
        if (!this.navigationService.enabled) {
            return;
        }
        if (this.logicalColIndex === -1) {
            return;
        }
        const indexChange = changes.logicalColIndex;
        const rowIndexChange = changes.logicalRowIndex;
        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
        const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
        this.navigationService.unregisterCell(index, rowIndex, this);
        this.registerChanges();
        this.updateElement();
    }
    ngOnDestroy() {
        if (this.navigationChange) {
            this.navigationChange.unsubscribe();
        }
        this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
    }
    onNavigationChange(e) {
        const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
        const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
        if (active || wasActive) {
            this.updateElement();
        }
    }
    updateElement() {
        const el = this.element.nativeElement;
        this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');
        if (this.isFocused()) {
            if (this.focusGroup.isNavigable()) {
                this.focusGroup.focus();
            }
            else {
                if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
                    this.microtask(() => this.isFocused() && el.focus());
                }
                this.renderer.addClass(el, 'k-state-focused');
            }
        }
        else {
            this.renderer.removeClass(el, 'k-state-focused');
        }
    }
    microtask(callback) {
        this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
    }
    registerChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCell(this);
        }
    }
    registerNoChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCellOnCurrentRow(this);
        }
    }
    isFocusable() {
        return this.navigationService.isCellFocusable(this);
    }
    isFocused() {
        return this.navigationService.isCellFocused(this);
    }
}
LogicalCellDirective.ɵfac = function LogicalCellDirective_Factory(t) { return new (t || LogicalCellDirective)(ɵngcc0.ɵɵdirectiveInject(FocusGroup), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(IdService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
LogicalCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LogicalCellDirective, selectors: [["", "kendoTreeListLogicalCell", ""]], hostVars: 2, hostBindings: function LogicalCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("aria-colindex", ctx.ariaColIndex);
    } }, inputs: { logicalSlaveCell: "logicalSlaveCell", colSpan: "colSpan", rowSpan: "rowSpan", dataRowIndex: "dataRowIndex", expandable: "expandable", logicalColIndex: "logicalColIndex", logicalRowIndex: "logicalRowIndex", column: "column", colIndex: "colIndex", dataItem: "dataItem" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: FocusGroup,
                deps: [FocusRoot],
                useClass: FocusGroup
            }]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
LogicalCellDirective.ctorParameters = () => [
    { type: FocusGroup },
    { type: ElementRef },
    { type: ColumnInfoService },
    { type: IdService },
    { type: NavigationService },
    { type: Renderer2 },
    { type: NgZone }
];
LogicalCellDirective.propDecorators = {
    logicalColIndex: [{ type: Input }],
    logicalRowIndex: [{ type: Input }],
    logicalSlaveCell: [{ type: Input }],
    column: [{ type: Input }],
    colIndex: [{ type: Input }],
    colSpan: [{ type: Input }],
    rowSpan: [{ type: Input }],
    dataRowIndex: [{ type: Input }],
    dataItem: [{ type: Input }],
    expandable: [{ type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }],
    ariaColIndex: [{ type: HostBinding, args: ['attr.aria-colindex',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LogicalCellDirective, [{
        type: Directive,
        args: [{
                providers: [{
                        provide: FocusGroup,
                        deps: [FocusRoot],
                        useClass: FocusGroup
                    }],
                selector: '[kendoTreeListLogicalCell]'
            }]
    }], function () { return [{ type: FocusGroup }, { type: ɵngcc0.ElementRef }, { type: ColumnInfoService }, { type: IdService }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { logicalSlaveCell: [{
            type: Input
        }], colSpan: [{
            type: Input
        }], rowSpan: [{
            type: Input
        }], dataRowIndex: [{
            type: Input
        }], expandable: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }], ariaColIndex: [{
            type: HostBinding,
            args: ['attr.aria-colindex']
        }], logicalColIndex: [{
            type: Input
        }], logicalRowIndex: [{
            type: Input
        }], column: [{
            type: Input
        }], colIndex: [{
            type: Input
        }], dataItem: [{
            type: Input
        }] }); })();

let id$1 = 0;
function nextId$1() {
    return id$1++;
}
/**
 * @hidden
 */
class LogicalRowDirective {
    constructor(idService, navigation) {
        this.idService = idService;
        this.navigation = navigation;
        this.logicalSlaveRow = false;
        this.logicalSlaveCellsCount = 0;
        this.dataRowIndex = -1;
        this.isNew = false;
        this.uid = nextId$1();
    }
    get hostRole() {
        return this.logicalSlaveRow ? 'presentation' : 'row';
    }
    get ariaRowIndex() {
        if (this.navigation.enabled) {
            return this.logicalRowIndex + 1;
        }
    }
    get ariaOwns() {
        if (!this.navigation.enabled || this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
            return undefined;
        }
        const ids = [];
        const total = this.logicalCellsCount + this.logicalSlaveCellsCount;
        for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
            ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
        }
        return ids.join(' ');
    }
    ngOnChanges(changes) {
        if (!this.navigation.enabled || this.logicalSlaveRow) {
            return;
        }
        const indexChange = changes.logicalRowIndex;
        const logicalSlaveRowChange = changes.logicalSlaveRow;
        const isNewChange = changes.isNew;
        if (indexChange || logicalSlaveRowChange || isNewChange) {
            const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
            this.navigation.unregisterRow(index, this);
            this.navigation.registerRow(this);
        }
        else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {
            this.navigation.updateRow(this);
        }
    }
    ngOnDestroy() {
        this.navigation.unregisterRow(this.logicalRowIndex, this);
    }
}
LogicalRowDirective.ɵfac = function LogicalRowDirective_Factory(t) { return new (t || LogicalRowDirective)(ɵngcc0.ɵɵdirectiveInject(IdService), ɵngcc0.ɵɵdirectiveInject(NavigationService)); };
LogicalRowDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LogicalRowDirective, selectors: [["", "kendoTreeListLogicalRow", ""]], hostVars: 3, hostBindings: function LogicalRowDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole)("aria-rowindex", ctx.ariaRowIndex)("aria-owns", ctx.ariaOwns);
    } }, inputs: { logicalSlaveRow: "logicalSlaveRow", logicalSlaveCellsCount: "logicalSlaveCellsCount", dataRowIndex: "dataRowIndex", isNew: "isNew", logicalRowIndex: "logicalRowIndex", logicalCellsCount: "logicalCellsCount", dataItem: "dataItem" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
LogicalRowDirective.ctorParameters = () => [
    { type: IdService },
    { type: NavigationService }
];
LogicalRowDirective.propDecorators = {
    logicalRowIndex: [{ type: Input }],
    logicalSlaveRow: [{ type: Input }],
    logicalCellsCount: [{ type: Input }],
    logicalSlaveCellsCount: [{ type: Input }],
    dataRowIndex: [{ type: Input }],
    dataItem: [{ type: Input }],
    isNew: [{ type: Input }],
    hostRole: [{ type: HostBinding, args: ['attr.role',] }],
    ariaRowIndex: [{ type: HostBinding, args: ['attr.aria-rowindex',] }],
    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LogicalRowDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListLogicalRow]'
            }]
    }], function () { return [{ type: IdService }, { type: NavigationService }]; }, { logicalSlaveRow: [{
            type: Input
        }], logicalSlaveCellsCount: [{
            type: Input
        }], dataRowIndex: [{
            type: Input
        }], isNew: [{
            type: Input
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaRowIndex: [{
            type: HostBinding,
            args: ['attr.aria-rowindex']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], logicalRowIndex: [{
            type: Input
        }], logicalCellsCount: [{
            type: Input
        }], dataItem: [{
            type: Input
        }] }); })();

/* tslint:disable:pipe-naming */
const FORMAT_REGEX = /\{\d+:?/;
/**
 * @hidden
 */
class FieldAccessorPipe {
    constructor(intlService) {
        this.intlService = intlService;
    }
    transform(dataItem, fieldName, format) {
        if (!isNullOrEmptyString(fieldName)) {
            const value = getter(fieldName)(dataItem);
            if (!isNullOrEmptyString(format)) {
                return this.formatValue(format, value);
            }
            return value;
        }
        return dataItem;
    }
    formatValue(format, value) {
        const intl = this.intlService;
        if (isString(format) && format.match(FORMAT_REGEX)) {
            return intl.format(format, value);
        }
        return intl.toString(value, format);
    }
}
FieldAccessorPipe.ɵfac = function FieldAccessorPipe_Factory(t) { return new (t || FieldAccessorPipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc10.IntlService)); };
FieldAccessorPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "valueOf", type: FieldAccessorPipe, pure: false });
/** @nocollapse */
FieldAccessorPipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FieldAccessorPipe, [{
        type: Pipe,
        args: [{
                name: 'valueOf',
                pure: false
            }]
    }], function () { return [{ type: ɵngcc10.IntlService }]; }, null); })();

/**
 * @hidden
 */
const columnsToResize = ({ columns }) => Math.max(1, resizableColumns(columns).length);
/**
 * @hidden
 */
const row = selector => element => element.querySelector(selector);
/**
 * @hidden
 */
const headerRow = index => element => element.querySelectorAll('thead>tr')[index];
/**
 * @hidden
 */
const cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
/**
 * @hidden
 */
const offsetWidth = element => element.offsetWidth;
/**
 * @hidden
 */
const pipe = (...fns) => data => fns.reduce((state$$1, fn) => state$$1 ? fn(state$$1) : 0, data);
/**
 * @hidden
 */
class TableDirective {
    constructor(element, renderer, service, zone, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.locked = false;
        this.firstResize = false;
    }
    get minWidth() {
        return this.firstResize ? 0 : null;
    }
    ngOnInit() {
        const obs = this.service
            .changes.pipe(filter(e => this.locked === e.locked));
        this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take$$1) => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take$$1)))).subscribe(this.resize.bind(this));
        this.autoFitSubscription = this.service
            .registerTable({
            autoFit: this.autoFitObservable.bind(this),
            locked: this.locked
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.autoFitSubscription) {
            this.autoFitSubscription();
            this.autoFitSubscription = null;
        }
    }
    initState() {
        this.firstResize = true;
        if (!this.virtualColumns || this.locked) {
            this.originalWidth = offsetWidth(this.element.nativeElement);
        }
    }
    resize(deltas) {
        if (!this.virtualColumns || this.locked) {
            const delta = deltas.reduce((sum, item) => sum + item, 0);
            const width = this.originalWidth + delta;
            this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');
        }
        this.cdr.detectChanges();
    }
    autoFitObservable(columnInfo) {
        return Observable.create(observer => {
            this.zone.runOutsideAngular(() => {
                this.renderer.addClass(this.element.nativeElement, 'k-autofitting');
                this.cdr.detectChanges();
                const widths = columnInfo.map(this.measureColumn.bind(this));
                this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');
                observer.next(widths);
            });
        });
    }
    measureColumn(info) {
        const dom = this.element.nativeElement;
        const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);
        let data = 0;
        if (!info.isParentSpan || (info.isParentSpan && info.isLastInSpan)) {
            data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);
        }
        return Math.max(header, data);
    }
}
TableDirective.ɵfac = function TableDirective_Factory(t) { return new (t || TableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
TableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TableDirective, selectors: [["table"]], hostVars: 2, hostBindings: function TableDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("min-width", ctx.minWidth);
    } }, inputs: { locked: "locked", virtualColumns: "virtualColumns" } });
/** @nocollapse */
TableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColumnResizingService },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
TableDirective.propDecorators = {
    locked: [{ type: Input }],
    virtualColumns: [{ type: Input }],
    minWidth: [{ type: HostBinding, args: ['style.min-width',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TableDirective, [{
        type: Directive,
        args: [{
                selector: 'table' // tslint:disable-line:directive-selector
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ColumnResizingService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { locked: [{
            type: Input
        }], minWidth: [{
            type: HostBinding,
            args: ['style.min-width']
        }], virtualColumns: [{
            type: Input
        }] }); })();

const exportedModules = [
    ColumnComponent,
    ColumnGroupComponent,
    LogicalCellDirective,
    LogicalRowDirective,
    FocusableDirective,
    ColGroupComponent,
    ResizableContainerDirective,
    TemplateContextDirective,
    FieldAccessorPipe,
    SpanColumnComponent,
    TableDirective,
    LoadingComponent,
    CheckboxColumnComponent
];
/**
 * @hidden
 */
class SharedModule {
    static exports() {
        return [
            ColumnComponent,
            SpanColumnComponent,
            CheckboxColumnComponent,
            ColumnGroupComponent,
            FocusableDirective
        ];
    }
}
SharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SharedModule_Factory(t) { return new (t || SharedModule)(); }, imports: [[CommonModule],
        DraggableModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [ColumnComponent,
        ColumnGroupComponent,
        LogicalCellDirective,
        LogicalRowDirective,
        FocusableDirective,
        ColGroupComponent,
        ResizableContainerDirective,
        TemplateContextDirective,
        FieldAccessorPipe,
        SpanColumnComponent,
        TableDirective,
        LoadingComponent,
        CheckboxColumnComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ColumnComponent,
        ColumnGroupComponent,
        LogicalCellDirective,
        LogicalRowDirective,
        FocusableDirective,
        ColGroupComponent,
        ResizableContainerDirective,
        TemplateContextDirective,
        FieldAccessorPipe,
        SpanColumnComponent,
        TableDirective,
        LoadingComponent,
        CheckboxColumnComponent,
        DraggableModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [exportedModules],
                exports: [exportedModules, DraggableModule],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Represents the `Contains` (**Contains**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class ContainsFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("contains", localization); }
}
ContainsFilterOperatorComponent.ɵfac = function ContainsFilterOperatorComponent_Factory(t) { return new (t || ContainsFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
ContainsFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContainsFilterOperatorComponent, selectors: [["kendo-filter-contains-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => ContainsFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ContainsFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ContainsFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContainsFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => ContainsFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-contains-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `DoesNotContain` (**Does not contain**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class DoesNotContainFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("doesnotcontain", localization); }
}
DoesNotContainFilterOperatorComponent.ɵfac = function DoesNotContainFilterOperatorComponent_Factory(t) { return new (t || DoesNotContainFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
DoesNotContainFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DoesNotContainFilterOperatorComponent, selectors: [["kendo-filter-not-contains-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function DoesNotContainFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
DoesNotContainFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DoesNotContainFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-not-contains-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `EndsWith` (**Ends with**) string filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class EndsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("endswith", localization); }
}
EndsWithFilterOperatorComponent.ɵfac = function EndsWithFilterOperatorComponent_Factory(t) { return new (t || EndsWithFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
EndsWithFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EndsWithFilterOperatorComponent, selectors: [["kendo-filter-endswith-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function EndsWithFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
EndsWithFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EndsWithFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-endswith-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `Equal` (**Is equal to**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class EqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("eq", localization); }
}
EqualFilterOperatorComponent.ɵfac = function EqualFilterOperatorComponent_Factory(t) { return new (t || EqualFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
EqualFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EqualFilterOperatorComponent, selectors: [["kendo-filter-eq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EqualFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function EqualFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
EqualFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EqualFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => EqualFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-eq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `IsEmpty` (**Is empty**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class IsEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isempty", localization); }
}
IsEmptyFilterOperatorComponent.ɵfac = function IsEmptyFilterOperatorComponent_Factory(t) { return new (t || IsEmptyFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
IsEmptyFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IsEmptyFilterOperatorComponent, selectors: [["kendo-filter-isempty-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsEmptyFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
IsEmptyFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsEmptyFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-isempty-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `IsNotEmpty` (**Is not empty**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isnotempty", localization); }
}
IsNotEmptyFilterOperatorComponent.ɵfac = function IsNotEmptyFilterOperatorComponent_Factory(t) { return new (t || IsNotEmptyFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
IsNotEmptyFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IsNotEmptyFilterOperatorComponent, selectors: [["kendo-filter-isnotempty-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsNotEmptyFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
IsNotEmptyFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsNotEmptyFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-isnotempty-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `IsNotNull` (**Is not null**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class IsNotNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isnotnull", localization); }
}
IsNotNullFilterOperatorComponent.ɵfac = function IsNotNullFilterOperatorComponent_Factory(t) { return new (t || IsNotNullFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
IsNotNullFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IsNotNullFilterOperatorComponent, selectors: [["kendo-filter-isnotnull-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsNotNullFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
IsNotNullFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsNotNullFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-isnotnull-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `IsNull` (**Is null**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class IsNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("isnull", localization); }
}
IsNullFilterOperatorComponent.ɵfac = function IsNullFilterOperatorComponent_Factory(t) { return new (t || IsNullFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
IsNullFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IsNullFilterOperatorComponent, selectors: [["kendo-filter-isnull-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNullFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IsNullFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
IsNullFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsNullFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => IsNullFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-isnull-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `NotEqual` (**Is not equal to**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class NotEqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("neq", localization); }
}
NotEqualFilterOperatorComponent.ɵfac = function NotEqualFilterOperatorComponent_Factory(t) { return new (t || NotEqualFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
NotEqualFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NotEqualFilterOperatorComponent, selectors: [["kendo-filter-neq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NotEqualFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
NotEqualFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NotEqualFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-neq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `StartsWith` (**Starts with**) filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class StartsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("startswith", localization); }
}
StartsWithFilterOperatorComponent.ɵfac = function StartsWithFilterOperatorComponent_Factory(t) { return new (t || StartsWithFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
StartsWithFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StartsWithFilterOperatorComponent, selectors: [["kendo-filter-startswith-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function StartsWithFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
StartsWithFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StartsWithFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-startswith-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `Greater` (**Is greater than**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class GreaterFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("gt", localization); }
}
GreaterFilterOperatorComponent.ɵfac = function GreaterFilterOperatorComponent_Factory(t) { return new (t || GreaterFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
GreaterFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GreaterFilterOperatorComponent, selectors: [["kendo-filter-gt-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function GreaterFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
GreaterFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GreaterFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => GreaterFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-gt-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/**
 * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("gte", localization); }
}
GreaterOrEqualToFilterOperatorComponent.ɵfac = function GreaterOrEqualToFilterOperatorComponent_Factory(t) { return new (t || GreaterOrEqualToFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
GreaterOrEqualToFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GreaterOrEqualToFilterOperatorComponent, selectors: [["kendo-filter-gte-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function GreaterOrEqualToFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
GreaterOrEqualToFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GreaterOrEqualToFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-gte-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `Less` (**Is less than**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class LessFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("lt", localization); }
}
LessFilterOperatorComponent.ɵfac = function LessFilterOperatorComponent_Factory(t) { return new (t || LessFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LessFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LessFilterOperatorComponent, selectors: [["kendo-filter-lt-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LessFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
LessFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LessFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => LessFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-lt-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("lte", localization); }
}
LessOrEqualToFilterOperatorComponent.ɵfac = function LessOrEqualToFilterOperatorComponent_Factory(t) { return new (t || LessOrEqualToFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
LessOrEqualToFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LessOrEqualToFilterOperatorComponent, selectors: [["kendo-filter-lte-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LessOrEqualToFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
LessOrEqualToFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LessOrEqualToFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-lte-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `Greater` (**Is after**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class AfterFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("after", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "gt"
        };
    }
}
AfterFilterOperatorComponent.ɵfac = function AfterFilterOperatorComponent_Factory(t) { return new (t || AfterFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
AfterFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AfterFilterOperatorComponent, selectors: [["kendo-filter-after-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AfterFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
AfterFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AfterFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => AfterFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-after-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `GreaterOrEqualTo` (**Is after or equal to**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class AfterEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("after-eq", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "gte"
        };
    }
}
AfterEqFilterOperatorComponent.ɵfac = function AfterEqFilterOperatorComponent_Factory(t) { return new (t || AfterEqFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
AfterEqFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AfterEqFilterOperatorComponent, selectors: [["kendo-filter-after-eq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AfterEqFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
AfterEqFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AfterEqFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-after-eq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `LessOrEqualTo` (**Is before or equal to**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class BeforeEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("before-eq", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "lte"
        };
    }
}
BeforeEqFilterOperatorComponent.ɵfac = function BeforeEqFilterOperatorComponent_Factory(t) { return new (t || BeforeEqFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
BeforeEqFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BeforeEqFilterOperatorComponent, selectors: [["kendo-filter-before-eq-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function BeforeEqFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
BeforeEqFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BeforeEqFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-before-eq-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

/*
 * Represents the `Less then` (**Is before**) date filter operator.
 *
 * For more information and examples, refer to:
 * * [Setting the default filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-default-filter-operator)
 * * [Setting the order of the filter operators]({% slug builtinfiltertemplate_treelist %}#toc-setting-the-order-of-the-filter-operators)
 */
class BeforeFilterOperatorComponent extends FilterOperatorBase {
    constructor(localization) { super("before", localization); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "lt"
        };
    }
}
BeforeFilterOperatorComponent.ɵfac = function BeforeFilterOperatorComponent_Factory(t) { return new (t || BeforeFilterOperatorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
BeforeFilterOperatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BeforeFilterOperatorComponent, selectors: [["kendo-filter-before-operator"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeFilterOperatorComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function BeforeFilterOperatorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
BeforeFilterOperatorComponent.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BeforeFilterOperatorComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: FilterOperatorBase,
                        useExisting: forwardRef(() => BeforeFilterOperatorComponent)
                    }
                ],
                selector: 'kendo-filter-before-operator',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, null); })();

const FILTER_OPERATORS = [
    FilterCellOperatorsComponent,
    ContainsFilterOperatorComponent,
    DoesNotContainFilterOperatorComponent,
    EndsWithFilterOperatorComponent,
    EqualFilterOperatorComponent,
    IsEmptyFilterOperatorComponent,
    IsNotEmptyFilterOperatorComponent,
    IsNotNullFilterOperatorComponent,
    IsNullFilterOperatorComponent,
    NotEqualFilterOperatorComponent,
    StartsWithFilterOperatorComponent,
    GreaterFilterOperatorComponent,
    GreaterOrEqualToFilterOperatorComponent,
    LessFilterOperatorComponent,
    LessOrEqualToFilterOperatorComponent,
    AfterFilterOperatorComponent,
    AfterEqFilterOperatorComponent,
    BeforeEqFilterOperatorComponent,
    BeforeFilterOperatorComponent
];
const importedModules = [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    DropDownListModule,
    AutoCompleteModule,
    InputsModule,
    DatePickerModule,
    PopupModule,
    SharedModule
];
const COMPONENTS = [
    FilterInputDirective
];
/**
 * @hidden
 */
class SharedFilterModule {
    static exports() {
        return [
            ...FILTER_OPERATORS
        ];
    }
}
SharedFilterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedFilterModule });
SharedFilterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SharedFilterModule_Factory(t) { return new (t || SharedFilterModule)(); }, imports: [[...importedModules],
        CommonModule,
        ReactiveFormsModule,
        FormsModule,
        DropDownListModule,
        AutoCompleteModule,
        InputsModule,
        DatePickerModule,
        PopupModule,
        SharedModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedFilterModule, { declarations: [FilterCellOperatorsComponent,
        ContainsFilterOperatorComponent,
        DoesNotContainFilterOperatorComponent,
        EndsWithFilterOperatorComponent,
        EqualFilterOperatorComponent,
        IsEmptyFilterOperatorComponent,
        IsNotEmptyFilterOperatorComponent,
        IsNotNullFilterOperatorComponent,
        IsNullFilterOperatorComponent,
        NotEqualFilterOperatorComponent,
        StartsWithFilterOperatorComponent,
        GreaterFilterOperatorComponent,
        GreaterOrEqualToFilterOperatorComponent,
        LessFilterOperatorComponent,
        LessOrEqualToFilterOperatorComponent,
        AfterFilterOperatorComponent,
        AfterEqFilterOperatorComponent,
        BeforeEqFilterOperatorComponent,
        BeforeFilterOperatorComponent,
        FilterInputDirective], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        DropDownListModule,
        AutoCompleteModule,
        InputsModule,
        DatePickerModule,
        PopupModule,
        SharedModule], exports: [FilterCellOperatorsComponent,
        ContainsFilterOperatorComponent,
        DoesNotContainFilterOperatorComponent,
        EndsWithFilterOperatorComponent,
        EqualFilterOperatorComponent,
        IsEmptyFilterOperatorComponent,
        IsNotEmptyFilterOperatorComponent,
        IsNotNullFilterOperatorComponent,
        IsNullFilterOperatorComponent,
        NotEqualFilterOperatorComponent,
        StartsWithFilterOperatorComponent,
        GreaterFilterOperatorComponent,
        GreaterOrEqualToFilterOperatorComponent,
        LessFilterOperatorComponent,
        LessOrEqualToFilterOperatorComponent,
        AfterFilterOperatorComponent,
        AfterEqFilterOperatorComponent,
        BeforeEqFilterOperatorComponent,
        BeforeFilterOperatorComponent,
        CommonModule,
        ReactiveFormsModule,
        FormsModule,
        DropDownListModule,
        AutoCompleteModule,
        InputsModule,
        DatePickerModule,
        PopupModule,
        SharedModule,
        FilterInputDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SharedFilterModule, [{
        type: NgModule,
        args: [{
                declarations: [FILTER_OPERATORS, COMPONENTS],
                exports: [FILTER_OPERATORS, importedModules, COMPONENTS],
                imports: [...importedModules]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class FilterHostDirective {
    constructor(host, resolver) {
        this.host = host;
        this.resolver = resolver;
    }
    ngOnInit() {
        this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));
        this.initComponent({
            column: this.column,
            filter: this.filter
        });
    }
    ngOnDestroy() {
        if (this.component) {
            this.component.destroy();
            this.component = null;
        }
    }
    ngOnChanges(changes) {
        if (anyChanged(["column", "filter"], changes)) {
            this.initComponent({
                column: this.column,
                filter: this.filter
            });
        }
    }
    initComponent({ column, filter: filter$$1 }) {
        const instance = this.component.instance;
        instance.column = column;
        instance.filter = filter$$1;
    }
}
FilterHostDirective.ɵfac = function FilterHostDirective_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
FilterHostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterHostDirective, inputs: { column: "column", filter: "filter" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
FilterHostDirective.propDecorators = {
    column: [{ type: Input }],
    filter: [{ type: Input }]
};


/**
 * @hidden
 *
 * > List the following components in the TreeListModule as `entryComponents`.
 */
const filterComponentFactory = (type) => ({
    "boolean": BooleanFilterCellComponent,
    "date": DateFilterCellComponent,
    "numeric": NumericFilterCellComponent,
    "text": StringFilterCellComponent
}[type]);

/**
 * @hidden
 */
class FilterCellHostDirective extends FilterHostDirective {
    constructor(host, resolver) {
        super(host, resolver);
    }
    componentType() {
        if (!isNullOrEmptyString(this.column.filter)) {
            return filterComponentFactory(this.column.filter);
        }
        return StringFilterCellComponent;
    }
}
FilterCellHostDirective.ɵfac = function FilterCellHostDirective_Factory(t) { return new (t || FilterCellHostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
FilterCellHostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterCellHostDirective, selectors: [["", "kendoFilterCellHost", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FilterCellHostDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterCellHostDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFilterCellHost]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();

const INTERNAL_COMPONENTS = [
    FilterRowComponent,
    FilterCellComponent,
    FilterCellTemplateDirective,
    StringFilterCellComponent,
    NumericFilterCellComponent,
    AutoCompleteFilterCellComponent,
    BooleanFilterCellComponent,
    FilterCellHostDirective,
    FilterCellWrapperComponent,
    DateFilterCellComponent
];
const ENTRY_COMPONENTS = [
    StringFilterCellComponent,
    NumericFilterCellComponent,
    BooleanFilterCellComponent,
    DateFilterCellComponent
];
/**
 * @hidden
 */
class RowFilterModule {
    static exports() {
        return [
            FilterRowComponent,
            FilterCellComponent,
            FilterCellTemplateDirective,
            FilterCellOperatorsComponent,
            StringFilterCellComponent,
            NumericFilterCellComponent,
            AutoCompleteFilterCellComponent,
            BooleanFilterCellComponent,
            DateFilterCellComponent,
            SharedFilterModule.exports()
        ];
    }
}
RowFilterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RowFilterModule });
RowFilterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RowFilterModule_Factory(t) { return new (t || RowFilterModule)(); }, imports: [[SharedFilterModule],
        SharedFilterModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RowFilterModule, { declarations: [FilterRowComponent,
        FilterCellComponent,
        FilterCellTemplateDirective,
        StringFilterCellComponent,
        NumericFilterCellComponent,
        AutoCompleteFilterCellComponent,
        BooleanFilterCellComponent,
        FilterCellHostDirective,
        FilterCellWrapperComponent,
        DateFilterCellComponent], imports: [SharedFilterModule], exports: [FilterRowComponent,
        FilterCellComponent,
        FilterCellTemplateDirective,
        StringFilterCellComponent,
        NumericFilterCellComponent,
        AutoCompleteFilterCellComponent,
        BooleanFilterCellComponent,
        FilterCellHostDirective,
        FilterCellWrapperComponent,
        DateFilterCellComponent,
        SharedFilterModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RowFilterModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_COMPONENTS],
                entryComponents: ENTRY_COMPONENTS,
                exports: [INTERNAL_COMPONENTS, SharedFilterModule],
                imports: [SharedFilterModule]
            }]
    }], null, null); })();

/**
 * @hidden
 */
const normalizeSettings = ({ buttonCount = 10, info = true, type = 'numeric', pageSizes = false, previousNext = true }) => ({
    buttonCount,
    info,
    pageSizes: pageSizes === true ? [5, 10, 20] : pageSizes,
    previousNext,
    type
});
/**
 * @hidden
 */
const normalize = (settings) => normalizeSettings(settings === true ? {} : settings);

/**
 * @hidden
 */
class PagerComponent {
    constructor(pagerContext) {
        this.pagerContext = pagerContext;
        this.allCount = 0;
        this.total = 0;
        this.skip = 1;
        this.pageChange = new EventEmitter();
        this.settings = normalize({});
        this._templateContext = {};
    }
    set options(value) {
        this.settings = normalize(value);
    }
    get pagerWrapClass() {
        return true;
    }
    get treelistPagerClass() {
        return true;
    }
    get widgetClass() {
        return true;
    }
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    get templateContext() {
        const context = this._templateContext;
        context.totalPages = this.totalPages;
        context.total = this.total;
        context.allCount = this.allCount || this.total;
        context.skip = this.skip;
        context.pageSize = this.pageSize;
        context.currentPage = this.currentPage;
        return context;
    }
    ngOnInit() {
        this.pageChangeSubscription = this.pagerContext.pageChange.subscribe(this.changePage.bind(this));
    }
    ngOnChanges(changes) {
        if (anyChanged(["pageSize", "skip", "total", "allCount"], changes, false)) {
            this.pagerContext.notifyChanges({
                pageSize: this.pageSize,
                skip: this.skip,
                total: this.total,
                allCount: this.allCount || this.total
            });
        }
    }
    ngOnDestroy() {
        if (this.pageChangeSubscription) {
            this.pageChangeSubscription.unsubscribe();
        }
    }
    changePage(event) {
        this.pageChange.emit(event);
    }
}
PagerComponent.ɵfac = function PagerComponent_Factory(t) { return new (t || PagerComponent)(ɵngcc0.ɵɵdirectiveInject(PagerContextService)); };
PagerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerComponent, selectors: [["kendo-treelist-pager"]], hostVars: 6, hostBindings: function PagerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pager-wrap", ctx.pagerWrapClass)("k-grid-pager", ctx.treelistPagerClass)("k-widget", ctx.widgetClass);
    } }, inputs: { allCount: "allCount", total: "total", skip: "skip", options: "options", pageSize: "pageSize", template: "template" }, outputs: { pageChange: "pageChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "buttonCount", 4, "ngIf"], [3, "pageSizes", 4, "ngIf"], [3, "buttonCount"], [3, "pageSizes"]], template: function PagerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PagerComponent_ng_container_0_Template, 1, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, PagerComponent_ng_container_1_Template, 7, 6, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.template == null ? null : ctx.template.templateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.template == null ? null : ctx.template.templateRef));
    } }, directives: function () { return [ɵngcc4.NgIf, ɵngcc4.NgTemplateOutlet, PagerPrevButtonsComponent,
        PagerNumericButtonsComponent,
        PagerInputComponent,
        PagerNextButtonsComponent,
        PagerInfoComponent,
        PagerPageSizesComponent]; }, encapsulation: 2 });
/** @nocollapse */
PagerComponent.ctorParameters = () => [
    { type: PagerContextService }
];
PagerComponent.propDecorators = {
    allCount: [{ type: Input }],
    total: [{ type: Input }],
    skip: [{ type: Input }],
    pageSize: [{ type: Input }],
    options: [{ type: Input }],
    template: [{ type: Input }],
    pageChange: [{ type: Output }],
    pagerWrapClass: [{ type: HostBinding, args: ['class.k-pager-wrap',] }],
    treelistPagerClass: [{ type: HostBinding, args: ['class.k-grid-pager',] }],
    widgetClass: [{ type: HostBinding, args: ['class.k-widget',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-pager',
                template: `
        <ng-container
            *ngIf="template?.templateRef"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext">
        </ng-container>
        <ng-container *ngIf="!template?.templateRef">
            <kendo-treelist-pager-prev-buttons *ngIf="settings.previousNext"></kendo-treelist-pager-prev-buttons>
            <kendo-treelist-pager-numeric-buttons
                *ngIf="settings.type === 'numeric'"
                [buttonCount]="settings.buttonCount">
            </kendo-treelist-pager-numeric-buttons>
            <kendo-treelist-pager-input *ngIf="settings.type === 'input'"></kendo-treelist-pager-input>
            <kendo-treelist-pager-next-buttons *ngIf="settings.previousNext"></kendo-treelist-pager-next-buttons>
            <kendo-treelist-pager-info *ngIf='settings.info'></kendo-treelist-pager-info>
            <kendo-treelist-pager-page-sizes *ngIf="settings.pageSizes" [pageSizes]="settings.pageSizes"></kendo-treelist-pager-page-sizes>
        </ng-container>
  `
            }]
    }], function () { return [{ type: PagerContextService }]; }, { allCount: [{
            type: Input
        }], total: [{
            type: Input
        }], skip: [{
            type: Input
        }], pageChange: [{
            type: Output
        }], options: [{
            type: Input
        }], pagerWrapClass: [{
            type: HostBinding,
            args: ['class.k-pager-wrap']
        }], treelistPagerClass: [{
            type: HostBinding,
            args: ['class.k-grid-pager']
        }], widgetClass: [{
            type: HostBinding,
            args: ['class.k-widget']
        }], pageSize: [{
            type: Input
        }], template: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class PagerElementComponent {
    constructor(localization, pagerContext, cd) {
        this.localization = localization;
        this.pagerContext = pagerContext;
        this.cd = cd;
        this.total = this.pagerContext.total;
        this.skip = this.pagerContext.skip;
        this.pageSize = this.pagerContext.pageSize;
        this.allCount = this.pagerContext.allCount;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerElementComponent
     */
    get currentPage() {
        return Math.floor((this.skip || 0) / this.pageSize) + 1;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerElementComponent
     */
    get totalPages() {
        return Math.ceil((this.total || 0) / this.pageSize);
    }
    /**
     * @hidden
     *
     * @param {string} key
     * @returns {string}
     *
     * @memberOf PagerElementComponent
     */
    textFor(key) {
        return this.localization.get(key);
    }
    /**
     * @hidden
     *
     * @param {number} page
     *
     * @memberOf PagerElementComponent
     */
    changePage(page) {
        this.pagerContext.changePage(page);
        return false;
    }
    /**
     * @hidden
     *
     * @memberOf PagerElementComponent
     */
    ngOnInit() {
        this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));
        this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
}
PagerElementComponent.ɵfac = function PagerElementComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
PagerElementComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PagerElementComponent });


// tslint:disable:no-access-missing-member
/**
 * Displays buttons for navigating to the first and to the previous page ([see example]({% slug paging_treelist %}#toc-pager-templates)).
 */
class PagerPrevButtonsComponent extends PagerElementComponent {
    constructor(localization, pagerContext, cd) {
        super(localization, pagerContext, cd);
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerPrevButtonsComponent
     */
    get disabled() {
        return this.currentPage === 1 || !this.total;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
}
PagerPrevButtonsComponent.ɵfac = function PagerPrevButtonsComponent_Factory(t) { return new (t || PagerPrevButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
PagerPrevButtonsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerPrevButtonsComponent, selectors: [["kendo-treelist-pager-prev-buttons"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 14, consts: [["href", "#", "tabindex", "-1", 3, "title", "ngClass", "click"], [3, "ngClass"]], template: function PagerPrevButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵlistener("click", function PagerPrevButtonsComponent_Template_a_click_0_listener() { return ctx.currentPage !== 1 ? ctx.changePage(0) : false; });
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "a", 0);
        ɵngcc0.ɵɵlistener("click", function PagerPrevButtonsComponent_Template_a_click_2_listener() { return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false; });
        ɵngcc0.ɵɵelement(3, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("title", ctx.textFor("pagerFirstPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(8, _c115, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(10, _c116));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerFirstPage"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.textFor("pagerPreviousPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(11, _c117, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(13, _c118));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerPreviousPage"));
    } }, directives: [ɵngcc4.NgClass], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
PagerPrevButtonsComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: PagerContextService },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerPrevButtonsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treelist-pager-prev-buttons',
                template: `
        <a  href="#"
            tabindex="-1"
            [title]="textFor('pagerFirstPage')"
            (click)="currentPage !== 1 ? changePage(0) : false"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                'k-pager-first': true
            }">
            <span [attr.aria-label]="textFor('pagerFirstPage')"
                [ngClass]="{
                    'k-icon':true,
                    'k-i-seek-w': true
                }">
            </span>
        </a>
        <a  href="#"
            tabindex="-1"
            [title]="textFor('pagerPreviousPage')"
            (click)="currentPage !== 1 ? changePage(currentPage-2) : false"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                '': true
            }">
            <span [attr.aria-label]="textFor('pagerPreviousPage')"
                [ngClass]="{
                    'k-icon':true,
                    'k-i-arrow-w': true
                }">
            </span>
        </a>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: PagerContextService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

// tslint:disable: no-access-missing-member
/**
 * Displays buttons for navigating to the next and to the last page ([see example]({% slug paging_treelist %}#toc-pager-templates)).
 */
class PagerNextButtonsComponent extends PagerElementComponent {
    constructor(localization, pagerContext, cd) {
        super(localization, pagerContext, cd);
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerNextButtonsComponent
     */
    get disabled() {
        return this.currentPage === this.totalPages || !this.total;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
}
PagerNextButtonsComponent.ɵfac = function PagerNextButtonsComponent_Factory(t) { return new (t || PagerNextButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
PagerNextButtonsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerNextButtonsComponent, selectors: [["kendo-treelist-pager-next-buttons"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 14, consts: [["href", "#", "tabindex", "-1", 3, "title", "ngClass", "click"], [3, "ngClass"]], template: function PagerNextButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵlistener("click", function PagerNextButtonsComponent_Template_a_click_0_listener() { return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false; });
        ɵngcc0.ɵɵelement(1, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "a", 0);
        ɵngcc0.ɵɵlistener("click", function PagerNextButtonsComponent_Template_a_click_2_listener() { return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false; });
        ɵngcc0.ɵɵelement(3, "span", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("title", ctx.textFor("pagerNextPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(8, _c117, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(10, _c119));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerNextPage"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.textFor("pagerLastPage"))("ngClass", ɵngcc0.ɵɵpureFunction1(11, _c120, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(13, _c121));
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerLastPage"));
    } }, directives: [ɵngcc4.NgClass], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
PagerNextButtonsComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: PagerContextService },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerNextButtonsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treelist-pager-next-buttons',
                template: `
        <a  href="#"
            tabindex="-1"
            [title]="textFor('pagerNextPage')"
            (click)="currentPage !== totalPages ? changePage(currentPage) : false"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                '': true
            }">
            <span [attr.aria-label]="textFor('pagerNextPage')"
                [ngClass]="{
                    'k-icon':true,
                    'k-i-arrow-e': true
                }">
            </span>
        </a>
        <a  href="#"
            tabindex="-1"
            [title]="textFor('pagerLastPage')"
            (click)="currentPage !== totalPages ? changePage(totalPages-1) : false"
            [ngClass]="{
                'k-link': true,
                'k-pager-nav': true,
                'k-state-disabled': disabled,
                'k-pager-last': true
            }">
            <span [attr.aria-label]="textFor('pagerLastPage')"
                [ngClass]="{
                    'k-icon':true,
                    'k-i-seek-e': true
                }">
            </span>
        </a>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: PagerContextService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

/**
 * Displays numeric buttons to enable navigation between the pages.
 */
class PagerNumericButtonsComponent extends PagerElementComponent {
    constructor(localization, cd, pagerContext) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number[]}
     * @memberOf PagerNumericButtonsComponent
     */
    get buttons() {
        let result = [];
        for (let idx = this.start; idx <= this.end; idx++) {
            result.push(idx);
        }
        return result;
    }
    /**
     * @hidden
     */
    get end() {
        return Math.min((this.start + this.buttonCount) - 1, this.totalPages);
    }
    /**
     * @hidden
     */
    get start() {
        const page = this.currentPage;
        const buttonCount = this.buttonCount;
        if (page > buttonCount) {
            const reminder = (page % buttonCount);
            return (reminder === 0) ? (page - buttonCount) + 1 : (page - reminder) + 1;
        }
        return 1;
    }
    /**
     * @hidden
     */
    pageLabel(num) {
        const pageText = this.textFor('pagerPage');
        if (pageText) {
            return pageText + ' ' + num;
        }
        return num.toString();
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
}
PagerNumericButtonsComponent.ɵfac = function PagerNumericButtonsComponent_Factory(t) { return new (t || PagerNumericButtonsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PagerContextService)); };
PagerNumericButtonsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerNumericButtonsComponent, selectors: [["kendo-treelist-pager-numeric-buttons"]], inputs: { buttonCount: "buttonCount" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 5, consts: [[3, "ngClass"], [4, "ngIf"], [4, "ngFor", "ngForOf"], ["href", "#", "tabindex", "-1", 1, "k-link", 3, "click"], ["href", "#", "tabindex", "-1", 3, "ngClass", "click"]], template: function PagerNumericButtonsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, PagerNumericButtonsComponent_li_1_Template, 3, 1, "li", 1);
        ɵngcc0.ɵɵtemplate(2, PagerNumericButtonsComponent_li_2_Template, 3, 5, "li", 2);
        ɵngcc0.ɵɵtemplate(3, PagerNumericButtonsComponent_li_3_Template, 3, 1, "li", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(4, _c123));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.start > 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.buttons);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
    } }, directives: [ɵngcc4.NgClass, ɵngcc4.NgIf, ɵngcc4.NgForOf], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
PagerNumericButtonsComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: ChangeDetectorRef },
    { type: PagerContextService }
];
PagerNumericButtonsComponent.propDecorators = {
    buttonCount: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerNumericButtonsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treelist-pager-numeric-buttons',
                template: `
       <ul [ngClass]="{'k-pager-numbers': true, 'k-reset': true}">
            <li *ngIf="start > 1">
                <a  class="k-link"
                    [attr.aria-label]="pageLabel(start - 1)"
                    href="#"
                    tabindex="-1"
                    (click)="changePage(start - 2)">...</a>
            </li>
            <li *ngFor="let num of buttons">
                <a  href="#"
                    [attr.aria-label]="pageLabel(num)"
                    tabindex="-1"
                    [ngClass]="{'k-link': true, 'k-state-selected':currentPage == num}"
                    (click)="changePage(num - 1)">
                    {{num}}
                </a>
            </li>
            <li *ngIf="end < totalPages">
                <a  class="k-link"
                    [attr.aria-label]="pageLabel(end + 1)"
                    href="#"
                    tabindex="-1"
                    (click)="changePage(end)">...</a>
            </li>
        </ul>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PagerContextService }]; }, { buttonCount: [{
            type: Input
        }] }); })();

/**
 * Displays an input element which allows the typing and rendering of page numbers.
 */
class PagerInputComponent extends PagerElementComponent {
    constructor(localization, pagerContext, zone, cd) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this.zone = zone;
        /**
         * @hidden
         *
         * @param {string} value
         *
         * @memberOf PagerInputComponent
         */
        this.handleKeyDown = (event) => {
            let incomingValue = this.numericInput.value || this.current;
            if (event.keyCode === Keys.Enter) {
                event.preventDefault();
                if (incomingValue !== this.current) {
                    this.zone.run(() => {
                        this.changePage(incomingValue - 1);
                    });
                }
            }
        };
        /**
         * @hidden
         *
         * @param {string} value
         *
         * @memberOf PagerInputComponent
         */
        this.handleBlur = () => {
            const inputValue = this.numericInput.value;
            if (!inputValue) {
                this.numericInput.writeValue(this.current);
                return;
            }
            if (inputValue !== this.current) {
                this.zone.run(() => {
                    this.changePage(inputValue - 1);
                });
            }
        };
    }
    /**
     * @hidden
     */
    get current() {
        return this.hasPages ? this.currentPage : 0;
    }
    get hasPages() {
        return this.totalPages !== 0;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.cd.markForCheck();
    }
}
PagerInputComponent.ɵfac = function PagerInputComponent_Factory(t) { return new (t || PagerInputComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(PagerContextService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
PagerInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerInputComponent, selectors: [["kendo-treelist-pager-input"]], viewQuery: function PagerInputComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NumericTextBoxComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.numericInput = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 21, consts: [[3, "ngClass"], ["format", "n0", 3, "spinners", "decimals", "disabled", "value", "min", "max", "autoCorrect", "title", "kendoEventsOutsideAngular"]], template: function PagerInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelement(2, "kendo-numerictextbox", 1);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction0(17, _c124));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.textFor("pagerPage"), " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("margin", "0 1ex")("width", "3em");
        ɵngcc0.ɵɵproperty("spinners", false)("decimals", 0)("disabled", !ctx.hasPages)("value", ctx.current)("min", ctx.hasPages ? 1 : 0)("max", ctx.totalPages)("autoCorrect", true)("title", ctx.textFor("pagerPageNumberInputTitle"))("kendoEventsOutsideAngular", ɵngcc0.ɵɵpureFunction2(18, _c125, ctx.handleKeyDown, ctx.handleBlur));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.textFor("pagerOf"), " ", ctx.totalPages, " ");
    } }, directives: [ɵngcc4.NgClass, ɵngcc6.NumericTextBoxComponent, ɵngcc5.EventsOutsideAngularDirective], encapsulation: 2 });
/** @nocollapse */
PagerInputComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: PagerContextService },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
PagerInputComponent.propDecorators = {
    numericInput: [{ type: ViewChild, args: [NumericTextBoxComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-pager-input',
                template: `
     <span [ngClass]="{'k-pager-input': true, 'k-label': true}">
        {{textFor('pagerPage')}}
        <kendo-numerictextbox
            [style.margin]="'0 1ex'"
            [style.width]="'3em'"
            [spinners]="false"
            [decimals]="0"
            format="n0"
            [disabled]="!hasPages"
            [value]="current"
            [min]="hasPages ? 1 : 0"
            [max]="totalPages"
            [autoCorrect]="true"
            [title]="textFor('pagerPageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }">
        </kendo-numerictextbox>
            {{textFor('pagerOf')}} {{totalPages}}
     </span>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: PagerContextService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { numericInput: [{
            type: ViewChild,
            args: [NumericTextBoxComponent]
        }] }); })();

// tslint:disable:no-access-missing-member
/**
 * Displays information about the current page and the total number of records ([see example]({% slug paging_treelist %}#toc-pager-templates)).
 */
class PagerInfoComponent extends PagerElementComponent {
    constructor(localization, cd, pagerContext) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerInfoComponent
     */
    get currentPageText() {
        return this.total ? this.currentPage : 0;
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {number}
     * @memberOf PagerInfoComponent
     */
    get maxPage() {
        return Math.ceil(this.total / this.pageSize);
    }
    /**
     * @hidden
     *
     * @readonly
     * @type {boolean}
     * @memberOf PagerInfoComponent
     */
    get classes() {
        return true;
    }
    onChanges({ allCount, total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = pageSize;
        this.allCount = allCount;
        this.cd.markForCheck();
    }
}
PagerInfoComponent.ɵfac = function PagerInfoComponent_Factory(t) { return new (t || PagerInfoComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PagerContextService)); };
PagerInfoComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerInfoComponent, selectors: [["kendo-treelist-pager-info"]], hostVars: 4, hostBindings: function PagerInfoComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pager-info", ctx.classes)("k-label", ctx.classes);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 6, template: function PagerInfoComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate6("", ctx.textFor("pagerPage"), " ", ctx.currentPageText, " ", ctx.textFor("pagerOf"), " ", ctx.maxPage, " (", ctx.allCount, " ", ctx.textFor("pagerItemsTotal"), ")");
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
PagerInfoComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: ChangeDetectorRef },
    { type: PagerContextService }
];
PagerInfoComponent.propDecorators = {
    classes: [{ type: HostBinding, args: ["class.k-pager-info",] }, { type: HostBinding, args: ["class.k-label",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerInfoComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treelist-pager-info',
                template: `{{textFor('pagerPage')}} {{currentPageText}} {{textFor('pagerOf')}} {{maxPage}} ({{allCount}} {{textFor('pagerItemsTotal')}})`
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PagerContextService }]; }, { classes: [{
            type: HostBinding,
            args: ["class.k-pager-info"]
        }, {
            type: HostBinding,
            args: ["class.k-label"]
        }] }); })();

// tslint:disable:no-access-missing-member
/**
 * Displays a drop-down list for the page size selection ([see example]({% slug paging_treelist %}#toc-pager-templates)).
 */
class PagerPageSizesComponent extends PagerElementComponent {
    constructor(localization, cd, pagerContext) {
        super(localization, pagerContext, cd);
        this.pagerContext = pagerContext;
        this._pageSizes = [];
    }
    get pageSizes() {
        return this._pageSizes;
    }
    /**
     * The page sizes collection. Can be an Array of numbers and/or PageSizeItem objects.
     *
     * {% meta height:500 %}
     * {% embed_file configuration/pager-template-page-sizes/app.component.ts preview %}
     * {% embed_file shared/app.module.ts %}
     * {% embed_file shared/filesystem.ts %}
     * {% embed_file shared/main.ts %}
     * {% endmeta %}
     */
    set pageSizes(pageSizes) {
        const normalizedItems = [];
        pageSizes.forEach(item => {
            if (typeof item === 'number') {
                normalizedItems.push({
                    text: item.toString(),
                    value: item
                });
            }
            else {
                normalizedItems.push(item);
            }
        });
        this._pageSizes = normalizedItems;
    }
    /**
     * @hidden
     *
     * @readonly
     */
    get classes() {
        return true;
    }
    /**
     * @hidden
     *
     * @readonly
     */
    get showInitialPageSize() {
        return this.pageSizes
            .filter(item => {
            if (typeof item.value === 'number') {
                return item.value === Number(this.pageSize);
            }
            return this.total === Number(this.pageSize);
        })
            .length === 0;
    }
    /**
     * @hidden
     */
    pageSizeChange(value) {
        this.pageSize = parseInt(value, 10);
        this.pagerContext.changePageSize(this.pageSize);
    }
    /**
     * @hidden
     */
    getValue(page) {
        return typeof page.value === 'number' ? page.value : this.total;
    }
    /**
     * @hidden
     */
    getSelectedState(page) {
        if (typeof page.value === 'number') {
            return page.value === this.pageSize ? true : undefined;
        }
        return this.pageSize === this.total;
    }
    onChanges({ total, skip, pageSize }) {
        this.total = total;
        this.skip = skip;
        this.pageSize = typeof pageSize === 'number' ? pageSize : this.total;
        this.cd.markForCheck();
    }
}
PagerPageSizesComponent.ɵfac = function PagerPageSizesComponent_Factory(t) { return new (t || PagerPageSizesComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PagerContextService)); };
PagerPageSizesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PagerPageSizesComponent, selectors: [["kendo-treelist-pager-page-sizes"]], hostVars: 4, hostBindings: function PagerPageSizesComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-pager-sizes", ctx.classes)("k-label", ctx.classes);
    } }, inputs: { pageSizes: "pageSizes" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 4, consts: [[3, "change"], ["select", ""], [3, "value", 4, "ngIf"], [3, "value", "selected", 4, "ngFor", "ngForOf"], [3, "value"], [3, "value", "selected"]], template: function PagerPageSizesComponent_Template(rf, ctx) { if (rf & 1) {
        const _r4 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "select", 0, 1);
        ɵngcc0.ɵɵlistener("change", function PagerPageSizesComponent_Template_select_change_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const _r0 = ɵngcc0.ɵɵreference(1); return ctx.pageSizeChange(_r0.value); });
        ɵngcc0.ɵɵtemplate(2, PagerPageSizesComponent_option_2_Template, 2, 2, "option", 2);
        ɵngcc0.ɵɵtemplate(3, PagerPageSizesComponent_option_3_Template, 2, 3, "option", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtext(4);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.textFor("pagerItemsPerPage"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showInitialPageSize);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pageSizes);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.textFor("pagerItemsPerPage"), " ");
    } }, directives: [ɵngcc4.NgIf, ɵngcc4.NgForOf], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
PagerPageSizesComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: ChangeDetectorRef },
    { type: PagerContextService }
];
PagerPageSizesComponent.propDecorators = {
    pageSizes: [{ type: Input }],
    classes: [{ type: HostBinding, args: ["class.k-pager-sizes",] }, { type: HostBinding, args: ["class.k-label",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerPageSizesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treelist-pager-page-sizes',
                template: `
        <select #select
            (change)="pageSizeChange(select.value)"
            [attr.aria-label]="textFor('pagerItemsPerPage')">
            <option *ngIf="showInitialPageSize" [value]="pageSize">{{pageSize}}</option>
            <option *ngFor="let page of pageSizes" [value]="getValue(page)" [selected]="getSelectedState(page)">
                {{page['text']}}
            </option>
        </select>
        {{ textFor('pagerItemsPerPage') }}
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }, { type: PagerContextService }]; }, { pageSizes: [{
            type: Input
        }], classes: [{
            type: HostBinding,
            args: ["class.k-pager-sizes"]
        }, {
            type: HostBinding,
            args: ["class.k-label"]
        }] }); })();

const importedModules$1 = [
    CommonModule,
    InputsModule,
    SharedModule,
    EventsModule
];
const INTERNAL_COMPONENTS$1 = [
    PagerComponent,
    PagerPrevButtonsComponent,
    PagerNextButtonsComponent,
    PagerNumericButtonsComponent,
    PagerInputComponent,
    PagerInfoComponent,
    PagerPageSizesComponent,
    PagerTemplateDirective
];
/**
 * @hidden
 */
class PagerModule {
    static exports() {
        return [
            PagerComponent,
            PagerPrevButtonsComponent,
            PagerNextButtonsComponent,
            PagerNumericButtonsComponent,
            PagerInputComponent,
            PagerInfoComponent,
            PagerPageSizesComponent,
            PagerTemplateDirective
        ];
    }
}
PagerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PagerModule });
PagerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PagerModule_Factory(t) { return new (t || PagerModule)(); }, imports: [[...importedModules$1]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PagerModule, { declarations: [PagerComponent,
        PagerPrevButtonsComponent,
        PagerNextButtonsComponent,
        PagerNumericButtonsComponent,
        PagerInputComponent,
        PagerInfoComponent,
        PagerPageSizesComponent,
        PagerTemplateDirective], imports: [CommonModule,
        InputsModule,
        SharedModule,
        EventsModule], exports: [PagerComponent,
        PagerPrevButtonsComponent,
        PagerNextButtonsComponent,
        PagerNumericButtonsComponent,
        PagerInputComponent,
        PagerInfoComponent,
        PagerPageSizesComponent,
        PagerTemplateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PagerModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_COMPONENTS$1],
                exports: [INTERNAL_COMPONENTS$1],
                imports: [...importedModules$1]
            }]
    }], null, null); })();

/**
 * @hidden
 */
const DEFAULTS = {
    allowUnsort: true,
    mode: 'single',
    showIndexes: true,
    initialDirection: 'asc'
};
/**
 * @hidden
 */
const normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);

/**
 * @hidden
 */
class DropTargetDirective {
    constructor(element, service) {
        this.element = element;
        this.service = service;
        this.context = {};
        this.enter = new EventEmitter();
        this.leave = new EventEmitter();
        this.drop = new EventEmitter();
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.service.add(this);
        const changes = this.service.changes.pipe(filter(({ target }) => target === this));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'leave'))
            .subscribe(e => {
            this.leave.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'enter'))
            .subscribe(e => {
            this.enter.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'drop'))
            .subscribe(e => {
            this.drop.next(this.eventArgs(e));
        }));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    eventArgs(e) {
        return {
            target: this,
            mouseEvent: e.mouseEvent,
            draggable: e.draggable
        };
    }
}
DropTargetDirective.ɵfac = function DropTargetDirective_Factory(t) { return new (t || DropTargetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragAndDropService)); };
DropTargetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropTargetDirective, selectors: [["", "kendoDropTarget", ""]], inputs: { context: "context" }, outputs: { enter: "enter", leave: "leave", drop: "drop" } });
/** @nocollapse */
DropTargetDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragAndDropService }
];
DropTargetDirective.propDecorators = {
    context: [{ type: Input }],
    enter: [{ type: Output }],
    leave: [{ type: Output }],
    drop: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropTargetDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDropTarget]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragAndDropService }]; }, { context: [{
            type: Input
        }], enter: [{
            type: Output
        }], leave: [{
            type: Output
        }], drop: [{
            type: Output
        }] }); })();

/**
 * @hidden
 */
const hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
/**
 * @hidden
 */
const hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
/**
 * @hidden
 */
const hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasColumnChooser = (settings) => settings.columnChooser !== false;
/**
 * @hidden
 */
const hasItems = (settings, column) => hasColumnChooser(settings) || hasLock(settings, column) || hasSort(settings, column) || hasFilter(settings, column);

const mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
const directions = initialDirection => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
/**
 * @hidden
 */
const isRootLevel = ({ parent }) => !isTruthy(parent);
const ofColumnType = ({ draggable }) => ['column', 'columnGroup']
    .indexOf(draggable.context.type) >= 0;
const notSameElement = ({ draggable, target }) => draggable.element.nativeElement !== target.element.nativeElement;
const inSameParent = (x, y) => x.parent === y.parent ||
    (isInSpanColumn(y) && inSameParent(x, y.parent));
const sameParent = ({ draggable, target }) => inSameParent(draggable.context.column, target.context.column);
const lastNonLocked = ({ draggable }) => !isTruthy(draggable.context.column.locked) &&
    isRootLevel(draggable.context.column) &&
    draggable.context.lastColumn;
const notInSpanColumn = ({ draggable }) => !isInSpanColumn(draggable.context.column);
const reorderable = ({ draggable }) => draggable.context.column.reorderable;
const lockable = ({ draggable, target }) => draggable.context.column.lockable !== false ||
    draggable.context.column.isLocked === target.context.column.isLocked;
const rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
/**
 * @hidden
 */
class HeaderComponent {
    constructor(popupService, hint, cue, reorderService, sortService, selectionService, localization, cd) {
        this.popupService = popupService;
        this.hint = hint;
        this.cue = cue;
        this.reorderService = reorderService;
        this.sortService = sortService;
        this.selectionService = selectionService;
        this.localization = localization;
        this.cd = cd;
        this.columns = [];
        this.sort = new Array();
        this.sortable = false;
        this.lockedColumnsCount = 0;
        this.resizable = false;
        this.reorderable = false;
        this.columnMenu = false;
        this.totalColumnsCount = 0;
        this.sortedFields = {};
        this.dropTargets = new QueryList();
        this.subscription = new Subscription();
    }
    get headerClass() {
        return !this.scrollable;
    }
    get sortableLabel() {
        return this.localization.get('sortable');
    }
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
    }
    sortColumn(column, event, link) {
        const target = event ? event.target : null;
        if (column.headerTemplateRef && target !== link) {
            const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));
            if (hasFocusableParent) {
                return target.type === 'checkbox'; // prevent navigation only if the element is not checkbox
            }
        }
        this.sortService.sort(this.toggleSort(column));
        // Prevent navigation
        return false;
    }
    onHeaderKeydown(column, args) {
        if (!this.sortable || args.defaultPrevented || column.sortable === false) {
            return;
        }
        if (args.keyCode === Keys.Enter) {
            this.sortService.sort(this.toggleSort(column));
        }
    }
    showSortNumbering(column) {
        const { showIndexes } = normalize$1(this.sortable);
        return showIndexes
            && this.sort
            && this.sort.filter(({ dir }) => isPresent(dir)).length > 1
            && this.sortOrder(column.field) > 0;
    }
    sortOrder(field) {
        return this.sort
            .filter(({ dir }) => isPresent(dir))
            .findIndex(x => x.field === field)
            + 1;
    }
    sortIcon(field) {
        const state$$1 = this.sortDescriptor(field);
        return {
            'k-icon': isPresent(state$$1.dir),
            'k-i-sort-desc-sm': state$$1.dir === "desc",
            'k-i-sort-asc-sm': state$$1.dir === "asc"
        };
    }
    sortState(column) {
        if (!this.isSortable(column)) {
            return;
        }
        const state$$1 = this.sortDescriptor(column.field);
        if (state$$1.dir === 'asc') {
            return 'ascending';
        }
        if (state$$1.dir === 'desc') {
            return 'descending';
        }
    }
    sortStatus(column) {
        if (!this.sortedFields[column.field] || !this.isSortable(column)) {
            return;
        }
        let msg = 'sortedDefault';
        const state$$1 = this.sortDescriptor(column.field);
        if (state$$1.dir === 'asc') {
            msg = 'sortedAscending';
        }
        else if (state$$1.dir === 'desc') {
            msg = 'sortedDescending';
        }
        return this.localization.get(msg);
    }
    toggleSort(column) {
        const { allowUnsort, mode, initialDirection } = normalize$1(this.sortable, column.sortable);
        const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
        if (mode === 'single') {
            return [descriptor];
        }
        return [...this.sort.filter(desc => desc.field !== column.field), descriptor];
    }
    ngAfterViewInit() {
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngDoCheck() {
        this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));
    }
    ngOnChanges(changes) {
        const sortChange = changes.sort;
        if (sortChange && !sortChange.isFirstChange()) {
            sortChange.currentValue.forEach(change => {
                this.sortedFields[change.field] = true;
            });
        }
    }
    ngOnInit() {
        this.subscription.add(this.localization.changes
            .subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        if (this.popupService) {
            this.popupService.destroy();
        }
        this.subscription.unsubscribe();
    }
    isFirstOnRow(column, index) {
        const isTailing = (c) => c &&
            (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
        return index === 0 && isTailing(column.parent);
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index;
        }
        return -1;
    }
    get showFilterMenu() {
        return !this.columnMenu && hasFilterMenu(this.filterable);
    }
    get showFilterRow() {
        return hasFilterRow(this.filterable);
    }
    showColumnMenu(column) {
        return this.columnMenu && column.columnMenu &&
            (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
    }
    isFilterable(column) {
        return !isNullOrEmptyString(column.field) && column.filterable === true;
    }
    canDrop(draggable, target) {
        return this.reorderable && rules({ draggable, target });
    }
    shouldActivate(column) {
        return this.reorderable && column.reorderable;
    }
    isSortable(column) {
        return !isNullOrEmptyString(column.field)
            && isTruthy(this.sortable) && isTruthy(column.sortable);
    }
    trackByIndex(index, _item) {
        return index;
    }
    toggleDirection(field, allowUnsort, initialDirection) {
        const descriptor = this.sortDescriptor(field);
        const [first, second] = directions(initialDirection);
        let dir = first;
        if (descriptor.dir === first) {
            dir = second;
        }
        else if (descriptor.dir === second && allowUnsort) {
            dir = undefined;
        }
        return { dir, field };
    }
    columnsForLevel(level) {
        const columns = this.columns ? this.columns.filter(column => column.level === level) : [];
        return sortColumns(columnsToRender(columns));
    }
    isColumnGroupComponent(column) {
        return isColumnGroupComponent(column);
    }
    get columnLevels() {
        return new Array((this.totalColumnLevels || 0) + 1);
    }
    renderSelectAll(column) {
        return column.isCheckboxColumn && column.showSelectAll && !column.headerTemplateRef &&
            this.selectionService.enableMultiple;
    }
    selectAllClick(args) {
        this.selectionService.toggleAll(args.target.checked);
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    get leafColumns() {
        return this._leafColumns;
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = merge(...this.dropTargets.map(target => target.enter));
        const leaveStream = merge(...this.dropTargets.map(target => target.leave));
        const dropStream = merge(...this.dropTargets.map(target => target.drop));
        this.targetSubscription.add(enterStream.pipe(tap(({ target, draggable }) => {
            const targetLocked = isTruthy(target.context.column.isLocked);
            const draggableLocked = isTruthy(draggable.context.column.isLocked);
            if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
                this.hint.toggleLock(targetLocked);
            }
        }), filter(({ draggable, target }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, { before: this.calculateBefore(e), changeContainer: e.changeContainer })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this)))))))
            .subscribe(this.drop.bind(this)));
    }
    normalizeTarget(e) {
        let target = e.target;
        const parent = target.context.column.parent;
        if (parent && parent.isSpanColumn) {
            const arr = this.dropTargets.toArray();
            const firstSpan = arr.find(t => t.context.column.parent === parent);
            const index = arr.indexOf(firstSpan);
            const adjust = e.before ? 0 : parent.childColumns.length - 1;
            target = arr[index + adjust];
        }
        return mergeObjects(e, { target });
    }
    trackMove(leaveStream, dropStream, e) {
        const column = e.target.context.column;
        const levelColumns = this.columnsForLevel(column.level);
        const index = levelColumns.indexOf(column);
        const isFirst = (column.locked ? index === levelColumns.length - 1 : index === 0);
        const changed = e.draggable.context.column.isLocked !== column.isLocked;
        if (changed && isFirst) {
            return e.draggable.drag
                .pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({ mouseEvent }) => mergeObjects({ changeContainer: true }, e, { mouseEvent })));
        }
        return of(mergeObjects({ changeContainer: changed }, e));
    }
    calculateBefore({ draggable, target, mouseEvent, changeContainer = false }) {
        const targetElement = target.element.nativeElement;
        let before = false;
        if (changeContainer) {
            const { left } = offset(targetElement);
            const halfWidth = targetElement.offsetWidth / 2;
            const middle = left + halfWidth;
            before = middle > mouseEvent.pageX;
            if (this.localization.rtl) {
                before = !before;
            }
        }
        else {
            before = isTargetBefore(draggable.element.nativeElement, targetElement);
        }
        return before;
    }
    enter({ target, before }) {
        this.hint.enable();
        if (this.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ draggable, target, before, changeContainer }) {
        this.reorderService.reorder({
            before,
            changeContainer,
            source: draggable.context.column,
            target: target.context.column
        });
    }
}
HeaderComponent.ɵfac = function HeaderComponent_Factory(t) { return new (t || HeaderComponent)(ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(DragHintService), ɵngcc0.ɵɵdirectiveInject(DropCueService), ɵngcc0.ɵɵdirectiveInject(ColumnReorderService), ɵngcc0.ɵɵdirectiveInject(SortService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
HeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeaderComponent, selectors: [["", "kendoTreeListHeader", ""]], viewQuery: function HeaderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(DropTargetDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropTargets = _t);
    } }, hostVars: 2, hostBindings: function HeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-header", ctx.headerClass);
    } }, inputs: { columns: "columns", sort: "sort", sortable: "sortable", lockedColumnsCount: "lockedColumnsCount", resizable: "resizable", reorderable: "reorderable", columnMenu: "columnMenu", totalColumnsCount: "totalColumnsCount", totalColumnLevels: "totalColumnLevels", scrollable: "scrollable", filterable: "filterable", filter: "filter", columnMenuTemplate: "columnMenuTemplate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c126, decls: 2, vars: 2, consts: [["kendoTreeListLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngFor", "ngForOf"], ["kendoTreeListFilterRow", "", "kendoTreeListLogicalRow", "", 3, "columns", "filter", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoTreeListLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], ["kendoTreeListLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header", 3, "logicalRowIndex", "logicalColIndex", "colSpan", "rowSpan", "enableDrag", "context", "k-filterable", "k-first", "ngClass", "ngStyle", "keydown", 4, "ngIf"], ["kendoTreeListLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "enableDrag", "context", "k-first", "k-filterable", "ngClass", "ngStyle", 4, "ngIf"], ["kendoTreeListLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", 3, "logicalRowIndex", "logicalColIndex", "colSpan", "rowSpan", "enableDrag", "context", "ngClass", "ngStyle", "keydown"], [3, "column", "filter", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", 4, "ngIf"], [3, "ngIf"], [4, "ngIf"], ["kendoTreeListColumnHandle", "", "kendoDraggable", "", "class", "k-column-resizer", 3, "column", "columns", 4, "ngIf"], [3, "column", "filter"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable"], [3, "templateContext"], ["href", "#", "tabindex", "-1", 1, "k-link", 3, "click"], ["link", ""], [3, "ngClass"], ["class", "k-sort-order", 4, "ngIf"], ["role", "status", 1, "k-sort-status", 2, "position", "absolute", "left", "-10000px", 3, "innerHtml"], [1, "k-sort-order"], ["type", "checkbox", "kendoTreeListFocusable", "", 1, "k-checkbox", 3, "click"], ["kendoTreeListColumnHandle", "", "kendoDraggable", "", 1, "k-column-resizer", 3, "column", "columns"], ["kendoTreeListLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "enableDrag", "context", "ngClass", "ngStyle"], [3, "standalone", "settings", "column", "columnMenuTemplate", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate"], ["kendoTreeListFilterRow", "", "kendoTreeListLogicalRow", "", 3, "columns", "filter", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"]], template: function HeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HeaderComponent_tr_0_Template, 2, 6, "tr", 0);
        ɵngcc0.ɵɵtemplate(1, HeaderComponent_tr_1_Template, 1, 7, "tr", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columnLevels);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showFilterRow);
    } }, directives: function () { return [ɵngcc4.NgForOf, ɵngcc4.NgIf, LogicalRowDirective,
        LogicalCellDirective,
        DropTargetDirective, ɵngcc5.DraggableDirective, DraggableColumnDirective, ɵngcc4.NgClass, ɵngcc4.NgStyle, FilterMenuComponent,
        ColumnMenuComponent,
        TemplateContextDirective,
        FocusableDirective,
        ColumnHandleDirective,
        FilterRowComponent]; }, encapsulation: 2 });
/** @nocollapse */
HeaderComponent.ctorParameters = () => [
    { type: SinglePopupService },
    { type: DragHintService },
    { type: DropCueService },
    { type: ColumnReorderService },
    { type: SortService },
    { type: SelectionService },
    { type: LocalizationService },
    { type: ChangeDetectorRef }
];
HeaderComponent.propDecorators = {
    totalColumnLevels: [{ type: Input }],
    columns: [{ type: Input }],
    scrollable: [{ type: Input }],
    filterable: [{ type: Input }],
    sort: [{ type: Input }],
    filter: [{ type: Input }],
    sortable: [{ type: Input }],
    lockedColumnsCount: [{ type: Input }],
    resizable: [{ type: Input }],
    reorderable: [{ type: Input }],
    columnMenu: [{ type: Input }],
    columnMenuTemplate: [{ type: Input }],
    totalColumnsCount: [{ type: Input }],
    headerClass: [{ type: HostBinding, args: ['class.k-grid-header',] }],
    dropTargets: [{ type: ViewChildren, args: [DropTargetDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeaderComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListHeader]',
                template: `
        <tr *ngFor="let i of columnLevels; let levelIndex = index"
            kendoTreeListLogicalRow
                [logicalRowIndex]="levelIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount">
            <ng-template ngFor let-column [ngForOf]="columnsForLevel(levelIndex)" [ngForTrackBy]="trackByIndex" let-columnIndex="index" let-last="last">
                <th *ngIf="!isColumnGroupComponent(column)"
                    kendoTreeListLogicalCell [logicalRowIndex]="levelIndex"
                                         [logicalColIndex]="logicalColumnIndex(column)"
                                         [colSpan]="column.colspan"
                                         [rowSpan]="column.rowspan(totalColumnLevels)"
                                         role="columnheader"
                                         aria-selected="false"
                                         [attr.aria-sort]="sortState(column)"
                                         (keydown)="onHeaderKeydown(column, $event)"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: column.field,
                        type: 'column',
                        column: column,
                        hint: column.title || column.field,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header"
                    [class.k-filterable]="(showFilterMenu && isFilterable(column)) || showColumnMenu(column)"
                    [class.k-first]="isFirstOnRow(column, columnIndex)"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                    <kendo-treelist-filter-menu
                        *ngIf="showFilterMenu && isFilterable(column)"
                        [column]="column"
                        [filter]="filter">
                    </kendo-treelist-filter-menu>
                    <kendo-treelist-column-menu *ngIf="showColumnMenu(column)"
                        [standalone]="false"
                        [settings]="columnMenu"
                        [column]="column"
                        [columnMenuTemplate]="columnMenuTemplate"
                        [sort]="sort"
                        [filter]="filter"
                        [sortable]="sortable">
                    </kendo-treelist-column-menu>
                    <ng-template [ngIf]="!isSortable(column)">
                        <ng-template
                            [templateContext]="{
                                templateRef: column.headerTemplateRef,
                                columnIndex: column.leafIndex,
                                column: column,
                                $implicit: column
                            }">
                        </ng-template>
                        <ng-template [ngIf]="!column.headerTemplateRef">{{column.displayTitle}}</ng-template>
                    </ng-template>
                    <ng-template [ngIf]="isSortable(column)">
                        <a #link href="#" tabindex="-1" class="k-link" (click)="sortColumn(column, $event, link)">
                            <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: column.leafIndex,
                                    column: column,
                                    $implicit: column
                                }">
                            </ng-template>
                            <ng-template [ngIf]="!column.headerTemplateRef">{{column.displayTitle}}</ng-template>
                            <span [attr.aria-label]="sortableLabel" [ngClass]="sortIcon(column.field)"></span>
                            <span *ngIf="showSortNumbering(column)" class="k-sort-order">{{sortOrder(column.field)}}</span>
                        </a>
                        <span role="status"
                              class="k-sort-status"
                              style="position: absolute; left: -10000px;"
                              [innerHtml]="sortStatus(column)">
                        </span>
                    </ng-template>
                    <ng-container *ngIf="renderSelectAll(column)">
                        <input type="checkbox" class="k-checkbox" kendoTreeListFocusable
                              (click)="selectAllClick($event)" />
                    </ng-container>
                    <span kendoTreeListColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
                <th *ngIf="isColumnGroupComponent(column)"
                    kendoTreeListLogicalCell [logicalRowIndex]="levelIndex"
                                         [logicalColIndex]="logicalColumnIndex(column)"
                                         [rowSpan]="column.rowspan(totalColumnLevels)"
                                         [colSpan]="column.colspan"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header"
                    [class.k-first]="isFirstOnRow(column, columnIndex)"
                    [class.k-filterable]="showColumnMenu(column)"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                        <kendo-treelist-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenu"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate">
                        </kendo-treelist-column-menu>
                        <ng-template
                            [templateContext]="{
                                templateRef: column.headerTemplateRef,
                                columnIndex: lockedColumnsCount + columnIndex,
                                column: column,
                                $implicit: column
                            }">
                        </ng-template>
                        <ng-template [ngIf]="!column.headerTemplateRef">{{column.displayTitle}}</ng-template>
                        <span kendoTreeListColumnHandle
                            kendoDraggable
                            class="k-column-resizer"
                            *ngIf="resizable"
                            [column]="column"
                            [columns]="columns">
                        </span>
                </th>
            </ng-template>
        </tr>
        <tr *ngIf="showFilterRow"
            kendoTreeListFilterRow
                [columns]="leafColumns"
                [filter]="filter"
                [lockedColumnsCount]="lockedColumnsCount"
            kendoTreeListLogicalRow
                [logicalRowIndex]="totalColumnLevels + 1"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
        ></tr>
    `
            }]
    }], function () { return [{ type: SinglePopupService }, { type: DragHintService }, { type: DropCueService }, { type: ColumnReorderService }, { type: SortService }, { type: SelectionService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columns: [{
            type: Input
        }], sort: [{
            type: Input
        }], sortable: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }], resizable: [{
            type: Input
        }], reorderable: [{
            type: Input
        }], columnMenu: [{
            type: Input
        }], totalColumnsCount: [{
            type: Input
        }], dropTargets: [{
            type: ViewChildren,
            args: [DropTargetDirective]
        }], headerClass: [{
            type: HostBinding,
            args: ['class.k-grid-header']
        }], totalColumnLevels: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], filterable: [{
            type: Input
        }], filter: [{
            type: Input
        }], columnMenuTemplate: [{
            type: Input
        }] }); })();

// TODO
// tslint:disable:rxjs-no-unsafe-takeuntil
/**
 * @hidden
 */
const fromPercentage = (value, percent) => {
    const sign = percent < 0 ? -1 : 1;
    return Math.ceil((Math.abs(percent) / 100) * value) * sign;
};
/**
 * @hidden
 */
const toPercentage = (value, whole) => (value / whole) * 100;
/**
 * @hidden
 */
const headerWidth = (handle) => handle.nativeElement.parentElement.offsetWidth;
/**
 * @hidden
 */
const allLeafColumns = columns => expandColumns(columns)
    .filter(c => !c.isColumnGroup);
/**
 * @hidden
 */
const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
/**
 * @hidden
 */
const createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({ pageX }) => ({
    originalX: mouseDown.pageX,
    pageX
})));
/**
 * @hidden
 */
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
/**
 * @hidden
 */
const isInSpanColumn$1 = column => !!(column.parent && column.parent.isSpanColumn);
/**
 * @hidden
 *
 * Calculates the column index. If the column is stated in `SpanColumn`,
 * the index for all child columns equals the index of the first child.
 */
const indexOf = (target, list) => {
    let index = 0;
    let ignore = 0;
    let skip = 0;
    while (index < list.length) {
        const current = list[index];
        const isParentSpanColumn = isInSpanColumn$1(current);
        if (current === target) {
            break;
        }
        if ((ignore-- <= 0) && isParentSpanColumn) {
            ignore = current.parent.childColumns.length - 1;
            skip += ignore;
        }
        index++;
    }
    return index - skip;
};
/**
 * @hidden
 */
class ColumnHandleDirective {
    constructor(draggable, element, service, zone, cdr, localization) {
        this.draggable = draggable;
        this.element = element;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.localization = localization;
        this.columns = [];
        this.subscriptions = new Subscription();
        this.rtl = false;
    }
    get visible() {
        return this.column.resizable ? 'block' : 'none';
    }
    get leftStyle() {
        return isTruthy(this.rtl) ? 0 : null;
    }
    get rightStyle() {
        return isTruthy(this.rtl) ? null : 0;
    }
    autoFit() {
        const allLeafs = allLeafColumns(this.columns);
        const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));
        const columnInfo = currentLeafs.map(column => {
            const isParentSpan = isInSpanColumn$1(column);
            const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;
            const index = indexOf(column, allLeafs);
            return {
                column,
                headerIndex: this.columnsForLevel(column.level).indexOf(column),
                index,
                isLastInSpan,
                isParentSpan,
                level: column.level
            };
        });
        currentLeafs.forEach(column => column.width = 0);
        this.service.measureColumns(columnInfo);
    }
    ngOnInit() {
        const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'start'))
            .subscribe(this.initState.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn'))
            .subscribe(this.resize.bind(this)));
        this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only
        ).subscribe(this.initColumnWidth.bind(this)));
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable)))
            .subscribe(({ pageX, originalX }) => {
            const delta = pageX - originalX;
            const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
            this.service.resizeColumns(percent);
        })));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete'))
            .subscribe(this.sizeToFit.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit'))
            .subscribe(this.autoFit.bind(this)));
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    shouldUpdate() {
        return !allLeafColumns(this.columns)
            .map(column => column.width)
            .some(isBlank);
    }
    initColumnWidth() {
        this.column.width = headerWidth(this.element);
    }
    initState() {
        this.column.resizeStartWidth = headerWidth(this.element);
        this.service.resizedColumn({
            column: this.column,
            oldWidth: this.column.resizeStartWidth
        });
    }
    resize({ deltaPercent }) {
        let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
        if (isTruthy(this.rtl)) {
            delta *= -1;
        }
        const newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
        const tableDelta = newWidth > this.column.minResizableWidth ?
            delta : this.column.minResizableWidth - this.column.resizeStartWidth;
        this.updateWidth(this.column, newWidth);
        this.service.resizeTable(this.column, tableDelta);
    }
    sizeToFit({ columns, widths }) {
        const index = columns.indexOf(this.column);
        const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE
        const tableDelta = width - this.column.resizeStartWidth;
        this.updateWidth(this.column, width);
        this.service.resizeTable(this.column, tableDelta);
    }
    updateWidth(column, width) {
        column.width = width;
        this.cdr.markForCheck(); //force CD cycle
    }
    columnsForLevel(level) {
        return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);
    }
}
ColumnHandleDirective.ɵfac = function ColumnHandleDirective_Factory(t) { return new (t || ColumnHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
ColumnHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnHandleDirective, selectors: [["", "kendoTreeListColumnHandle", ""]], hostVars: 6, hostBindings: function ColumnHandleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function ColumnHandleDirective_dblclick_HostBindingHandler() { return ctx.autoFit(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible)("left", ctx.leftStyle)("right", ctx.rightStyle);
    } }, inputs: { columns: "columns", column: "column" } });
/** @nocollapse */
ColumnHandleDirective.ctorParameters = () => [
    { type: DraggableDirective, decorators: [{ type: Host }] },
    { type: ElementRef },
    { type: ColumnResizingService },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: LocalizationService }
];
ColumnHandleDirective.propDecorators = {
    columns: [{ type: Input }],
    column: [{ type: Input }],
    visible: [{ type: HostBinding, args: ['style.display',] }],
    leftStyle: [{ type: HostBinding, args: ['style.left',] }],
    rightStyle: [{ type: HostBinding, args: ['style.right',] }],
    autoFit: [{ type: HostListener, args: ['dblclick',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListColumnHandle]'
            }]
    }], function () { return [{ type: ɵngcc5.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }, { type: ColumnResizingService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.LocalizationService }]; }, { columns: [{
            type: Input
        }], visible: [{
            type: HostBinding,
            args: ['style.display']
        }], leftStyle: [{
            type: HostBinding,
            args: ['style.left']
        }], rightStyle: [{
            type: HostBinding,
            args: ['style.right']
        }], autoFit: [{
            type: HostListener,
            args: ['dblclick']
        }], column: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FilterMenuComponent {
    constructor(filterService, popupService, localization) {
        this.filterService = filterService;
        this.popupService = popupService;
        this.localization = localization;
        /**
         * @hidden
         */
        this.filterLabel = this.localization.get('filter');
    }
    get hasFilters() {
        return filtersByField(this.filter, (this.column || {}).field).length > 0;
    }
    toggle(anchor, template) {
        this.popupRef = this.popupService.open(anchor, template, this.popupRef);
        return false;
    }
    close() {
        this.popupService.destroy();
    }
}
FilterMenuComponent.ɵfac = function FilterMenuComponent_Factory(t) { return new (t || FilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
FilterMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterMenuComponent, selectors: [["kendo-treelist-filter-menu"]], inputs: { column: "column", filter: "filter" }, decls: 5, vars: 4, consts: [["href", "#", 3, "ngClass", "click"], ["anchor", ""], [1, "k-icon", "k-i-filter"], ["template", ""], [3, "column", "filter", "close"]], template: function FilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        const _r5 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵlistener("click", function FilterMenuComponent_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const _r0 = ɵngcc0.ɵɵreference(1); const _r1 = ɵngcc0.ɵɵreference(4); return ctx.toggle(_r0, _r1); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, FilterMenuComponent_ng_template_3_Template, 1, 2, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c130, ctx.hasFilters));
        ɵngcc0.ɵɵattribute("title", ctx.filterLabel);
    } }, directives: function () { return [ɵngcc4.NgClass, FilterMenuContainerComponent]; }, encapsulation: 2 });
/** @nocollapse */
FilterMenuComponent.ctorParameters = () => [
    { type: FilterService },
    { type: SinglePopupService },
    { type: LocalizationService }
];
FilterMenuComponent.propDecorators = {
    column: [{ type: Input }],
    filter: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-filter-menu',
                template: `
        <a #anchor
            [ngClass]="{'k-grid-filter':true, 'k-state-active': hasFilters}"
            (click)="toggle(anchor, template)"
            href="#"
            [attr.title]="filterLabel">
            <span class="k-icon k-i-filter"></span>
        </a>
        <ng-template #template>
            <kendo-treelist-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                >
            </kendo-treelist-filter-menu-container>
        </ng-template>
    `
            }]
    }], function () { return [{ type: FilterService }, { type: SinglePopupService }, { type: ɵngcc2.LocalizationService }]; }, { column: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();

const isNoValueOperator = operator => (operator === "isnull"
    || operator === "isnotnull"
    || operator === "isempty"
    || operator === "isnotempty");
const validFilters = ({ value, operator }) => !isNullOrEmptyString(value) || isNoValueOperator(operator);
const trimFilters = filter$$1 => {
    filter$$1.filters = filter$$1.filters.filter(validFilters);
    return filter$$1;
};
const findParent = (filters, field, parent) => {
    return filters.reduce((acc, filter$$1) => {
        if (acc) {
            return acc;
        }
        if (filter$$1.filters) {
            return findParent(filter$$1.filters, field, filter$$1);
        }
        else if (filter$$1.field === field) {
            return parent;
        }
        return acc;
    }, undefined); // tslint:disable-line:align
};
const parentLogicOfDefault = (filter$$1, field, def = "and") => {
    const parent = findParent(((filter$$1 || {}).filters || []), field);
    return isPresent(parent) ? parent.logic : def;
};
/**
 * @hidden
 */
class FilterMenuContainerComponent {
    constructor(parentService, childService, localization, cd) {
        this.parentService = parentService;
        this.childService = childService;
        this.localization = localization;
        this.cd = cd;
        this.close = new EventEmitter();
        /**
         * @hidden
         */
        this.actionsClass = 'k-action-buttons k-button-group';
        this._templateContext = {};
    }
    get filter() {
        return this._filter;
    }
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    get childFilter() {
        if (!isPresent(this._childFilter)) {
            this._childFilter = {
                filters: filtersByField(this.filter, (this.column || {}).field),
                logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
            };
        }
        return this._childFilter;
    }
    ngOnInit() {
        this.subscription = this.childService.changes.subscribe(filter$$1 => this._childFilter = filter$$1);
        this.subscription.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    get disabled() {
        return !this.childFilter.filters.some(validFilters);
    }
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.childFilter;
        this._templateContext.filterService = this.childService;
        // tslint:disable-next-line:no-string-literal
        this._templateContext["$implicit"] = this.childFilter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);
    }
    submit() {
        const filter$$1 = trimFilters(this.childFilter);
        if (filter$$1.filters.length) {
            const root = this.filter || {
                filters: [],
                logic: "and"
            };
            removeFilter(root, this.column.field);
            root.filters.push(filter$$1);
            this.parentService.filter(root);
        }
        this.close.emit();
        return false;
    }
    reset() {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        removeFilter(root, this.column.field);
        this.parentService.filter(root);
        this.close.emit();
    }
    get clearText() {
        return this.localization.get("filterClearButton");
    }
    get filterText() {
        return this.localization.get("filterFilterButton");
    }
}
FilterMenuContainerComponent.ɵfac = function FilterMenuContainerComponent_Factory(t) { return new (t || FilterMenuContainerComponent)(ɵngcc0.ɵɵdirectiveInject(FilterService, 4), ɵngcc0.ɵɵdirectiveInject(FilterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
FilterMenuContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterMenuContainerComponent, selectors: [["kendo-treelist-filter-menu-container"]], inputs: { actionsClass: "actionsClass", filter: "filter", column: "column" }, outputs: { close: "close" }, features: [ɵngcc0.ɵɵProvidersFeature([FilterService])], decls: 10, vars: 7, consts: [[1, "k-filter-menu", "k-group", "k-reset", "k-state-border-up", 3, "submit", "reset"], [1, "k-filter-menu-container"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "ngClass"], ["type", "reset", 1, "k-button"], ["type", "submit", 1, "k-button", "k-primary", 3, "disabled"], ["kendoFilterMenuHost", "", 3, "filterService", "column", "filter"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function FilterMenuContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "form", 0);
        ɵngcc0.ɵɵlistener("submit", function FilterMenuContainerComponent_Template_form_submit_0_listener() { return ctx.submit(); })("reset", function FilterMenuContainerComponent_Template_form_reset_0_listener() { return ctx.reset(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵtemplate(3, FilterMenuContainerComponent_ng_container_3_Template, 2, 3, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(4, FilterMenuContainerComponent_ng_container_4_Template, 2, 1, "ng-container", 3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "button", 5);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "button", 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.hasTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.actionsClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.clearText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.filterText);
    } }, directives: function () { return [ɵngcc7.ɵangular_packages_forms_forms_y, ɵngcc7.NgControlStatusGroup, ɵngcc7.NgForm, ɵngcc4.NgSwitch, ɵngcc4.NgSwitchCase, ɵngcc4.NgClass, FilterMenuHostDirective, ɵngcc4.NgIf, ɵngcc4.NgTemplateOutlet]; }, encapsulation: 2 });
/** @nocollapse */
FilterMenuContainerComponent.ctorParameters = () => [
    { type: FilterService, decorators: [{ type: SkipSelf }] },
    { type: FilterService },
    { type: LocalizationService },
    { type: ChangeDetectorRef }
];
FilterMenuContainerComponent.propDecorators = {
    close: [{ type: Output }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    actionsClass: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterMenuContainerComponent, [{
        type: Component,
        args: [{
                providers: [FilterService],
                selector: 'kendo-treelist-filter-menu-container',
                template: `
        <form (submit)="submit()" (reset)="reset()"
            class="k-filter-menu k-group k-reset k-state-border-up">
            <div class="k-filter-menu-container">
                <ng-container [ngSwitch]="hasTemplate">
                    <ng-container *ngSwitchCase="false">
                        <ng-container
                            kendoFilterMenuHost
                            [filterService]="childService"
                            [column]="column"
                            [filter]="childFilter">
                        </ng-container>
                    </ng-container>
                    <ng-container *ngSwitchCase="true">
                        <ng-template
                            *ngIf="column.filterMenuTemplateRef"
                            [ngTemplateOutlet]="column.filterMenuTemplateRef"
                            [ngTemplateOutletContext]="templateContext"
                            >
                        </ng-template>
                    </ng-container>
                </ng-container>
                <div [ngClass]="actionsClass">
                    <button type="reset" class="k-button">{{clearText}}</button>
                    <button type="submit" class="k-button k-primary" [disabled]="disabled">{{filterText}}</button>
                </div>
            </div>
        </form>
    `
            }]
    }], function () { return [{ type: FilterService, decorators: [{
                type: SkipSelf
            }] }, { type: FilterService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { close: [{
            type: Output
        }], actionsClass: [{
            type: Input
        }], filter: [{
            type: Input
        }], column: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {
    constructor() {
        super(null);
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    operatorChange(dataItem) {
        this.currentOperator = dataItem;
    }
    filterChange(filter$$1) {
        this.applyFilter(filter$$1);
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this._currentFilter;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    set currentFilter(value) {
        this._currentFilter = value;
    }
    updateFilter(filter$$1) {
        Object.assign(this.currentFilter, filter$$1);
        return this.filter;
    }
    onChange(value) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: this.currentOperator,
            value: value
        }));
    }
}
FilterMenuInputWrapperComponent.ɵfac = function FilterMenuInputWrapperComponent_Factory(t) { return new (t || FilterMenuInputWrapperComponent)(); };
FilterMenuInputWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: FilterMenuInputWrapperComponent, selectors: [["kendo-treelist-filter-menu-input-wrapper"]], inputs: { currentFilter: "currentFilter", filterService: "filterService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c109, decls: 2, vars: 3, consts: [["textField", "text", "valueField", "value", 3, "data", "value", "valuePrimitive", "valueChange"]], template: function FilterMenuInputWrapperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "kendo-dropdownlist", 0);
        ɵngcc0.ɵɵlistener("valueChange", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) { return ctx.operatorChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("data", ctx.operators)("value", ctx.currentOperator)("valuePrimitive", true);
    } }, directives: [ɵngcc8.DropDownListComponent], encapsulation: 2 });
/** @nocollapse */
FilterMenuInputWrapperComponent.ctorParameters = () => [];
FilterMenuInputWrapperComponent.propDecorators = {
    filterService: [{ type: Input }],
    currentFilter: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterMenuInputWrapperComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-filter-menu-input-wrapper',
                template: `
        <kendo-dropdownlist
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `
            }]
    }], function () { return []; }, { currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class StringFilterMenuInputComponent {
    constructor() {
        this.operators = [];
    }
}
StringFilterMenuInputComponent.ɵfac = function StringFilterMenuInputComponent_Factory(t) { return new (t || StringFilterMenuInputComponent)(); };
StringFilterMenuInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StringFilterMenuInputComponent, selectors: [["kendo-treelist-string-filter-menu-input"]], inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService" }, decls: 2, vars: 8, consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService"], ["kendoFilterInput", "", 1, "k-textbox", 3, "filterDelay", "ngModel"]], template: function StringFilterMenuInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-menu-input-wrapper", 0);
        ɵngcc0.ɵɵelement(1, "input", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("filterDelay", 0)("ngModel", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    } }, directives: [FilterMenuInputWrapperComponent, ɵngcc7.DefaultValueAccessor, FilterInputDirective, ɵngcc7.NgControlStatus, ɵngcc7.NgModel], encapsulation: 2 });
StringFilterMenuInputComponent.propDecorators = {
    operators: [{ type: Input }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    operator: [{ type: Input }],
    currentFilter: [{ type: Input }],
    filterService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StringFilterMenuInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-string-filter-menu-input',
                template: `
        <kendo-treelist-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            >
            <input class="k-textbox" kendoFilterInput [filterDelay]="0" [ngModel]="currentFilter?.value" />
        </kendo-treelist-filter-menu-input-wrapper>
    `
            }]
    }], function () { return []; }, { operators: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], operator: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }] }); })();

/**
 * Represents a string-filter menu component.
 * ([see example]({% slug builtinfiltertemplate_treelist %}#toc-configuration-components-for-filter-templates)).
 */
class StringFilterMenuComponent extends StringFilterComponent {
    constructor(localization) {
        super(null, localization);
        this.logicOperators = logicOperators(this.localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        /**
         * Determines if the inputs of second criteria will displayed.
         */
        this.extra = true;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.localization);
        super.localizationChange();
    }
}
StringFilterMenuComponent.ɵfac = function StringFilterMenuComponent_Factory(t) { return new (t || StringFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
StringFilterMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StringFilterMenuComponent, selectors: [["kendo-treelist-string-filter-menu"]], hostVars: 2, hostBindings: function StringFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", extra: "extra", column: "column", filterService: "filterService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 7, consts: [[3, "currentFilter", "operators", "filterService", "column", "filter"], ["class", "k-filter-and", "textField", "text", "valueField", "value", 3, "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", 4, "ngIf"], ["textField", "text", "valueField", "value", 1, "k-filter-and", 3, "data", "valuePrimitive", "value", "valueChange"], [3, "operators", "currentFilter", "filterService", "column", "filter"]], template: function StringFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "kendo-treelist-string-filter-menu-input", 0);
        ɵngcc0.ɵɵtemplate(1, StringFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 3, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵtemplate(2, StringFilterMenuComponent_kendo_treelist_string_filter_menu_input_2_Template, 1, 5, "kendo-treelist-string-filter-menu-input", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
    } }, directives: [StringFilterMenuInputComponent, ɵngcc4.NgIf, ɵngcc8.DropDownListComponent], encapsulation: 2 });
/** @nocollapse */
StringFilterMenuComponent.ctorParameters = () => [
    { type: LocalizationService }
];
StringFilterMenuComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    extra: [{ type: Input }],
    filterService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StringFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-string-filter-menu',
                template: `
        <kendo-treelist-string-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter">
        </kendo-treelist-string-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-treelist-string-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter">
        </kendo-treelist-string-filter-menu-input>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { filter: [{
            type: Input
        }], extra: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], column: [{
            type: Input
        }], filterService: [{
            type: Input
        }] }); })();

/**
 * Represents a numeric-filter menu component.
 *
 * @example
 *  ```html-no-run
 *      <kendo-treelist-column field="UnitPrice" title="Unit Price">
 *          <ng-template kendoTreeListFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *          <kendo-treelist-numeric-filter-menu
 *              [column]="column"
 *              [filter]="filter"
 *              [filterService]="filterService"
 *              >
 *          </kendo-treelist-numeric-filter-menu>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class NumericFilterMenuComponent extends NumericFilterComponent {
    constructor(localization) {
        super(null, localization);
        this.logicOperators = logicOperators(this.localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        /**
         * Determines if the inputs of second criteria will displayed.
         */
        this.extra = true;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.localization);
        super.localizationChange();
    }
}
NumericFilterMenuComponent.ɵfac = function NumericFilterMenuComponent_Factory(t) { return new (t || NumericFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
NumericFilterMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumericFilterMenuComponent, selectors: [["kendo-treelist-numeric-filter-menu"]], hostVars: 2, hostBindings: function NumericFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", extra: "extra", column: "column", filterService: "filterService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 13, consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step"], ["class", "k-filter-and", "textField", "text", "valueField", "value", 3, "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", 4, "ngIf"], ["textField", "text", "valueField", "value", 1, "k-filter-and", 3, "data", "valuePrimitive", "value", "valueChange"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step"]], template: function NumericFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "kendo-treelist-numeric-filter-menu-input", 0);
        ɵngcc0.ɵɵtemplate(1, NumericFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 3, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵtemplate(2, NumericFilterMenuComponent_kendo_treelist_numeric_filter_menu_input_2_Template, 1, 11, "kendo-treelist-numeric-filter-menu-input", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
    } }, directives: function () { return [NumericFilterMenuInputComponent, ɵngcc4.NgIf, ɵngcc8.DropDownListComponent]; }, encapsulation: 2 });
/** @nocollapse */
NumericFilterMenuComponent.ctorParameters = () => [
    { type: LocalizationService }
];
NumericFilterMenuComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    extra: [{ type: Input }],
    filterService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-numeric-filter-menu',
                template: `
        <kendo-treelist-numeric-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            >
        </kendo-treelist-numeric-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-treelist-numeric-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            >
        </kendo-treelist-numeric-filter-menu-input>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { filter: [{
            type: Input
        }], extra: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], column: [{
            type: Input
        }], filterService: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class NumericFilterMenuInputComponent {
    constructor() {
        this.operators = [];
        /**
         * Specifies the value which is used to increment or decrement the component value.
         * @type {numeric}
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered.
         * @type {boolean}
         */
        this.spinners = true;
    }
}
NumericFilterMenuInputComponent.ɵfac = function NumericFilterMenuInputComponent_Factory(t) { return new (t || NumericFilterMenuInputComponent)(); };
NumericFilterMenuInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumericFilterMenuInputComponent, selectors: [["kendo-treelist-numeric-filter-menu-input"]], inputs: { operators: "operators", step: "step", spinners: "spinners", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", min: "min", max: "max", decimals: "decimals", format: "format" }, decls: 2, vars: 15, consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService"], ["kendoFilterInput", "", 3, "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "step"]], template: function NumericFilterMenuInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-menu-input-wrapper", 0);
        ɵngcc0.ɵɵelement(1, "kendo-numerictextbox", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("filterDelay", 0)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step);
    } }, directives: [FilterMenuInputWrapperComponent, ɵngcc6.NumericTextBoxComponent, FilterInputDirective], encapsulation: 2 });
NumericFilterMenuInputComponent.propDecorators = {
    operators: [{ type: Input }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    operator: [{ type: Input }],
    currentFilter: [{ type: Input }],
    filterService: [{ type: Input }],
    step: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    spinners: [{ type: Input }],
    decimals: [{ type: Input }],
    format: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericFilterMenuInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-numeric-filter-menu-input',
                template: `
        <kendo-treelist-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            >
            <kendo-numerictextbox
                kendoFilterInput
                [filterDelay]="0"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step">
            </kendo-numerictextbox>
        </kendo-treelist-filter-menu-input-wrapper>
    `
            }]
    }], function () { return []; }, { operators: [{
            type: Input
        }], step: [{
            type: Input
        }], spinners: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], operator: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], decimals: [{
            type: Input
        }], format: [{
            type: Input
        }] }); })();

/**
 * Represents a date-filter menu component.
 *
 * @example
 *  ```html-no-run
 *      <kendo-treelist-column field="OrderDate" title="Order Date">
 *          <ng-template kendoTreeListFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *            <kendo-treelist-date-filter-menu
 *                [column]="column"
 *                [filter]="filter"
 *                [filterService]="filterService"
 *                >
 *            </kendo-treelist-date-filter-menu>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class DateFilterMenuComponent extends DateFilterComponent {
    constructor(localization) {
        super(null, localization);
        this.logicOperators = logicOperators(this.localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        /**
         * Determines if the inputs of second criteria will be displayed.
         */
        this.extra = true;
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.localization);
        super.localizationChange();
    }
}
DateFilterMenuComponent.ɵfac = function DateFilterMenuComponent_Factory(t) { return new (t || DateFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
DateFilterMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DateFilterMenuComponent, selectors: [["kendo-treelist-date-filter-menu"]], hostVars: 2, hostBindings: function DateFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", extra: "extra", column: "column", filterService: "filterService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 16, consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber"], ["class", "k-filter-and", "textField", "text", "valueField", "value", 3, "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", 4, "ngIf"], ["textField", "text", "valueField", "value", 1, "k-filter-and", 3, "data", "valuePrimitive", "value", "valueChange"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber"]], template: function DateFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "kendo-treelist-date-filter-menu-input", 0);
        ɵngcc0.ɵɵtemplate(1, DateFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 3, "kendo-dropdownlist", 1);
        ɵngcc0.ɵɵtemplate(2, DateFilterMenuComponent_kendo_treelist_date_filter_menu_input_2_Template, 1, 14, "kendo-treelist-date-filter-menu-input", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.extra);
    } }, directives: function () { return [DateFilterMenuInputComponent, ɵngcc4.NgIf, ɵngcc8.DropDownListComponent]; }, encapsulation: 2 });
/** @nocollapse */
DateFilterMenuComponent.ctorParameters = () => [
    { type: LocalizationService }
];
DateFilterMenuComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    extra: [{ type: Input }],
    filterService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-date-filter-menu',
                template: `
        <kendo-treelist-date-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            >
        </kendo-treelist-date-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-treelist-date-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            >
        </kendo-treelist-date-filter-menu-input>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { filter: [{
            type: Input
        }], extra: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], column: [{
            type: Input
        }], filterService: [{
            type: Input
        }] }); })();

/**
 * Represents a Boolean-filter menu component.
 *
 * @example
 *  ```html-no-run
 *      <kendo-treelist-column field="Discontinued" title="Discontinued">
 *          <ng-template kendoTreeListFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *            <kendo-treelist-boolean-filter-menu
 *                [column]="column"
 *                [filter]="filter"
 *                [filterService]="filterService"
 *                >
 *            </kendo-treelist-boolean-filter-menu>
 *          </ng-template>
 *      </kendo-treelist-column>
 *   ```
 */
class BooleanFilterMenuComponent extends BooleanFilterComponent {
    constructor(localization) {
        super(null, localization);
        /**
         * The current menu filter.
         * @type {CompositeFilterDescriptor}
         */
        this.filter = { filters: [], logic: "and" };
        this.idPrefix = guid();
    }
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * @hidden
     */
    radioId(value) {
        return `${this.idPrefix}_${value}`;
    }
    /**
     * @hidden
     */
    onChange(value) {
        this.applyFilter(this.updateFilter({
            field: this.column.field,
            operator: "eq",
            value: value
        }));
    }
    /**
     * @hidden
     */
    isSelected(radioValue) {
        return this.filtersByField(this.column.field).some(({ value }) => value === radioValue);
    }
}
BooleanFilterMenuComponent.ɵfac = function BooleanFilterMenuComponent_Factory(t) { return new (t || BooleanFilterMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
BooleanFilterMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BooleanFilterMenuComponent, selectors: [["kendo-treelist-boolean-filter-menu"]], hostVars: 2, hostBindings: function BooleanFilterMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-filtercell", ctx.hostClasses);
    } }, inputs: { filter: "filter", filterService: "filterService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "k-radio-list", "k-reset"], [4, "ngFor", "ngForOf"], ["type", "radio", 1, "k-radio", 3, "name", "checked", "change"], [1, "k-radio-label"]], template: function BooleanFilterMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, BooleanFilterMenuComponent_li_1_Template, 4, 5, "li", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc4.NgForOf], encapsulation: 2 });
/** @nocollapse */
BooleanFilterMenuComponent.ctorParameters = () => [
    { type: LocalizationService }
];
BooleanFilterMenuComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-filtercell',] }],
    filter: [{ type: Input }],
    filterService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BooleanFilterMenuComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-boolean-filter-menu',
                template: `
        <ul class="k-radio-list k-reset">
            <li *ngFor="let item of items">
                <input type="radio"
                    [name]="idPrefix"
                    class="k-radio"
                    [checked]="isSelected(item.value)"
                    [attr.id]="radioId(item.value)"
                    (change)="onChange(item.value)"
                />
                <label class="k-radio-label" [attr.for]="radioId(item.value)">{{item.text}}</label>
            </li>
        </ul>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { filter: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-filtercell']
        }], filterService: [{
            type: Input
        }] }); })();

/**
 * @hidden
 *
 * > List the following components as `entryComponents` in the TreeListModule.
 */
const filterMenuComponentFactory = (type) => ({
    "boolean": BooleanFilterMenuComponent,
    "date": DateFilterMenuComponent,
    "numeric": NumericFilterMenuComponent,
    "text": StringFilterMenuComponent
}[type]);

/**
 * @hidden
 */
class FilterMenuHostDirective extends FilterHostDirective {
    constructor(host, resolver) {
        super(host, resolver);
    }
    componentType() {
        if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {
            return filterMenuComponentFactory(this.column.filter);
        }
        return StringFilterMenuComponent;
    }
    initComponent(ctx) {
        super.initComponent(ctx);
        this.component.instance.filterService = this.filterService;
    }
}
FilterMenuHostDirective.ɵfac = function FilterMenuHostDirective_Factory(t) { return new (t || FilterMenuHostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
FilterMenuHostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilterMenuHostDirective, selectors: [["", "kendoFilterMenuHost", ""]], inputs: { filterService: "filterService" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FilterMenuHostDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
FilterMenuHostDirective.propDecorators = {
    filterService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterMenuHostDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoFilterMenuHost]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }]; }, { filterService: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class DateFilterMenuInputComponent {
    constructor(popupService) {
        this.popupService = popupService;
        this.operators = [];
    }
    open(picker) {
        this.subscription = this.popupService.onClose
            .pipe(filter(() => picker.isActive))
            .subscribe(e => e.preventDefault());
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
DateFilterMenuInputComponent.ɵfac = function DateFilterMenuInputComponent_Factory(t) { return new (t || DateFilterMenuInputComponent)(ɵngcc0.ɵɵdirectiveInject(SinglePopupService)); };
DateFilterMenuInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DateFilterMenuInputComponent, selectors: [["kendo-treelist-date-filter-menu-input"]], inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", format: "format", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", min: "min", max: "max", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber" }, decls: 3, vars: 17, consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService"], ["kendoFilterInput", "", 3, "filterDelay", "value", "placeholder", "formatPlaceholder", "format", "min", "max", "activeView", "bottomView", "topView", "weekNumber", "open"], ["picker", ""]], template: function DateFilterMenuInputComponent_Template(rf, ctx) { if (rf & 1) {
        const _r1 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-filter-menu-input-wrapper", 0);
        ɵngcc0.ɵɵelementStart(1, "kendo-datepicker", 1, 2);
        ɵngcc0.ɵɵlistener("open", function DateFilterMenuInputComponent_Template_kendo_datepicker_open_1_listener() { ɵngcc0.ɵɵrestoreView(_r1); const _r0 = ɵngcc0.ɵɵreference(2); return ctx.open(_r0); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("filterDelay", 0)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("placeholder", ctx.placeholder)("formatPlaceholder", ctx.formatPlaceholder)("format", ctx.format)("min", ctx.min)("max", ctx.max)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("weekNumber", ctx.weekNumber);
    } }, directives: [FilterMenuInputWrapperComponent, ɵngcc9.DatePickerComponent, FilterInputDirective], encapsulation: 2 });
/** @nocollapse */
DateFilterMenuInputComponent.ctorParameters = () => [
    { type: SinglePopupService }
];
DateFilterMenuInputComponent.propDecorators = {
    operators: [{ type: Input }],
    column: [{ type: Input }],
    filter: [{ type: Input }],
    operator: [{ type: Input }],
    currentFilter: [{ type: Input }],
    filterService: [{ type: Input }],
    format: [{ type: Input }],
    formatPlaceholder: [{ type: Input }],
    placeholder: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    activeView: [{ type: Input }],
    bottomView: [{ type: Input }],
    topView: [{ type: Input }],
    weekNumber: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateFilterMenuInputComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-date-filter-menu-input',
                template: `
        <kendo-treelist-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            >
            <kendo-datepicker
                #picker
                kendoFilterInput
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber"
                >
            </kendo-datepicker>
        </kendo-treelist-filter-menu-input-wrapper>
    `
            }]
    }], function () { return [{ type: SinglePopupService }]; }, { operators: [{
            type: Input
        }], column: [{
            type: Input
        }], filter: [{
            type: Input
        }], operator: [{
            type: Input
        }], currentFilter: [{
            type: Input
        }], filterService: [{
            type: Input
        }], format: [{
            type: Input
        }], formatPlaceholder: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activeView: [{
            type: Input
        }], bottomView: [{
            type: Input
        }], topView: [{
            type: Input
        }], weekNumber: [{
            type: Input
        }] }); })();

const INTERNAL_COMPONENTS$2 = [
    FilterMenuComponent,
    FilterMenuContainerComponent,
    FilterMenuInputWrapperComponent,
    StringFilterMenuInputComponent,
    StringFilterMenuComponent,
    FilterMenuTemplateDirective,
    NumericFilterMenuComponent,
    NumericFilterMenuInputComponent,
    DateFilterMenuInputComponent,
    DateFilterMenuComponent,
    FilterMenuHostDirective,
    BooleanFilterMenuComponent
];
const ENTRY_COMPONENTS$1 = [
    StringFilterMenuComponent,
    NumericFilterMenuComponent,
    DateFilterMenuComponent,
    BooleanFilterMenuComponent
];
/**
 * @hidden
 */
class FilterMenuModule {
    static exports() {
        return [
            StringFilterMenuComponent,
            FilterMenuTemplateDirective,
            NumericFilterMenuComponent,
            DateFilterMenuComponent,
            BooleanFilterMenuComponent,
            SharedFilterModule.exports()
        ];
    }
}
FilterMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FilterMenuModule });
FilterMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FilterMenuModule_Factory(t) { return new (t || FilterMenuModule)(); }, imports: [[SharedFilterModule],
        SharedFilterModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FilterMenuModule, { declarations: [FilterMenuComponent,
        FilterMenuContainerComponent,
        FilterMenuInputWrapperComponent,
        StringFilterMenuInputComponent,
        StringFilterMenuComponent,
        FilterMenuTemplateDirective,
        NumericFilterMenuComponent,
        NumericFilterMenuInputComponent,
        DateFilterMenuInputComponent,
        DateFilterMenuComponent,
        FilterMenuHostDirective,
        BooleanFilterMenuComponent], imports: [SharedFilterModule], exports: [FilterMenuComponent,
        FilterMenuContainerComponent,
        FilterMenuInputWrapperComponent,
        StringFilterMenuInputComponent,
        StringFilterMenuComponent,
        FilterMenuTemplateDirective,
        NumericFilterMenuComponent,
        NumericFilterMenuInputComponent,
        DateFilterMenuInputComponent,
        DateFilterMenuComponent,
        FilterMenuHostDirective,
        BooleanFilterMenuComponent,
        SharedFilterModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilterMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [INTERNAL_COMPONENTS$2],
                entryComponents: ENTRY_COMPONENTS$1,
                exports: [INTERNAL_COMPONENTS$2, SharedFilterModule],
                imports: [SharedFilterModule]
            }]
    }], null, null); })();

// TODO
// tslint:disable:rxjs-no-unsafe-takeuntil
/**
 * @hidden
 */
const preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);
const isDeleteButton = or(hasClass("k-i-group-delete"), hasClass("k-button-icon"));
const isSortIcon = or(hasClass("k-i-sort-asc-sm"), hasClass("k-i-sort-desc-sm"));
const skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName("label")));
const elementUnderCursor = ({ clientX, clientY }) => document.elementFromPoint(clientX, clientY);
const hideThenShow = (element, cont) => {
    element.style.display = 'none';
    const result = cont();
    element.style.display = 'block';
    return result;
};
/**
 * @hidden
 */
class DraggableColumnDirective {
    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
        this.draggable = draggable;
        this.element = element;
        this.zone = zone;
        this.service = service;
        this.hint = hint;
        this.cue = cue;
        this.nav = nav;
        this.renderer = renderer;
        this.context = {};
        this.drag = new EventEmitter();
        this.subscriptions = new Subscription();
    }
    set enableDrag(enabled) {
        this.enabled = enabled;
        this.updateTouchAction();
    }
    get hostClass() {
        return this.enabled;
    }
    ngOnInit() {
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(_ => this.enabled), filter(({ originalEvent: { target } }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
            const originalEvent = e.originalEvent;
            if (!e.isTouch) {
                originalEvent.preventDefault();
            }
            this.nav.navigateTo(originalEvent.target);
        }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap(down => {
            this.hint.create(down, this.element.nativeElement, this.context.hint);
            this.cue.create();
        }), switchMap(down => this.draggable.kendoDrag.pipe(tap((e) => {
            if (e.isTouch) {
                e.originalEvent.preventDefault();
            }
        }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map(move => ({ move, down })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    drop(upEvent) {
        this.hint.remove();
        this.cue.remove();
        this.service.notifyDrop(this, upEvent);
    }
    performDrag({ move }) {
        this.hint.move(move);
        const cursorElement = this.elementUnderCursor(move);
        if (cursorElement) {
            this.service.notifyDrag(this, cursorElement, move);
        }
        this.drag.emit({
            draggable: this,
            mouseEvent: move
        });
    }
    elementUnderCursor(mouseEvent) {
        this.hint.hide();
        let target = elementUnderCursor(mouseEvent);
        if (target && /k-grouping-dropclue/.test(target.className)) {
            target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
        }
        this.hint.show();
        return target;
    }
    updateTouchAction() {
        if (!this.element) {
            return;
        }
        this.renderer.setStyle(this.element.nativeElement, 'touch-action', this.enabled ? 'none' : '');
    }
}
DraggableColumnDirective.ɵfac = function DraggableColumnDirective_Factory(t) { return new (t || DraggableColumnDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.DraggableDirective, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DragAndDropService), ɵngcc0.ɵɵdirectiveInject(DragHintService), ɵngcc0.ɵɵdirectiveInject(DropCueService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
DraggableColumnDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DraggableColumnDirective, selectors: [["", "kendoDraggableColumn", ""]], hostVars: 2, hostBindings: function DraggableColumnDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-draggable-header", ctx.hostClass);
    } }, inputs: { context: "context", enableDrag: "enableDrag" }, outputs: { drag: "drag" } });
/** @nocollapse */
DraggableColumnDirective.ctorParameters = () => [
    { type: DraggableDirective, decorators: [{ type: Host }] },
    { type: ElementRef },
    { type: NgZone },
    { type: DragAndDropService },
    { type: DragHintService },
    { type: DropCueService },
    { type: NavigationService },
    { type: Renderer2 }
];
DraggableColumnDirective.propDecorators = {
    context: [{ type: Input }],
    enableDrag: [{ type: Input }],
    drag: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ['class.k-grid-draggable-header',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableColumnDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDraggableColumn]'
            }]
    }], function () { return [{ type: ɵngcc5.DraggableDirective, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: DragAndDropService }, { type: DragHintService }, { type: DropCueService }, { type: NavigationService }, { type: ɵngcc0.Renderer2 }]; }, { context: [{
            type: Input
        }], drag: [{
            type: Output
        }], enableDrag: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['class.k-grid-draggable-header']
        }] }); })();

const exported = [
    DraggableColumnDirective,
    DropTargetDirective
];
/**
 * @hidden
 */
class DragAndDropModule {
}
DragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DragAndDropModule });
DragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DragAndDropModule_Factory(t) { return new (t || DragAndDropModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, { declarations: [DraggableColumnDirective,
        DropTargetDirective], exports: [DraggableColumnDirective,
        DropTargetDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{
        type: NgModule,
        args: [{
                declarations: [exported],
                exports: [exported]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class ColumnListComponent {
    constructor(element, ngZone, renderer) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.reset = new EventEmitter();
        this.apply = new EventEmitter();
        this.columnChange = new EventEmitter();
        this.autoSync = true;
        this.allowHideAll = false;
        this.actionsClass = 'k-action-buttons';
        this.unlockedCount = 0;
    }
    get className() {
        return true;
    }
    set columns(value) {
        this._columns = value.filter(column => column.includeInChooser !== false);
        this.allColumns = value;
        this.updateColumnState();
    }
    get columns() {
        return this._columns;
    }
    isDisabled(column) {
        return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) ||
            (this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden);
    }
    ngOnInit() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.domSubscriptions = this.renderer.listen(this.element.nativeElement, 'click', (e) => {
                if (hasClasses(e.target, 'k-checkbox')) {
                    if (this.autoSync) {
                        const index = parseInt(e.target.getAttribute('data-index'), 10);
                        const column = this.columns[index];
                        const hidden = !e.target.checked;
                        if (Boolean(column.hidden) !== hidden) {
                            this.ngZone.run(() => {
                                column.hidden = hidden;
                                this.columnChange.emit([column]);
                            });
                        }
                    }
                    else {
                        this.updateDisabled();
                    }
                }
            });
        });
    }
    ngOnDestroy() {
        if (this.domSubscriptions) {
            this.domSubscriptions();
        }
    }
    cancelChanges() {
        this.forEachCheckBox((element, index) => {
            element.checked = !this.columns[index].hidden;
        });
        this.updateDisabled();
        this.reset.emit();
    }
    applyChanges() {
        const changed = [];
        this.forEachCheckBox((element, index) => {
            const column = this.columns[index];
            const hidden = !element.checked;
            if (Boolean(column.hidden) !== hidden) {
                column.hidden = hidden;
                changed.push(column);
            }
        });
        this.updateDisabled();
        this.apply.emit(changed);
    }
    forEachCheckBox(callback) {
        const checkboxes = this.element.nativeElement.getElementsByClassName('k-checkbox');
        const length = checkboxes.length;
        for (let idx = 0; idx < length; idx++) {
            callback(checkboxes[idx], idx);
        }
    }
    updateDisabled() {
        if (this.allowHideAll && !this.hasLocked) {
            return;
        }
        const checkedItems = [];
        this.forEachCheckBox((checkbox, index) => {
            if (checkbox.checked) {
                checkedItems.push({ checkbox, index });
            }
            checkbox.disabled = false;
        });
        if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {
            checkedItems[0].checkbox.disabled = true;
        }
        else if (this.hasLocked && !this.hasUnlockedFiltered) {
            const columns = this.columns;
            const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);
            if (checkedUnlocked.length === 1) {
                checkedUnlocked[0].checkbox.disabled = true;
            }
        }
    }
    updateColumnState() {
        this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;
        this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;
        this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;
        const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);
        if (filteredColumns.length) {
            this.hasFiltered = filteredColumns.length > 0;
            this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;
        }
        else {
            this.hasFiltered = false;
            this.hasUnlockedFiltered = false;
        }
    }
}
ColumnListComponent.ɵfac = function ColumnListComponent_Factory(t) { return new (t || ColumnListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ColumnListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnListComponent, selectors: [["kendo-treelist-columnlist"]], hostVars: 2, hostBindings: function ColumnListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-column-list-wrapper", ctx.className);
    } }, inputs: { autoSync: "autoSync", allowHideAll: "allowHideAll", actionsClass: "actionsClass", columns: "columns", applyText: "applyText", resetText: "resetText" }, outputs: { reset: "reset", apply: "apply", columnChange: "columnChange" }, decls: 3, vars: 2, consts: [[1, "k-column-list"], ["class", "k-column-list-item", 4, "ngFor", "ngForOf"], [3, "ngClass", 4, "ngIf"], [1, "k-column-list-item"], ["type", "checkbox", 1, "k-checkbox", 3, "checked", "disabled"], [1, "k-checkbox-label"], [3, "ngClass"], ["type", "button", 1, "k-button", 3, "click"], ["type", "button", 1, "k-button", "k-primary", 3, "click"]], template: function ColumnListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ColumnListComponent_label_1_Template, 4, 4, "label", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, ColumnListComponent_div_2_Template, 5, 3, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.columns);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.autoSync);
    } }, directives: [ɵngcc4.NgForOf, ɵngcc4.NgIf, ɵngcc4.NgClass], encapsulation: 2 });
/** @nocollapse */
ColumnListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
ColumnListComponent.propDecorators = {
    className: [{ type: HostBinding, args: ["class.k-column-list-wrapper",] }],
    reset: [{ type: Output }],
    apply: [{ type: Output }],
    columnChange: [{ type: Output }],
    columns: [{ type: Input }],
    autoSync: [{ type: Input }],
    allowHideAll: [{ type: Input }],
    applyText: [{ type: Input }],
    resetText: [{ type: Input }],
    actionsClass: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnListComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-columnlist',
                template: `
        <div class="k-column-list">
            <label *ngFor="let column of columns; let index = index;" class='k-column-list-item'>
                <input class="k-checkbox" type="checkbox" [attr.data-index]="index" [checked]="!column.hidden" [disabled]="isDisabled(column)" /><span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button type="button" class="k-button" (click)="cancelChanges()">{{ resetText }}</button>
            <button type="button" class="k-button k-primary" (click)="applyChanges()">{{ applyText }}</button>
        </div>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { reset: [{
            type: Output
        }], apply: [{
            type: Output
        }], columnChange: [{
            type: Output
        }], autoSync: [{
            type: Input
        }], allowHideAll: [{
            type: Input
        }], actionsClass: [{
            type: Input
        }], className: [{
            type: HostBinding,
            args: ["class.k-column-list-wrapper"]
        }], columns: [{
            type: Input
        }], applyText: [{
            type: Input
        }], resetText: [{
            type: Input
        }] }); })();

/**
 * Represents the component for selecting columns in the TreeList. To enable the user to show or hide columns,
 * add the component inside a [`ToolbarTemplate`]({% slug api_treelist_toolbartemplatedirective %}) directive.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/chooser-toolbar/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnChooserComponent {
    constructor(localization, columnInfoService, popupService, ngZone, renderer, changeDetector) {
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.popupService = popupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        /**
         * Specifies if the changes in the visibility of the column will be immediately applied.
         */
        this.autoSync = false;
        /**
         * Specifies if all columns can be hidden.
         */
        this.allowHideAll = true;
    }
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    ngOnDestroy() {
        this.close();
    }
    /**
     * @hidden
     */
    toggle(anchor, template) {
        if (!this.popupRef) {
            const direction = this.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: anchor,
                content: template,
                positionMode: 'absolute',
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction }
            });
            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.localization.rtl ? 'rtl' : 'ltr');
            this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen("document", "click", ({ target }) => {
                if (!closest(target, node => node === this.popupRef.popupElement || node === anchor)) {
                    this.close();
                }
            }));
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close();
        if (changed.length) {
            this.changeDetector.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
    /**
     * @hidden
     */
    onChange(changed) {
        this.changeDetector.markForCheck();
        this.columnInfoService.changeVisibility(changed);
    }
    close() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        this.detachClose();
    }
    detachClose() {
        if (this.closeClick) {
            this.closeClick();
            this.closeClick = null;
        }
    }
}
ColumnChooserComponent.ɵfac = function ColumnChooserComponent_Factory(t) { return new (t || ColumnChooserComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnChooserComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnChooserComponent, selectors: [["kendo-treelist-column-chooser"]], inputs: { autoSync: "autoSync", allowHideAll: "allowHideAll" }, decls: 5, vars: 1, consts: [["type", "button", 1, "k-button", "k-bare", "k-button-icon", 3, "click"], ["anchor", ""], [1, "k-icon", "k-i-columns"], ["template", ""], [1, "k-column-chooser-title"], [3, "columns", "applyText", "resetText", "autoSync", "allowHideAll", "apply", "columnChange"]], template: function ColumnChooserComponent_Template(rf, ctx) { if (rf & 1) {
        const _r6 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("click", function ColumnChooserComponent_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const _r0 = ɵngcc0.ɵɵreference(1); const _r1 = ɵngcc0.ɵɵreference(4); return ctx.toggle(_r0, _r1); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ColumnChooserComponent_ng_template_3_Template, 3, 6, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("title", ctx.localization.get("columns"));
    } }, directives: [ColumnListComponent], encapsulation: 2 });
/** @nocollapse */
ColumnChooserComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: ColumnInfoService },
    { type: PopupService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
ColumnChooserComponent.propDecorators = {
    autoSync: [{ type: Input }],
    allowHideAll: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnChooserComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-column-chooser',
                template: `
        <button #anchor
            type="button"
            (click)="toggle(anchor, template)"
            class="k-button k-bare k-button-icon"
            [attr.title]="localization.get('columns')">
            <span class="k-icon k-i-columns"></span>
        </button>
        <ng-template #template>
            <span class='k-column-chooser-title'>{{ localization.get('columns') }}</span>
            <kendo-treelist-columnlist
                [columns]="columns"
                [applyText]="localization.get('columnsApply')"
                [resetText]="localization.get('columnsReset')"
                [autoSync]="autoSync"
                [allowHideAll]="allowHideAll"
                (apply)="onApply($event)"
                (columnChange)="onChange($event)">
            </kendo-treelist-columnlist>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc1.PopupService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { autoSync: [{
            type: Input
        }], allowHideAll: [{
            type: Input
        }] }); })();

/**
 * Represents the service that is passed to the
 * [`ColumnMenuTemplate`]({% slug api_treelist_columnmenutemplatedirective %}) directive.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-item/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuService {
    constructor() {
        /**
         * @hidden
         */
        this.closeMenu = new EventEmitter();
    }
    /**
     * Closes the column menu.
     */
    close() {
        this.closeMenu.emit();
    }
}
ColumnMenuService.ɵfac = function ColumnMenuService_Factory(t) { return new (t || ColumnMenuService)(); };
ColumnMenuService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ColumnMenuService, factory: ColumnMenuService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class ColumnMenuItemBase {
    constructor() {
        this.hostClass = true;
    }
    ngOnInit() {
        if (isDevMode() && !this.service) {
            throw new Error('The service input of the predefined column menu components is mandatory.');
        }
    }
    /**
     * @hidden
     */
    close() {
        this.service.close();
    }
}
ColumnMenuItemBase.ɵfac = function ColumnMenuItemBase_Factory(t) { return new (t || ColumnMenuItemBase)(); };
ColumnMenuItemBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuItemBase, hostVars: 2, hostBindings: function ColumnMenuItemBase_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-columnmenu-item-wrapper", ctx.hostClass);
    } }, inputs: { service: "service" } });
ColumnMenuItemBase.propDecorators = {
    service: [{ type: Input }],
    hostClass: [{ type: HostBinding, args: ['class.k-columnmenu-item-wrapper',] }]
};


/* tslint:disable:max-line-length */
/**
 * Represents the component for selecting columns in the TreeList that can be placed
 * inside a [`ColumnMenuTemplate`]({% slug api_treelist_columnmenutemplatedirective %}) directive.
 *
 * > You have to set the [ColumnMenuService]({% slug api_treelist_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-treelist-columnmenu-chooser` component.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-chooser/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuChooserComponent extends ColumnMenuItemBase {
    constructor(localization, columnInfoService, changeDetector) {
        super();
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        /**
         * Specifies if the content is expanded.
         */
        this.expanded = false;
        /**
         * @hidden
         */
        this.actionsClass = 'k-columnmenu-actions';
    }
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close();
        if (changed.length) {
            this.changeDetector.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
}
ColumnMenuChooserComponent.ɵfac = function ColumnMenuChooserComponent_Factory(t) { return new (t || ColumnMenuChooserComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnMenuChooserComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuChooserComponent, selectors: [["kendo-treelist-columnmenu-chooser"]], inputs: { expanded: "expanded" }, outputs: { expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["icon", "columns", 3, "text", "expanded", "collapse", "expand"], ["kendoTreeListColumnMenuItemContentTemplate", ""], [3, "applyText", "resetText", "columns", "autoSync", "allowHideAll", "actionsClass", "apply"]], template: function ColumnMenuChooserComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("collapse", function ColumnMenuChooserComponent_Template_kendo_treelist_columnmenu_item_collapse_0_listener() { return ctx.collapse.emit(); })("expand", function ColumnMenuChooserComponent_Template_kendo_treelist_columnmenu_item_expand_0_listener() { return ctx.expand.emit(); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuChooserComponent_ng_template_1_Template, 1, 6, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("columns"))("expanded", ctx.expanded);
    } }, directives: function () { return [ColumnMenuItemComponent,
        ColumnMenuItemContentTemplateDirective,
        ColumnListComponent]; }, encapsulation: 2 });
/** @nocollapse */
ColumnMenuChooserComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: ColumnInfoService },
    { type: ChangeDetectorRef }
];
ColumnMenuChooserComponent.propDecorators = {
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    expanded: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuChooserComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-columnmenu-chooser',
                template: `
        <kendo-treelist-columnmenu-item [text]="localization.get('columns')"
            icon="columns" [expanded]="expanded" (collapse)="collapse.emit()" (expand)="expand.emit()">
            <ng-template kendoTreeListColumnMenuItemContentTemplate>
                <kendo-treelist-columnlist
                    [applyText]="localization.get('columnsApply')"
                    [resetText]="localization.get('columnsReset')"
                    [columns]="columns"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    [actionsClass]="actionsClass"
                    (apply)="onApply($event)">
                </kendo-treelist-columnlist>
            </ng-template>
        </kendo-treelist-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Represents the component for editing column filters in the TreeList that can be placed
 * inside a [`ColumnMenuTemplate`]({% slug api_treelist_columnmenutemplatedirective %}) directive.
 *
 * > You have to set the [ColumnMenuService]({% slug api_treelist_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-treelist-columnmenu-filter` component.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-filter/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuFilterComponent extends ColumnMenuItemBase {
    constructor(localization) {
        super();
        this.localization = localization;
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        /**
         * Specifies if the content is expanded.
         */
        this.expanded = false;
        /**
         * @hidden
         */
        this.actionsClass = 'k-columnmenu-actions';
    }
}
ColumnMenuFilterComponent.ɵfac = function ColumnMenuFilterComponent_Factory(t) { return new (t || ColumnMenuFilterComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
ColumnMenuFilterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuFilterComponent, selectors: [["kendo-treelist-columnmenu-filter"]], inputs: { expanded: "expanded" }, outputs: { expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["icon", "filter", 3, "text", "expanded", "collapse", "expand"], ["kendoTreeListColumnMenuItemContentTemplate", ""], [3, "column", "filter", "actionsClass", "close"]], template: function ColumnMenuFilterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("collapse", function ColumnMenuFilterComponent_Template_kendo_treelist_columnmenu_item_collapse_0_listener() { return ctx.collapse.emit(); })("expand", function ColumnMenuFilterComponent_Template_kendo_treelist_columnmenu_item_expand_0_listener() { return ctx.expand.emit(); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuFilterComponent_ng_template_1_Template, 1, 3, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("filter"))("expanded", ctx.expanded);
    } }, directives: function () { return [ColumnMenuItemComponent,
        ColumnMenuItemContentTemplateDirective,
        FilterMenuContainerComponent]; }, encapsulation: 2 });
/** @nocollapse */
ColumnMenuFilterComponent.ctorParameters = () => [
    { type: LocalizationService }
];
ColumnMenuFilterComponent.propDecorators = {
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    expanded: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuFilterComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-columnmenu-filter',
                template: `
        <kendo-treelist-columnmenu-item [text]="localization.get('filter')" icon="filter"
            [expanded]="expanded" (collapse)="collapse.emit()" (expand)="expand.emit()">
            <ng-template kendoTreeListColumnMenuItemContentTemplate>
                    <kendo-treelist-filter-menu-container
                        [column]="service.column"
                        [filter]="service.filter"
                        [actionsClass]="actionsClass"
                        (close)="close()">
                    </kendo-treelist-filter-menu-container>
                </ng-template>
        </kendo-treelist-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }]; }, { expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Represents the content template of the
 * [`kendo-treelist-columnmenu-item`]({% slug api_treelist_columnmenuitemcomponent %}) component.
 * Provides an option for specifying the content of a column item.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoTreeListColumnMenuItemContentTemplate` directive inside a `<kendo-treelist-columnmenu-item>`.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-item-content/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuItemContentTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ColumnMenuItemContentTemplateDirective.ɵfac = function ColumnMenuItemContentTemplateDirective_Factory(t) { return new (t || ColumnMenuItemContentTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ColumnMenuItemContentTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnMenuItemContentTemplateDirective, selectors: [["", "kendoTreeListColumnMenuItemContentTemplate", ""]] });
/** @nocollapse */
ColumnMenuItemContentTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuItemContentTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListColumnMenuItemContentTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents an item that can be placed inside a
 * [`ColumnMenuTemplate`]({% slug api_treelist_columnmenutemplatedirective %}) directive.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-item/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuItemComponent {
    constructor() {
        /**
         * Fires when the item is clicked.
         */
        this.itemClick = new EventEmitter();
        /**
         * Fires when the content is expanded.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the content is collapsed.
         */
        this.collapse = new EventEmitter();
        this.contentState = 'collapsed';
    }
    get iconClass() {
        return `k-i-${this.icon}`;
    }
    ngOnChanges(changes) {
        if (changes.expanded) {
            this.updateContentState();
        }
    }
    /**
     * @hidden
     */
    onClick(e) {
        this.itemClick.emit(e);
        if (this.contentTemplate) {
            this.expanded = !this.expanded;
            this.updateContentState();
            if (this.expanded) {
                this.expand.emit();
            }
            else {
                this.collapse.emit();
            }
        }
    }
    updateContentState() {
        this.contentState = this.expanded ? 'expanded' : 'collapsed';
    }
}
ColumnMenuItemComponent.ɵfac = function ColumnMenuItemComponent_Factory(t) { return new (t || ColumnMenuItemComponent)(); };
ColumnMenuItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuItemComponent, selectors: [["kendo-treelist-columnmenu-item"]], contentQueries: function ColumnMenuItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, inputs: { expanded: "expanded", icon: "icon", text: "text", selected: "selected", disabled: "disabled" }, outputs: { itemClick: "itemClick", expand: "expand", collapse: "collapse" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 7, consts: [[1, "k-columnmenu-item", 3, "click"], ["class", "k-icon", 3, "ngClass", 4, "ngIf"], ["style", "overflow:hidden;", "class", "k-columnmenu-item-content", 4, "ngIf"], [1, "k-icon", 3, "ngClass"], [1, "k-columnmenu-item-content", 2, "overflow", "hidden"], [3, "ngTemplateOutlet"]], template: function ColumnMenuItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function ColumnMenuItemComponent_Template_div_click_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵtemplate(1, ColumnMenuItemComponent_span_1_Template, 1, 1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ColumnMenuItemComponent_div_3_Template, 3, 2, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-state-selected", ctx.selected)("k-state-disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.text, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentTemplate);
    } }, directives: [ɵngcc4.NgIf, ɵngcc4.NgClass, ɵngcc4.NgTemplateOutlet], encapsulation: 2, data: { animation: [
            trigger('state', [
                state('collapsed', style({ display: 'none' })),
                state('expanded', style({ display: 'block' })),
                transition('collapsed => expanded', [
                    style({
                        height: '0px',
                        display: 'block'
                    }),
                    animate('100ms ease-in', style({
                        height: '*'
                    }))
                ]),
                transition('expanded => collapsed', [
                    style({
                        height: '*'
                    }),
                    animate('100ms ease-in', style({
                        height: '0px'
                    }))
                ])
            ])
        ] } });
ColumnMenuItemComponent.propDecorators = {
    itemClick: [{ type: Output }],
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    icon: [{ type: Input }],
    text: [{ type: Input }],
    selected: [{ type: Input }],
    disabled: [{ type: Input }],
    expanded: [{ type: Input }],
    contentTemplate: [{ type: ContentChild, args: [ColumnMenuItemContentTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuItemComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('state', [
                        state('collapsed', style({ display: 'none' })),
                        state('expanded', style({ display: 'block' })),
                        transition('collapsed => expanded', [
                            style({
                                height: '0px',
                                display: 'block'
                            }),
                            animate('100ms ease-in', style({
                                height: '*'
                            }))
                        ]),
                        transition('expanded => collapsed', [
                            style({
                                height: '*'
                            }),
                            animate('100ms ease-in', style({
                                height: '0px'
                            }))
                        ])
                    ])
                ],
                selector: 'kendo-treelist-columnmenu-item',
                template: `
        <div class="k-columnmenu-item" (click)="onClick($event)" [class.k-state-selected]="selected" [class.k-state-disabled]="disabled">
           <span *ngIf="icon" class="k-icon" [ngClass]="iconClass">
           </span>
           {{ text }}
        </div>
        <div *ngIf="contentTemplate" [@state]="contentState" style="overflow:hidden;" class="k-columnmenu-item-content">
            <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
            </ng-container>
        <div>
    `
            }]
    }], function () { return []; }, { itemClick: [{
            type: Output
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], expanded: [{
            type: Input
        }], icon: [{
            type: Input
        }], text: [{
            type: Input
        }], selected: [{
            type: Input
        }], disabled: [{
            type: Input
        }], contentTemplate: [{
            type: ContentChild,
            args: [ColumnMenuItemContentTemplateDirective]
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Represents a column-menu item for sorting TreeList columns that can be placed inside a
 * [`ColumnMenuTemplate`]({% slug api_treelist_columnmenutemplatedirective %}) directive.
 * Allows the user to sort the column.
 *
 * > You have to set the [ColumnMenuService]({% slug api_treelist_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-treelist-columnmenu-sort` component.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-sort/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuSortComponent extends ColumnMenuItemBase {
    constructor(localization, sortService) {
        super();
        this.localization = localization;
        this.sortService = sortService;
    }
    get sortedAsc() {
        const descriptor = this.descriptor;
        return descriptor && (!descriptor.dir || descriptor.dir === 'asc');
    }
    get sortedDesc() {
        const descriptor = this.descriptor;
        return descriptor && descriptor.dir === 'desc';
    }
    /**
     * @hidden
     */
    toggleSort(dir) {
        const field = this.service.column.field;
        const { mode, allowUnsort } = normalize$1(this.service.sortable);
        const descriptor = this.descriptor;
        const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];
        if (descriptor && descriptor.dir === dir) {
            if (!allowUnsort) {
                return;
            }
        }
        else {
            sort.push({ field, dir });
        }
        this.sortService.sort(sort);
        this.close();
    }
    get descriptor() {
        return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);
    }
}
ColumnMenuSortComponent.ɵfac = function ColumnMenuSortComponent_Factory(t) { return new (t || ColumnMenuSortComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(SortService)); };
ColumnMenuSortComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuSortComponent, selectors: [["kendo-treelist-columnmenu-sort"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 4, consts: [["icon", "sort-asc-sm", 3, "text", "selected", "itemClick"], ["icon", "sort-desc-sm", 3, "text", "selected", "itemClick"]], template: function ColumnMenuSortComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_treelist_columnmenu_item_itemClick_0_listener() { return ctx.toggleSort("asc"); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "kendo-treelist-columnmenu-item", 1);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_treelist_columnmenu_item_itemClick_1_listener() { return ctx.toggleSort("desc"); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("sortAscending"))("selected", ctx.sortedAsc);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("text", ctx.localization.get("sortDescending"))("selected", ctx.sortedDesc);
    } }, directives: [ColumnMenuItemComponent], encapsulation: 2 });
/** @nocollapse */
ColumnMenuSortComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: SortService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuSortComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-columnmenu-sort',
                template: `
        <kendo-treelist-columnmenu-item [text]="localization.get('sortAscending')"
            icon="sort-asc-sm" (itemClick)="toggleSort('asc')" [selected]="sortedAsc">
        </kendo-treelist-columnmenu-item>
        <kendo-treelist-columnmenu-item [text]="localization.get('sortDescending')"
            icon="sort-desc-sm" (itemClick)="toggleSort('desc')" [selected]="sortedDesc">
        </kendo-treelist-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: SortService }]; }, null); })();

const POPUP_CLASS = 'k-grid-columnmenu-popup';
/**
 * Represents the [column menu]({% slug columnmenu_treelist %}) component.
 */
class ColumnMenuComponent {
    constructor(popupService, localization, service) {
        this.popupService = popupService;
        this.localization = localization;
        this.service = service;
        /**
         * @hidden
         */
        this.standalone = true;
        /**
         * The settings for the Column Menu.
         */
        this.settings = {};
        /**
         * @hidden
         */
        this.sortable = true;
        /**
         * @hidden
         */
        this.expandedFilter = false;
        /**
         * @hidden
         */
        this.expandedColumns = false;
        this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this));
    }
    /**
     * @hidden
     */
    get isActive() {
        return (this.hasFilter && filtersByField(this.filter, this.column.field).length > 0) ||
            (!this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field));
    }
    /**
     * @hidden
     */
    get hasFilter() {
        return hasFilter(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasSort() {
        return hasSort(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasColumnChooser() {
        return hasColumnChooser(this.settings);
    }
    /**
     * @hidden
     */
    get hasLock() {
        return hasLock(this.settings, this.column);
    }
    ngOnChanges() {
        this.service.column = this.column;
        this.service.sort = this.sort;
        this.service.filter = this.filter;
        this.service.sortable = this.sortable;
    }
    ngOnDestroy() {
        this.close();
        this.closeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    toggle(e, anchor, template) {
        e.preventDefault();
        this.expandedFilter = !this.hasColumnChooser;
        this.expandedColumns = !this.hasFilter;
        this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASS);
    }
    /**
     * @hidden
     */
    close() {
        this.popupService.destroy();
        this.popupRef = null;
    }
    /**
     * @hidden
     */
    onColumnsExpand() {
        this.expandedColumns = true;
        this.expandedFilter = false;
    }
    /**
     * @hidden
     */
    onFilterExpand() {
        this.expandedFilter = true;
        this.expandedColumns = false;
    }
}
ColumnMenuComponent.ɵfac = function ColumnMenuComponent_Factory(t) { return new (t || ColumnMenuComponent)(ɵngcc0.ɵɵdirectiveInject(SinglePopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnMenuService)); };
ColumnMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuComponent, selectors: [["kendo-treelist-column-menu"]], hostVars: 2, hostBindings: function ColumnMenuComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-column-menu-standalone", ctx.standalone);
    } }, inputs: { standalone: "standalone", settings: "settings", sortable: "sortable", column: "column", sort: "sort", filter: "filter", columnMenuTemplate: "columnMenuTemplate" }, features: [ɵngcc0.ɵɵProvidersFeature([ColumnMenuService]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 4, consts: [["href", "#", "tabindex", "-1", 1, "k-grid-column-menu", "k-grid-filter", 3, "ngClass", "click"], ["anchor", ""], [1, "k-icon", "k-i-more-vertical"], ["template", ""], ["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "service", 4, "ngIf"], [3, "service", "expanded", "expand", 4, "ngIf"], [3, "service"], [3, "service", "expanded", "expand"]], template: function ColumnMenuComponent_Template(rf, ctx) { if (rf & 1) {
        const _r13 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "a", 0, 1);
        ɵngcc0.ɵɵlistener("click", function ColumnMenuComponent_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const _r0 = ɵngcc0.ɵɵreference(1); const _r1 = ɵngcc0.ɵɵreference(4); return ctx.toggle($event, _r0, _r1); });
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ColumnMenuComponent_ng_template_3_Template, 1, 5, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, ColumnMenuComponent_ng_template_5_Template, 4, 4, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c132, ctx.isActive));
        ɵngcc0.ɵɵattribute("title", ctx.localization.get("columnMenu"));
    } }, directives: function () { return [ɵngcc4.NgClass, ɵngcc4.NgTemplateOutlet, ɵngcc4.NgIf, ColumnMenuSortComponent,
        ColumnMenuLockComponent,
        ColumnMenuChooserComponent,
        ColumnMenuFilterComponent]; }, encapsulation: 2 });
/** @nocollapse */
ColumnMenuComponent.ctorParameters = () => [
    { type: SinglePopupService },
    { type: LocalizationService },
    { type: ColumnMenuService }
];
ColumnMenuComponent.propDecorators = {
    standalone: [{ type: HostBinding, args: ['class.k-grid-column-menu-standalone',] }, { type: Input }],
    column: [{ type: Input }],
    settings: [{ type: Input }],
    sort: [{ type: Input }],
    filter: [{ type: Input }],
    sortable: [{ type: Input }],
    columnMenuTemplate: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuComponent, [{
        type: Component,
        args: [{
                providers: [ColumnMenuService],
                selector: 'kendo-treelist-column-menu',
                template: `
        <a #anchor
            class="k-grid-column-menu k-grid-filter"
            [ngClass]="{ 'k-state-active': isActive }"
            (click)="toggle($event, anchor, template)"
            href="#"
            tabindex="-1"
            [attr.title]="localization.get('columnMenu')">
            <span class="k-icon k-i-more-vertical"></span>
        </a>
        <ng-template #template>
            <ng-container [ngTemplateOutlet]="column.columnMenuTemplateRef || columnMenuTemplate || defaultTemplate"
                          [ngTemplateOutletContext]="{ service: service, column: column }">
            </ng-container>
        </ng-template>
        <ng-template #defaultTemplate>
            <kendo-treelist-columnmenu-sort *ngIf="hasSort" [service]="service">
            </kendo-treelist-columnmenu-sort>
            <kendo-treelist-columnmenu-lock *ngIf="hasLock" [service]="service">
            </kendo-treelist-columnmenu-lock>
            <kendo-treelist-columnmenu-chooser *ngIf="hasColumnChooser" [service]="service"
                [expanded]="expandedColumns" (expand)="onColumnsExpand()">
            </kendo-treelist-columnmenu-chooser>
            <kendo-treelist-columnmenu-filter *ngIf="hasFilter" [service]="service"
                [expanded]="expandedFilter" (expand)="onFilterExpand()">
            </kendo-treelist-columnmenu-filter>
        </ng-template>
    `
            }]
    }], function () { return [{ type: SinglePopupService }, { type: ɵngcc2.LocalizationService }, { type: ColumnMenuService }]; }, { standalone: [{
            type: HostBinding,
            args: ['class.k-grid-column-menu-standalone']
        }, {
            type: Input
        }], settings: [{
            type: Input
        }], sortable: [{
            type: Input
        }], column: [{
            type: Input
        }], sort: [{
            type: Input
        }], filter: [{
            type: Input
        }], columnMenuTemplate: [{
            type: Input
        }] }); })();

/* tslint:disable:max-line-length */
/**
 * Represents a column-menu item that can be placed inside a
 * [`ColumnMenuTemplate`]({% slug api_treelist_columnmenutemplatedirective %}) directive.
 * Allows the user to lock or unlock the columns.
 *
 * > You have to set the [ColumnMenuService]({% slug api_treelist_columnmenuservice %}) that is passed by
 * > the template to the service input of the `kendo-treelist-columnmenu-lock` component.
 *
 * {% meta height:500 %}
 * {% embed_file column-menu/template-lock/app.component.ts preview %}
 * {% embed_file column-menu/app.module.ts %}
 * {% embed_file column-menu/main.ts %}
 * {% embed_file shared/employees.ts %}
 * {% endmeta %}
 */
class ColumnMenuLockComponent extends ColumnMenuItemBase {
    constructor(localization, columnInfoService, changeDetector) {
        super();
        this.localization = localization;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.localization.get(this.locked ? 'unlock' : 'lock');
    }
    get icon() {
        return this.locked ? 'unlock' : 'lock';
    }
    get disabled() {
        return !this.locked && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.locked);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(locked) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.locked = locked;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeLocked(allChanged);
    }
    get locked() {
        return this.service.column.locked;
    }
}
ColumnMenuLockComponent.ɵfac = function ColumnMenuLockComponent_Factory(t) { return new (t || ColumnMenuLockComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnMenuLockComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnMenuLockComponent, selectors: [["kendo-treelist-columnmenu-lock"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 3, consts: [[3, "text", "icon", "disabled", "itemClick"]], template: function ColumnMenuLockComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "kendo-treelist-columnmenu-item", 0);
        ɵngcc0.ɵɵlistener("itemClick", function ColumnMenuLockComponent_Template_kendo_treelist_columnmenu_item_itemClick_0_listener() { return ctx.toggleColumn(); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("text", ctx.text)("icon", ctx.icon)("disabled", ctx.disabled);
    } }, directives: [ColumnMenuItemComponent], encapsulation: 2 });
/** @nocollapse */
ColumnMenuLockComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: ColumnInfoService },
    { type: ChangeDetectorRef }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuLockComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-columnmenu-lock',
                template: `
       <kendo-treelist-columnmenu-item [text]="text" [icon]="icon" (itemClick)="toggleColumn()" [disabled]="disabled">
       </kendo-treelist-columnmenu-item>
    `
            }]
    }], function () { return [{ type: ɵngcc2.LocalizationService }, { type: ColumnInfoService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

const COMPONENTS$1 = [
    ColumnListComponent,
    ColumnChooserComponent,
    ColumnMenuChooserComponent,
    ColumnMenuFilterComponent,
    ColumnMenuItemComponent,
    ColumnMenuItemContentTemplateDirective,
    ColumnMenuSortComponent,
    ColumnMenuComponent,
    ColumnMenuLockComponent,
    ColumnMenuTemplateDirective
];
/**
 * @hidden
 */
class ColumnMenuModule {
    static exports() {
        return [
            ColumnChooserComponent,
            ColumnMenuFilterComponent,
            ColumnMenuItemComponent,
            ColumnMenuItemContentTemplateDirective,
            ColumnMenuSortComponent,
            ColumnMenuLockComponent,
            ColumnMenuChooserComponent,
            ColumnMenuTemplateDirective,
            ColumnMenuComponent
        ];
    }
}
ColumnMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ColumnMenuModule });
ColumnMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ColumnMenuModule_Factory(t) { return new (t || ColumnMenuModule)(); }, imports: [[CommonModule, FilterMenuModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ColumnMenuModule, { declarations: function () { return [ColumnListComponent,
        ColumnChooserComponent,
        ColumnMenuChooserComponent,
        ColumnMenuFilterComponent,
        ColumnMenuItemComponent,
        ColumnMenuItemContentTemplateDirective,
        ColumnMenuSortComponent,
        ColumnMenuComponent,
        ColumnMenuLockComponent,
        ColumnMenuTemplateDirective]; }, imports: function () { return [CommonModule,
        FilterMenuModule]; }, exports: function () { return [ColumnListComponent,
        ColumnChooserComponent,
        ColumnMenuChooserComponent,
        ColumnMenuFilterComponent,
        ColumnMenuItemComponent,
        ColumnMenuItemContentTemplateDirective,
        ColumnMenuSortComponent,
        ColumnMenuComponent,
        ColumnMenuLockComponent,
        ColumnMenuTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENTS$1],
                imports: [CommonModule, FilterMenuModule],
                exports: [COMPONENTS$1]
            }]
    }], null, null); })();

const exportedModules$1 = [
    HeaderComponent,
    HeaderTemplateDirective,
    ColumnHandleDirective
];
const importedModules$2 = [
    CommonModule,
    RowFilterModule,
    FilterMenuModule,
    SharedModule,
    DragAndDropModule,
    ColumnMenuModule
];
/**
 * @hidden
 */
class HeaderModule {
    static exports() {
        return [
            HeaderTemplateDirective
        ];
    }
}
HeaderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HeaderModule });
HeaderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HeaderModule_Factory(t) { return new (t || HeaderModule)(); }, imports: [[...importedModules$2]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeaderModule, { declarations: [HeaderComponent,
        HeaderTemplateDirective,
        ColumnHandleDirective], imports: [CommonModule,
        RowFilterModule,
        FilterMenuModule,
        SharedModule,
        DragAndDropModule,
        ColumnMenuModule], exports: [HeaderComponent,
        HeaderTemplateDirective,
        ColumnHandleDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeaderModule, [{
        type: NgModule,
        args: [{
                declarations: [exportedModules$1],
                exports: [exportedModules$1],
                imports: [...importedModules$2]
            }]
    }], null, null); })();

/**
 * Represents the command columns of the TreeList. You have to define the content of the
 * column inside an `<ng-template>` tag. The template context is set to the current
 * data item. For more information and examples on using the passed fields
 * and the command directives, refer to the article on
 * [editing the TreeList in Angular Reactive Forms]({% slug editing_reactive_forms_treelist %}).
 *
 * The following additional fields are passed:
 * - `columnIndex`&mdash;The current column index.
 * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex`is `-1`.
 * - `dataItem`&mdash;The current data item.
 * - `column`&mdash;The current column instance.
 * - `isNew`&mdash;The state of the current item.
 *
 * Usually, the template contains CRUD command directives such as:
 * - [`EditCommandDirective`]({% slug api_treelist_editcommanddirective %})
 * - [`RemoveCommandDirective`]({% slug api_treelist_removecommanddirective %})
 * - [`CancelCommandDirective`]({% slug api_treelist_cancelcommanddirective %})
 * - [`SaveCommandDirective`]({% slug api_treelist_savecommanddirective %})
 *
 * {% meta height:590 %}
 * {% embed_file editing/editing-directives/reactive-editing/app.component.ts preview %}
 * {% embed_file shared/employees.ts %}
 * {% embed_file editing/editing-directives/reactive-editing/app.module.ts %}
 * {% embed_file shared/main.ts %}
 * {% endmeta %}
 */
class CommandColumnComponent extends ColumnBase$1 {
    constructor(parent, optionChanges) {
        super(parent, optionChanges);
        this.parent = parent;
        this.isCommand = true;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
}
CommandColumnComponent.ɵfac = function CommandColumnComponent_Factory(t) { return new (t || CommandColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase$1, 13), ɵngcc0.ɵɵdirectiveInject(OptionChangesService)); };
CommandColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CommandColumnComponent, selectors: [["kendo-treelist-command-column"]], contentQueries: function CommandColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CellTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase$1,
                useExisting: forwardRef(() => CommandColumnComponent)
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CommandColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
CommandColumnComponent.ctorParameters = () => [
    { type: ColumnBase$1, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
    { type: OptionChangesService }
];
CommandColumnComponent.propDecorators = {
    template: [{ type: ContentChild, args: [CellTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CommandColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase$1,
                        useExisting: forwardRef(() => CommandColumnComponent)
                    }
                ],
                selector: 'kendo-treelist-command-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase$1, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }, { type: OptionChangesService }]; }, { template: [{
            type: ContentChild,
            args: [CellTemplateDirective]
        }] }); })();

const columnCellIndex = (cell, cells) => {
    for (let idx = 0; idx < cells.length; idx++) {
        if (cells[idx] === cell) {
            return idx;
        }
    }
};
/**
 * @hidden
 */
class TableBodyComponent {
    constructor(changeNotification, editService, localization, ngZone, renderer, element, domEvents, columnInfoService, navigationService, expandState, selection) {
        this.changeNotification = changeNotification;
        this.editService = editService;
        this.localization = localization;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.element = element;
        this.domEvents = domEvents;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.expandState = expandState;
        this.selection = selection;
        this.columns = [];
        this.skip = 0;
        this.noRecordsText = this.localization.get('noRecords');
        this.isLocked = false;
        this.lockedColumnsCount = 0;
        this.totalColumnsCount = 0;
        this.trackBy = defaultTrackBy;
        this.rowClass = () => null;
        this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
        this.trackByWrapper = this.trackByWrapper.bind(this);
        this.trackByColumns = this.trackByColumns.bind(this);
        this.selection.registerTable(this);
    }
    get newDataItem() {
        return this.editService.newDataItem;
    }
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;
    }
    isOdd(item) {
        return item.index % 2 !== 0;
    }
    trackByWrapper(index, item) {
        if (item.type === 'data') {
            item.isEditing = this.editService.isEdited(item.data);
        }
        return this.trackBy(index, item);
    }
    trackByColumns(index, item) {
        return this.virtualColumns ? index : item;
    }
    ngOnChanges(changes) {
        if (isChanged("columns", changes, false)) {
            this.changeNotification.notify();
        }
    }
    addRowLogicalIndex() {
        return this.columnInfoService.totalLevels + 1;
    }
    logicalColIndex(column) {
        if (!isPresent(column.leafIndex)) {
            return -1;
        }
        return column.leafIndex;
    }
    ariaExpanded(item, column) {
        if (!column.expandable || !item.hasChildren) {
            return;
        }
        return Boolean(item.expanded);
    }
    ariaSelected(item, column, columnIndex) {
        if (!this.selection.enabled) {
            return;
        }
        return item.selected || this.isCellSelected(item.data, column, columnIndex);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            const clickHandler = this.clickHandler.bind(this);
            const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);
            const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);
            const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);
            this.clickSubscription = () => {
                mousedownSubscription();
                clickSubscription();
                contextmenuSubscription();
            };
        });
        let originalNoRecordText = this.localization.get('noRecords');
        this.localization.changes.subscribe(() => {
            if (this.noRecordsText === originalNoRecordText) {
                this.noRecordsText = this.localization.get('noRecords');
                originalNoRecordText = this.noRecordsText;
            }
        });
    }
    ngDoCheck() {
        this.headerOffset = this.columnInfoService.totalLevels + (hasFilterRow(this.filterable) ? 1 : 0);
    }
    ngOnDestroy() {
        if (this.clickSubscription) {
            this.clickSubscription();
        }
        this.cellKeydownSubscription.unsubscribe();
        this.selection.unregisterTable(this);
        clearTimeout(this.clickTimeout);
    }
    isEditingCell(item, column) {
        return Boolean(item.editContext && this.editService.isEditingColumn(column));
    }
    isEditingRow(item) {
        return Boolean(item.editContext) || item.isNew;
    }
    get columnsContainer() {
        return this.columnInfoService.columnsContainer;
    }
    get hasFooter() {
        return this.columnsContainer.hasFooter;
    }
    get columnsSpan() {
        return columnsSpan(this.columns);
    }
    get allColumnsSpan() {
        return columnsSpan(this.allColumns || this.columns);
    }
    get colSpan() {
        return this.columnsSpan;
    }
    get footerColumns() {
        return this.isLocked ? this.columnsContainer.lockedColumnsToRender : this.columnsContainer.nonLockedColumnsToRender;
    }
    logicalRowIndex(rowIndex) {
        return 1 + rowIndex + this.headerOffset;
    }
    isCellSelected(dataItem, column, columnIndex) {
        return this.selection.isCellSelected(dataItem, column, columnIndex);
    }
    targetArgs(target, skipFocusable) {
        const { cell, row } = this.targetElements(target);
        if (cell && (!skipFocusable || target === cell || !isFocusableWithTabKey(target, false))) {
            const index = columnCellIndex(cell, row.cells);
            const column = this.columns.toArray()[index];
            const columnIndex = this.lockedColumnsCount + index;
            return {
                item: this.rowItem(row),
                column: column,
                columnIndex: columnIndex
            };
        }
    }
    clickHandler(eventArg) {
        const target = eventArg.target;
        const { cell, row } = this.targetElements(target);
        if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) &&
            !hasClasses(row, NON_DATA_ROW_CLASSES)) {
            if (this.expandClick(eventArg, row) || this.checkboxClick(cell, row, eventArg)) {
                return;
            }
            this.editService.preventCellClose();
            const focusable = target !== cell && isFocusableWithTabKey(target, false);
            if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) &&
                !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell)) {
                const args = this.cellClickArgs(cell, row, eventArg);
                if (!args) {
                    return;
                }
                if (eventArg.type === 'mousedown') {
                    this.domEvents.cellMousedown.emit(args);
                }
                else {
                    if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
                        if (eventArg.type === 'click') {
                            this.clickTimeout = setTimeout(() => {
                                this.emitCellClick(args);
                            }, 0);
                        }
                        else {
                            this.emitCellClick(args);
                        }
                    }
                }
            }
        }
    }
    emitCellClick(args) {
        this.domEvents.cellClick.emit(args);
    }
    cellKeydownHandler(args) {
        if (args.keyCode === Keys.Enter) {
            this.clickHandler(args);
        }
    }
    cellClickArgs(cell, row, eventArg) {
        const index = columnCellIndex(cell, row.cells);
        const column = this.columns.toArray()[index];
        const columnIndex = this.lockedColumnsCount + index;
        const viewItem = this.rowItem(row);
        if (viewItem.type !== 'data') {
            return;
        }
        const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;
        return {
            column: column,
            columnIndex: columnIndex,
            viewItem: viewItem,
            dataItem: viewItem.data,
            index: viewItem.index,
            isEditedColumn: (viewItem.editContext && this.editService.isEditingColumn(column)),
            isEdited: viewItem.isNew || (viewItem.editContext && this.editService.isEditedColumn(column)),
            originalEvent: eventArg,
            type: type
        };
    }
    targetElements(target) {
        const element = this.element.nativeElement;
        let cell, row, body, treelistElement;
        let currentTarget = target;
        do {
            cell = closest(currentTarget, matchesNodeName('td'));
            row = closest(cell, matchesNodeName('tr'));
            body = closest(row, matchesNodeName('tbody'));
            currentTarget = body;
            treelistElement = closestInScope(currentTarget, matchesClasses('k-treelist k-grid'), element);
        } while (body && body !== element && !treelistElement);
        if (cell && body === element && !treelistElement) {
            return {
                cell,
                row
            };
        }
        return {};
    }
    expandClick(eventArg, row) {
        if (eventArg.type === 'click' && hasClasses(eventArg.target, 'k-i-expand k-i-collapse')) {
            eventArg.preventDefault();
            const viewItem = this.rowItem(row);
            if (viewItem.type === 'data') {
                this.ngZone.run(() => {
                    this.expandState.toggleState(viewItem.data);
                });
                return true;
            }
        }
    }
    checkboxClick(cell, row, eventArg) {
        if (eventArg.type === 'click' && hasClasses(cell, 'k-checkbox-cell') &&
            this.selection.enabled && this.selection.rowSelection) {
            const args = this.cellClickArgs(cell, row, eventArg);
            this.selection.checkboxClick(args);
            if (eventArg.target.checked !== this.selection.isRowSelected(args.dataItem)) {
                eventArg.preventDefault();
            }
            return true;
        }
    }
    rowItem(row) {
        let viewIndex = row.getAttribute('data-treelist-view-index');
        viewIndex = viewIndex ? parseInt(viewIndex, 10) : -1;
        const viewItem = this.view.at(viewIndex);
        return viewItem;
    }
}
TableBodyComponent.ɵfac = function TableBodyComponent_Factory(t) { return new (t || TableBodyComponent)(ɵngcc0.ɵɵdirectiveInject(ChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DomEventsService), ɵngcc0.ɵɵdirectiveInject(ColumnInfoService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(SelectionService)); };
TableBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableBodyComponent, selectors: [["", "kendoTreeListTableBody", ""]], inputs: { columns: "columns", skip: "skip", noRecordsText: "noRecordsText", isLocked: "isLocked", lockedColumnsCount: "lockedColumnsCount", totalColumnsCount: "totalColumnsCount", trackBy: "trackBy", rowClass: "rowClass", allColumns: "allColumns", noRecordsTemplate: "noRecordsTemplate", view: "view", filterable: "filterable", virtualColumns: "virtualColumns", expandIcons: "expandIcons" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c133, decls: 2, vars: 3, consts: [["class", "k-grid-norecords", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-grid-norecords"], [3, "ngTemplateOutlet", 4, "ngIf"], [4, "ngIf"], [3, "ngTemplateOutlet"], ["kendoTreeListLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "isNew", "ngClass", "k-alt", "k-grid-edit-row", "k-grid-add-row", "k-state-selected", 4, "ngIf"], ["class", "k-footer", "kendoTreeListLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoTreeListLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "isNew", "ngClass"], ["kendoTreeListCell", "", "kendoTreeListLogicalCell", "", "role", "gridcell", 3, "columnIndex", "column", "viewItem", "dataItem", "level", "hasChildren", "isExpanded", "loading", "isNew", "selected", "expandIcons", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "expandable", "ngClass", "k-grid-edit-cell", "k-state-selected", "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoTreeListCell", "", "kendoTreeListLogicalCell", "", "role", "gridcell", 3, "columnIndex", "column", "viewItem", "dataItem", "level", "hasChildren", "isExpanded", "loading", "isNew", "selected", "expandIcons", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "expandable", "ngClass", "ngStyle"], ["kendoTreeListLogicalRow", "", 1, "k-footer", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoTreeListLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "column", "colIndex", "ngClass", "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoTreeListLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "column", "colIndex", "ngClass", "ngStyle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-icon k-i-none", 4, "ngFor", "ngForOf"], [1, "k-icon", "k-i-none"]], template: function TableBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableBodyComponent_tr_0_Template, 4, 3, "tr", 0);
        ɵngcc0.ɵɵtemplate(1, TableBodyComponent_ng_container_1_Template, 3, 2, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.view || (ctx.view.data == null ? null : ctx.view.data.length) === 0 || ctx.view.data == null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.view == null ? null : ctx.view.data)("ngForTrackBy", ctx.trackByWrapper);
    } }, directives: function () { return [ɵngcc4.NgIf, ɵngcc4.NgForOf, ɵngcc4.NgTemplateOutlet, LogicalRowDirective, ɵngcc4.NgClass, CellComponent,
        LogicalCellDirective, ɵngcc4.NgStyle]; }, pipes: function () { return [LevelItemsPipe]; }, encapsulation: 2 });
/** @nocollapse */
TableBodyComponent.ctorParameters = () => [
    { type: ChangeNotificationService },
    { type: EditService },
    { type: LocalizationService },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DomEventsService },
    { type: ColumnInfoService },
    { type: NavigationService },
    { type: ExpandStateService },
    { type: SelectionService }
];
TableBodyComponent.propDecorators = {
    columns: [{ type: Input }],
    allColumns: [{ type: Input }],
    noRecordsTemplate: [{ type: Input }],
    view: [{ type: Input }],
    skip: [{ type: Input }],
    filterable: [{ type: Input }],
    noRecordsText: [{ type: Input }],
    isLocked: [{ type: Input }],
    lockedColumnsCount: [{ type: Input }],
    totalColumnsCount: [{ type: Input }],
    virtualColumns: [{ type: Input }],
    expandIcons: [{ type: Input }],
    trackBy: [{ type: Input }],
    rowClass: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TableBodyComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListTableBody]',
                template: `
    <tr *ngIf="!view || view.data?.length === 0 || view.data == null" class="k-grid-norecords">
        <td [attr.colspan]="colSpan">
            <ng-container *ngIf="noRecordsTemplate?.templateRef" [ngTemplateOutlet]="noRecordsTemplate.templateRef">
            </ng-container>
            <ng-container *ngIf="!noRecordsTemplate?.templateRef">
                {{noRecordsText}}
            </ng-container>
        </td>
    </tr>
    <ng-container *ngFor="let item of view?.data;let rowIndex = index;trackBy: trackByWrapper;">
        <tr *ngIf="item.type === 'data'"
            kendoTreeListLogicalRow
                [dataRowIndex]="item.index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(item.rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [isNew]="item.isNew"
            [ngClass]="rowClass({ dataItem: item.data, index: item.index })"
            [class.k-alt]="isOdd(item)"
            [class.k-grid-edit-row]="isEditingRow(item)"
            [class.k-grid-add-row]="item.isNew"
            [class.k-state-selected]="item.selected"
            [attr.data-treelist-view-index]="rowIndex">

            <td kendoTreeListCell
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [column]="column"
                    [viewItem]="item"
                    [dataItem]="item.data"
                    [level]="item.level"
                    [hasChildren]="item.hasChildren"
                    [isExpanded]="item.expanded"
                    [loading]="item.loading"
                    [isNew]="item.isNew"
                    [selected]="item.selected"
                    [expandIcons]="expandIcons"
                kendoTreeListLogicalCell
                    [logicalRowIndex]="logicalRowIndex(item.rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                    [dataRowIndex]="item.index"
                    [column]="column"
                    [colIndex]="columnIndex"
                    [colSpan]="column.colspan"
                    [expandable]="column.expandable"
                    role="gridcell"
                    [attr.aria-expanded]="ariaExpanded(item, column)"
                    [attr.aria-selected]="ariaSelected(item, column, lockedColumnsCount + columnIndex)"
                [ngClass]="column.cssClass"
                [class.k-grid-edit-cell]="isEditingCell(item, column)"
                [class.k-state-selected]="isCellSelected(item.data, column, lockedColumnsCount + columnIndex)"
                [ngStyle]="column.style"
                [attr.colspan]="column.colspan"
                *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;">
            </td>
        </tr>
        <tr *ngIf="item.type === 'footer' && hasFooter"
            class="k-footer"
            [attr.data-treelist-view-index]="rowIndex"
            kendoTreeListLogicalRow
                [logicalRowIndex]="logicalRowIndex(item.rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount">

            <td kendoTreeListLogicalCell
                    [logicalRowIndex]="logicalRowIndex(item.rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                    [column]="column"
                    [colIndex]="columnIndex"
                [ngClass]="column.footerClass"
                [ngStyle]="column.footerStyle"
                *ngFor="let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;">
                <ng-container *ngIf="column.expandable">
                    <span class="k-icon k-i-none" *ngFor="let item of item.level | levelItems"></span>
                </ng-container>
                <ng-container [ngTemplateOutlet]="column.footerTemplateRef"
                    [ngTemplateOutletContext]="{
                        items: item.items,
                        field: column.field,
                        column: column,
                        columnIndex: columnIndex,
                        aggregates: item.aggregates,
                        $implicit: item.aggregates
                    }">
                </ng-container>
           </td>
        </tr>
    </ng-container>
    `
            }]
    }], function () { return [{ type: ChangeNotificationService }, { type: EditService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: DomEventsService }, { type: ColumnInfoService }, { type: NavigationService }, { type: ExpandStateService }, { type: SelectionService }]; }, { columns: [{
            type: Input
        }], skip: [{
            type: Input
        }], noRecordsText: [{
            type: Input
        }], isLocked: [{
            type: Input
        }], lockedColumnsCount: [{
            type: Input
        }], totalColumnsCount: [{
            type: Input
        }], trackBy: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], allColumns: [{
            type: Input
        }], noRecordsTemplate: [{
            type: Input
        }], view: [{
            type: Input
        }], filterable: [{
            type: Input
        }], virtualColumns: [{
            type: Input
        }], expandIcons: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class CellComponent {
    constructor(editService, focusGroup) {
        this.editService = editService;
        this.focusGroup = focusGroup;
        this.isNew = false;
        this.level = 0;
        this.cellContext = {};
        this._templateContext = {};
        this._editTemplateContext = {};
        this.templateContext.cellContext = this.cellContext;
        this.cellContext.focusGroup = focusGroup;
    }
    get commandCellClass() {
        return this.column.isCommand;
    }
    get checkboxCellClass() {
        return this.column.isCheckboxColumn;
    }
    get textNoWrapClass() {
        return this.column.expandable;
    }
    set viewItem(value) {
        this._viewItem = value;
        this.cellContext.viewItem = this.viewItem;
    }
    get viewItem() {
        return this._viewItem;
    }
    get formGroup() {
        return this.viewItem.isNew ? this.editService.newItemGroup :
            this.viewItem.editContext ? this.viewItem.editContext.group : null;
    }
    get isEdited() {
        return Boolean((this.viewItem.isNew && isColumnEditable(this.column, this.editService.newItemGroup)) ||
            (isColumnEditable(this.column, this.formGroup) &&
                this.viewItem.editContext &&
                this.editService.isEditedColumn(this.column)));
    }
    get templateContext() {
        return this._templateContext;
    }
    get editTemplateContext() {
        this._editTemplateContext.$implicit = this.formGroup;
        this._editTemplateContext.cellContext = this.cellContext;
        this._editTemplateContext.column = this.column;
        this._editTemplateContext.dataItem = this.dataItem;
        this._editTemplateContext.formGroup = this.formGroup;
        this._editTemplateContext.isNew = this.isNew;
        return this._editTemplateContext;
    }
    get format() {
        if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {
            return extractFormat(this.column.format);
        }
        return undefined;
    }
    get isBoundColumn() {
        return this.column.field && !this.column.templateRef;
    }
    get isSpanColumn() {
        return isSpanColumn(this.column) && !this.column.templateRef;
    }
    get childColumns() {
        return columnsToRender([this.column]);
    }
    ngDoCheck() {
        if (this.column.templateRef) {
            this.updateTemplateContext();
        }
    }
    updateTemplateContext() {
        const context = this._templateContext;
        context.$implicit = this.dataItem;
        context.column = this.column;
        context.columnIndex = this.columnIndex;
        context.dataItem = this.dataItem;
        context.hasChildren = this.hasChildren;
        context.isExpanded = this.isExpanded;
        context.isNew = this.isNew;
        context.level = this.level;
        context.loading = this.loading;
        context.rowIndex = this.viewItem.rowIndex;
    }
}
CellComponent.ɵfac = function CellComponent_Factory(t) { return new (t || CellComponent)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(FocusGroup)); };
CellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CellComponent, selectors: [["", "kendoTreeListCell", ""]], hostVars: 6, hostBindings: function CellComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-command-cell", ctx.commandCellClass)("k-checkbox-cell", ctx.checkboxCellClass)("k-text-nowrap", ctx.textNoWrapClass);
    } }, inputs: { isNew: "isNew", level: "level", viewItem: "viewItem", column: "column", columnIndex: "columnIndex", hasChildren: "hasChildren", isExpanded: "isExpanded", loading: "loading", expandIcons: "expandIcons", selected: "selected", dataItem: "dataItem" }, attrs: _c136, decls: 3, vars: 3, consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [3, "ngIf"], ["class", "k-icon k-i-none", 4, "ngFor", "ngForOf"], ["class", "k-icon", 3, "ngClass", 4, "ngIf"], [1, "k-icon", "k-i-none"], [1, "k-icon", 3, "ngClass"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf"], ["type", "checkbox", "kendoTreeListFocusable", "", 1, "k-checkbox", 3, "checked"], [3, "ngSwitch", 4, "ngIf"], ["kendoTreeListFocusable", "", 3, "format", "formControl", 4, "ngSwitchCase"], ["type", "checkbox", "kendoTreeListFocusable", "", 3, "formControl", 4, "ngSwitchCase"], ["type", "text", "class", "k-textbox", "kendoTreeListFocusable", "", 3, "formControl", 4, "ngSwitchDefault"], ["kendoTreeListFocusable", "", 3, "format", "formControl"], ["type", "checkbox", "kendoTreeListFocusable", "", 3, "formControl"], ["type", "text", "kendoTreeListFocusable", "", 1, "k-textbox", 3, "formControl"]], template: function CellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, CellComponent_ng_container_1_Template, 6, 5, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(2, CellComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.isEdited);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    } }, directives: function () { return [ɵngcc4.NgSwitch, ɵngcc4.NgSwitchCase, ɵngcc4.NgIf, ɵngcc4.NgForOf, ɵngcc4.NgClass, ɵngcc4.NgTemplateOutlet, FocusableDirective, ɵngcc4.NgSwitchDefault, ɵngcc6.NumericTextBoxComponent, ɵngcc7.NgControlStatus, ɵngcc7.FormControlDirective, ɵngcc9.DatePickerComponent, ɵngcc7.CheckboxControlValueAccessor, ɵngcc7.DefaultValueAccessor]; }, pipes: function () { return [LevelItemsPipe,
        FieldAccessorPipe]; }, encapsulation: 2 });
/** @nocollapse */
CellComponent.ctorParameters = () => [
    { type: EditService },
    { type: FocusGroup }
];
CellComponent.propDecorators = {
    commandCellClass: [{ type: HostBinding, args: ['class.k-command-cell',] }],
    checkboxCellClass: [{ type: HostBinding, args: ['class.k-checkbox-cell',] }],
    textNoWrapClass: [{ type: HostBinding, args: ['class.k-text-nowrap',] }],
    column: [{ type: Input }],
    columnIndex: [{ type: Input }],
    isNew: [{ type: Input }],
    level: [{ type: Input }],
    hasChildren: [{ type: Input }],
    isExpanded: [{ type: Input }],
    loading: [{ type: Input }],
    expandIcons: [{ type: Input }],
    selected: [{ type: Input }],
    dataItem: [{ type: Input }],
    viewItem: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CellComponent, [{
        type: Component,
        args: [{
                selector: '[kendoTreeListCell]',
                template: `
        <ng-container [ngSwitch]="isEdited">
            <ng-container *ngSwitchCase="false">
                <ng-container *ngIf="column.expandable">
                    <span class="k-icon k-i-none" *ngFor="let item of level | levelItems : hasChildren && expandIcons"></span>
                    <span class="k-icon" *ngIf="hasChildren && expandIcons"
                        [ngClass]="{ 'k-i-collapse': isExpanded && !loading, 'k-i-expand': !isExpanded && !loading, 'k-i-loading': loading }">
                    </span>
                </ng-container>
                <ng-container *ngIf="column.templateRef"
                    [ngTemplateOutlet]="column.templateRef"
                    [ngTemplateOutletContext]="templateContext">
                </ng-container>
                <ng-container *ngIf="isSpanColumn">
                    <ng-container *ngFor="let childColumn of childColumns">
                        {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                    </ng-container>
                </ng-container>
                <ng-container *ngIf="isBoundColumn">{{ dataItem | valueOf: column.field: column.format}}</ng-container>
                <ng-template [ngIf]="column.isCheckboxColumn && !isNew">
                    <input type="checkbox" kendoTreeListFocusable class="k-checkbox" [checked]="selected" />
                </ng-template>
            </ng-container>
            <ng-container *ngSwitchCase="true">
                <ng-container
                    *ngIf="column.editTemplateRef"
                    [ngTemplateOutlet]="column.editTemplateRef"
                    [ngTemplateOutletContext]="editTemplateContext">
                </ng-container>
                <ng-container [ngSwitch]="column.editor" *ngIf="!column.editTemplateRef">
                    <kendo-numerictextbox
                        *ngSwitchCase="'numeric'"
                        [format]="format"
                        [formControl]="formGroup.get(column.field)"
                        kendoTreeListFocusable
                    ></kendo-numerictextbox>

                    <kendo-datepicker
                        *ngSwitchCase="'date'"
                        [format]="format"
                        [formControl]="formGroup.get(column.field)"
                        kendoTreeListFocusable
                    ></kendo-datepicker>

                    <input
                        *ngSwitchCase="'boolean'"
                        type="checkbox"
                        [formControl]="formGroup.get(column.field)"
                        kendoTreeListFocusable
                    />

                    <input
                        *ngSwitchDefault
                        type="text"
                        class="k-textbox"
                        [formControl]="formGroup.get(column.field)"
                        kendoTreeListFocusable
                    />
                </ng-container>
            </ng-container>
        </ng-container>
    `
            }]
    }], function () { return [{ type: EditService }, { type: FocusGroup }]; }, { isNew: [{
            type: Input
        }], level: [{
            type: Input
        }], commandCellClass: [{
            type: HostBinding,
            args: ['class.k-command-cell']
        }], checkboxCellClass: [{
            type: HostBinding,
            args: ['class.k-checkbox-cell']
        }], textNoWrapClass: [{
            type: HostBinding,
            args: ['class.k-text-nowrap']
        }], viewItem: [{
            type: Input
        }], column: [{
            type: Input
        }], columnIndex: [{
            type: Input
        }], hasChildren: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], loading: [{
            type: Input
        }], expandIcons: [{
            type: Input
        }], selected: [{
            type: Input
        }], dataItem: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class BaseCommandDirective extends Button {
    constructor(editService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.editService = editService;
    }
    /**
     * @hidden
     */
    get visible() {
        if (this.cellContext) {
            return this.isEdited !== this.readVisible ? '' : 'none';
        }
    }
    get isEdited() {
        return Boolean(this.cellContext && this.editService.isEdited(this.dataItem) && !this.editService.isEditingCell());
    }
    get dataItem() {
        if (this.cellContext) {
            return this.cellContext.viewItem.data;
        }
    }
    /**
     * @hidden
     */
    clickHandler(e) {
        e.preventDefault();
        this.onClick();
    }
}
BaseCommandDirective.ɵfac = function BaseCommandDirective_Factory(t) { return new (t || BaseCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
BaseCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseCommandDirective, selectors: [["", "kendoTreeListBaseCommand", ""]], hostVars: 2, hostBindings: function BaseCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function BaseCommandDirective_click_HostBindingHandler($event) { return ctx.clickHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.visible);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
BaseCommandDirective.ctorParameters = () => [
    { type: EditService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
BaseCommandDirective.propDecorators = {
    visible: [{ type: HostBinding, args: ['style.display',] }],
    clickHandler: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListBaseCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { visible: [{
            type: HostBinding,
            args: ['style.display']
        }], clickHandler: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

/**
 * Represents the `edit` command of the TreeList. You can apply this directive to any `button`
 * element inside a [`CommandColumnComponent`]({% slug api_treelist_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [`edit`]({% slug api_treelist_treelistcomponent %}#toc-edit) event
 * is triggered ([see example]({% slug editing_treelist %})).
 *
 * > * When the row is in the edit mode, the button with `kendoTreeListEditCommand` is automatically hidden.
 * > * The directive takes as input the `cellContext` from the cell template.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext">
 *       <button [kendoTreeListEditCommand]="cellContext" class="k-primary">Edit</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 *
 */
class EditCommandDirective extends BaseCommandDirective {
    constructor(editService, element, renderer, localization, ngZone) {
        super(editService, element, renderer, localization, ngZone);
        this.commandClass = true;
        this.readVisible = true;
    }
    onClick() {
        if (this.cellContext) {
            this.editService.beginEdit(this.dataItem);
        }
    }
}
EditCommandDirective.ɵfac = function EditCommandDirective_Factory(t) { return new (t || EditCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
EditCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EditCommandDirective, selectors: [["", "kendoTreeListEditCommand", ""]], hostVars: 2, hostBindings: function EditCommandDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-edit-command", ctx.commandClass);
    } }, inputs: { cellContext: ["kendoTreeListEditCommand", "cellContext"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
EditCommandDirective.ctorParameters = () => [
    { type: EditService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
EditCommandDirective.propDecorators = {
    cellContext: [{ type: Input, args: ['kendoTreeListEditCommand',] }],
    commandClass: [{ type: HostBinding, args: ['class.k-grid-edit-command',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EditCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListEditCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-edit-command']
        }], cellContext: [{
            type: Input,
            args: ['kendoTreeListEditCommand']
        }] }); })();

/**
 * Represents the `cancel` command of the TreeList. You can apply this directive to any `button`
 * element inside a [`CommandColumnComponent`]({% slug api_treelist_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [`cancel`]({% slug api_treelist_treelistcomponent %}#toc-cancel) event
 * is triggered ([see example]({% slug editing_treelist %})).
 *
 * > * When the row is not in the edit mode, the button with the `kendoTreeListCancelCommand` is automatically hidden.
 * > * The directive takes as input the `cellContext` from the cell template.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext">
 *       <button [kendoTreeListCancelCommand]="cellContext">Cancel changes</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 *
 * You can control the content of the button based on the state of the row.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext" let-isNew="isNew">
 *       <button [kendoTreeListCancelCommand]="cellContext">{{isNew ? 'Discard' : 'Cancel changes'}}</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 */
class CancelCommandDirective extends BaseCommandDirective {
    constructor(editService, element, renderer, localization, ngZone) {
        super(editService, element, renderer, localization, ngZone);
        this.commandClass = true;
        this.readVisible = false;
    }
    onClick() {
        if (this.cellContext) {
            const viewItem = this.cellContext.viewItem;
            this.editService.endEdit(viewItem.data, viewItem.isNew);
        }
    }
}
CancelCommandDirective.ɵfac = function CancelCommandDirective_Factory(t) { return new (t || CancelCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CancelCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CancelCommandDirective, selectors: [["", "kendoTreeListCancelCommand", ""]], hostVars: 2, hostBindings: function CancelCommandDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-cancel-command", ctx.commandClass);
    } }, inputs: { cellContext: ["kendoTreeListCancelCommand", "cellContext"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
CancelCommandDirective.ctorParameters = () => [
    { type: EditService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
CancelCommandDirective.propDecorators = {
    cellContext: [{ type: Input, args: ['kendoTreeListCancelCommand',] }],
    commandClass: [{ type: HostBinding, args: ['class.k-grid-cancel-command',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CancelCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListCancelCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-cancel-command']
        }], cellContext: [{
            type: Input,
            args: ['kendoTreeListCancelCommand']
        }] }); })();

/**
 * Represents the `save` command of the TreeList. You can apply this directive to any `button`
 * element inside a [`CommandColumnComponent`]({% slug api_treelist_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [`save`]({% slug api_treelist_treelistcomponent %}#toc-save) event
 * is triggered ([see example]({% slug editing_treelist %})).
 *
 * > * When the row is not in the edit mode, the button with `kendoTreeListSaveCommand` is automatically hidden.
 * > * The directive takes as input the `cellContext` from the cell template.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext">
 *       <button [kendoTreeListSaveCommand]="cellContext">Save changes</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 *
 * You can control the content of the button based on the state of the row.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext" let-isNew="isNew">
 *       <button [kendoTreeListSaveCommand]="cellContext">{{isNew ? 'Add' : 'Update'}}</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 */
class SaveCommandDirective extends BaseCommandDirective {
    constructor(editService, element, renderer, localization, ngZone) {
        super(editService, element, renderer, localization, ngZone);
        this.commandClass = true;
        this.readVisible = false;
    }
    onClick() {
        if (this.cellContext) {
            this.editService.save(this.dataItem, this.cellContext.viewItem.isNew);
        }
    }
}
SaveCommandDirective.ɵfac = function SaveCommandDirective_Factory(t) { return new (t || SaveCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SaveCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SaveCommandDirective, selectors: [["", "kendoTreeListSaveCommand", ""]], hostVars: 2, hostBindings: function SaveCommandDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-save-command", ctx.commandClass);
    } }, inputs: { cellContext: ["kendoTreeListSaveCommand", "cellContext"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
SaveCommandDirective.ctorParameters = () => [
    { type: EditService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
SaveCommandDirective.propDecorators = {
    cellContext: [{ type: Input, args: ['kendoTreeListSaveCommand',] }],
    commandClass: [{ type: HostBinding, args: ['class.k-grid-save-command',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SaveCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListSaveCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-save-command']
        }], cellContext: [{
            type: Input,
            args: ['kendoTreeListSaveCommand']
        }] }); })();

/**
 * Represents the `remove` command of the TreeList. You can apply this directive to any `button` element
 * inside a [`CommandColumnComponent`]({% slug api_treelist_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [`remove` event]({% slug api_treelist_treelistcomponent %}#toc-remove)
 * is triggered ([see example]({% slug editing_reactive_forms_treelist %})).
 *
 * > * When the row is in the edit mode, the button with the `kendoTreeListRemoveCommand` is automatically hidden.
 * > * The directive takes as input the `cellContext` from the cell template.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext">
 *       <button [kendoTreeListRemoveCommand]="cellContext">Remove row</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 */
class RemoveCommandDirective extends BaseCommandDirective {
    constructor(editService, element, renderer, localization, ngZone) {
        super(editService, element, renderer, localization, ngZone);
        this.commandClass = true;
        this.readVisible = true;
    }
    onClick() {
        if (this.cellContext) {
            this.editService.remove(this.dataItem, (this.cellContext.viewItem.parent || {}).data);
        }
    }
}
RemoveCommandDirective.ɵfac = function RemoveCommandDirective_Factory(t) { return new (t || RemoveCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
RemoveCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RemoveCommandDirective, selectors: [["", "kendoTreeListRemoveCommand", ""]], hostVars: 2, hostBindings: function RemoveCommandDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-remove-command", ctx.commandClass);
    } }, inputs: { cellContext: ["kendoTreeListRemoveCommand", "cellContext"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
RemoveCommandDirective.ctorParameters = () => [
    { type: EditService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
RemoveCommandDirective.propDecorators = {
    cellContext: [{ type: Input, args: ['kendoTreeListRemoveCommand',] }],
    commandClass: [{ type: HostBinding, args: ['class.k-grid-remove-command',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RemoveCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListRemoveCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-remove-command']
        }], cellContext: [{
            type: Input,
            args: ['kendoTreeListRemoveCommand']
        }] }); })();

/**
 * Represents the command for adding a new item to the TreeList. You can apply this directive to any
 * `button` element inside a [`ToolbarTemplate`]({% slug api_treelist_commandcolumncomponent %}) or
 * inside a [`CommandColumnComponent`]({% slug api_treelist_commandcolumncomponent %}).
 *
 * When an associated button with the directive is clicked, the
 * [`add`]({% slug api_treelist_treelistcomponent %}#toc-add) event is triggered
 * ([see example]({% slug editing_treelist %})).
 *
 * > When the row is in the edit mode, the button with `kendoTreeListAddCommand` is automatically hidden.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *    <ng-template kendoTreeListToolbarTemplate>
 *       <button kendoTreeListAddCommand>Add new</button>
 *    </ng-template>
 * </kendo-treelist>
 * ```
 *
 * When added to the command column, the directive takes as input the `cellContext` from the cell template.
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *   <kendo-treelist-command-column title="command">
 *     <ng-template kendoTreeListCellTemplate let-cellContext="cellContext">
 *       <button [kendoTreeListAddCommand]="cellContext" class="k-primary">Edit</button>
 *     </ng-template>
 *   </kendo-treelist-command-column>
 * </kendo-treelist>
 * ```
 */
class AddCommandDirective extends BaseCommandDirective {
    constructor(editService, element, renderer, localization, ngZone) {
        super(editService, element, renderer, localization, ngZone);
        this.commandClass = true;
        this.readVisible = true;
    }
    onClick() {
        this.editService.beginAdd(this.dataItem);
    }
}
AddCommandDirective.ɵfac = function AddCommandDirective_Factory(t) { return new (t || AddCommandDirective)(ɵngcc0.ɵɵdirectiveInject(EditService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
AddCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AddCommandDirective, selectors: [["", "kendoTreeListAddCommand", ""]], hostVars: 2, hostBindings: function AddCommandDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-add-command", ctx.commandClass);
    } }, inputs: { cellContext: ["kendoTreeListAddCommand", "cellContext"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
AddCommandDirective.ctorParameters = () => [
    { type: EditService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
AddCommandDirective.propDecorators = {
    cellContext: [{ type: Input, args: ['kendoTreeListAddCommand',] }],
    commandClass: [{ type: HostBinding, args: ['class.k-grid-add-command',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AddCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListAddCommand]'
            }]
    }], function () { return [{ type: EditService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { commandClass: [{
            type: HostBinding,
            args: ['class.k-grid-add-command']
        }], cellContext: [{
            type: Input,
            args: ['kendoTreeListAddCommand']
        }] }); })();

/* tslint:disable:pipe-naming */
/**
 * @hidden
 */
class LevelItemsPipe {
    transform(level, hasChildren) {
        const result = [];
        const count = level + 1 - (hasChildren ? 1 : 0);
        for (let idx = 0; idx < count; idx++) {
            result.push(idx);
        }
        return result;
    }
}
LevelItemsPipe.ɵfac = function LevelItemsPipe_Factory(t) { return new (t || LevelItemsPipe)(); };
LevelItemsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "levelItems", type: LevelItemsPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LevelItemsPipe, [{
        type: Pipe,
        args: [{
                name: 'levelItems',
                pure: true
            }]
    }], null, null); })();

const exported$1 = [
    CommandColumnComponent,
    CellTemplateDirective,
    EditTemplateDirective,
    TableBodyComponent,
    NoRecordsTemplateDirective,
    CellComponent,
    BaseCommandDirective,
    EditCommandDirective,
    CancelCommandDirective,
    SaveCommandDirective,
    RemoveCommandDirective,
    AddCommandDirective,
    LevelItemsPipe,
    FooterTemplateDirective
];
const importedModules$3 = [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    SharedModule,
    NumericTextBoxModule,
    DatePickerModule
];
/**
 * @hidden
 */
class BodyModule {
    static exports() {
        return [
            CommandColumnComponent,
            CellTemplateDirective,
            NoRecordsTemplateDirective,
            EditTemplateDirective,
            EditCommandDirective,
            CancelCommandDirective,
            SaveCommandDirective,
            RemoveCommandDirective,
            AddCommandDirective,
            FooterTemplateDirective
        ];
    }
}
BodyModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BodyModule });
BodyModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BodyModule_Factory(t) { return new (t || BodyModule)(); }, imports: [[...importedModules$3]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BodyModule, { declarations: [CommandColumnComponent,
        CellTemplateDirective,
        EditTemplateDirective,
        TableBodyComponent,
        NoRecordsTemplateDirective,
        CellComponent,
        BaseCommandDirective,
        EditCommandDirective,
        CancelCommandDirective,
        SaveCommandDirective,
        RemoveCommandDirective,
        AddCommandDirective,
        LevelItemsPipe,
        FooterTemplateDirective], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        SharedModule,
        NumericTextBoxModule,
        DatePickerModule], exports: [CommandColumnComponent,
        CellTemplateDirective,
        EditTemplateDirective,
        TableBodyComponent,
        NoRecordsTemplateDirective,
        CellComponent,
        BaseCommandDirective,
        EditCommandDirective,
        CancelCommandDirective,
        SaveCommandDirective,
        RemoveCommandDirective,
        AddCommandDirective,
        LevelItemsPipe,
        FooterTemplateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BodyModule, [{
        type: NgModule,
        args: [{
                declarations: [exported$1],
                exports: [exported$1],
                imports: [...importedModules$3]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class ToolbarComponent {
    constructor(treelist) {
        this.treelist = treelist;
        this.context = {};
    }
    get classNames() {
        return 'k-header k-grid-toolbar';
    }
    set position(value) {
        this.context.position = value;
    }
    get toolbarTemplateRef() {
        return this.treelist.toolbarTemplate ? this.treelist.toolbarTemplate.templateRef : undefined;
    }
}
ToolbarComponent.ɵfac = function ToolbarComponent_Factory(t) { return new (t || ToolbarComponent)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent)); };
ToolbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ToolbarComponent, selectors: [["kendo-treelist-toolbar"]], hostVars: 2, hostBindings: function ToolbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.classNames);
    } }, inputs: { position: "position" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function ToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, ToolbarComponent_0_Template, 1, 2, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.toolbarTemplateRef);
    } }, directives: [ɵngcc4.NgIf, ɵngcc4.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
ToolbarComponent.ctorParameters = () => [
    { type: TreeListComponent }
];
ToolbarComponent.propDecorators = {
    classNames: [{ type: HostBinding, args: ['class',] }],
    position: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToolbarComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-toolbar',
                template: `
        <ng-template
            *ngIf="toolbarTemplateRef"
            [ngTemplateOutlet]="toolbarTemplateRef"
            [ngTemplateOutletContext]="context"
            >
        </ng-template>
    `
            }]
    }], function () { return [{ type: TreeListComponent }]; }, { classNames: [{
            type: HostBinding,
            args: ['class']
        }], position: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class EditingDirectiveBase {
    constructor(treelist) {
        this.treelist = treelist;
    }
    /**
     * The edit service that will handle the operations.
     */
    set editService(value) {
        this.userEditService = value;
    }
    get editService() {
        return this.userEditService || this.defaultEditService;
    }
    /**
     * Gets or sets a function that will be called to determine the unique identifier
     * for new items. The function receives the `item` and its `parent` as parameters
     * and must return an ID.
     */
    set newItemId(callback) {
        this.idCallback = callback;
    }
    get newItemId() {
        return this.idCallback;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions = this.treelist.add.subscribe(this.addHandler.bind(this));
        this.subscriptions.add(this.treelist.remove.subscribe(this.removeHandler.bind(this)));
        this.subscriptions.add(this.treelist.cancel.subscribe(this.cancelHandler.bind(this)));
        this.subscriptions.add(this.treelist.save.subscribe(this.saveHandler.bind(this)));
        this.subscriptions.add(merge(this.treelist.dataStateChange, this.treelist.pageChange).subscribe(this.onStateChange.bind(this)));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get defaultEditService() {
        return this.treelist.localEditService;
    }
    addHandler({ parent }) {
        this.parent = parent;
        this.isNew = true;
        if (parent) {
            this.treelist.expand(parent);
        }
        this.treelist.addRow(this.createModel({ isNew: true }), parent);
    }
    saveHandler(args) {
        const item = this.saveModel(args);
        if (item) {
            if (args.isNew) {
                this.editService.create(item, args.parent, this.idCallback ? this.idCallback(item, args.parent) : null);
            }
            else {
                this.editService.update(item);
            }
        }
        this.treelist.closeRow(args.dataItem, args.isNew);
    }
    cancelHandler(args) {
        this.closeEditor(args);
    }
    removeHandler({ dataItem, parent }) {
        const removeItem = (shouldRemove) => {
            if (shouldRemove) {
                this.editService.remove(dataItem, parent);
            }
        };
        if (this.removeConfirmation) {
            const result = this.removeConfirmation(dataItem, parent);
            if (result instanceof Promise) {
                result.then(removeItem);
            }
            else if (result instanceof Observable) {
                result.pipe(take(1)).subscribe(removeItem);
            }
            else {
                removeItem(result);
            }
        }
        else {
            removeItem(true);
        }
    }
    closeEditor(args = { dataItem: this.dataItem, isNew: this.isNew }) {
        this.treelist.closeRow(args.dataItem, args.isNew);
        this.clean();
    }
    clean() {
        this.isNew = false;
        this.dataItem = null;
        this.parent = null;
    }
    onStateChange() {
        this.closeEditor();
    }
}
EditingDirectiveBase.ɵfac = function EditingDirectiveBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
EditingDirectiveBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EditingDirectiveBase, inputs: { editService: "editService", newItemId: "newItemId", removeConfirmation: "removeConfirmation" } });
EditingDirectiveBase.propDecorators = {
    editService: [{ type: Input }],
    newItemId: [{ type: Input }],
    removeConfirmation: [{ type: Input }]
};


/**
 * @hidden
 */
class RowEditingDirectiveBase extends EditingDirectiveBase {
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions
            .add(this.treelist.edit.subscribe(this.editHandler.bind(this)));
    }
    addHandler(args) {
        this.closeEditor();
        super.addHandler(args);
    }
    editHandler(args) {
        this.closeEditor();
        this.dataItem = args.dataItem;
        this.treelist.editRow(args.dataItem, this.createModel(args));
    }
    saveHandler(args) {
        super.saveHandler(args);
        this.clean();
    }
}
RowEditingDirectiveBase.ɵfac = function RowEditingDirectiveBase_Factory(t) { return ɵRowEditingDirectiveBase_BaseFactory(t || RowEditingDirectiveBase); };
RowEditingDirectiveBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RowEditingDirectiveBase, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵRowEditingDirectiveBase_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(RowEditingDirectiveBase);

/**
 * A directive which encapsulates the editing operations of the TreeList when using
 * the Template-Driven Angular Forms ([see example]({% slug editing_directives_treelist %}#toc-the-template-directive)).
 */
class TemplateEditingDirective extends RowEditingDirectiveBase {
    constructor(treelist) {
        super(treelist);
        this.treelist = treelist;
    }
    editHandler(args) {
        super.editHandler(args);
        this.dataItem = args.dataItem;
        this.originalValues = {};
        this.editService.assignValues(this.originalValues, this.dataItem);
    }
    closeEditor(args) {
        if (this.dataItem) {
            this.editService.assignValues(this.dataItem, this.originalValues);
        }
        super.closeEditor(args);
    }
    createModel(args) {
        if (args.isNew) {
            return this.createNewItem();
        }
    }
    saveModel(args) {
        return args.dataItem;
    }
}
TemplateEditingDirective.ɵfac = function TemplateEditingDirective_Factory(t) { return new (t || TemplateEditingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent)); };
TemplateEditingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TemplateEditingDirective, selectors: [["", "kendoTreeListTemplateEditing", ""]], inputs: { createNewItem: ["kendoTreeListTemplateEditing", "createNewItem"] }, exportAs: ["kendoTreeListTemplateEditing"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
TemplateEditingDirective.ctorParameters = () => [
    { type: TreeListComponent }
];
TemplateEditingDirective.propDecorators = {
    createNewItem: [{ type: Input, args: ['kendoTreeListTemplateEditing',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TemplateEditingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListTemplateEditing',
                selector: '[kendoTreeListTemplateEditing]'
            }]
    }], function () { return [{ type: TreeListComponent }]; }, { createNewItem: [{
            type: Input,
            args: ['kendoTreeListTemplateEditing']
        }] }); })();

/**
 * @hidden
 */
const markAllAsTouched = (control) => {
    control.markAsTouched();
    if (control.hasOwnProperty('controls')) {
        let controls = control.controls;
        for (let inner in controls) {
            if (controls.hasOwnProperty(inner)) {
                markAllAsTouched(controls[inner]);
            }
        }
    }
};
/**
 * @hidden
 */
const insertNewItem = (newItem, originalData, treelist, parent) => {
    let insertAt = 0;
    if (!parent && treelist.skip) {
        let firstItem = treelist.view.find(item => item.type === 'data' && !item.isNew);
        let firstRootItem = firstItem;
        let firstOffset = 0;
        if (firstItem.level > 0) {
            while (firstItem.level > 0) {
                firstItem = firstItem.parent;
            }
            firstRootItem = firstItem;
            firstOffset = 1;
        }
        const firstIndex = originalData.indexOf(firstRootItem.data);
        if (firstIndex > 0) {
            insertAt = firstIndex + firstOffset;
        }
    }
    originalData.splice(insertAt, 0, newItem);
};

/**
 * A directive which encapsulates the editing operations of the TreeList when using the
 * Reactive Forms ([see example]({% slug editing_directives_treelist %}#toc-the-reactive-directive)).
 */
class ReactiveEditingDirective extends RowEditingDirectiveBase {
    constructor(treelist) {
        super(treelist);
        this.treelist = treelist;
    }
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
}
ReactiveEditingDirective.ɵfac = function ReactiveEditingDirective_Factory(t) { return new (t || ReactiveEditingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent)); };
ReactiveEditingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ReactiveEditingDirective, selectors: [["", "kendoTreeListReactiveEditing", ""]], inputs: { createFormGroup: ["kendoTreeListReactiveEditing", "createFormGroup"] }, exportAs: ["kendoTreeListReactiveEditing"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
ReactiveEditingDirective.ctorParameters = () => [
    { type: TreeListComponent }
];
ReactiveEditingDirective.propDecorators = {
    createFormGroup: [{ type: Input, args: ['kendoTreeListReactiveEditing',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ReactiveEditingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListReactiveEditing',
                selector: '[kendoTreeListReactiveEditing]'
            }]
    }], function () { return [{ type: TreeListComponent }]; }, { createFormGroup: [{
            type: Input,
            args: ['kendoTreeListReactiveEditing']
        }] }); })();

/**
 * A directive which encapsulates the editing operations of the TreeList when using the in-cell
 * editing with Reactive Forms ([see example]({% slug editing_directives_treelist %}#toc-the-incell-directive)).
 */
class InCellEditingDirective extends EditingDirectiveBase {
    constructor(treelist) {
        super(treelist);
        this.treelist = treelist;
    }
    // Need mixin
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions.add(this.treelist.cellClick.subscribe(this.cellClickHandler.bind(this)));
        this.subscriptions.add(this.treelist.cellClose.subscribe(this.cellCloseHandler.bind(this)));
    }
    removeHandler(args) {
        super.removeHandler(args);
        this.treelist.cancelCell();
    }
    cellClickHandler(args) {
        if (!args.isEdited && args.type === 'click') {
            this.treelist.editCell(args.dataItem, args.columnIndex, this.createFormGroup(args));
        }
    }
    cellCloseHandler(args) {
        const { formGroup, dataItem } = args;
        if (!formGroup.valid) {
            args.preventDefault();
        }
        else if (formGroup.dirty) {
            this.editService.assignValues(dataItem, formGroup.value);
            this.editService.update(dataItem);
        }
    }
}
InCellEditingDirective.ɵfac = function InCellEditingDirective_Factory(t) { return new (t || InCellEditingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent)); };
InCellEditingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: InCellEditingDirective, selectors: [["", "kendoTreeListInCellEditing", ""]], inputs: { createFormGroup: ["kendoTreeListInCellEditing", "createFormGroup"] }, exportAs: ["kendoTreeListInCellEditing"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
InCellEditingDirective.ctorParameters = () => [
    { type: TreeListComponent }
];
InCellEditingDirective.propDecorators = {
    createFormGroup: [{ type: Input, args: ['kendoTreeListInCellEditing',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InCellEditingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListInCellEditing',
                selector: '[kendoTreeListInCellEditing]'
            }]
    }], function () { return [{ type: TreeListComponent }]; }, { createFormGroup: [{
            type: Input,
            args: ['kendoTreeListInCellEditing']
        }] }); })();

class BaseBindingDirective {
    constructor(treelist) {
        this.treelist = treelist;
        this.state = {};
        this.cache = new Map();
        this.originalData = [];
        this.subscriptions = new Subscription();
        this.treelist.fetchChildren = this.fetchChildren.bind(this);
        this.treelist.hasChildren = this.hasChildren.bind(this);
    }
    /**
     * Defines the descriptors by which the data will be sorted.
     */
    set sort(value) {
        this.treelist.sort = this.state.sort = value;
    }
    /**
     * Defines the descriptor by which the data will be filtered.
     */
    set filter(value) {
        this.treelist.filter = this.state.filter = value;
    }
    /**
     * Defines the descriptor by which the data will be filtered.
     */
    set aggregate(value) {
        this._aggregate = value;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.applyState(this.state);
        this.subscriptions.add(this.treelist.dataStateChange
            .subscribe(this.onStateChange.bind(this)));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    ngDoCheck() {
        if (this.dataChanged) {
            this.dataChanged = false;
            this.rebind();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (anyChanged(['sort', 'filter', 'aggregate'], changes)) {
            this.rebind();
        }
    }
    /**
     * @hidden
     */
    onStateChange(state$$1) {
        this.applyState(state$$1);
        this.rebind();
    }
    /**
     * @hidden
     */
    rebind() {
        this.cache.clear();
        this.treelist.data = this.fetchChildren();
    }
    applyState({ sort, filter: filter$$1 }) {
        this.sort = sort;
        this.filter = filter$$1;
    }
    fetchChildren(item) {
        const key = this.itemKey(item);
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        const children = this.getChildren(item);
        let items = this.filterItems(children);
        let aggregates;
        if (items.length) {
            if (this.state.sort) {
                items = process(items, { sort: this.state.sort }).data;
            }
            if (this._aggregate) {
                aggregates = this.calculateAggregates(items);
            }
        }
        const result = {
            data: items,
            aggregates: aggregates
        };
        this.cache.set(key, result);
        return result;
    }
    hasChildren(item) {
        const items = this.fetchChildren(item).data;
        return items && items.length > 0;
    }
    filterItems(items) {
        if (this.state.filter) {
            const filter$$1 = {
                logic: 'or',
                filters: [this.state.filter, {
                        operator: (item) => {
                            const children = this.fetchChildren(item);
                            return Boolean(children.data && children.data.length);
                        }
                    }]
            };
            return process(items, {
                filter: filter$$1
            }).data;
        }
        return items;
    }
    calculateAggregates(items) {
        const list = [];
        const toAdd = items.slice(0);
        while (toAdd.length) {
            const current = toAdd.shift();
            list.push(current);
            if (this.hasChildren(current)) {
                toAdd.push.apply(toAdd, this.fetchChildren(current).data);
            }
        }
        // can accumulate from children aggregates except for average
        // for average we need the children count that have numeric value
        // maybe move the aggregates implementation here ???
        return aggregateBy(list, this._aggregate);
    }
}
BaseBindingDirective.ɵfac = function BaseBindingDirective_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BaseBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseBindingDirective, inputs: { sort: "sort", filter: "filter", aggregate: "aggregate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
BaseBindingDirective.propDecorators = {
    sort: [{ type: Input }],
    filter: [{ type: Input }],
    aggregate: [{ type: Input }]
};


/**
 * @hidden
 */
class HierarchyEditService extends LocalEditService {
    constructor(bindingDirective, localDataChanges) {
        super();
        this.bindingDirective = bindingDirective;
        this.localDataChanges = localDataChanges;
    }
    create(item, parent, _id) {
        const { childrenGetter, childrenSetter, originalData, treelist } = this.bindingDirective;
        if (parent) {
            const children = childrenGetter(parent);
            if (children) {
                children.unshift(item);
            }
            else {
                childrenSetter(parent, [item]);
            }
        }
        else {
            insertNewItem(item, originalData, treelist);
        }
        this.bindingDirective.rebind();
    }
    update(_item) {
        this.bindingDirective.rebind();
    }
    remove(item, parent) {
        const idGetter = this.bindingDirective.treelist.idGetter; // refactor provide idGetter via context service
        const { childrenGetter, originalData } = this.bindingDirective;
        const children = parent ? childrenGetter(parent) : originalData;
        if (children && children.length) {
            const id = idGetter(item);
            const index = children.findIndex(i => idGetter(i) === id);
            if (index >= 0) {
                children.splice(index, 1);
                this.bindingDirective.rebind();
                this.notifyRemove(item);
            }
        }
    }
    notifyRemove(item) {
        if (this.localDataChanges && hasObservers(this.localDataChanges.changes)) {
            const childrenGetter = this.bindingDirective.childrenGetter;
            const toNotify = [item];
            while (toNotify.length) {
                const current = toNotify.shift();
                this.localDataChanges.changes.emit({ action: 'remove', item: current });
                const children = childrenGetter(current);
                if (children && children.length) {
                    toNotify.push.apply(toNotify, children);
                }
            }
        }
    }
}

/**
 * A directive which binds the TreeList to a tree of objects.
 *
 * The directive encapsulates the in-memory handling of data operations such as
 * [sorting]({% slug sorting_treelist %}), [aggregation]({% slug treelist_with_aggregates %})
 * and [filtering]({% slug filtering_treelist %}) ([more information and examples]({% slug databinding_treelist %})).
 */
class HierarchyBindingDirective extends BaseBindingDirective {
    constructor(treelist, localDataChanges) {
        super(treelist);
        this.treelist = treelist;
        this.childrenGetter = getter('items');
        this.childrenSetter = setter('items');
        treelist.localEditService = new HierarchyEditService(this, localDataChanges);
    }
    /**
     *  The name of the field which holds the child data items of the node.
     */
    set childrenField(value) {
        this.childrenGetter = getter(value);
        this.childrenSetter = setter(value);
    }
    /**
     * The array of data which will be used to populate the TreeList.
     */
    set data(value) {
        this.originalData = value || [];
        this.dataChanged = true;
    }
    getChildren(item) {
        return item ? this.childrenGetter(item) || [] : this.originalData;
    }
    itemKey(item) {
        return item;
    }
}
HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) { return new (t || HierarchyBindingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService)); };
HierarchyBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HierarchyBindingDirective, selectors: [["", "kendoTreeListHierarchyBinding", ""]], inputs: { childrenField: "childrenField", data: ["kendoTreeListHierarchyBinding", "data"] }, exportAs: ["kendoTreeListHierarchyBinding"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
HierarchyBindingDirective.ctorParameters = () => [
    { type: TreeListComponent },
    { type: LocalDataChangesService }
];
HierarchyBindingDirective.propDecorators = {
    childrenField: [{ type: Input }],
    data: [{ type: Input, args: ["kendoTreeListHierarchyBinding",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HierarchyBindingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListHierarchyBinding',
                selector: '[kendoTreeListHierarchyBinding]'
            }]
    }], function () { return [{ type: TreeListComponent }, { type: LocalDataChangesService }]; }, { childrenField: [{
            type: Input
        }], data: [{
            type: Input,
            args: ["kendoTreeListHierarchyBinding"]
        }] }); })();

/**
 * @hidden
 */
class FlatEditService extends LocalEditService {
    constructor(bindingDirective, localDataChanges) {
        super();
        this.bindingDirective = bindingDirective;
        this.localDataChanges = localDataChanges;
    }
    create(item, parent, id) {
        const { idGetter, idSetter, parentIdSetter, originalData, treelist } = this.bindingDirective;
        idSetter(item, isPresent(id) ? id : guid());
        if (parent) {
            parentIdSetter(item, idGetter(parent));
        }
        insertNewItem(item, originalData, treelist, parent);
        this.bindingDirective.rebind();
    }
    update(_item) {
        this.bindingDirective.rebind();
    }
    remove(item, _parent) {
        const { idGetter, parentIdGetter, originalData } = this.bindingDirective;
        const toRemove = [item];
        while (toRemove.length) {
            const current = toRemove.shift();
            const id = idGetter(current);
            let itemIndex = -1;
            for (let idx = 0; idx < originalData.length; idx++) {
                const dataItem = originalData[idx];
                if (itemIndex === -1 && idGetter(dataItem) === id) {
                    itemIndex = idx;
                }
                if (parentIdGetter(dataItem) === id) {
                    toRemove.push(dataItem);
                }
            }
            if (itemIndex >= 0) {
                originalData.splice(itemIndex, 1);
                this.notifyRemove(current);
            }
        }
        this.bindingDirective.rebind();
    }
    notifyRemove(item) {
        if (this.localDataChanges) {
            this.localDataChanges.changes.emit({ action: 'remove', item });
        }
    }
}

const ROOT_ID = null;
/**
 * A directive which binds the TreeList to an array of objects by using
 * an ID and parentID field to define the hierarchy.
 *
 * The directive encapsulates the in-memory handling of data operations such as
 * [sorting]({% slug sorting_treelist %}), [aggregation]({% slug treelist_with_aggregates %})
 * and [filtering]({% slug filtering_treelist %}) ([more information and examples]({% slug databinding_treelist %})).
 */
class FlatBindingDirective extends BaseBindingDirective {
    constructor(treelist, localDataChanges) {
        super(treelist);
        this.treelist = treelist;
        this.idGetter = getter('id');
        this.idSetter = setter('id');
        this.parentIdGetter = getter('parentId');
        this.parentIdSetter = setter('parentId');
        treelist.localEditService = new FlatEditService(this, localDataChanges);
    }
    /**
     * The name of the field which contains the identifier of the parent node.
     */
    set parentIdField(value) {
        this.parentIdGetter = getter(value);
        this.parentIdSetter = setter(value);
    }
    /**
     * The name of the field which contains the unique identifier of the node.
     */
    set idField(value) {
        this.idGetter = getter(value);
        this.idSetter = setter(value);
    }
    /**
     * The array of data which will be used to populate the TreeList.
     */
    set data(value) {
        this.originalData = value || [];
        this.dataChanged = true;
    }
    getChildren(item) {
        const id = this.itemKey(item);
        const children = id === ROOT_ID ?
            this.originalData.filter(o => !isPresent(this.parentIdGetter(o))) :
            this.originalData.filter(o => this.parentIdGetter(o) === id);
        return children;
    }
    itemKey(item) {
        return item ? this.idGetter(item) : ROOT_ID;
    }
}
FlatBindingDirective.ɵfac = function FlatBindingDirective_Factory(t) { return new (t || FlatBindingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent), ɵngcc0.ɵɵdirectiveInject(LocalDataChangesService)); };
FlatBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FlatBindingDirective, selectors: [["", "kendoTreeListFlatBinding", ""]], inputs: { parentIdField: "parentIdField", idField: "idField", data: ["kendoTreeListFlatBinding", "data"] }, exportAs: ["kendoTreeListFlatBinding"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
FlatBindingDirective.ctorParameters = () => [
    { type: TreeListComponent },
    { type: LocalDataChangesService }
];
FlatBindingDirective.propDecorators = {
    parentIdField: [{ type: Input }],
    idField: [{ type: Input }],
    data: [{ type: Input, args: ["kendoTreeListFlatBinding",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FlatBindingDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListFlatBinding',
                selector: '[kendoTreeListFlatBinding]'
            }]
    }], function () { return [{ type: TreeListComponent }, { type: LocalDataChangesService }]; }, { parentIdField: [{
            type: Input
        }], idField: [{
            type: Input
        }], data: [{
            type: Input,
            args: ["kendoTreeListFlatBinding"]
        }] }); })();

/**
 * A directive which controls the expanded state of the items
 */
class ExpandableDirective {
    constructor(treelist) {
        this.treelist = treelist;
        /**
         * Fires when the expandedKeys are changed.
         */
        this.expandedKeysChange = new EventEmitter();
        /**
         * Specifies if the items should be initially expanded.
         * @default false
         */
        this.initiallyExpanded = false;
        this.state = new Set();
        this.treelist.isExpanded = this.isExpanded.bind(this);
        this.toggleState = this.toggleState.bind(this);
        this.subscriptions = this.treelist.expandStateChange.subscribe(this.toggleState);
    }
    /**
     * Sets the expanded item keys.
     */
    set expandedKeys(value) {
        if (value !== this._expandedKeys) {
            this._expandedKeys = value;
            this.treelist.updateView();
        }
    }
    get expandedKeys() {
        return Array.from(this.state.keys());
    }
    /**
     * Defines the item key that will be stored in the expandedKeys collection.
     * Defaults to the TreeList idField.
     */
    set expandBy(key) {
        if (isString(key)) {
            this._expandBy = getter(key);
        }
        else {
            this._expandBy = key;
        }
    }
    get keyGetter() {
        return this._expandBy || this.treelist.idGetter;
    }
    /**
     * @hidden
     */
    isExpanded(item) {
        const key = this.keyGetter(item);
        return this.state.has(key) ? !this.initiallyExpanded : this.initiallyExpanded;
    }
    ngOnChanges(changes) {
        if (changes.expandedKeys) {
            this.state = new Set(this._expandedKeys);
        }
        else if (changes.initiallyExpanded) {
            this.state.clear();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    toggleState(args) {
        const key = this.keyGetter(args.dataItem);
        if (Boolean(this.initiallyExpanded) !== args.expand) {
            this.state.add(key);
        }
        else {
            this.state.delete(key);
        }
        this.expandedKeysChange.emit(this.expandedKeys);
    }
}
ExpandableDirective.ɵfac = function ExpandableDirective_Factory(t) { return new (t || ExpandableDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent)); };
ExpandableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ExpandableDirective, selectors: [["", "kendoTreeListExpandable", ""]], inputs: { initiallyExpanded: "initiallyExpanded", expandedKeys: "expandedKeys", expandBy: "expandBy" }, outputs: { expandedKeysChange: "expandedKeysChange" }, exportAs: ["kendoTreeListExpandable"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
ExpandableDirective.ctorParameters = () => [
    { type: TreeListComponent }
];
ExpandableDirective.propDecorators = {
    expandedKeysChange: [{ type: Output }],
    expandedKeys: [{ type: Input }],
    initiallyExpanded: [{ type: Input }],
    expandBy: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandableDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListExpandable',
                selector: '[kendoTreeListExpandable]'
            }]
    }], function () { return [{ type: TreeListComponent }]; }, { expandedKeysChange: [{
            type: Output
        }], initiallyExpanded: [{
            type: Input
        }], expandedKeys: [{
            type: Input
        }], expandBy: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class RowSelectionState {
    constructor() {
        this.keys = new Set();
    }
    clear() {
        this.keys.clear();
    }
    has(key) {
        return this.keys.has(key);
    }
    add(key) {
        this.keys.add(key);
    }
    remove(key) {
        this.keys.delete(key);
    }
    toArray() {
        const result = [];
        this.keys.forEach(key => {
            result.push({ itemKey: key });
        });
        return result;
    }
    fromArray(arr) {
        this.keys.clear();
        arr.forEach(item => {
            this.add(item.itemKey);
        });
    }
}
/**
 * @hidden
 */
class CellSelectionState {
    constructor() {
        this.keys = new Map();
    }
    clear() {
        this.keys.clear();
    }
    has(key, columnKey) {
        return this.keys.has(key) && this.keys.get(key).has(columnKey);
    }
    add(key, columnKey) {
        if (!this.keys.has(key)) {
            this.keys.set(key, new Set());
        }
        const columnSet = this.keys.get(key);
        columnSet.add(columnKey);
    }
    remove(key, columnKey) {
        if (this.keys.has(key)) {
            const columnSet = this.keys.get(key);
            columnSet.delete(columnKey);
            if (!columnSet.size) {
                this.keys.delete(key);
            }
        }
    }
    toArray() {
        const result = [];
        this.forEach((itemKey, columnKey) => {
            result.push({ itemKey, columnKey });
        });
        return result;
    }
    fromArray(state$$1) {
        this.keys.clear();
        state$$1.forEach(item => {
            this.add(item.itemKey, item.columnKey);
        });
    }
    updateColumKeys(changes) {
        let hasChanges = false;
        this.keys.forEach((value, key) => {
            const newKeys = [];
            value.forEach(columnKey => {
                if (changes.has(columnKey)) {
                    newKeys.push(changes.get(columnKey));
                    hasChanges = true;
                }
                else {
                    newKeys.push(columnKey);
                }
            });
            this.keys.set(key, new Set(newKeys));
        });
        return hasChanges;
    }
    forEach(callback) {
        this.keys.forEach((value, key) => {
            value.forEach((columnKey) => {
                callback(key, columnKey);
            });
        });
    }
}
/**
 * @hidden
 */
const createState = (settings) => settings.mode === 'cell' ? new CellSelectionState() : new RowSelectionState();

const defaultColumnKeyGetter = (_column, columnIndex) => columnIndex;
/**
 * A directive which controls the selection state
 */
class SelectableDirective {
    constructor(treelist) {
        this.treelist = treelist;
        /**
         * Fires when the selected items are changed.
         */
        this.selectedItemsChange = new EventEmitter();
        this.state = new RowSelectionState();
        this.cellSelected = this.cellSelected.bind(this);
        this.rowSelected = this.rowSelected.bind(this);
        this.selectionChange = this.selectionChange.bind(this);
        this.updateColumnIndices = this.updateColumnIndices.bind(this);
        this.treelist.selectable = this.selectable = true;
    }
    /**
     * @hidden
     */
    set selectable(value) {
        if (typeof value === 'object') { // add method to normalize this
            this._settings = value;
        }
        else {
            this._settings = {
                enabled: value
            };
        }
        this.state = createState(this._settings);
        if (this._settings.enabled !== false) {
            this.treelist.isSelected = this._settings.mode === 'cell' ? this.cellSelected : this.rowSelected;
            this.subscribeSelection();
        }
        else {
            this.treelist.isSelected = null;
            this.unsubscribeSelection();
        }
    }
    /**
     * Specifies the selected items.
     */
    set selectedItems(value) {
        if (!value) {
            this.state.clear();
        }
        else if (value !== this.lastChange) {
            this.state.fromArray(value);
            this.treelist.updateView();
        }
    }
    /**
     * The field name or a function that specify the dataItems key.
     */
    set itemKey(value) {
        if (isString(value)) {
            this._keyGetter = getter(String(value));
        }
        else {
            this._keyGetter = value;
        }
    }
    /**
     * The field name or a function that specify the columns key.
     */
    set columnKey(value) {
        if (isString(value)) {
            this._columnKeyGetter = getter(String(value));
        }
        else if (value) {
            this._columnKeyGetter = value;
        }
    }
    get keyGetter() {
        return this._keyGetter || this.treelist.idGetter;
    }
    get columnKeyGetter() {
        return this._columnKeyGetter || defaultColumnKeyGetter;
    }
    ngOnDestroy() {
        this.unsubscribeSelection();
    }
    /**
     * @hidden
     */
    cellSelected(dataItem, column, columnIndex) {
        return this.state.has(this.keyGetter(dataItem), this.columnKeyGetter(column, columnIndex));
    }
    /**
     * @hidden
     */
    rowSelected(dataItem) {
        return this.state.has(this.keyGetter(dataItem));
    }
    selectionChange({ action, items }) {
        if (action === 'select' || action === 'add') {
            if (action === 'select') {
                this.state.clear();
            }
            items.forEach(item => {
                this.state.add(this.keyGetter(item.dataItem), this.columnKeyGetter(item.column, item.columnIndex));
            });
        }
        else {
            items.forEach(item => {
                this.state.remove(this.keyGetter(item.dataItem), this.columnKeyGetter(item.column, item.columnIndex));
            });
        }
        this.emitSelectedItemsChange();
    }
    emitSelectedItemsChange() {
        this.lastChange = this.state.toArray();
        this.selectedItemsChange.emit(this.lastChange);
    }
    subscribeSelection() {
        this.unsubscribeSelection();
        this.subscriptions = this.treelist.selectionChange.subscribe(this.selectionChange);
        if (this._settings.mode === 'cell') {
            this.subscriptions.add(this.treelist.columnOrderChange.subscribe(this.updateColumnIndices));
            this.subscriptions.add(this.treelist.columnLockedChange.subscribe(this.updateColumnIndices));
        }
    }
    unsubscribeSelection() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
            this.subscriptions = null;
        }
    }
    updateColumnIndices() {
        if (!this._columnKeyGetter) {
            const changes = new Map();
            const currentIndices = [];
            this.leafColumns.forEach((column) => {
                currentIndices.push(column);
            });
            this.treelist.columnsContainer.refresh();
            const leafColumns = this.leafColumns;
            currentIndices.forEach((column, index) => {
                if (column !== leafColumns[index]) {
                    changes.set(index, leafColumns.indexOf(column));
                }
            });
            if (changes.size && this.state.updateColumKeys(changes)) {
                this.emitSelectedItemsChange();
            }
        }
    }
    get leafColumns() {
        return this.treelist.lockedLeafColumns.toArray().concat(this.treelist.nonLockedLeafColumns.toArray());
    }
}
SelectableDirective.ɵfac = function SelectableDirective_Factory(t) { return new (t || SelectableDirective)(ɵngcc0.ɵɵdirectiveInject(TreeListComponent)); };
SelectableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SelectableDirective, selectors: [["", "kendoTreeListSelectable", ""]], inputs: { selectable: "selectable", selectedItems: "selectedItems", itemKey: "itemKey", columnKey: "columnKey" }, outputs: { selectedItemsChange: "selectedItemsChange" }, exportAs: ["kendoTreeListSelectable"] });
/** @nocollapse */
SelectableDirective.ctorParameters = () => [
    { type: TreeListComponent }
];
SelectableDirective.propDecorators = {
    selectable: [{ type: Input }],
    selectedItems: [{ type: Input }],
    selectedItemsChange: [{ type: Output }],
    itemKey: [{ type: Input }],
    columnKey: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectableDirective, [{
        type: Directive,
        args: [{
                exportAs: 'kendoTreeListSelectable',
                selector: '[kendoTreeListSelectable]'
            }]
    }], function () { return [{ type: TreeListComponent }]; }, { selectedItemsChange: [{
            type: Output
        }], selectable: [{
            type: Input
        }], selectedItems: [{
            type: Input
        }], itemKey: [{
            type: Input
        }], columnKey: [{
            type: Input
        }] }); })();

const createElement = () => {
    const marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
    return marquee;
};
const elementUnderCursor$1 = ({ clientX, clientY }) => document.elementFromPoint(clientX, clientY);
/**
 * @hidden
 */
class MarqueeDirective {
    constructor(draggable, selection, changeDetector) {
        this.draggable = draggable;
        this.selection = selection;
        this.changeDetector = changeDetector;
        this.cellSelected = this.cellSelected.bind(this);
        this.rowSelected = this.rowSelected.bind(this);
    }
    get userSelection() {
        return this.selection.enableMarquee ? 'none' : null;
    }
    ngOnInit() {
        // handle esc
        // trigger cancel
        this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));
        this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(this.endSelection.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.clean();
    }
    cellSelected(dataItem, column) {
        return this.state.has(dataItem, column);
    }
    rowSelected(dataItem) {
        return this.state.has(dataItem);
    }
    start(args) {
        const pressTarget = this.targetArgs(args, true);
        if (!pressTarget) {
            return;
        }
        this.pressTarget = pressTarget;
        this.pressArgs = args;
    }
    moveMarquee(args) {
        if (this.pressTarget && !this.state) {
            this.initMarquee();
        }
        if (this.marqueeElement) {
            const element = this.marqueeElement;
            const press = this.pressArgs;
            const left = Math.min(args.pageX, press.pageX);
            const top = Math.min(args.pageY, press.pageY);
            const width = Math.abs(args.pageX - press.pageX);
            const height = Math.abs(args.pageY - press.pageY);
            element.style.left = `${left}px`;
            element.style.top = `${top}px`;
            element.style.width = `${width}px`;
            element.style.height = `${height}px`;
        }
        else if (this.state) {
            const currentTarget = this.targetArgs(args);
            if (currentTarget && (!this.currentTarget || this.currentTarget.item.data !== currentTarget.item.data ||
                (this.selection.settings.mode === 'cell' && this.currentTarget.column !== currentTarget.column))) {
                this.currentTarget = currentTarget;
                this.state.fromArray(this.selection.rangeItems(this.pressTarget, currentTarget).map(item => ({ itemKey: item.dataItem, columnKey: item.column })));
                this.selection.updateSelectedState();
                this.changeDetector.detectChanges();
            }
        }
    }
    endSelection(args) {
        if (!this.state) {
            return;
        }
        if ((this.pressArgs.pageX !== args.pageX || this.pressArgs.pageY !== args.pageY)) {
            const pressTarget = this.pressTarget;
            const releaseTarget = this.targetArgs(args);
            this.clean();
            // if one is missing select first / last viewItem depending on the position
            // select column based on coordinates
            if (pressTarget && releaseTarget) {
                this.selection.selectRange(pressTarget, releaseTarget);
            }
            else {
                this.changeDetector.detectChanges();
            }
        }
        else {
            this.clean();
            this.changeDetector.detectChanges();
        }
    }
    clean() {
        if (this.marqueeElement) {
            document.body.removeChild(this.marqueeElement);
            this.marqueeElement = null;
        }
        if (this.selectionSelected) {
            if (this.selection.settings.mode === 'cell') {
                this.selection.isCellSelected = this.selectionSelected;
            }
            else {
                this.selection.isRowSelected = this.selectionSelected;
            }
            this.selectionSelected = null;
        }
        if (this.state) {
            this.state.clear();
            this.state = null;
        }
        this.pressTarget = null;
        this.pressArgs = null;
    }
    targetArgs(args, skipFocusable) {
        let target = args.originalEvent.target;
        if (this.marqueeElement) {
            this.marqueeElement.style.display = 'none';
            target = elementUnderCursor$1(args);
            this.marqueeElement.style.display = 'block';
        }
        return this.selection.targetArgs(target, skipFocusable);
    }
    initMarquee() {
        this.state = createState(this.selection.settings);
        if (this.selection.settings.mode === 'cell') {
            this.selectionSelected = this.selection.isCellSelected;
            this.selection.isCellSelected = this.cellSelected;
        }
        else {
            this.selectionSelected = this.selection.isRowSelected;
            this.selection.isRowSelected = this.rowSelected;
        }
        this.changeDetector.detectChanges();
        const drag = this.selection.settings.drag;
        if (!(drag && drag.snap)) {
            this.marqueeElement = createElement();
            document.body.appendChild(this.marqueeElement);
        }
    }
}
MarqueeDirective.ɵfac = function MarqueeDirective_Factory(t) { return new (t || MarqueeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.DraggableDirective), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
MarqueeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MarqueeDirective, selectors: [["", "kendoTreeListSelectionMarquee", ""]], hostVars: 2, hostBindings: function MarqueeDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("user-select", ctx.userSelection);
    } } });
/** @nocollapse */
MarqueeDirective.ctorParameters = () => [
    { type: DraggableDirective },
    { type: SelectionService },
    { type: ChangeDetectorRef }
];
MarqueeDirective.propDecorators = {
    userSelection: [{ type: HostBinding, args: ['style.user-select',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MarqueeDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListSelectionMarquee]'
            }]
    }], function () { return [{ type: ɵngcc5.DraggableDirective }, { type: SelectionService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { userSelection: [{
            type: HostBinding,
            args: ['style.user-select']
        }] }); })();

const exportedModules$2 = [
    TreeListComponent,
    ToolbarTemplateDirective,
    ToolbarComponent,
    CustomMessagesComponent,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    HierarchyBindingDirective,
    FlatBindingDirective,
    ExpandableDirective,
    SelectableDirective,
    ...SharedModule.exports(),
    ...BodyModule.exports(),
    ...HeaderModule.exports(),
    ...PagerModule.exports(),
    ...RowFilterModule.exports(),
    ...FilterMenuModule.exports(),
    ...ColumnMenuModule.exports()
];
const declarations = [
    TreeListComponent,
    ListComponent,
    ToolbarComponent,
    LocalizedMessagesDirective,
    CustomMessagesComponent,
    ToolbarTemplateDirective,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    HierarchyBindingDirective,
    FlatBindingDirective,
    ExpandableDirective,
    SelectableDirective,
    MarqueeDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TreeList component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TreeList module
 * import { TreeListModule } from '@progress/kendo-angular-treelist';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TreeListModule], // import TreeList module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class TreeListModule {
}
TreeListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TreeListModule });
TreeListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TreeListModule_Factory(t) { return new (t || TreeListModule)(); }, imports: [[
            CommonModule,
            SharedModule,
            BodyModule,
            HeaderModule,
            PagerModule,
            RowFilterModule,
            FilterMenuModule,
            ResizeSensorModule,
            ColumnMenuModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeListModule, { declarations: function () { return [TreeListComponent,
        ListComponent,
        ToolbarComponent,
        LocalizedMessagesDirective,
        CustomMessagesComponent,
        ToolbarTemplateDirective,
        TemplateEditingDirective,
        ReactiveEditingDirective,
        InCellEditingDirective,
        HierarchyBindingDirective,
        FlatBindingDirective,
        ExpandableDirective,
        SelectableDirective,
        MarqueeDirective]; }, imports: function () { return [CommonModule,
        SharedModule,
        BodyModule,
        HeaderModule,
        PagerModule,
        RowFilterModule,
        FilterMenuModule,
        ResizeSensorModule,
        ColumnMenuModule]; }, exports: function () { return [TreeListComponent,
        ToolbarTemplateDirective,
        ToolbarComponent,
        CustomMessagesComponent,
        TemplateEditingDirective,
        ReactiveEditingDirective,
        InCellEditingDirective,
        HierarchyBindingDirective,
        FlatBindingDirective,
        ExpandableDirective,
        SelectableDirective,
        ColumnComponent,
        SpanColumnComponent,
        CheckboxColumnComponent,
        ColumnGroupComponent,
        FocusableDirective,
        CommandColumnComponent,
        CellTemplateDirective,
        NoRecordsTemplateDirective,
        EditTemplateDirective,
        EditCommandDirective,
        CancelCommandDirective,
        SaveCommandDirective,
        RemoveCommandDirective,
        AddCommandDirective,
        FooterTemplateDirective,
        HeaderTemplateDirective,
        PagerComponent,
        PagerPrevButtonsComponent,
        PagerNextButtonsComponent,
        PagerNumericButtonsComponent,
        PagerInputComponent,
        PagerInfoComponent,
        PagerPageSizesComponent,
        PagerTemplateDirective,
        FilterRowComponent,
        FilterCellComponent,
        FilterCellTemplateDirective,
        FilterCellOperatorsComponent,
        StringFilterCellComponent,
        NumericFilterCellComponent,
        AutoCompleteFilterCellComponent,
        BooleanFilterCellComponent,
        DateFilterCellComponent,
        FilterCellOperatorsComponent,
        ContainsFilterOperatorComponent,
        DoesNotContainFilterOperatorComponent,
        EndsWithFilterOperatorComponent,
        EqualFilterOperatorComponent,
        IsEmptyFilterOperatorComponent,
        IsNotEmptyFilterOperatorComponent,
        IsNotNullFilterOperatorComponent,
        IsNullFilterOperatorComponent,
        NotEqualFilterOperatorComponent,
        StartsWithFilterOperatorComponent,
        GreaterFilterOperatorComponent,
        GreaterOrEqualToFilterOperatorComponent,
        LessFilterOperatorComponent,
        LessOrEqualToFilterOperatorComponent,
        AfterFilterOperatorComponent,
        AfterEqFilterOperatorComponent,
        BeforeEqFilterOperatorComponent,
        BeforeFilterOperatorComponent,
        StringFilterMenuComponent,
        FilterMenuTemplateDirective,
        NumericFilterMenuComponent,
        DateFilterMenuComponent,
        BooleanFilterMenuComponent,
        FilterCellOperatorsComponent,
        ContainsFilterOperatorComponent,
        DoesNotContainFilterOperatorComponent,
        EndsWithFilterOperatorComponent,
        EqualFilterOperatorComponent,
        IsEmptyFilterOperatorComponent,
        IsNotEmptyFilterOperatorComponent,
        IsNotNullFilterOperatorComponent,
        IsNullFilterOperatorComponent,
        NotEqualFilterOperatorComponent,
        StartsWithFilterOperatorComponent,
        GreaterFilterOperatorComponent,
        GreaterOrEqualToFilterOperatorComponent,
        LessFilterOperatorComponent,
        LessOrEqualToFilterOperatorComponent,
        AfterFilterOperatorComponent,
        AfterEqFilterOperatorComponent,
        BeforeEqFilterOperatorComponent,
        BeforeFilterOperatorComponent,
        ColumnChooserComponent,
        ColumnMenuFilterComponent,
        ColumnMenuItemComponent,
        ColumnMenuItemContentTemplateDirective,
        ColumnMenuSortComponent,
        ColumnMenuLockComponent,
        ColumnMenuChooserComponent,
        ColumnMenuTemplateDirective,
        ColumnMenuComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeListModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [exportedModules$2],
                imports: [
                    CommonModule,
                    SharedModule,
                    BodyModule,
                    HeaderModule,
                    PagerModule,
                    RowFilterModule,
                    FilterMenuModule,
                    ResizeSensorModule,
                    ColumnMenuModule
                ]
            }]
    }], null, null); })();

class PDFMarginComponent$1 extends PDFMarginComponent {
}
PDFMarginComponent$1.ɵfac = function PDFMarginComponent$1_Factory(t) { return ɵPDFMarginComponent$1_BaseFactory(t || PDFMarginComponent$1); };
PDFMarginComponent$1.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PDFMarginComponent$1, selectors: [["kendo-treelist-pdf-margin"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PDFMarginComponent$1_Template(rf, ctx) { }, encapsulation: 2 });
const ɵPDFMarginComponent$1_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PDFMarginComponent$1);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFMarginComponent$1, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-pdf-margin',
                template: ''
            }]
    }], null, null); })();

/**
 * Represents the PDF page template of the TreeList that helps to customize the PDF pages. To define a page template,
 * nest an `<ng-template>` tag with the `kendoTreeListPDFTemplate` directive inside `<kendo-treelist-pdf>`.
 *
 * The template context provides the following fields:
 * - `pageNumber`&mdash;Defines PDF page number.
 * - `totalPages`&mdash;Defines the total number of PDF pages.
 *
 * {% meta height:550 %}
 * {% embed_file pdf-export/page-template-inline/app.component.ts preview %}
 * {% embed_file pdf-export/app.module.ts %}
 * {% embed_file shared/filesystem.ts %}
 * {% embed_file pdf-export/main.ts %}
 * {% endmeta %}
 */
class PDFTemplateDirective$1 extends PDFTemplateDirective {
    constructor(templateRef) {
        super(templateRef);
    }
}
PDFTemplateDirective$1.ɵfac = function PDFTemplateDirective$1_Factory(t) { return new (t || PDFTemplateDirective$1)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
PDFTemplateDirective$1.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PDFTemplateDirective$1, selectors: [["", "kendoTreeListPDFTemplate", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
PDFTemplateDirective$1.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFTemplateDirective$1, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListPDFTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
const HEADER_CLASS = 'k-grid-header';
/**
 * @hidden
 */
const FOOTER_CLASS = 'k-grid-footer';
const GRID_LIST = 'KENDO-TREELIST-LIST';
const TABLE = 'TABLE';
const matchesList = matchesNodeName(GRID_LIST);
const matchesTable = matchesNodeName(TABLE);
const suffix = (locked) => locked ? 'locked' : 'wrap';
/**
 * @hidden
 */
class TreeListQuery {
    constructor(element) {
        this.element = element;
        this.list = findElement(element, matchesList);
    }
    content(locked) {
        return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));
    }
    header(locked) {
        this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));
        return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));
    }
    footer(locked) {
        this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));
        return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));
    }
    table() {
        return findElement(this.element, matchesTable);
    }
}

const FIRST_CLASS = 'k-first';
const INPUTS = ['input', 'select', 'textarea', 'option'];
/** @hidden */
const cloneNode = (node) => {
    const clone = node.cloneNode(false);
    if (node._kendoExportVisual) {
        clone._kendoExportVisual = node._kendoExportVisual;
    }
    if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
        clone.removeAttribute("id");
        clone.removeAttribute("name");
        clone.value = node.value;
        clone.checked = node.checked;
        clone.selected = node.selected;
    }
    let child = node.firstChild;
    while (child) {
        clone.appendChild(cloneNode(child));
        child = child.nextSibling;
    }
    return clone;
};
const appendNodes = (element, nodes) => {
    const length = nodes.length;
    for (let idx = 0; idx < length; idx++) {
        element.appendChild(cloneNode(nodes[idx]));
    }
};
const wrapTable = (table) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'k-widget k-grid';
    wrapper.appendChild(table);
    return wrapper;
};
const createTableElement = (sources) => {
    const sourceCount = sources.length;
    const element = cloneNode(sources[0]);
    const rowsCount = element.rows.length;
    if (sourceCount > 1) {
        for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
            for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
                appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
            }
        }
    }
    return element;
};
const setFirstCellClass = (header, headers) => {
    if (headers.length > 1 && header.rows.length > 1) {
        for (let idx = 1; idx < header.rows.length; idx++) {
            const firstCellIndex = headers[0].rows[idx].cells.length;
            const cell = header.rows[idx].cells[firstCellIndex];
            if (String(cell.className).indexOf(FIRST_CLASS) === -1) {
                cell.className += ` ${FIRST_CLASS}`;
            }
        }
    }
};
const createTable = (colGroups, headers, bodies, footers) => {
    const table = document.createElement('table');
    const colGroup = colGroups[0].cloneNode(true);
    for (let idx = 1; idx < colGroups.length; idx++) {
        appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));
    }
    const header = createTableElement(headers);
    const body = createTableElement(bodies);
    header.className = HEADER_CLASS;
    setFirstCellClass(header, headers);
    table.appendChild(colGroup);
    table.appendChild(header);
    table.appendChild(body);
    if (footers.length) {
        const footer = createTableElement(footers);
        footer.className = FOOTER_CLASS;
        table.appendChild(footer);
    }
    return wrapTable(table);
};
/**
 * @hidden
 */
const exportElement = (wrapper) => {
    const query = new TreeListQuery(wrapper);
    const content = query.content();
    let result;
    if (content) {
        const colGroups = [content.querySelector('colgroup')];
        const headers = [query.header().querySelector('thead')];
        const bodies = [content.querySelector('tbody')];
        const footer = query.footer();
        const footers = [];
        if (footer) {
            footers.push(footer.querySelector('tfoot'));
        }
        const lockedContent = query.content(true);
        if (lockedContent) {
            colGroups.unshift(lockedContent.querySelector('colgroup'));
            headers.unshift(query.header(true).querySelector('thead'));
            bodies.unshift(lockedContent.querySelector('tbody'));
            if (footer) {
                footers.unshift(query.footer(true).querySelector('tfoot'));
            }
        }
        result = createTable(colGroups, headers, bodies, footers);
    }
    else {
        result = wrapTable(query.table().cloneNode(true));
    }
    return result;
};

const createElement$1 = (tagName, className) => {
    const element = document.createElement(tagName);
    if (className) {
        element.className = className;
    }
    return element;
};
const createDiv = (className) => {
    return createElement$1('div', className);
};
/**
 * Configures the settings for the export of TreeList in PDF ([see example]({% slug pdfexport_treelist %})).
 */
class PDFComponent extends PDFExportComponent {
    constructor(pdfService, suspendService, ngZone, element) {
        super(element);
        this.pdfService = pdfService;
        this.suspendService = suspendService;
        this.ngZone = ngZone;
        this.columns = new QueryList();
        this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
        this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
        this.reset = this.reset.bind(this);
        this.draw = this.draw.bind(this);
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        this.drawSubscription.unsubscribe();
        this.reset();
    }
    savePDF(component) {
        this.createPDF(component, this.draw);
    }
    drawPDF({ component, promise }) {
        this.createPDF(component, () => {
            this.createExportGroup(promise);
        });
    }
    createPDF(component, callback) {
        const pageSize = component.pageSize;
        const total = component.view.totalVisible;
        const columns = this.columns.toArray();
        if (columns.length) {
            this.originalColumns = component.columns.toArray();
        }
        this.component = component;
        this.suspendService.scroll = true;
        this.pdfService.exporting = true;
        this.initProgress();
        this.renderAllPages = this.allPages && pageSize < total;
        if (this.renderAllPages) {
            this.skip = component.skip;
            this.pageSize = pageSize;
            this.changePage(0, total, callback, columns);
        }
        else if (columns.length || component.virtualColumns) {
            this.changeColumns(columns, callback);
        }
        else {
            callback();
        }
    }
    initProgress() {
        const wrapperElement = this.component.wrapper.nativeElement;
        const progress = this.progress = createDiv('k-loading-pdf-mask');
        const overlay = cloneNode(wrapperElement);
        progress.appendChild(overlay);
        progress.appendChild(createDiv('k-loading-color'));
        progress.appendChild(createElement$1('span', 'k-i-loading k-icon'));
        this.originalHeight = wrapperElement.style.height;
        this.originalOverflow = wrapperElement.style.overflow;
        wrapperElement.style.height = wrapperElement.offsetHeight + 'px';
        wrapperElement.style.overflow = 'hidden';
        wrapperElement.appendChild(progress);
        this.applyScroll(overlay);
    }
    applyScroll(overlay) {
        const query = new TreeListQuery(this.component.wrapper.nativeElement);
        const content = query.content();
        if (content) {
            const overlayQuery = new TreeListQuery(overlay);
            const overlayContent = overlayQuery.content();
            overlayContent.scrollTop = content.scrollTop;
            overlayContent.scrollLeft = content.scrollLeft;
            overlayQuery.header().scrollLeft = query.header().scrollLeft;
            const footer = query.footer();
            if (footer) {
                overlayQuery.footer().scrollLeft = footer.scrollLeft;
            }
            const lockedContent = query.content(true);
            if (lockedContent) {
                const overlayLockedContent = overlayQuery.content(true);
                overlayLockedContent.scrollTop = lockedContent.scrollTop;
                overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
            }
        }
    }
    draw() {
        this.createExportElement((element) => {
            this.save(element, this.fileName);
        });
    }
    createExportGroup(promise) {
        this.createExportElement((element) => {
            this.exportElement(element).then(group => promise.resolve(group));
        });
    }
    createExportElement(callback) {
        this.ngZone.runOutsideAngular(() => {
            const container = this.container = createDiv('k-grid-pdf-export-element');
            const element = exportElement(this.component.wrapper.nativeElement);
            container.appendChild(element);
            document.body.appendChild(container);
            callback(element);
        });
    }
    drawOptions() {
        const options = super.drawOptions();
        options._destructive = true;
        return options;
    }
    cleanup() {
        super.cleanup();
        this.pdfService.exporting = false;
        if (this.component) {
            const originalColumns = this.originalColumns;
            delete this.originalColumns;
            if (this.renderAllPages) {
                this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
            }
            else if (originalColumns || this.component.virtualColumns) {
                this.changeColumns(originalColumns, this.reset);
            }
            else {
                this.reset();
            }
        }
        else {
            this.reset();
        }
        this.removeContainer();
    }
    removeContainer() {
        if (this.container) {
            document.body.removeChild(this.container);
            delete this.container;
        }
    }
    changePage(skip, _take, callback, columns) {
        this.ngZone.run(() => {
            const onPageChanged = () => {
                if ((columns && columns.length) || this.component.virtualColumns) {
                    this.changeColumns(columns, callback);
                }
                else {
                    this.onStable(callback);
                }
            };
            this.component.notifyPageChange('pdf', { skip: skip, take: _take });
            if (this.component.view.loading) {
                this.component.vida.dataLoaded.pipe(take(1)).subscribe(onPageChanged);
            }
            else {
                onPageChanged();
            }
        });
    }
    changeColumns(columns, callback) {
        this.ngZone.run(() => {
            this.onStable(callback);
            if (columns && columns.length) {
                this.component.columns.reset(columns);
            }
        });
    }
    reset() {
        this.suspendService.scroll = false;
        this.renderAllPages = false;
        if (!this.component) {
            return;
        }
        const wrapperElement = this.component.wrapper.nativeElement;
        wrapperElement.removeChild(this.progress);
        wrapperElement.style.height = this.originalHeight;
        wrapperElement.style.overflow = this.originalOverflow;
        delete this.progress;
        delete this.component;
    }
    onStable(callback) {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(callback);
    }
}
PDFComponent.ɵfac = function PDFComponent_Factory(t) { return new (t || PDFComponent)(ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(SuspendService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
PDFComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PDFComponent, selectors: [["kendo-treelist-pdf"]], contentQueries: function PDFComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PDFMarginComponent$1, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, PDFTemplateDirective$1, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase$1, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { allPages: "allPages" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PDFComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
PDFComponent.ctorParameters = () => [
    { type: PDFService },
    { type: SuspendService },
    { type: NgZone },
    { type: ElementRef }
];
PDFComponent.propDecorators = {
    allPages: [{ type: Input }],
    columns: [{ type: ContentChildren, args: [ColumnBase$1,] }],
    marginComponent: [{ type: ContentChild, args: [PDFMarginComponent$1,] }],
    pageTemplateDirective: [{ type: ContentChild, args: [PDFTemplateDirective$1,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-pdf',
                template: ''
            }]
    }], function () { return [{ type: PDFService }, { type: SuspendService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }]; }, { columns: [{
            type: ContentChildren,
            args: [ColumnBase$1]
        }], allPages: [{
            type: Input
        }], marginComponent: [{
            type: ContentChild,
            args: [PDFMarginComponent$1]
        }], pageTemplateDirective: [{
            type: ContentChild,
            args: [PDFTemplateDirective$1]
        }] }); })();

/**
 * Represents the `export-to-PDF` command of the TreeList.
 * You can apply this directive to any `button` element inside a
 * [`ToolbarTemplate`]({% slug api_treelist_commandcolumncomponent %}).
 * When the user clicks a button that is associated with the directive, the
 * [`pdfExport`]({% slug api_treelist_treelistcomponent %}#toc-pdfexport) event
 * fires ([see example]({% slug pdfexport_treelist %})).
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *      <ng-template kendoTreeListToolbarTemplate>
 *          <button kendoTreeListPDFCommand>Export to PDF</button>
 *      </ng-template>
 *      <kendo-treelist-pdf fileName="TreeList.pdf">
 *      </kendo-treelist-pdf>
 * </kendo-treelist>
 * ```
 */
class PDFCommandDirective extends Button {
    constructor(pdfService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.pdfService = pdfService;
        this.ngZone = ngZone;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get pdfClass() {
        return true;
    }
}
PDFCommandDirective.ɵfac = function PDFCommandDirective_Factory(t) { return new (t || PDFCommandDirective)(ɵngcc0.ɵɵdirectiveInject(PDFService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
PDFCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PDFCommandDirective, selectors: [["", "kendoTreeListPDFCommand", ""]], hostVars: 2, hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PDFCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-pdf", ctx.pdfClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
PDFCommandDirective.ctorParameters = () => [
    { type: PDFService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
PDFCommandDirective.propDecorators = {
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    pdfClass: [{ type: HostBinding, args: ['class.k-grid-pdf',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListPDFCommand]'
            }]
    }], function () { return [{ type: PDFService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], pdfClass: [{
            type: HostBinding,
            args: ['class.k-grid-pdf']
        }] }); })();

const exportedModules$3 = [
    PDFComponent,
    PDFMarginComponent$1,
    PDFCommandDirective,
    PDFTemplateDirective$1
];
const declarations$1 = [
    PDFComponent,
    PDFMarginComponent$1,
    PDFCommandDirective,
    PDFTemplateDirective$1
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TreeList PDF component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TreeList and PDF modules
 * import { TreeListModule, PDFModule } from '@progress/kendo-angular-treelist';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TreeListModule, PDFModule], // import TreeList and PDF modules
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class PDFModule {
}
PDFModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PDFModule });
PDFModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PDFModule_Factory(t) { return new (t || PDFModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PDFModule, { declarations: [PDFComponent,
        PDFMarginComponent$1,
        PDFCommandDirective,
        PDFTemplateDirective$1], exports: [PDFComponent,
        PDFMarginComponent$1,
        PDFCommandDirective,
        PDFTemplateDirective$1] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PDFModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$1],
                exports: [exportedModules$3]
            }]
    }], null, null); })();

/**
 * Arguments for the `excelExport` event.
 */
class ExcelExportEvent extends PreventableEvent {
    constructor(workbook) {
        super();
        this.workbook = workbook;
    }
}

const hierarchyData = (view) => {
    const data = view.data;
    const levels = {};
    const aggregates = {};
    const items = [];
    let depth = 0;
    for (let idx = 0, dataIndex = 0; idx < data.length; idx++) {
        const item = data[idx];
        if (item.type === 'data') {
            items.push(item.data);
            levels[dataIndex] = item.level;
            depth = Math.max(depth, item.level);
            dataIndex++;
        }
        else {
            aggregates[item.parentIndex] = item.aggregates;
        }
    }
    return {
        itemId: (_item, idx) => idx,
        itemLevel: (_item, idx) => levels[idx],
        depth: depth + 1,
        aggregates,
        data: items
    };
};
const toExcelColumn = (column) => {
    return {
        title: column.title,
        field: column.field,
        locked: Boolean(column.locked),
        width: column.width,
        level: column.level,
        hidden: !column.isVisible,
        footerTemplate: column.footerTemplate
    };
};
const toExcelColumns = (columns) => {
    const result = [];
    sortColumns(columns)
        .forEach((column) => {
        if (column.isSpanColumn) {
            result.push(...toExcelColumns(column.childrenArray));
        }
        else {
            const excelColumn = toExcelColumn(column);
            if (column.isColumnGroup) {
                excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
            }
            result.push(excelColumn);
        }
    });
    return result;
};
const componentColumns = (component) => {
    const columns = toExcelColumns(component.columns.toArray());
    return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
};
/**
 * Configures the settings for the export of TreeList in Excel ([see example]({% slug excelexport_treelist %})).
 */
class ExcelComponent {
    constructor(excelService, localization, zone) {
        this.excelService = excelService;
        this.localization = localization;
        this.zone = zone;
        /**
         * Specifies the file name of the exported Excel file.
         * @default "Export.xlsx"
         */
        this.fileName = 'Export.xlsx';
        /**
         * Specifies if export should include all pages
         * @default true
         */
        this.allPages = true;
        /**
         * Specifies if the export should expand all items or should use the current TreeList state.
         * @default true
         */
        this.expandAll = true;
        /**
         * @hidden
         */
        this.columns = new QueryList();
        this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        if (this.dataSubscription) {
            this.dataSubscription.unsubscribe();
        }
    }
    save(component) {
        const result = this.fetchData ? this.fetchData(component) : null;
        this.excelService.toggleLoading(true);
        this.zone.runOutsideAngular(() => {
            if (result && isObservable(result.data)) {
                this.dataSubscription = result.data.pipe(take(1)).subscribe((data) => {
                    this.dataSubscription = null;
                    this.exportData(component, {
                        data: data,
                        fetchChildren: result.fetchChildren,
                        hasChildren: result.hasChildren
                    });
                });
            }
            else {
                // allow the loading to be shown
                setTimeout(() => {
                    this.exportData(component, result);
                });
            }
        });
    }
    exportData(component, result) {
        const viewOptions = result ? {
            fields: result,
            expandState: this.expandAll ? EXPANDED_STATE : component.expandStateService
        } : this.componentViewOptions(component);
        ViewCollection.loadView(viewOptions).subscribe((view) => {
            if (!view) {
                return;
            }
            const hierarchy = hierarchyData(view);
            const options = workbookOptions({
                columns: this.columns.length ? this.columns : componentColumns(component),
                data: hierarchy.data,
                aggregates: hierarchy.aggregates,
                filterable: this.filterable,
                creator: this.creator,
                date: this.date,
                rtl: this.localization.rtl,
                collapsible: this.collapsible,
                hierarchy: hierarchy,
                paddingCellOptions: this.paddingCellOptions
            });
            const args = new ExcelExportEvent(options);
            if (hasObservers(component.excelExport)) {
                this.zone.run(() => {
                    component.excelExport.emit(args);
                });
            }
            this.excelService.toggleLoading(false);
            if (!args.isDefaultPrevented()) {
                this.saveFile(options);
            }
        });
    }
    saveFile(options) {
        toDataURL(options).then((dataURL) => {
            saveAs(dataURL, this.fileName, {
                forceProxy: this.forceProxy,
                proxyURL: this.proxyURL
            });
        });
    }
    componentViewOptions(component) {
        return {
            fields: Object.assign(component.viewFieldAccessor(), {
                pageable: !this.allPages,
                skip: this.allPages ? 0 : component.skip
            }),
            expandState: !this.expandAll || (!this.allPages && component.pageable) ? component.expandStateService : EXPANDED_STATE,
            loaded: new Map(component.view.loaded)
        };
    }
}
ExcelComponent.ɵfac = function ExcelComponent_Factory(t) { return new (t || ExcelComponent)(ɵngcc0.ɵɵdirectiveInject(ExcelService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ExcelComponent, selectors: [["kendo-treelist-excel"]], contentQueries: function ExcelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { fileName: "fileName", allPages: "allPages", expandAll: "expandAll", filterable: "filterable", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", fetchData: "fetchData", collapsible: "collapsible", paddingCellOptions: "paddingCellOptions" }, decls: 0, vars: 0, template: function ExcelComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ExcelComponent.ctorParameters = () => [
    { type: ExcelService },
    { type: LocalizationService },
    { type: NgZone }
];
ExcelComponent.propDecorators = {
    fileName: [{ type: Input }],
    filterable: [{ type: Input }],
    creator: [{ type: Input }],
    date: [{ type: Input }],
    forceProxy: [{ type: Input }],
    proxyURL: [{ type: Input }],
    fetchData: [{ type: Input }],
    collapsible: [{ type: Input }],
    allPages: [{ type: Input }],
    expandAll: [{ type: Input }],
    paddingCellOptions: [{ type: Input }],
    columns: [{ type: ContentChildren, args: [ColumnBase, { descendants: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-treelist-excel',
                template: ``
            }]
    }], function () { return [{ type: ExcelService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { fileName: [{
            type: Input
        }], allPages: [{
            type: Input
        }], expandAll: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase, { descendants: true }]
        }], filterable: [{
            type: Input
        }], creator: [{
            type: Input
        }], date: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], fetchData: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], paddingCellOptions: [{
            type: Input
        }] }); })();

/**
 * Represents the `export-to-Excel` command of the TreeList. You can apply this
 * directive to any `button` element inside a
 * [`ToolbarTemplate`]({% slug api_treelist_commandcolumncomponent %}).
 * When the user clicks a button associated with the directive, the
 * [`excelExport`]({% slug api_treelist_treelistcomponent %}#toc-excelexport) event
 * fires ([see example]({% slug excelexport_treelist %})).
 *
 * @example
 * ```html-no-run
 * <kendo-treelist>
 *      <ng-template kendoTreeListToolbarTemplate>
 *          <button kendoTreeListExcelCommand>Export to PDF</button>
 *      </ng-template>
 *      <kendo-treelist-excel fileName="TreeList.xlsx">
 *      </kendo-treelist-excel>
 * </kendo-treelist>
 * ```
 */
class ExcelCommandDirective extends Button {
    constructor(excelService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.excelService = excelService;
        this.ngZone = ngZone;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.excelService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get excelClass() {
        return true;
    }
}
ExcelCommandDirective.ɵfac = function ExcelCommandDirective_Factory(t) { return new (t || ExcelCommandDirective)(ɵngcc0.ɵɵdirectiveInject(ExcelService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelCommandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ExcelCommandDirective, selectors: [["", "kendoTreeListExcelCommand", ""]], hostVars: 2, hostBindings: function ExcelCommandDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ExcelCommandDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-grid-excel", ctx.excelClass);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
ExcelCommandDirective.ctorParameters = () => [
    { type: ExcelService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocalizationService },
    { type: NgZone }
];
ExcelCommandDirective.propDecorators = {
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    excelClass: [{ type: HostBinding, args: ['class.k-grid-excel',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelCommandDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeListExcelCommand]'
            }]
    }], function () { return [{ type: ExcelService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], excelClass: [{
            type: HostBinding,
            args: ['class.k-grid-excel']
        }] }); })();

const declarations$2 = [ExcelComponent, ExcelCommandDirective];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Excel component of the TreeList.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TreeList and Excel modules
 * import { TreeListModule, ExcelModule } from '@progress/kendo-angular-treelist';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TreeListModule, ExcelModule], // import TreeList and Excel modules
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class ExcelModule {
}
ExcelModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ExcelModule });
ExcelModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ExcelModule_Factory(t) { return new (t || ExcelModule)(); }, imports: [ExcelExportModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelModule, { declarations: function () { return [ExcelComponent,
        ExcelCommandDirective]; }, exports: function () { return [ExcelComponent,
        ExcelCommandDirective,
        ExcelExportModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations$2],
                exports: [declarations$2, ExcelExportModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { BaseBindingDirective, ColumnChooserComponent, ColumnListComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemBase, ColumnMenuItemContentTemplateDirective, ColumnMenuItemComponent, ColumnMenuLockComponent, ColumnMenuSortComponent, ColumnMenuTemplateDirective, ColumnMenuModule, ColumnMenuService, ColumnHandleDirective, ColumnResizingService, TableDirective, ColumnInfoService, DomEventsService, IdService, OptionChangesService, PreventableEvent, SortService, ChangeNotificationService, ColumnReorderService, DragAndDropModule, DragAndDropService, DragHintService, DraggableColumnDirective, DropCueService, DropTargetDirective, EditingDirectiveBase, RowEditingDirectiveBase, AddCommandDirective, BaseCommandDirective, CancelCommandDirective, EditCommandDirective, EditService as EditService$1, LocalDataChangesService, RemoveCommandDirective, SaveCommandDirective, ExcelCommandDirective, ExpandStateService, BooleanFilterComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellWrapperComponent, DateFilterComponent, FilterHostDirective, FilterInputWrapperComponent, FilterInputDirective, FilterRowComponent, DateFilterMenuInputComponent, FilterMenuContainerComponent, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuComponent, NumericFilterMenuInputComponent, StringFilterMenuInputComponent, NumericFilterComponent, FilterOperatorBase, SharedFilterModule, StringFilterComponent, BrowserSupportService, ResizeService, ResponsiveService, LocalizedMessagesDirective, Messages, FocusGroup, FocusRoot, LogicalCellDirective, LogicalRowDirective, NavigationService, PagerContextService, PagerElementComponent, PDFCommandDirective, PDFTemplateDirective$1 as PDFTemplateDirective, CellComponent, FieldAccessorPipe, LevelItemsPipe, DEFAULT_SCROLLER_FACTORY, SCROLLER_FACTORY_TOKEN, ScrollRequestService, ScrollSyncService, ScrollerService, MarqueeDirective, SelectionService, TreeListModule, SharedModule, TreeListComponent, HierarchyBindingDirective, FlatBindingDirective, ColumnBase$1 as ColumnBase, ColumnComponent, CheckboxColumnComponent, CommandColumnComponent, SpanColumnComponent, ColumnGroupComponent, ToolbarComponent, ToolbarTemplateDirective, CellTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, PagerTemplateDirective, ResizableContainerDirective, TemplateContextDirective, NoRecordsTemplateDirective, FilterService, FilterCellTemplateDirective, FilterCellComponent, StringFilterCellComponent, DateFilterCellComponent, BaseFilterCellComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, StringFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, RowFilterModule, FilterMenuModule, BodyModule, HeaderModule, PagerModule, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, EditTemplateDirective, ColGroupComponent, HeaderComponent, ListComponent, TableBodyComponent, PagerComponent, CustomMessagesComponent, LoadingComponent, PDFModule, PDFComponent, PDFMarginComponent$1 as PDFMarginComponent, PDFService, ExcelModule, ExcelComponent, ExcelService, SelectableDirective, SelectionChangeEvent, CellCloseEvent, SuspendService, Skip, ColumnReorderEvent, FocusableDirective, ColumnVisibilityChangeEvent, ColumnMenuComponent, SinglePopupService, PopupCloseEvent, ExpandEvent, ExpandableDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpSkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aUpBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZKQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs2ZkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2SkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7aUpBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O3FKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3NKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K0hBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7MkdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lHQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozt1RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7dUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswSkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OElBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzTEFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttSEFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7dUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0hBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7cU1BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7NkVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhGQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OzttRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswdEJBV0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21IQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyRkFHRTtBQUNGO0FBQ0E7OztnREFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0VBbVZFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29HQWdGRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7ZzdEQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7cUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztrREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3lKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztzREFrQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7d0tBcUJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MkdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7V0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tUQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O3NEQTJCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpT0FLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O21NQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O2lHQWVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRNQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzsyRkFvQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBIQStCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzJIQW1CRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzswR0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzsySEF1QkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpSkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1pBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O3lIQTZCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3lKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzsyREFRRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs2QkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVFBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1TEFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2lEQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3NTQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUdBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs2RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7MkVBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7aUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7dUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7aUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OEpBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Z0tBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7bUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7a0tBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7K0pBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7aUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7bUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Z0tBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7eUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkpBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7c0tBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OEpBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Z0tBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7aUtBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7K0pBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRLQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0xBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7NEhBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFRRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O3lEQXVCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytFQTBDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1SkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrRUEwQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs0R0FpQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpSUE0QkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2lEQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0RkFpQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d05BS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvREE0SkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs2REFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7aUhBc0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRRQW1DRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O3lFQWdCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O3VLQWlCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7c0hBK0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzsrSUE4Q0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7a0lBNEJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7NElBb0RFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7MkRBbUJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b09BS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OEhBaUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2dHQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozt3RkFnQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztnRUEwQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsyQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztxREFxQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OERBa0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4TEFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBdUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0VBYUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzsyR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyREFrQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztvRUFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztxSkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3dKQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O3VIQWlHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7bURBbUVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswREFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztnSUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2tJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2dJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztrSUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsrSEFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7aUZBYUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrTEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O21HQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZUQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpVUFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VUQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrTUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dWQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MlVBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvWEFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VWQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBaUJFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyTEFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O3dMQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7MERBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzttWUFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswREFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYsIE9wdGlvbmFsLCBRdWVyeUxpc3QsIElucHV0LCBDb250ZW50Q2hpbGRyZW4sIENvbnRlbnRDaGlsZCwgSW5qZWN0aW9uVG9rZW4sIEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCBTa2lwU2VsZiwgSG9zdCwgTmdab25lLCBDaGFuZ2VEZXRlY3RvclJlZiwgaXNEZXZNb2RlLCBSZW5kZXJlcjIsIFNlY3VyaXR5Q29udGV4dCwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIFZpZXdFbmNhcHN1bGF0aW9uLCBPdXRwdXQsIEhvc3RCaW5kaW5nLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiwgSW5qZWN0LCBTZWxmLCBWaWV3Q29udGFpbmVyUmVmLCBQaXBlLCBOZ01vZHVsZSwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwLCBOR19WQUxVRV9BQ0NFU1NPUiwgUmVhY3RpdmVGb3Jtc01vZHVsZSwgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBtZXJnZSwgb2YsIGZyb21FdmVudCwgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24sIGlzT2JzZXJ2YWJsZSwgU3ViamVjdCwgemlwLCBmcm9tLCBpbnRlcnZhbCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgYXVkaXRUaW1lLCB0YWtlLCBzd2l0Y2hNYXAsIG1hcCwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgdGFwLCB0aHJvdHRsZVRpbWUsIHRha2VVbnRpbCwgc3dpdGNoTWFwVG8sIGRlbGF5LCBkZWJvdW5jZVRpbWUsIGJ1ZmZlckNvdW50IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgS2V5cywgaGFzT2JzZXJ2ZXJzLCBhbnlDaGFuZ2VkLCBpc0NoYW5nZWQsIFJlc2l6ZVNlbnNvckNvbXBvbmVudCwgRHJhZ2dhYmxlTW9kdWxlLCBFdmVudHNNb2R1bGUsIERyYWdnYWJsZURpcmVjdGl2ZSwgZ3VpZCwgUmVzaXplU2Vuc29yTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IG9yZGVyQnksIGlzQ29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvciwgcHJvY2VzcywgYWdncmVnYXRlQnkgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZGF0YS1xdWVyeSc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCwgQ29tcG9uZW50TWVzc2FnZXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IFBvcHVwU2VydmljZSwgUG9wdXBNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IGdldHRlciwgc2V0dGVyIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWNvbW1vbic7XG5pbXBvcnQgeyBEcm9wRG93bkxpc3RNb2R1bGUsIEF1dG9Db21wbGV0ZU1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWRyb3Bkb3ducyc7XG5pbXBvcnQgeyBJbnB1dHNNb2R1bGUsIE51bWVyaWNUZXh0Qm94Q29tcG9uZW50LCBOdW1lcmljVGV4dEJveE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWlucHV0cyc7XG5pbXBvcnQgeyBEYXRlUGlja2VyTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZGF0ZWlucHV0cyc7XG5pbXBvcnQgeyBJbnRsU2VydmljZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWludGwnO1xuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCBhbmltYXRlIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1idXR0b25zJztcbmltcG9ydCB7IFBERk1hcmdpbkNvbXBvbmVudCwgUERGVGVtcGxhdGVEaXJlY3RpdmUsIFBERkV4cG9ydENvbXBvbmVudCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBkZi1leHBvcnQnO1xuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWZpbGUtc2F2ZXInO1xuaW1wb3J0IHsgd29ya2Jvb2tPcHRpb25zLCB0b0RhdGFVUkwsIENvbHVtbkJhc2UsIEV4Y2VsRXhwb3J0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZXhjZWwtZXhwb3J0JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW4gY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgVHJlZUxpc3QgKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19jb2x1bW5zX3RyZWVsaXN0ICV9I3RvYy1jZWxsLXRlbXBsYXRlKSkuXG4gKiBIZWxwcyB0byBjdXN0b21pemUgdGhlIGNvbnRlbnQgb2YgdGhlIGNlbGxzLiBUbyBkZWZpbmUgdGhlIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZ1xuICogd2l0aCB0aGUgYGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbj5gIHRhZy5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgZGF0YSBpdGVtIGFuZCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBwYXNzZWQ6XG4gKiAtIGBjb2x1bW5JbmRleGAmbWRhc2g7VGhlIGN1cnJlbnQgY29sdW1uIGluZGV4LiBVc2UgaXQgYXMgYW4gYWxpYXMgZm9yIGEgdGVtcGxhdGUgdmFyaWFibGUgYnkgdXRpbGl6aW5nIHRoZSBgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcImAgc3ludGF4LlxuICogLSBgY29sdW1uYCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gaW5zdGFuY2UuIFVzZSBpdCBhcyBhbiBhbGlhcyBmb3IgYSB0ZW1wbGF0ZSB2YXJpYWJsZSBieSB1dGlsaXppbmcgdGhlIGBsZXQtY29sdW1uPVwiY29sdW1uXCJgIHN5bnRheC5cbiAqIC0gYGRhdGFJdGVtYCZtZGFzaDtUaGUgY3VycmVudCBkYXRhIGl0ZW0uIFJlcHJlc2VudHMgdGhlIGRlZmF1bHQgY29udGV4dCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gYW55IHRlbXBsYXRlIHZhcmlhYmxlIHdoaWNoIHV0aWxpemVzIHRoZSBgbGV0LXhgIHN5bnRheCZtZGFzaDtmb3IgZXhhbXBsZSwgYGxldC1kYXRhSXRlbWAuXG4gKiAtIGBjZWxsQ29udGV4dGAmbWRhc2g7QW4gb2JqZWN0IHVzZWQgdG8gcGFzcyBjb250ZXh0IGluZm9ybWF0aW9uIHRvIGJ1aWx0LWluIGRpcmVjdGl2ZXMuXG4gKiAtIGBoYXNDaGlsZHJlbmAmbWRhc2g7U3BlY2lmaWVzIGlmIHRoZSBpdGVtIGhhcyBjaGlsZHJlbi5cbiAqIC0gYGlzRXhwYW5kZWRgJm1kYXNoO1NwZWNpZmllcyBpZiB0aGUgaXRlbSBpcyBleHBhbmRlZC5cbiAqIC0gYGxldmVsYCZtZGFzaDtUaGUgaGllcmFyY2h5IGxldmVsIG9mIHRoZSBpdGVtLlxuICogLSBgbG9hZGluZ2AmbWRhc2g7U3BlY2lmaWVzIGlmIHRoZSBpdGVtIGNoaWxkcmVuIGFyZSBjdXJyZW50bHkgbG9hZGluZy5cbiAqIC0gYHJvd0luZGV4YCZtZGFzaDtUaGUgY3VycmVudCByb3cgaW5kZXguIFVzZSBpdCBhcyBhbiBhbGlhcyBmb3IgYSB0ZW1wbGF0ZSB2YXJpYWJsZSBieSB1dGlsaXppbmcgdGhlIGBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiYCBzeW50YXguXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NDcwICV9XG4gKiB7JSBlbWJlZF9maWxlIGRhdGEtYmluZGluZy9oaWVyYXJjaHkvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9maWxlc3lzdGVtLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkNlbGxUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DZWxsVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW4gZWRpdC1jZWxsIHRlbXBsYXRlIG9mIHRoZSBUcmVlTGlzdCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfdHJlZWxpc3QgJX0pKS5cbiAqIEhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgY29udGVudCBvZiB0aGUgZWRpdGVkIGNlbGxzLiBUbyBkZWZpbmUgdGhlIGNlbGwgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gXG4gKiB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZUxpc3RFZGl0VGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbj5gIHRhZy5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqIC0gYGNvbHVtbmAmbWRhc2g7VGhlIGN1cnJlbnQgY29sdW1uIGluc3RhbmNlLlxuICogLSBgZGF0YUl0ZW1gJm1kYXNoO1RoZSBjdXJyZW50IGRhdGEgaXRlbS5cbiAqIC0gYGNlbGxDb250ZXh0YCZtZGFzaDtBbiBvYmplY3QgdXNlZCB0byBwYXNzIGNvbnRleHQgaW5mb3JtYXRpb24gdG8gYnVpbHQtaW4gZGlyZWN0aXZlcy5cbiAqIC0gYGZvcm1Hcm91cGAmbWRhc2g7VGhlIGN1cnJlbnQgW2BGb3JtR3JvdXBgXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWydmb3JtZ3JvdXBhcGknXSB9fSkuXG4gKiBJZiB5b3UgdXNlIHRoZSBUcmVlTGlzdCBpbnNpZGUgW1RlbXBsYXRlLURyaXZlbiBGb3Jtc10oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnZm9ybXMnXSB9fSksIGl0IHdpbGwgYmUgYHVuZGVmaW5lZGAuXG4gKiAtIGBpc05ld2AmbWRhc2g7VGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG4gKiAtIGByb3dJbmRleGAmbWRhc2g7VGhlIGN1cnJlbnQgcm93IGluZGV4LiBJZiBpbnNpZGUgYSBuZXcgaXRlbSByb3csIGByb3dJbmRleGAgaXMgYC0xYC5cbiAqL1xuY2xhc3MgRWRpdFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuRWRpdFRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEVkaXRUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkVkaXRUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbiBoZWFkZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgVHJlZUxpc3RcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyB0ZW1wbGF0ZXNfY29sdW1uc190cmVlbGlzdCAlfSN0b2MtaGVhZGVyLXRlbXBsYXRlKSkuXG4gKiBIZWxwcyB0byBjdXN0b21pemUgdGhlIHRhYmxlIGhlYWRlciBjZWxsIGZvciB0aGUgY29sdW1uLlxuICogVG8gZGVmaW5lIGEgaGVhZGVyIHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGVcbiAqIFtga2VuZG9UcmVlTGlzdEhlYWRlclRlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfaGVhZGVydGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZSBpbnNpZGUgdGhlIGA8a2VuZG8tdHJlZWxpc3QtY29sdW1uPmAgdGFnLlxuICpcbiAqICBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgY29sdW1uIGFuZCB0aGVuIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBmaWVsZHMgYXJlIHBhc3NlZDpcbiAqICogYGNvbHVtbmAmbWRhc2g7RGVmaW5lcyBhbiBpbnN0YW5jZSBvZiB0aGUgW2BDb2x1bW5Db21wb25lbnRgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb2x1bW5jb21wb25lbnQgJX0pIG9wdGlvbi5cbiAqICogYGNvbHVtbkluZGV4YCZtZGFzaDtEZWZpbmVzIHRoZSBjdXJyZW50IGNvbHVtbiBpbmRleC5cbiAqXG4gKiB7JSBtZXRhIGhlaWdodDo1MzMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29uZmlndXJhdGlvbi9oZWFkZXItdGVtcGxhdGUvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9lbXBsb3llZXMudHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5IZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RIZWFkZXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1uIGZvb3RlciBjZWxsIHRlbXBsYXRlIG9mIHRoZSBUcmVlTGlzdFxuICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIHRlbXBsYXRlc19jb2x1bW5zX3RyZWVsaXN0ICV9I3RvYy1mb290ZXItdGVtcGxhdGUpKS5cbiAqIEhlbHBzIHRvIGN1c3RvbWl6ZSB0aGUgdGFibGUgZm9vdGVyIGNlbGwgZm9yIHRoZSBjb2x1bW4uXG4gKiBUbyBkZWZpbmUgYSBmb290ZXIgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZVxuICogW2BrZW5kb1RyZWVMaXN0Rm9vdGVyVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9mb290ZXJ0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlIGluc2lkZSB0aGUgYDxrZW5kby10cmVlbGlzdC1jb2x1bW4+YCB0YWcuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBhZ2dyZWdhdGUgdmFsdWVzIGFuZCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBwYXNzZWQ6XG4gKiAqIGBhZ2dyZWdhdGVzYCZtZGFzaDtUaGUgYWdncmVnYXRlcyBmb3IgdGhlIGxldmVsIGl0ZW1zLlxuICogKiBgY29sdW1uYCZtZGFzaDtEZWZpbmVzIGFuIGluc3RhbmNlIG9mIHRoZSBbYENvbHVtbkNvbXBvbmVudGBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NvbHVtbmNvbXBvbmVudCAlfSkgb3B0aW9uLlxuICogKiBgY29sdW1uSW5kZXhgJm1kYXNoO0RlZmluZXMgdGhlIGN1cnJlbnQgY29sdW1uIGluZGV4LlxuICogKiBgZmllbGRgJm1kYXNoO1RoZSBuYW1lIG9mIHRoZSBjb2x1bW4gZmllbGQsIGlmIHNldC5cbiAqXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NTAwICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbmZpZ3VyYXRpb24vZm9vdGVyLXRlbXBsYXRlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvbWFpbi50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZW1wbG95ZWVzLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0Rm9vdGVyVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Gb290ZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBjb2x1bW4gbWVudSBpbiB0aGUgVHJlZUxpc3QuIFByb3ZpZGVzIGFuIG9wdGlvbiBmb3JcbiAqIGN1c3RvbWl6aW5nIHRoZSBjb250ZW50IG9mIHRoZSBjb2x1bW4gbWVudSBmb3IgYWxsIG9yIGZvciBzcGVjaWZpYyBjb2x1bW5zLlxuICogVG8gZGVmaW5lIHRoZSBjb250ZW50IHRlbXBsYXRlLCBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGVcbiAqIGBrZW5kb1RyZWVMaXN0Q29sdW1uTWVudVRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIHRoZSBga2VuZG8tdHJlZWxpc3RgIG9yIHRoZSBgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbj5gIGNvbXBvbmVudC5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBwYXNzZXMgdGhyb3VnaCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqIC0gYHNlcnZpY2VgJm1kYXNoO1JlcHJlc2VudHMgdGhlIFtDb2x1bW5NZW51U2VydmljZV0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29sdW1ubWVudXNlcnZpY2UgJX0pLlxuICogLSBgY29sdW1uYCZtZGFzaDtSZXByZXNlbnRzIHRoZSBUcmVlTGlzdCBjb2x1bW4uXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NTAwICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L3RlbXBsYXRlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2VtcGxveWVlcy50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBDb2x1bW5NZW51VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Db2x1bW5NZW51VGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0Q29sdW1uTWVudVRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sdW1uTWVudVRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1NwYW5Db2x1bW4gPSBjb2x1bW4gPT4gY29sdW1uLmlzU3BhbkNvbHVtbjtcbmNvbnN0IGlzQ29sdW1uQ29udGFpbmVyID0gY29sdW1uID0+IGNvbHVtbi5pc0NvbHVtbkdyb3VwIHx8IGlzU3BhbkNvbHVtbihjb2x1bW4pO1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgdGhlIGNvbHVtbiBjb21wb25lbnRzIG9mIHRoZSBUcmVlTGlzdC5cbiAqL1xuY2xhc3MgQ29sdW1uQmFzZSQxIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvcHRpb25DaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm9wdGlvbkNoYW5nZXMgPSBvcHRpb25DaGFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXRjaGVzTWVkaWEgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbHVtbiBpbmRleCBhZnRlciByZW9yZGVyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IGBvcmRlckluZGV4YCBpcyBhIHJlYWQtb25seSBwcm9wZXJ0eS4gU2V0dGluZyB0aGlzIGZpZWxkIGRvZXMgbm90IGFmZmVjdCBjb2x1bW4gb3JkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yZGVySW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NvbHVtbkdyb3VwID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU3BhbkNvbHVtbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyByZXNpemFibGUuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgcmVvcmRlcmFibGUuXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVvcmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIChpbiBwaXhlbHMpIGJlbG93IHdoaWNoIHRoZSB1c2VyIGlzIG5vdCBhYmxlIHRvIHJlc2l6ZSB0aGUgY29sdW1uIGJ5IHVzaW5nIHRoZSBVSS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluUmVzaXphYmxlV2lkdGggPSAxMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvZ2dsZXMgdGhlIGxvY2tlZCAoZnJvemVuKSBzdGF0ZSBvZiB0aGUgY29sdW1ucyAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgbG9ja2VkX2NvbHVtbnNfdHJlZWxpc3QgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICAgICAgICA8a2VuZG8tdHJlZWxpc3QgW2RhdGFdPVwidHJlZWxpc3REYXRhXCIgW3Njcm9sbGFibGVdPVwic2Nyb2xsYWJsZVwiIHN0eWxlPVwiaGVpZ2h0OiAyMDBweFwiPlxuICAgICAgICAgKiAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiUHJvZHVjdElEXCIgdGl0bGU9XCJQcm9kdWN0IElEXCIgd2lkdGg9XCIxMjBcIiBbbG9ja2VkXT1cInRydWVcIj5cbiAgICAgICAgICogICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICAgICAqICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCIgd2lkdGg9XCIyMDBcIj5cbiAgICAgICAgICogICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICAgICAqICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIiB0aXRsZT1cIlVuaXQgUHJpY2VcIiB3aWR0aD1cIjIzMFwiPlxuICAgICAgICAgKiAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgICAgICogICAgICAgIDwva2VuZG8tdHJlZWxpc3Q+XG4gICAgICAgICAqICAgIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICpcbiAgICAgICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICAgcHVibGljIHRyZWVsaXN0RGF0YTogYW55W107XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgKiAgICAgICAgdGhpcy50cmVlbGlzdERhdGEgPSBwcm9kdWN0cztcbiAgICAgICAgICogICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAgICAgICAgICogICAgXCJQcm9kdWN0SURcIjogMSxcbiAgICAgICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgICAgICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAgICAgICAgICogICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICAgICAgICAgKiAgfSwge1xuICAgICAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICAgICAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAgICAgICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgICAgICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAgICAgICAgICogIH1cbiAgICAgICAgICogXTtcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBjb2x1bW4gY2FuIGJlIGxvY2tlZCBvciB1bmxvY2tlZCBmcm9tIHRoZSBjb2x1bW4gbWVudSBvciBieSByZW9yZGVyaW5nIHRoZSBjb2x1bW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2NrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNvbHVtbiBtZW51IHdpbGwgYmUgc2hvd24gZm9yIHRoZSBjb2x1bW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbk1lbnUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBjb2x1bW4gd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY29sdW1uLWNob29zZXIgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5jbHVkZUluQ2hvb3NlciA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWRlclRlbXBsYXRlcyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1uTWVudVRlbXBsYXRlcyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhaXNDb2x1bW5Db250YWluZXIocGFyZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2x1bW5zIGNhbiBiZSBuZXN0ZWQgb25seSBpbnNpZGUgQ29sdW1uR3JvdXBDb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNvbHVtbiAoaW4gcGl4ZWxzKS5cbiAgICAgKi9cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93aWR0aDsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbGV2ZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiBpc1NwYW5Db2x1bW4odGhpcy5wYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubGV2ZWwgKyAxIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaXNMb2NrZWQgOiB0aGlzLmxvY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb2xzcGFuKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJvd3NwYW4odG90YWxDb2x1bW5MZXZlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWwgPCB0b3RhbENvbHVtbkxldmVscyA/ICh0b3RhbENvbHVtbkxldmVscyAtIHRoaXMubGV2ZWwpICsgMSA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5oZWFkZXJUZW1wbGF0ZXMuZmlyc3Q7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSA/IHRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGZvb3RlclRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb290ZXJUZW1wbGF0ZSA/IHRoaXMuZm9vdGVyVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29sdW1uTWVudVRlbXBsYXRlUmVmKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuY29sdW1uTWVudVRlbXBsYXRlcy5maXJzdDtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlID8gdGVtcGxhdGUudGVtcGxhdGVSZWYgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRpc3BsYXlUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGlkZGVuICYmIHRoaXMubWF0Y2hlc01lZGlhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoX2NoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25DaGFuZ2VzLmNvbHVtbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbHVtbkJhc2UkMS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICByZXNpemFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlb3JkZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW5SZXNpemFibGVXaWR0aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdpZHRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhdXRvU2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9ja2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoaWRkZW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1lZGlhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2NrYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uTWVudTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW5jbHVkZUluQ2hvb3NlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3R5bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhlYWRlclN0eWxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb290ZXJTdHlsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3NzQ2xhc3M6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIGhlYWRlckNsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb290ZXJDbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGVhZGVyVGVtcGxhdGVzOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogZmFsc2UgfSxdIH1dLFxuICAgIGZvb3RlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGNvbHVtbk1lbnVUZW1wbGF0ZXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0NvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dXG59O1xuXG5jb25zdCBFTVBUWV9SRUdFWCA9IC9eXFxzKiQvO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzUHJlc2VudCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0JsYW5rID0gKHZhbHVlKSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzVHJ1dGh5ID0gKHZhbHVlKSA9PiAhIXZhbHVlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTnVsbE9yRW1wdHlTdHJpbmcgPSAodmFsdWUpID0+IGlzQmxhbmsodmFsdWUpIHx8IEVNUFRZX1JFR0VYLnRlc3QodmFsdWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG9ic2VydmUgPSAobGlzdCkgPT4gbWVyZ2Uob2YobGlzdCksIGxpc3QuY2hhbmdlcyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNVbml2ZXJzYWwgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbHVlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHRyYWN0Rm9ybWF0ID0gKGZvcm1hdCkgPT4ge1xuICAgIGlmIChpc1N0cmluZyhmb3JtYXQpICYmICFpc051bGxPckVtcHR5U3RyaW5nKGZvcm1hdCkgJiYgZm9ybWF0LnN0YXJ0c1dpdGgoJ3swOicpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQuc2xpY2UoMywgZm9ybWF0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3QgPSAoZm4pID0+ICguLi5hcmdzKSA9PiAhZm4uYXBwbHkobnVsbCwgYXJncyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgb3IgPSAoLi4uY29uZGl0aW9ucykgPT4gKHZhbHVlKSA9PiBjb25kaXRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgfHwgeCh2YWx1ZSksIGZhbHNlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhbmQgPSAoLi4uY29uZGl0aW9ucykgPT4gKHZhbHVlKSA9PiBjb25kaXRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgJiYgeCh2YWx1ZSksIHRydWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFNraXAgPSBuZXcgSW5qZWN0aW9uVG9rZW4oXCJTa2lwXCIpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOnZhcmlhYmxlLW5hbWVcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjcmVhdGVQcm9taXNlID0gKCkgPT4ge1xuICAgIGxldCByZXNvbHZlRm4sIHJlamVjdEZuO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmVGbiA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJlamVjdEZuID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHByb21pc2UucmVzb2x2ZSA9IHJlc29sdmVGbjtcbiAgICBwcm9taXNlLnJlamVjdCA9IHJlamVjdEZuO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbi8qKiBAaGlkZGVuICovXG5jb25zdCBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKCk7XG4vLyBUT0RPOiBNb3ZlIHRvIGtlbmRvLWNvbW1vblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICBjb25zdCBwcm90byA9IE1hcC5wcm90b3R5cGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBwcm90b1trZXldID09PSBwcm90by5lbnRyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgRlJBTUVfRFVSQVRJT04gPSAxMDAwIC8gNjA7XG5jb25zdCB3bmQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHduZC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd25kLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IChjYWxsYmFjayA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBGUkFNRV9EVVJBVElPTikpO1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd25kLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHduZC5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBjbGVhclRpbWVvdXQ7XG4vKiogQGhpZGRlbiAqL1xuY29uc3QgaXNDb2x1bW5FZGl0YWJsZSA9IChjb2x1bW4sIGZvcm1Hcm91cCkgPT4gY29sdW1uLmlzRWRpdGFibGUgIT09IGZhbHNlICYmXG4gICAgKGNvbHVtbi5lZGl0VGVtcGxhdGUgfHwgKGZvcm1Hcm91cCAmJiBjb2x1bW4uZmllbGQgJiYgZm9ybUdyb3VwLmdldChjb2x1bW4uZmllbGQpKSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZmlsdGVyLWNlbGwgdGVtcGxhdGUgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLWN1c3RvbWl6aW5nLWZpbHRlci1yb3dzKSkuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaXMgc2V0IHRvIHRoZSBmaWx0ZXIgZGVzY3JpcHRvciBhbmQgdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgcGFzc2VkOlxuICogLSBgY29sdW1uYCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gaW5zdGFuY2UuIFVzZSBpdCBhcyBhbiBhbGlhcyBmb3IgYSB0ZW1wbGF0ZSB2YXJpYWJsZSBieSB1dGlsaXppbmcgdGhlIGBsZXQtY29sdW1uPVwiY29sdW1uXCJgIHN5bnRheC5cbiAqIC0gYGZpbHRlcmAmbWRhc2g7VGhlIGZpbHRlciBkZXNjcmlwdG9yLlxuICogLSBgY2VsbENvbnRleHRgJm1kYXNoO0FuIG9iamVjdCB1c2VkIHRvIHBhc3MgY29udGV4dCBpbmZvcm1hdGlvbiB0byBidWlsdC1pbiBkaXJlY3RpdmVzLlxuICovXG5jbGFzcyBGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5GaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0RmlsdGVyQ2VsbFRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZmlsdGVyLW1lbnUgdGVtcGxhdGVcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1jdXN0b21pemluZy1maWx0ZXItbWVudXMpKS5cbiAqL1xuY2xhc3MgRmlsdGVyTWVudVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuRmlsdGVyTWVudVRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEZpbHRlck1lbnVUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgT3B0aW9uQ2hhbmdlc1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgb3B0aW9uQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVtaXQoKTtcbiAgICB9XG4gICAgY29sdW1uQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zLmVtaXQoKTtcbiAgICB9XG59XG5PcHRpb25DaGFuZ2VzU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sdW1uQ29tcG9uZW50KGNvbHVtbikge1xuICAgIHJldHVybiBpc1ByZXNlbnQoY29sdW1uLmZpZWxkKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1ucyBvZiB0aGUgW0FuZ3VsYXIgVHJlZUxpc3RdKHslIHNsdWcgZ2V0c3RhcnRlZF90cmVlbGlzdCAlfSkuXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NDcwICV9XG4gKiB7JSBlbWJlZF9maWxlIGJhc2ljLXVzYWdlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBiYXNpYy11c2FnZS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIGJhc2ljLXVzYWdlL21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2VtcGxveWVlcy50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBDb2x1bW5Db21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlJDEge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb3B0aW9uQ2hhbmdlcykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG9wdGlvbkNoYW5nZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHRoZSBjb2x1bW4gaGVhZGVycyB0byBiZSBjbGlja2VkIGFuZCB0aGUgYHNvcnRDaGFuZ2VgIGV2ZW50IGVtaXR0ZWQuXG4gICAgICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgYHNvcnRDaGFuZ2VgIGV2ZW50IHlvdXJzZWxmIGFuZCBzb3J0IHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBlZGl0b3IgdHlwZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfcmVhY3RpdmVfZm9ybXNfdHJlZWxpc3QgJX0jdG9jLXNldHVwKSkuXG4gICAgICAgICAqIFVzZWQgd2hlbiB0aGUgY29sdW1uIGVudGVycyB0aGUgZWRpdCBtb2RlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdGV4dGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGh0bWwtbm8tcnVuXG4gICAgICAgICAqIDxrZW5kby10cmVlbGlzdD5cbiAgICAgICAgICogICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIGVkaXRvcj1cIm51bWVyaWNcIj5cbiAgICAgICAgICogICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICAgICAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0b3IgPSAndGV4dCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBmaWx0ZXIgdHlwZSB0aGF0IGlzIGRpc3BsYXllZCBpbnNpZGUgdGhlIGZpbHRlciByb3cuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0ZXh0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgaHRtbC1uby1ydW5cbiAgICAgICAgICogPGtlbmRvLXRyZWVsaXN0PlxuICAgICAgICAgKiAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCIgZmlsdGVyPVwibnVtZXJpY1wiPlxuICAgICAgICAgKiAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgICAgICogPC9rZW5kby10cmVlbGlzdD5cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9ICd0ZXh0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaWYgYSBmaWx0ZXIgVUkgd2lsbCBiZSBkaXNwbGF5ZWQgZm9yIHRoaXMgY29sdW1uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGh0bWwtbm8tcnVuXG4gICAgICAgICAqIDxrZW5kby10cmVlbGlzdD5cbiAgICAgICAgICogICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIlVuaXRQcmljZVwiIFtmaWx0ZXJhYmxlXT1cImZhbHNlXCI+XG4gICAgICAgICAqICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAgICAgKiA8L2tlbmRvLXRyZWVsaXN0PlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBlZGl0YWJsZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGBodG1sLW5vLXJ1blxuICAgICAgICAgKiA8a2VuZG8tdHJlZWxpc3Q+XG4gICAgICAgICAqICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIiBbZWRpdGFibGVdPVwiZmFsc2VcIj5cbiAgICAgICAgICogICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICAgICAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGdldCB0ZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUgPyB0aGlzLnRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZWRpdFRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0VGVtcGxhdGUgPyB0aGlzLmVkaXRUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGZpbHRlckNlbGxUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlID8gdGhpcy5maWx0ZXJDZWxsVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBmaWx0ZXJNZW51VGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlck1lbnVUZW1wbGF0ZSA/IHRoaXMuZmlsdGVyTWVudVRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZGlzcGxheVRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5maWVsZCA6IHRoaXMudGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuICAgIH1cbn1cbkNvbHVtbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2x1bW5Db21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtY29sdW1uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sdW1uQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ29sdW1uQmFzZSQxLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBTa2lwU2VsZiB9LCB7IHR5cGU6IEhvc3QgfSwgeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgIHsgdHlwZTogT3B0aW9uQ2hhbmdlc1NlcnZpY2UgfVxuXTtcbkNvbHVtbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBleHBhbmRhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzb3J0YWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZWRpdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGVkaXRhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0ZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZWRpdFRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtFZGl0VGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBmaWx0ZXJDZWxsVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0ZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGZpbHRlck1lbnVUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbRmlsdGVyTWVudVRlbXBsYXRlRGlyZWN0aXZlLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc1NwYW5Db2x1bW5Db21wb25lbnQoY29sdW1uKSB7XG4gICAgcmV0dXJuIGNvbHVtbi5pc1NwYW5Db2x1bW47XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb2x1bW4gd2hpY2ggY2FuIGJlIHNwYW5uZWQgb3ZlciBtdWx0aXBsZSBkYXRhIGNlbGxzIHdoaWxlIHRoZSBpbmRpdmlkdWFsXG4gKiBoZWFkZXIgYW5kIGZvb3RlciBjZWxscyBhcmUgcmV0YWluZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzcGFubmVkX2NvbHVtbnNfdHJlZWxpc3QgJX0pKS5cbiAqIEVuYWJsZXMgeW91IHRvIGFjaGlldmUgbW9yZSBmbGV4aWJsZSBsYXlvdXQgd2hpbGUga2VlcGluZyB0aGUgYnVpbHQtaW4gVUkgZWxlbWVudCBmb3JcbiAqIFtzb3J0aW5nXSh7JSBzbHVnIHNvcnRpbmdfdHJlZWxpc3QgJX0pIGFuZCBbZmlsdGVyaW5nXSh7JSBzbHVnIGZpbHRlcmluZ190cmVlbGlzdCAlfSkuIFdyYXAgdGhlIGNvbHVtbnMgdGhhdCB3aWxsIGJlXG4gKiBtZXJnZWQgaW5zaWRlIHRoZSBgPGtlbmRvLXRyZWVsaXN0LXNwYW4tY29sdW1uPmAgdGFnLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjU3MCAlfVxuICogeyUgZW1iZWRfZmlsZSBjb25maWd1cmF0aW9uL3NwYW4tY29sdW1uL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvbWFpbi50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZW1wbG95ZWVzLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIGRhdGEgY2VsbCBkaXNwbGF5cyB0aGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZHMuIFRvIGZ1cnRoZXIgY3VzdG9taXplXG4gKiB0aGUgc3Bhbi1jb2x1bW4gZnVuY3Rpb25hbGl0eSwgdXNlIGEgW2NlbGwgdGVtcGxhdGVdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NlbGx0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkuXG4gKlxuICogYGBgaHRtbC1uby1ydW5cbiAqIDxrZW5kby10cmVlbGlzdC1zcGFuLWNvbHVtbj5cbiAqICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiZmllbGQxXCIgdGl0bGU9XCJGaWVsZCAxXCI+PC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gKiAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cImZpZWxkMlwiIHRpdGxlPVwiRmllbGQgMlwiPjwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICogICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWRhdGFJdGVtPlxuICogICAgICAgIDxoNT57eyBkYXRhSXRlbS5maWVsZDEgfX08L2g1PlxuICogICAgICAgIDxwPnt7IGRhdGFJdGVtLmZpZWxkMiB9fTwvcD5cbiAqICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9rZW5kby10cmVlbGlzdC1zcGFuLWNvbHVtbj5cbiAqIGBgYFxuICovXG5jbGFzcyBTcGFuQ29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9wdGlvbkNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvcHRpb25DaGFuZ2VzKTtcbiAgICAgICAgLypcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1NwYW5Db2x1bW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLmVkaXRUZW1wbGF0ZSA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRDb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmNsdWRlSW5DaG9vc2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzU3BhbkNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGFuQ29sdW1uIGNhbm5vdCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgU3BhbkNvbHVtbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGUgZWRpdCB0ZW1wbGF0ZSBvZiB0aGUgY29sdW1uIHdpbGwgYmUgcmVuZGVyZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiA+IFRvIGVuYWJsZSB0aGUgZWRpdGluZyBmdW5jdGlvbmFsaXR5IGZvciBhIHNwYW5uZWQgY29sdW1uLCBzZXQgYW4gZWRpdCB0ZW1wbGF0ZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWwtbm8tcnVuXG4gICAgICogPGtlbmRvLXRyZWVsaXN0PlxuICAgICAqICAgIDxrZW5kby10cmVlbGlzdC1zcGFuLWNvbHVtbiBbZWRpdGFibGVdPVwiZmFsc2VcIj5cbiAgICAgKiAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW4gZmllbGQ9XCJVbml0UHJpY2VcIj5cbiAgICAgKiAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCI+XG4gICAgICogICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0RWRpdFRlbXBsYXRlPlxuICAgICAqICAgICAgICAgLi4uLi5cbiAgICAgKiAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgPC9rZW5kby10cmVlbGlzdC1zcGFuLWNvbHVtbj5cbiAgICAgKiA8L2tlbmRvLXRyZWVsaXN0PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBlZGl0YWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lZGl0YWJsZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZWRpdGFibGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5lZGl0VGVtcGxhdGVSZWYpICYmIHRoaXMuX2VkaXRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogYWRkZWQgZm9yIGJhY2t3YXJkcyBjb21waXRhYmlsaXR5XG4gICAgICovXG4gICAgc2V0IHdpZHRoKF92YWx1ZSkge1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29sdW1ucy5yZWR1Y2UoKHRvdGFsLCBjb2x1bW4pID0+IHRvdGFsICsgY29sdW1uLndpZHRoLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBsZWFmSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29sdW1ucy5maXJzdC5sZWFmSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5maXJzdDtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlID8gdGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZWRpdFRlbXBsYXRlUmVmKCkge1xuICAgICAgICBjb25zdCBlZGl0VGVtcGxhdGUgPSB0aGlzLmVkaXRUZW1wbGF0ZS5maXJzdDtcbiAgICAgICAgcmV0dXJuIGVkaXRUZW1wbGF0ZSA/IGVkaXRUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb2xzcGFuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENvbHVtbnMuZmlsdGVyKGMgPT4gYy5pc1Zpc2libGUpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgbG9ja2VkIChmcm96ZW4pIHN0YXRlIG9mIHRoZSBjb2x1bW5zLiBMb2NrZWQgY29sdW1ucyBhcmUgdmlzaWJsZVxuICAgICAqIGF0IGFsbCB0aW1lcyBkdXJpbmcgdGhlIGhvcml6b250YWwgc2Nyb2xsaW5nIG9mIHRoZSBUcmVlTGlzdC5cbiAgICAgKlxuICAgICAqIEZvciB0aGUgb3B0aW9uIHRvIHdvcmsgcHJvcGVybHksIG1ha2Ugc3VyZSB0aGF0OlxuICAgICAqIC0gU2Nyb2xsaW5nIGlzIGVuYWJsZWQuXG4gICAgICogLSBUaGUgYGhlaWdodGAgb3B0aW9uIG9mIHRoZSBUcmVlTGlzdCBpcyBzZXQuXG4gICAgICogLSBUaGUgd2lkdGhzIG9mIGFsbCBUcmVlTGlzdCBjb2x1bW5zIGFyZSBleHBsaWNpdGx5IHNldCBpbiBwaXhlbHMuIEluIHRoaXMgd2F5LFxuICAgICAqIHRoZSBUcmVlTGlzdCBhZGp1c3RzIHRoZSBsYXlvdXQgb2YgdGhlIGxvY2tlZCBhbmQgdW5sb2NrZWQgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogX0BDb21wb25lbnQoe1xuICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICAgICA8a2VuZG8tdHJlZWxpc3QgW2RhdGFdPVwidHJlZWxpc3REYXRhXCIgW3Njcm9sbGFibGVdPVwic2Nyb2xsYWJsZVwiIHN0eWxlPVwiaGVpZ2h0OiAyMDBweFwiPlxuICAgICAqICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1zcGFuLWNvbHVtbiBbbG9ja2VkXT1cInRydWVcIj5cbiAgICAgKiAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiUHJvZHVjdElEXCIgdGl0bGU9XCJQcm9kdWN0IElEXCIgd2lkdGg9XCIxMjBcIj5cbiAgICAgKiAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiUHJvZHVjdE5hbWVcIiB0aXRsZT1cIlByb2R1Y3QgTmFtZVwiIHdpZHRoPVwiMjAwXCI+XG4gICAgICogICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICogICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1zcGFuLWNvbHVtbj5cbiAgICAgKiAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCIgdGl0bGU9XCJVbml0IFByaWNlXCIgd2lkdGg9XCIyMzBcIj5cbiAgICAgKiAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgPC9rZW5kby10cmVlbGlzdD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgcHVibGljIHRyZWVsaXN0RGF0YTogYW55W107XG4gICAgICpcbiAgICAgKiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgKiAgICAgICAgdGhpcy50cmVlbGlzdERhdGEgPSBwcm9kdWN0cztcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBsb2NrZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbG9ja2VkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBsb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NrZWQgfHwgdGhpcy5jaGlsZENvbHVtbnMuc29tZShjID0+IGMubG9ja2VkKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZWRpdFRlbXBsYXRlUmVmKTtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29sdW1ucy50b0FycmF5KCk7XG4gICAgfVxuICAgIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDb2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgfVxufVxuU3BhbkNvbHVtbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTcGFuQ29sdW1uQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LXNwYW4tY29sdW1uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU3BhbkNvbHVtbkNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbHVtbkJhc2UkMSwgZGVjb3JhdG9yczogW3sgdHlwZTogU2tpcFNlbGYgfSwgeyB0eXBlOiBIb3N0IH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICB7IHR5cGU6IE9wdGlvbkNoYW5nZXNTZXJ2aWNlIH1cbl07XG5TcGFuQ29sdW1uQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGV4cGFuZGFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0sXSB9XSxcbiAgICBlZGl0VGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0VkaXRUZW1wbGF0ZURpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogZmFsc2UgfSxdIH1dLFxuICAgIGNoaWxkQ29sdW1uczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ29sdW1uQ29tcG9uZW50LF0gfV0sXG4gICAgZWRpdGFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvY2tlZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHBhbmRDb2x1bW5zID0gKGNvbHVtbnMpID0+IChjb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IGFjYy5jb25jYXQoaXNTcGFuQ29sdW1uQ29tcG9uZW50KGNvbHVtbikgPyBjb2x1bW4uY2hpbGRyZW5BcnJheSA6IFtjb2x1bW5dKSwgW10pIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXhwYW5kQ29sdW1uc1dpdGhTcGFuID0gKGNvbHVtbnMpID0+IChjb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IGFjYy5jb25jYXQoaXNTcGFuQ29sdW1uQ29tcG9uZW50KGNvbHVtbikgP1xuICAgIFtjb2x1bW5dLmNvbmNhdChjb2x1bW4uY2hpbGRyZW5BcnJheSkgOlxuICAgIFtjb2x1bW5dKSwgW10pIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY29sdW1uc1RvUmVuZGVyID0gKGNvbHVtbnMpID0+IChleHBhbmRDb2x1bW5zKGNvbHVtbnMpLmZpbHRlcih4ID0+IHguaXNWaXNpYmxlKSk7XG5jb25zdCBzdW1Qcm9wID0gKHByb3ApID0+IChhcnJheSkgPT4gKGFycmF5IHx8IFtdKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYgKyAoY3Vycltwcm9wXSB8fCAwKSwgMCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3VtQ29sdW1uV2lkdGhzID0gc3VtUHJvcCgnd2lkdGgnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb2x1bW5zU3BhbiA9IHN1bVByb3AoJ2NvbHNwYW4nKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmNvbnN0IHZhbGlkRmllbGQgPSBuZXcgUmVnRXhwKGBeWyRBLVpcXF9hLXpdWyRBLVpcXF9hLXowLTlcXFxcLl0qJGApO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzVmFsaWRGaWVsZE5hbWUgPSAoZmllbGROYW1lKSA9PiAhaXNOdWxsT3JFbXB0eVN0cmluZyhmaWVsZE5hbWUpICYmIHZhbGlkRmllbGQudGVzdChmaWVsZE5hbWUpICYmXG4gICAgZmllbGROYW1lWzBdICE9PSBcIi5cIiAmJiBmaWVsZE5hbWVbZmllbGROYW1lLmxlbmd0aCAtIDFdICE9PSBcIi5cIjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjaGlsZHJlbiA9IGNvbHVtbiA9PiBjb2x1bW4uY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkICE9PSBjb2x1bW4pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1ucyA9PiB7XG4gICAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xuICAgICAgICBpZiAoY29sdW1uLmlzQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQobGVhZkNvbHVtbnMoY2hpbGRyZW4oY29sdW1uKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbHVtbi5pc1NwYW5Db2x1bW4pIHtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQoY29sdW1uLmNoaWxkcmVuQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjLnB1c2goY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKS5maWx0ZXIoeCA9PiB4LmlzVmlzaWJsZSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc29tZUxlYWZDb2x1bW4gPSAoY2FsbGJhY2ssIC4uLmNvbHVtbnMpID0+IGxlYWZDb2x1bW5zKGNvbHVtbnMpLnNvbWUoY2FsbGJhY2spO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlc2l6YWJsZUNvbHVtbnMgPSBjb2x1bW5zID0+IGNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBpc1RydXRoeShjb2x1bW4ucmVzaXphYmxlKSAmJiBjb2x1bW4uaXNWaXNpYmxlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzb3J0Q29sdW1ucyA9IChjb2x1bW5zKSA9PiBvcmRlckJ5KGNvbHVtbnMsIFt7IGZpZWxkOiAnb3JkZXJJbmRleCcsIGRpcjogJ2FzYycgfV0pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzSW5TcGFuQ29sdW1uID0gKGNvbHVtbikgPT4gaXNUcnV0aHkoY29sdW1uLnBhcmVudCkgJiYgaXNTcGFuQ29sdW1uQ29tcG9uZW50KGNvbHVtbi5wYXJlbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNDb2x1bW5Hcm91cENvbXBvbmVudChjb2x1bW4pIHtcbiAgICByZXR1cm4gY29sdW1uLmlzQ29sdW1uR3JvdXA7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbHVtbiBncm91cCBoZWFkZXIgb2YgdGhlIFRyZWVMaXN0XG4gKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzXSh7JSBzbHVnIG11bHRpY29sdW1uaGVhZGVyc19jb2x1bW5zX3RyZWVsaXN0ICV9KSkuXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NTMzICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbmZpZ3VyYXRpb24vbXVsdGktY29sdW1uLWhlYWRlcnMvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9maWxlc3lzdGVtLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIENvbHVtbkdyb3VwQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9wdGlvbkNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvcHRpb25DaGFuZ2VzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5jbHVkZUluQ2hvb3NlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NvbHVtbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluUmVzaXphYmxlV2lkdGggPSAxMDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbHVtbkdyb3VwQ29tcG9uZW50IGNhbm5vdCBiZSBuZXN0ZWQgaW5zaWRlIFNwYW5Db2x1bW5Db21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcm93c3BhbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29sc3BhbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uc1NwYW4odGhpcy5jaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcihjaGlsZCA9PiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5pc1Zpc2libGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBsZWFmSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuID8gKHRoaXMuZmlyc3RDaGlsZCB8fCB7fSkubGVhZkluZGV4IDogLTE7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbkFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoYyA9PiBjICE9PSB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZmluZChjb2x1bW4gPT4gY29sdW1uICE9PSB0aGlzKTtcbiAgICB9XG59XG5Db2x1bW5Hcm91cENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb2x1bW5Hcm91cENvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1jb2x1bW4tZ3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db2x1bW5Hcm91cENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbHVtbkJhc2UkMSwgZGVjb3JhdG9yczogW3sgdHlwZTogU2tpcFNlbGYgfSwgeyB0eXBlOiBIb3N0IH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICB7IHR5cGU6IE9wdGlvbkNoYW5nZXNTZXJ2aWNlIH1cbl07XG5Db2x1bW5Hcm91cENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ29sdW1uQmFzZSQxLF0gfV1cbn07XG5cbmNvbnN0IGNhbkNyZWF0ZUVsZW1lbnQgPSAoKSA9PiBpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbmxldCBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IG51bGw7XG5sZXQgY2FjaGVkUGl4ZWxSYXRpbztcbmxldCBjYWNoZWRSdGxTY3JvbGxMZWZ0ID0gbnVsbDtcbmZ1bmN0aW9uIHNjcm9sbGJhcldpZHRoKCkge1xuICAgIGlmIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9PT0gbnVsbCAmJiBjYW5DcmVhdGVFbGVtZW50KCkpIHtcbiAgICAgICAgY2FjaGVkUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJvdmVyZmxvdzpzY3JvbGw7b3ZlcmZsb3cteDpoaWRkZW47em9vbToxO2NsZWFyOmJvdGg7ZGlzcGxheTpibG9ja1wiO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCImbmJzcDtcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IGRpdi5vZmZzZXRXaWR0aCAtIGRpdi5zY3JvbGxXaWR0aDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkU2Nyb2xsYmFyV2lkdGg7XG59XG5mdW5jdGlvbiBydGxTY3JvbGxMZWZ0KCkge1xuICAgIGlmIChjYWNoZWRSdGxTY3JvbGxMZWZ0ID09PSBudWxsICYmIGNhbkNyZWF0ZUVsZW1lbnQoKSkge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IFwib3ZlcmZsb3c6c2Nyb2xsO3pvb206MTtjbGVhcjpib3RoO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwcHg7dmlzaWJpbGl0eTpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwMDBweDtkaXJlY3Rpb246cnRsO1wiO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IHN0eWxlPSd3aWR0aDoyMDBweDtoZWlnaHQ6MXB4Oyc8L2Rpdj5cIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBjb25zdCBpbml0aWFsID0gZGl2LnNjcm9sbExlZnQ7XG4gICAgICAgIGRpdi5zY3JvbGxMZWZ0ID0gLTE7XG4gICAgICAgIGNhY2hlZFJ0bFNjcm9sbExlZnQgPSBkaXYuc2Nyb2xsTGVmdCA8IDAgPyBkaXYuc2Nyb2xsTGVmdCA6IGluaXRpYWw7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFJ0bFNjcm9sbExlZnQ7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqIG1vdmUgdG8ga2VuZG8tY29tbW9uXG4gKi9cbmNsYXNzIEJyb3dzZXJTdXBwb3J0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3Ioem9uZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJykucGlwZShhdWRpdFRpbWUoMTAwKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFBpeGVsUmF0aW8gIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aCgpO1xuICAgIH1cbiAgICBnZXQgcnRsU2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHJ0bFNjcm9sbExlZnQoKTtcbiAgICB9XG59XG5Ccm93c2VyU3VwcG9ydFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkJyb3dzZXJTdXBwb3J0U2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEVYUEFOREVEX1NUQVRFID0ge1xuICAgIGlzRXhwYW5kZWQ6ICgpID0+IHRydWVcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgVU5TRUxFQ1RFRF9TVEFURSA9IHtcbiAgICBpc1Jvd1NlbGVjdGVkOiAoKSA9PiBmYWxzZVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBOT1RfRURJVEVEX1NUQVRFID0ge1xuICAgIGhhc05ldzogKCkgPT4gZmFsc2UsXG4gICAgY29udGV4dDogKCkgPT4gbnVsbFxufTtcbmNvbnN0IGlkZW50aXR5ID0gaXRlbSA9PiBpdGVtO1xuZnVuY3Rpb24gbG9hZFZpZXcodmlldywgc3ViamVjdCkge1xuICAgIHZpZXcubG9hZERhdGEoKTtcbiAgICBpZiAodmlldy5sb2FkaW5nKSB7XG4gICAgICAgIHZpZXcuZGF0YUxvYWRlZC5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBsb2FkVmlldyh2aWV3LCBzdWJqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdWJqZWN0Lm5leHQodmlldyk7XG4gICAgfVxufVxuY29uc3QgTE9BRElORyA9ICdsb2FkaW5nJztcbmNsYXNzIFZpZXdSYW5nZSB7XG4gICAgY29uc3RydWN0b3Ioc2tpcCwgcGFnZVNpemUpIHtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBza2lwLCBwYWdlU2l6ZSwgcGFnZWFibGUsIGlzVmlydHVhbCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHJhbmdlVHlwZSA9IFZpZXdSYW5nZTtcbiAgICAgICAgaWYgKHBhZ2VTaXplKSB7XG4gICAgICAgICAgICBpZiAocGFnZWFibGUpIHtcbiAgICAgICAgICAgICAgICByYW5nZVR5cGUgPSBQYWdlclJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VUeXBlID0gVmlydHVhbFJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgcmFuZ2VUeXBlKHNraXAsIHBhZ2VTaXplKTtcbiAgICB9XG4gICAgaW5SYW5nZShfaW5kZXgsIF9yb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV2ZWxJblJhbmdlKF9wYXJlbnQsIF9pdGVtcywgX3Jvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbmNsdWRlUGFyZW50cyhfY2hpbGRyZW4pIHtcbiAgICB9XG59XG5jbGFzcyBQYWdlclJhbmdlIGV4dGVuZHMgVmlld1JhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5leHBhbmRBbGwgPSB0cnVlO1xuICAgIH1cbiAgICBpblJhbmdlKGluZGV4LCBfcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMuc2tpcCArIHRoaXMucGFnZVNpemU7XG4gICAgfVxuICAgIGxldmVsSW5SYW5nZShwYXJlbnQsIGl0ZW1zLCBfcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5sZXZlbCA9PT0gLTEgfHxcbiAgICAgICAgICAgICh0aGlzLnNraXAgPD0gcGFyZW50LmluZGV4ICsgaXRlbXMubGVuZ3RoICYmIHBhcmVudC5pbmRleCArIDEgPCB0aGlzLnNraXAgKyB0aGlzLnBhZ2VTaXplKTtcbiAgICB9XG4gICAgaW5jbHVkZVBhcmVudHMoY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBhcmVudExldmVsID0gY2hpbGRyZW4ucGFyZW50TGV2ZWw7XG4gICAgICAgIHdoaWxlIChwYXJlbnRMZXZlbCAmJiAhcGFyZW50TGV2ZWwuaW5SYW5nZSkge1xuICAgICAgICAgICAgcGFyZW50TGV2ZWwuaW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnRMZXZlbCA9IHBhcmVudExldmVsLnBhcmVudExldmVsO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVmlydHVhbFJhbmdlIGV4dGVuZHMgVmlld1JhbmdlIHtcbiAgICBpblJhbmdlKF9pbmRleCwgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcCA8PSByb3dJbmRleCAmJiByb3dJbmRleCA8IHRoaXMuc2tpcCArIHRoaXMucGFnZVNpemU7XG4gICAgfVxuICAgIGxldmVsSW5SYW5nZShwYXJlbnQsIF9pdGVtcywgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5SYW5nZShwYXJlbnQuaW5kZXgsIHJvd0luZGV4KTtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVmlld0l0ZW1GYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihleHBhbmRTdGF0ZSwgZWRpdFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSwgbG9hZGVkLCBmaWVsZEFjY2Vzc29yLCByb290SXRlbSkge1xuICAgICAgICB0aGlzLmV4cGFuZFN0YXRlID0gZXhwYW5kU3RhdGU7XG4gICAgICAgIHRoaXMuZWRpdFN0YXRlID0gZWRpdFN0YXRlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gc2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMubG9hZGVkID0gbG9hZGVkO1xuICAgICAgICB0aGlzLmZpZWxkQWNjZXNzb3IgPSBmaWVsZEFjY2Vzc29yO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gW107XG4gICAgICAgIHRoaXMucm93SW5kZXggPSAwO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5maWVsZEFjY2Vzc29yKCk7XG4gICAgICAgIHRoaXMuZmV0Y2hDaGlsZHJlbiA9IG9wdGlvbnMuZmV0Y2hDaGlsZHJlbjtcbiAgICAgICAgdGhpcy5oYXNDaGlsZHJlbiA9IG9wdGlvbnMuaGFzQ2hpbGRyZW47XG4gICAgICAgIHRoaXMuaWRHZXR0ZXIgPSBvcHRpb25zLmlkR2V0dGVyO1xuICAgICAgICB0aGlzLmhhc0Zvb3RlciA9IG9wdGlvbnMuaGFzRm9vdGVyO1xuICAgICAgICB0aGlzLnZpZXdSYW5nZSA9IFZpZXdSYW5nZS5jcmVhdGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChyb290SXRlbSkge1xuICAgICAgICAgICAgdGhpcy5yb290TGV2ZWwgPSB0aGlzLmxvYWRDaGlsZHJlbihyb290SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RMZXZlbCA9IHRoaXMuZGF0YUxldmVsKHtcbiAgICAgICAgICAgICAgICBsZXZlbDogLTEsXG4gICAgICAgICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQ6IHRydWVcbiAgICAgICAgICAgIH0sIG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdHJ5IHRvIHN0b3AgaXRlcmF0aW9uIGlmIGNhY2hlZCB0b3RhbCBhbmQgdmlld1JhbmdlIGVuZHNcbiAgICBnZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFMZXZlbHMgPSBbdGhpcy5yb290TGV2ZWxdO1xuICAgICAgICBsZXQgaXRlbUluZGV4ID0gMDtcbiAgICAgICAgbGV0IGl0ZW1Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuYWRkTmV3KHJlc3VsdCk7XG4gICAgICAgIHdoaWxlIChkYXRhTGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpbGUgKGRhdGFMZXZlbHNbMF0gJiYgZGF0YUxldmVsc1swXS5pZHggPj0gZGF0YUxldmVsc1swXS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTGV2ZWwgPSBkYXRhTGV2ZWxzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzRm9vdGVyICYmIGRhdGFMZXZlbC5leHBhbmRlZCAmJiBkYXRhTGV2ZWwuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGV2ZWwuaW5SYW5nZSB8fCB0aGlzLnZpZXdSYW5nZS5sZXZlbEluUmFuZ2UoZGF0YUxldmVsLnBhcmVudCwgZGF0YUxldmVsLml0ZW1zLCB0aGlzLnJvd0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBkYXRhTGV2ZWwuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlczogZGF0YUxldmVsLmFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGRhdGFMZXZlbC5sZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbmRleDogZGF0YUxldmVsLnBhcmVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiB0aGlzLnJvd0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1JhbmdlLmluY2x1ZGVQYXJlbnRzKGRhdGFMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YUxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGRhdGFMZXZlbHNbMF07XG4gICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGN1cnJlbnRMZXZlbC5pdGVtc1tjdXJyZW50TGV2ZWwuaWR4KytdO1xuICAgICAgICAgICAgY29uc3Qgdmlld0l0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFJdGVtLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkR2V0dGVyKGRhdGFJdGVtKSxcbiAgICAgICAgICAgICAgICByb3dJbmRleDogdGhpcy5yb3dJbmRleCxcbiAgICAgICAgICAgICAgICBpbmRleDogaXRlbUluZGV4LFxuICAgICAgICAgICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWwubGV2ZWwsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IHRoaXMuaGFzQ2hpbGRyZW4oZGF0YUl0ZW0pLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3VycmVudExldmVsLnBhcmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1JhbmdlLmluUmFuZ2UoaXRlbUluZGV4LCB2aWV3SXRlbS5yb3dJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0Rmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdJdGVtLnJvd0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmlld0l0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB2aWV3SXRlbS5lZGl0Q29udGV4dCA9IHRoaXMuZWRpdFN0YXRlLmNvbnRleHQodmlld0l0ZW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdJdGVtLnNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25TdGF0ZS5pc1Jvd1NlbGVjdGVkKGRhdGFJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGROZXcocmVzdWx0LCBkYXRhSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbUNvdW50Kys7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZCA9IHZpZXdJdGVtLmhhc0NoaWxkcmVuICYmIHRoaXMuZXhwYW5kU3RhdGUuaXNFeHBhbmRlZCh2aWV3SXRlbS5kYXRhKTtcbiAgICAgICAgICAgIGlmICh2aWV3SXRlbS5oYXNDaGlsZHJlbiAmJiAoZXhwYW5kZWQgfHwgdGhpcy52aWV3UmFuZ2UuZXhwYW5kQWxsKSkge1xuICAgICAgICAgICAgICAgIHZpZXdJdGVtLmV4cGFuZGVkID0gZXhwYW5kZWQgJiYgY3VycmVudExldmVsLmV4cGFuZGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5sb2FkQ2hpbGRyZW4odmlld0l0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhTGV2ZWxzLnVuc2hpZnQoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wYXJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1zOiByZXN1bHQsXG4gICAgICAgICAgICBvYnNlcnZhYmxlczogdGhpcy5vYnNlcnZhYmxlcyxcbiAgICAgICAgICAgIHRvdGFsOiBpdGVtQ291bnQsXG4gICAgICAgICAgICB0b3RhbFZpc2libGU6IGl0ZW1JbmRleCxcbiAgICAgICAgICAgIHRvdGFsUm93czogdGhpcy5yb3dJbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsb2FkQ2hpbGRyZW4ocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudElkID0gcGFyZW50LmlkO1xuICAgICAgICBpZiAodGhpcy5sb2FkZWQuaGFzKHBhcmVudElkKSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmxvYWRlZC5nZXQocGFyZW50SWQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuID09PSBMT0FESU5HKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUxldmVsKHBhcmVudCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmZldGNoQ2hpbGRyZW4ocGFyZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmFibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHBhcmVudElkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZC5zZXQocGFyZW50SWQsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhTGV2ZWwocGFyZW50LCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGF0YUxldmVsKHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoaWxkcmVuLmRhdGEgfHwgY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZGF0YSAmJiBkYXRhLmxlbmd0aCA/IGRhdGEgOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkeDogMCxcbiAgICAgICAgICAgIGxldmVsOiBwYXJlbnQubGV2ZWwgKyAxLFxuICAgICAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICAgICAgYWdncmVnYXRlczogY2hpbGRyZW4uYWdncmVnYXRlcyxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBwYXJlbnQuZXhwYW5kZWQsXG4gICAgICAgICAgICBwYXJlbnRJbmRleDogcGFyZW50LmluZGV4LFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkTmV3KHJlc3VsdCwgcGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRTdGF0ZS5oYXNOZXcocGFyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgaW5SYW5nZSA9IHRoaXMudmlld1JhbmdlLmluUmFuZ2UoMCwgdGhpcy5yb3dJbmRleCk7XG4gICAgICAgICAgICBjb25zdCByb3dJbmRleCA9IHBhcmVudCB8fCBpblJhbmdlID8gdGhpcy5yb3dJbmRleCA6IHRoaXMudmlld1JhbmdlLnNraXA7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgaXNOZXc6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZWRpdFN0YXRlLm5ld0l0ZW0uZGF0YUl0ZW0sXG4gICAgICAgICAgICAgICAgZWRpdENvbnRleHQ6IHRoaXMuZWRpdFN0YXRlLm5ld0l0ZW0sXG4gICAgICAgICAgICAgICAgcm93SW5kZXg6IHJvd0luZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgfHwgaW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZpZXdDb2xsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZEFjY2Vzc29yLCBleHBhbmRTdGF0ZSwgZWRpdFN0YXRlLCBzZWxlY3Rpb25TdGF0ZSkge1xuICAgICAgICB0aGlzLmZpZWxkQWNjZXNzb3IgPSBmaWVsZEFjY2Vzc29yO1xuICAgICAgICB0aGlzLmV4cGFuZFN0YXRlID0gZXhwYW5kU3RhdGU7XG4gICAgICAgIHRoaXMuZWRpdFN0YXRlID0gZWRpdFN0YXRlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gc2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5Mb2FkZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGF0YUxvYWRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldFBhZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsVmlzaWJsZSA9IDA7XG4gICAgICAgIHRoaXMubG9hZGVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdG90YWxSb3dzID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBzdGF0aWMgbG9hZFZpZXcob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgICAgICAgY29uc3Qgdmlld0ZpZWxkcyA9ICgpID0+IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaWRHZXR0ZXI6IGlkZW50aXR5LFxuICAgICAgICAgICAgcGFnZWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaXJ0dWFsOiBmYWxzZSxcbiAgICAgICAgICAgIHNraXA6IDBcbiAgICAgICAgfSwgb3B0aW9ucy5maWVsZHMpO1xuICAgICAgICBjb25zdCBjaGlsZHJlblZpZXcgPSBuZXcgVmlld0NvbGxlY3Rpb24odmlld0ZpZWxkcywgb3B0aW9ucy5leHBhbmRTdGF0ZSB8fCBFWFBBTkRFRF9TVEFURSwgb3B0aW9ucy5lZGl0U3RhdGUgfHwgTk9UX0VESVRFRF9TVEFURSwgb3B0aW9ucy5zZWxlY3Rpb25TdGF0ZSB8fCBVTlNFTEVDVEVEX1NUQVRFKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGVkKSB7XG4gICAgICAgICAgICBjaGlsZHJlblZpZXcubG9hZGVkID0gb3B0aW9ucy5sb2FkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZFZpZXcoY2hpbGRyZW5WaWV3LCBzdWJqZWN0KTtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfVxuICAgIGdldCB0b3RhbFJvd3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbFJvd3M7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZERhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgZmlyc3QoKSB7IHJldHVybiB0aGlzLmRhdGFbMF07IH1cbiAgICBnZXQgZmlyc3RJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kKGl0ZW0gPT4gaXRlbS50eXBlID09PSAnZGF0YScpO1xuICAgIH1cbiAgICBnZXQgbGFzdCgpIHsgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV07IH1cbiAgICBhdChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9XG4gICAgaXRlbUluZGV4KGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaWRHZXR0ZXIgPSB0aGlzLmZpZWxkQWNjZXNzb3IoKS5pZEdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maW5kSW5kZXgoaSA9PiBpLmlkID09PSBpZEdldHRlcihpdGVtKSk7XG4gICAgfVxuICAgIG1hcChmbikgeyByZXR1cm4gdGhpcy5kYXRhLm1hcChmbik7IH1cbiAgICBmaWx0ZXIoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWx0ZXIoZm4pO1xuICAgIH1cbiAgICBmaW5kSW5kZXgoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maW5kSW5kZXgoZm4pO1xuICAgIH1cbiAgICByZWR1Y2UoZm4sIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5yZWR1Y2UoZm4sIGluaXQpO1xuICAgIH1cbiAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZuKTtcbiAgICB9XG4gICAgc29tZShmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNvbWUoZm4pO1xuICAgIH1cbiAgICBmaW5kKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZmluZChmbik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCk7IH1cbiAgICB1cGRhdGVTZWxlY3RlZFN0YXRlKCkge1xuICAgICAgICB0aGlzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25TdGF0ZS5pc1Jvd1NlbGVjdGVkKGl0ZW0uZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVFZGl0ZWRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5lZGl0Q29udGV4dCA9IHRoaXMuZWRpdFN0YXRlLmNvbnRleHQoaXRlbS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmxvYWRlZC5jbGVhcigpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDaGlsZHJlbigpO1xuICAgIH1cbiAgICByZXNldEl0ZW0oaXRlbSwgcmVzZXRDaGlsZHJlbikge1xuICAgICAgICBjb25zdCBpZEdldHRlciA9IHRoaXMuZmllbGRBY2Nlc3NvcigpLmlkR2V0dGVyO1xuICAgICAgICBjb25zdCB0b1Jlc2V0ID0gW2l0ZW1dO1xuICAgICAgICB3aGlsZSAodG9SZXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0b1Jlc2V0LnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGlkR2V0dGVyKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMubG9hZGVkLmdldChpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzZXRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICB0b1Jlc2V0LnB1c2guYXBwbHkodG9SZXNldCwgY2hpbGRyZW4uZGF0YSB8fCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBsb2FkRGF0YSgpIHtcbiAgICAgICAgY29uc3QgaXRlbUZhY3RvcnkgPSBuZXcgVmlld0l0ZW1GYWN0b3J5KHRoaXMuZXhwYW5kU3RhdGUsIHRoaXMuZWRpdFN0YXRlLCB0aGlzLnNlbGVjdGlvblN0YXRlLCB0aGlzLmxvYWRlZCwgdGhpcy5maWVsZEFjY2Vzc29yKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGl0ZW1GYWN0b3J5LmdlbmVyYXRlKCk7XG4gICAgICAgIGlmICghcmVzdWx0LmxvYWRpbmcgJiYgcmVzdWx0LnRvdGFsICYmICghcmVzdWx0Lml0ZW1zLmxlbmd0aCB8fCAhcmVzdWx0Lml0ZW1zLnNvbWUoaSA9PiBpLnR5cGUgPT09ICdkYXRhJykpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFnZS5lbWl0KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVmlld0l0ZW1GYWN0b3J5KHRoaXMuZXhwYW5kU3RhdGUsIHRoaXMuZWRpdFN0YXRlLCB0aGlzLnNlbGVjdGlvblN0YXRlLCB0aGlzLmxvYWRlZCwgdGhpcy5maWVsZEFjY2Vzc29yKS5nZW5lcmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSByZXN1bHQuaXRlbXM7XG4gICAgICAgIHRoaXMudG90YWwgPSByZXN1bHQudG90YWw7XG4gICAgICAgIHRoaXMudG90YWxWaXNpYmxlID0gcmVzdWx0LnRvdGFsVmlzaWJsZTtcbiAgICAgICAgdGhpcy5fdG90YWxSb3dzID0gcmVzdWx0LnRvdGFsUm93cztcbiAgICAgICAgaWYgKHJlc3VsdC5vYnNlcnZhYmxlcyAmJiByZXN1bHQub2JzZXJ2YWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQ291bnQgKz0gcmVzdWx0Lm9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGlsZHJlblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5TdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQub2JzZXJ2YWJsZXMuZm9yRWFjaChvID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZC5zZXQoby5wYXJlbnRJZCwgTE9BRElORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblN1YnNjcmlwdGlvbi5hZGQoby5vYnNlcnZhYmxlLnN1YnNjcmliZShjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQuc2V0KG8ucGFyZW50SWQsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkxvYWRlZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ0NvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUxvYWRlZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxvYWRlZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDaGlsZHJlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSW4gdGhpcyB3YXksIHRoZSBzb3VyY2UgY29tcG9uZW50IHN1cHByZXNzZXNcbiAgICAgKiB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXZlbnQgd2FzIHByZXZlbnRlZFxuICAgICAqIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQuXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICovXG4gICAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50ZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjZWxsQ2xvc2VgIGV2ZW50LlxuICovXG5jbGFzcyBDZWxsQ2xvc2VFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aW9uID0gJ2NlbGxDbG9zZSc7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5jb25zdCBpZGVudGl0eSQxID0gaXRlbSA9PiBpdGVtO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEVkaXRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pZEdldHRlciA9IGlkZW50aXR5JDE7XG4gICAgICAgIC8vIE1hcHMgSURzIHRvIGVkaXRlZCByb3dzXG4gICAgICAgIHRoaXMuZWRpdGVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmtlZXBFZGl0Q2VsbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NpbmdDZWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbmdlZFNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRoaXMuY2hhbmdlZFNvdXJjZS5hc09ic2VydmFibGUoKS5waXBlKHN3aXRjaE1hcCgoKSA9PiB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpKSk7XG4gICAgfVxuICAgIGdldCBuZXdJdGVtR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0l0ZW0gPyB0aGlzLm5ld0l0ZW0uZ3JvdXAgOiBudWxsO1xuICAgIH1cbiAgICBlZGl0Um93KGRhdGFJdGVtLCBncm91cCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVkaXRlZC5zZXQodGhpcy5pZEdldHRlcihkYXRhSXRlbSksIHtcbiAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgaXRlbTogZGF0YUl0ZW1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VkKCk7XG4gICAgfVxuICAgIGFkZFJvdyhwYXJlbnQsIGdyb3VwKSB7XG4gICAgICAgIHRoaXMubmV3SXRlbSA9IHsgcGFyZW50LCBncm91cCwgZGF0YUl0ZW06IGdyb3VwID8gZ3JvdXAudmFsdWUgOiBudWxsIH07XG4gICAgICAgIHRoaXMub25DaGFuZ2VkKCk7XG4gICAgfVxuICAgIGVkaXRDZWxsKGl0ZW0sIGNvbHVtbiwgZ3JvdXApIHtcbiAgICAgICAgaWYgKCFpc0NvbHVtbkVkaXRhYmxlKGNvbHVtbiwgZ3JvdXApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2ZW50Q2VsbENsb3NlKCk7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZUNlbGwoKSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Um93KGl0ZW0sIGdyb3VwKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VkaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRlZC5zaXplID4gMDtcbiAgICB9XG4gICAgaXNFZGl0ZWQoZGF0YUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5ld0l0ZW0gJiYgdGhpcy5uZXdJdGVtLmRhdGFJdGVtID09PSBkYXRhSXRlbSkgfHxcbiAgICAgICAgICAgIHRoaXMuZWRpdGVkLmhhcyh0aGlzLmlkR2V0dGVyKGRhdGFJdGVtKSk7XG4gICAgfVxuICAgIGlzRWRpdGluZ0NlbGwoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb2x1bW4pO1xuICAgIH1cbiAgICBpc0VkaXRpbmdDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbiA9PT0gY29sdW1uO1xuICAgIH1cbiAgICBpc0VkaXRlZENvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtbiB8fCB0aGlzLmNvbHVtbiA9PT0gY29sdW1uO1xuICAgIH1cbiAgICBoYXNOZXcocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMubmV3SXRlbSAmJiAoKCF0aGlzLm5ld0l0ZW0ucGFyZW50ICYmICFwYXJlbnQpIHx8XG4gICAgICAgICAgICB0aGlzLmlkR2V0dGVyKHRoaXMubmV3SXRlbS5wYXJlbnQpID09PSB0aGlzLmlkR2V0dGVyKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZ2V0IG5ld0RhdGFJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5uZXdJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdJdGVtLmdyb3VwLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKGl0ZW0sIGlzTmV3KSB7XG4gICAgICAgIGlmIChpc05ldykgeyAvLyBwYXJlbnRcbiAgICAgICAgICAgIHRoaXMubmV3SXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRlZC5kZWxldGUodGhpcy5pZEdldHRlcihpdGVtKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZWQoKTtcbiAgICB9XG4gICAgY2xvc2VDZWxsKG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uICYmICF0aGlzLmNsb3NpbmdDZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGl0ZW0sIGdyb3VwIH0gPSB0aGlzLmZpcnN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgQ2VsbENsb3NlRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtR3JvdXA6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbTogaXRlbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2luZ0NlbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2luZ0NlbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxDZWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsQ2VsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRlZC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRDbG9zZUNlbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbiAmJiAhdGhpcy5rZWVwRWRpdENlbGw7XG4gICAgfVxuICAgIHByZXZlbnRDZWxsQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQ2VsbFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5rZWVwRWRpdENlbGwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5rZWVwQ2VsbFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwRWRpdENlbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDApOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmFsaWduXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb250ZXh0KGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRlZC5nZXQodGhpcy5pZEdldHRlcihkYXRhSXRlbSkpO1xuICAgIH1cbiAgICBiZWdpbkVkaXQoaXRlbSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCh7IGFjdGlvbjogJ2VkaXQnLCBkYXRhSXRlbTogaXRlbSB9KTtcbiAgICB9XG4gICAgYmVnaW5BZGQocGFyZW50KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHsgYWN0aW9uOiAnYWRkJywgcGFyZW50IH0pO1xuICAgIH1cbiAgICBlbmRFZGl0KGRhdGFJdGVtLCBpc05ldykge1xuICAgICAgICBjb25zdCBmb3JtR3JvdXAgPSBpc05ldyA/IHRoaXMubmV3SXRlbUdyb3VwIDogdGhpcy5jb250ZXh0KGRhdGFJdGVtKS5ncm91cDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoeyBhY3Rpb246ICdjYW5jZWwnLCBkYXRhSXRlbSwgZm9ybUdyb3VwLCBpc05ldyB9KTtcbiAgICB9XG4gICAgc2F2ZShpdGVtLCBpc05ldykge1xuICAgICAgICBjb25zdCBhcmdzID0geyBhY3Rpb246ICdzYXZlJywgaXNOZXc6IGlzTmV3IH07XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgICAgYXJncy5wYXJlbnQgPSB0aGlzLm5ld0l0ZW0ucGFyZW50O1xuICAgICAgICAgICAgYXJncy5mb3JtR3JvdXAgPSB0aGlzLm5ld0l0ZW0uZ3JvdXA7XG4gICAgICAgICAgICBhcmdzLmRhdGFJdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MuZGF0YUl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgYXJncy5mb3JtR3JvdXAgPSB0aGlzLmNvbnRleHQoaXRlbSkuZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoYXJncyk7XG4gICAgfVxuICAgIHJlbW92ZShkYXRhSXRlbSwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHsgYWN0aW9uOiAncmVtb3ZlJywgZGF0YUl0ZW0sIHBhcmVudCB9KTtcbiAgICB9XG4gICAgb25DaGFuZ2VkKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRTb3VyY2UubmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICBpZiAodGhpcy5pc0VkaXRpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGVkLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkVkaXRTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5FZGl0U2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuXG5jb25zdCByZXNldCA9ICguLi5saXN0cykgPT4ge1xuICAgIGxldCBkaWZmID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbGlzdHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBbbGlzdCwgY29sdW1uc10gPSBsaXN0c1tpZHhdO1xuICAgICAgICBkaWZmID0gZGlmZiB8fCBsaXN0Lmxlbmd0aCAhPT0gY29sdW1ucy5sZW5ndGg7XG4gICAgICAgIGxpc3QucmVzZXQoY29sdW1ucyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5zQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5sZWFmQ29sdW1ucyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5sb2NrZWRDb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLm5vbkxvY2tlZENvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMubG9ja2VkTGVhZkNvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMubm9uTG9ja2VkTGVhZkNvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMudG90YWxMZXZlbHMgPSAwO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGVhZkNvbHVtbnNUb1JlbmRlciA9IFtdO1xuICAgICAgICB0aGlzLmxvY2tlZENvbHVtbnNUb1JlbmRlciA9IFtdO1xuICAgICAgICB0aGlzLm5vbkxvY2tlZENvbHVtbnNUb1JlbmRlciA9IFtdO1xuICAgICAgICB0aGlzLmhhc0Zvb3RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVubG9ja2VkV2lkdGggPSAwO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TGV2ZWxzID0gdGhpcy50b3RhbExldmVscztcbiAgICAgICAgY29uc3QgbGVhZkNvbHVtbnMkJDEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbG9ja2VkTGVhZkNvbHVtbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgbm9uTG9ja2VkTGVhZkNvbHVtbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbG9ja2VkQ29sdW1ucyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBub25Mb2NrZWRDb2x1bW5zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGFsbENvbHVtbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGVhZkNvbHVtbnNUb1JlbmRlciA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBsb2NrZWRDb2x1bW5zVG9SZW5kZXIgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgbm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGxldCBoYXNGb290ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHVubG9ja2VkV2lkdGggPSAwO1xuICAgICAgICBsZXQgbGVhZkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50b3RhbExldmVscyA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1ucygpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckxlYWZDb2x1bW5zID0gY29sdW1uLmlzTG9ja2VkID09PSB0cnVlID8gbG9ja2VkTGVhZkNvbHVtbnMgOiBub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckNvbHVtbnMgPSBjb2x1bW4uaXNMb2NrZWQgPT09IHRydWUgPyBsb2NrZWRDb2x1bW5zIDogbm9uTG9ja2VkQ29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IHRvUmVuZGVyQ29udGFpbmVyID0gY29sdW1uLmlzTG9ja2VkID09PSB0cnVlID8gbG9ja2VkQ29sdW1uc1RvUmVuZGVyIDogbm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyO1xuICAgICAgICAgICAgaWYgKCFpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJMZWFmQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgbGVhZkNvbHVtbnMkJDEucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGxlYWZDb2x1bW5zVG9SZW5kZXIucHVzaC5hcHBseShsZWFmQ29sdW1uc1RvUmVuZGVyLCBjb2x1bW5zVG9SZW5kZXIoW2NvbHVtbl0pKTtcbiAgICAgICAgICAgICAgICB0b1JlbmRlckNvbnRhaW5lci5wdXNoLmFwcGx5KHRvUmVuZGVyQ29udGFpbmVyLCBjb2x1bW5zVG9SZW5kZXIoW2NvbHVtbl0pKTtcbiAgICAgICAgICAgICAgICBoYXNGb290ZXIgPSBoYXNGb290ZXIgfHwgc29tZUxlYWZDb2x1bW4obGVhZiA9PiBCb29sZWFuKGxlYWYuZm9vdGVyVGVtcGxhdGVSZWYpLCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmICghY29sdW1uLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVubG9ja2VkV2lkdGggKz0gY29sdW1uLndpZHRoIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jaGlsZENvbHVtbnMuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGVhZkluZGV4ID0gbGVhZkluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmxlYWZJbmRleCA9IGxlYWZJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lckNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgYWxsQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB0aGlzLnRvdGFsTGV2ZWxzID0gY29sdW1uLmxldmVsID4gdGhpcy50b3RhbExldmVscyA/IGNvbHVtbi5sZXZlbCA6IHRoaXMudG90YWxMZXZlbHM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhc0Zvb3RlciA9IGhhc0Zvb3RlcjtcbiAgICAgICAgdGhpcy5sZWFmQ29sdW1uc1RvUmVuZGVyID0gbGVhZkNvbHVtbnNUb1JlbmRlcjtcbiAgICAgICAgdGhpcy5sb2NrZWRDb2x1bW5zVG9SZW5kZXIgPSBsb2NrZWRDb2x1bW5zVG9SZW5kZXI7XG4gICAgICAgIHRoaXMubm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyID0gbm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyO1xuICAgICAgICB0aGlzLnVubG9ja2VkV2lkdGggPSB1bmxvY2tlZFdpZHRoO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gcmVzZXQoW3RoaXMubGVhZkNvbHVtbnMsIGxlYWZDb2x1bW5zJCQxXSwgW3RoaXMubG9ja2VkTGVhZkNvbHVtbnMsIGxvY2tlZExlYWZDb2x1bW5zXSwgW3RoaXMubm9uTG9ja2VkTGVhZkNvbHVtbnMsIG5vbkxvY2tlZExlYWZDb2x1bW5zXSwgW3RoaXMubG9ja2VkQ29sdW1ucywgbG9ja2VkQ29sdW1uc10sIFt0aGlzLmFsbENvbHVtbnMsIGFsbENvbHVtbnNdLCBbdGhpcy5ub25Mb2NrZWRDb2x1bW5zLCBub25Mb2NrZWRDb2x1bW5zXSkgfHwgY3VycmVudExldmVscyAhPT0gdGhpcy50b3RhbExldmVscztcbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbiB8fCB0aGlzLnN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5uZ1pvbmUub25TdGFibGVcbiAgICAgICAgICAgICAgICAuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jaGFuZ2VzLmVtaXQoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5DaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbm8tcmVjb3JkcyB0ZW1wbGF0ZSBvZiB0aGUgVHJlZUxpc3QuIFByb3ZpZGVzIGFuIG9wdGlvbiB0byBjdXN0b21pemUgdGhlXG4gKiBhcHBlYXJhbmNlIG9mIHRoZSBpdGVtIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gbm8gZGF0YSBpcyBwcmVzZW50LiBUbyBkZWZpbmUgdGhlIG5vLXJlY29yZHMgdGVtcGxhdGUsXG4gKiBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZUxpc3ROb1JlY29yZHNUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBgPGtlbmRvLXRyZWVsaXN0PmAuXG4gKlxuICogPiBXaGVuIHRoZSBsb2NrZWQgY29sdW1ucyBvZiB0aGUgVHJlZUxpc3QgYXJlIGluIHVzZSwgdGhlIHRlbXBsYXRlIGlzIGRpc3BsYXllZCBpbiB0aGUgbm9uLWxvY2tlZCBwYXJ0IG9mIHRoZSBjb250ZW50LlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjUzMyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb25maWd1cmF0aW9uL25vLXJlY29yZHMtdGVtcGxhdGUvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9lbXBsb3llZXMudHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgTm9SZWNvcmRzVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Ob1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3ROb1JlY29yZHNUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbmNvbnN0IHNldCA9IHZhbHVlID0+IHBhaXIgPT4gcGFpci5mb3JFYWNoKHggPT4geC5zdHlsZS5oZWlnaHQgPSB2YWx1ZSk7XG5jb25zdCBjbGVhckhlaWdodCA9IHBhaXJzID0+IHBhaXJzXG4gICAgLmZpbHRlcigoW2xlZnQsIHJpZ2h0XSkgPT4gbGVmdC5zdHlsZS5oZWlnaHQgfHwgcmlnaHQuc3R5bGUuaGVpZ2h0KVxuICAgIC5mb3JFYWNoKHNldChcIlwiKSk7XG5jb25zdCB6aXAkMSA9IChhcnIxLCBhcnIyKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgbGVuID0gYXJyMS5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKCFhcnIyW2lkeF0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKFthcnIxW2lkeF0sIGFycjJbaWR4XV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IHNldEhlaWdodCA9IGhlaWdodHMgPT4gKHJvdywgaWR4KSA9PiBzZXQoYCR7aGVpZ2h0c1tpZHhdICsgMX1weGApKHJvdyk7XG5jb25zdCBnZXRIZWlnaHRzID0gcm93cyA9PiByb3dzLm1hcCgoW2xlZnQsIHJpZ2h0XSkgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IGxlZnQub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldEhlaWdodDIgPSByaWdodC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKGhlaWdodCA8IG9mZnNldEhlaWdodDIpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldEhlaWdodDI7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzeW5jUm93c0hlaWdodCA9ICh0YWJsZTEsIHRhYmxlMikgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGNvbnN0IHJvd3MgPSB6aXAkMSh0YWJsZTEucm93cywgdGFibGUyLnJvd3MpO1xuICAgIGNsZWFySGVpZ2h0KHJvd3MpO1xuICAgIGNvbnN0IGhlaWdodHMgPSBnZXRIZWlnaHRzKHJvd3MpO1xuICAgIFt0YWJsZTEsIHRhYmxlMl0uZm9yRWFjaCh4ID0+IHguc3R5bGUuZGlzcGxheSA9ICdub25lJyk7XG4gICAgcm93cy5mb3JFYWNoKHNldEhlaWdodChoZWlnaHRzKSk7XG4gICAgW3RhYmxlMSwgdGFibGUyXS5mb3JFYWNoKHggPT4geC5zdHlsZS5kaXNwbGF5ID0gJycpO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmVFbGVtZW50ICYmXG4gICAgICAgICh0YWJsZTEuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgfHwgdGFibGUyLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2VydmljZSB0byBzZXQgdGhlIGZpbHRlciBkZXNjcmlwdG9yXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJldXNhYmxlY3VzdG9tZmlsdGVyc190cmVlbGlzdCAlfSkpLlxuICovXG5jbGFzcyBGaWx0ZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZpbHRlciBkZXNjcmlwdG9ycyBpcyBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWx0ZXIgZGVzY3JpcHRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcn0gdmFsdWUgLSBUaGUgZmlsdGVyIGRlc2NyaXB0b3IgdGhhdCB3aWxsIGJlIHNldC5cbiAgICAgKi9cbiAgICBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQodmFsdWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBwYWdlciB0ZW1wbGF0ZSB3aGljaCBoZWxwcyB0byBjdXN0b21pemUgdGhlIHBhZ2VyIGFwcGVhcmFuY2UgaW4gdGhlIFRyZWVMaXN0LiBUbyBkZWZpbmUgYSBwYWdlclxuICogdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9UcmVlTGlzdFBhZ2VyVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYDxrZW5kby10cmVlbGlzdD5gLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBjb250ZXh0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICogKiBgY3VycmVudFBhZ2VgJm1kYXNoO1RoZSBpbmRleCBvZiB0aGUgZGlzcGxheWVkIHBhZ2UuXG4gKiAqIGBwYWdlU2l6ZWAmbWRhc2g7VGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGBwYWdlU2l6ZWAuXG4gKiAqIGBza2lwYCZtZGFzaDtUaGUgY3VycmVudCBza2lwIHZhbHVlLlxuICogKiBgdG90YWxgJm1kYXNoO1RoZSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkcy5cbiAqICogYHRvdGFsUGFnZXNgJm1kYXNoO1RoZSB0b3RhbCBudW1iZXIgb2YgYXZhaWxhYmxlIHBhZ2VzLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjQ3MCAlfVxuICogeyUgZW1iZWRfZmlsZSBjb25maWd1cmF0aW9uL3BhZ2VyLXRlbXBsYXRlLWFsbC9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2ZpbGVzeXN0ZW0udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cblBhZ2VyVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0UGFnZXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBhZ2VyVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhZ2VyQ29udGV4dFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNraXAgLyB0aGlzLnBhZ2VTaXplO1xuICAgIH1cbiAgICBub3RpZnlDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IGNoYW5nZXMudG90YWw7XG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBjaGFuZ2VzLnBhZ2VTaXplO1xuICAgICAgICB0aGlzLnNraXAgPSBjaGFuZ2VzLnNraXA7XG4gICAgICAgIHRoaXMuYWxsQ291bnQgPSBjaGFuZ2VzLmFsbENvdW50O1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dChjaGFuZ2VzKTtcbiAgICB9XG4gICAgY2hhbmdlUGFnZShwYWdlKSB7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZS5uZXh0KHsgc2tpcDogcGFnZSAqIHRoaXMucGFnZVNpemUsIHRha2U6IHRoaXMucGFnZVNpemUgfSk7XG4gICAgfVxuICAgIGNoYW5nZVBhZ2VTaXplKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZS5uZXh0KHsgc2tpcDogMCwgdGFrZTogdmFsdWUgfSk7XG4gICAgfVxuICAgIG5leHRQYWdlKCkge1xuICAgICAgICBjb25zdCBuZXh0UGFnZSA9IHRoaXMuY3VycmVudFBhZ2UgKyAxO1xuICAgICAgICBpZiAobmV4dFBhZ2UgKiB0aGlzLnBhZ2VTaXplIDw9IHRoaXMudG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlUGFnZShuZXh0UGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldlBhZ2UoKSB7XG4gICAgICAgIGNvbnN0IHByZXZQYWdlID0gdGhpcy5jdXJyZW50UGFnZSAtIDE7XG4gICAgICAgIGlmIChwcmV2UGFnZSAqIHRoaXMucGFnZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKHByZXZQYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBERlNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNhdmVQREYgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZHJhd1BERiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5leHBvcnRDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgc2F2ZShjb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5zYXZlUERGLCBjb21wb25lbnQpO1xuICAgIH1cbiAgICBkcmF3KGNvbXBvbmVudCwgcHJvbWlzZSkge1xuICAgICAgICB0aGlzLmVtaXRFdmVudCh0aGlzLmRyYXdQREYsIHsgY29tcG9uZW50LCBwcm9taXNlIH0pO1xuICAgIH1cbiAgICBlbWl0RXZlbnQoZW1pdHRlciwgYXJncykge1xuICAgICAgICBpZiAoZW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWF0aW5nIFBERiByZXF1aXJlcyBpbmNsdWRpbmcgdGhlIFBERk1vZHVsZSBhbmQgYWRkaW5nIHRoZSA8a2VuZG8tdHJlZWxpc3QtcGRmPiBjb21wb25lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5QREZTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBwZGZFeHBvcnRgIGV2ZW50LlxuICovXG5jbGFzcyBQREZFeHBvcnRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3VzcGVuZFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNjcm9sbCA9IGZhbHNlO1xuICAgIH1cbn1cblN1c3BlbmRTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTogb2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzICovXG5jb25zdCBib290c3RyYXBUb01lZGlhID0gKG1lZGlhKSA9PiAoKHtcbiAgICBcInhzXCI6IFwiKG1heC13aWR0aDogNTc2cHgpXCIsXG4gICAgXCJzbVwiOiBcIihtaW4td2lkdGg6IDU3NnB4KVwiLFxuICAgIFwibWRcIjogXCIobWluLXdpZHRoOiA3NjhweClcIixcbiAgICBcImxnXCI6IFwiKG1pbi13aWR0aDogOTkycHgpXCIsXG4gICAgXCJ4bFwiOiBcIihtaW4td2lkdGg6IDEyMDBweClcIlxufSlbbWVkaWFdIHx8IG1lZGlhKTtcbi8qIHRzbGludDplbmFibGU6IG9iamVjdC1saXRlcmFsLXNvcnQta2V5cyAqL1xuY29uc3QgYnJvd3Nlck1hdGNoTWVkaWEgPSAobWVkaWEpID0+IHdpbmRvdy5tYXRjaE1lZGlhKG1lZGlhKS5tYXRjaGVzO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJlc3BvbnNpdmVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF0Y2hNZWRpYSA9IGJyb3dzZXJNYXRjaE1lZGlhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbWF0Y2hlc01lZGlhKG1lZGlhKSB7XG4gICAgICAgIHJldHVybiAhbWVkaWEgfHwgdGhpcy5tYXRjaE1lZGlhKGJvb3RzdHJhcFRvTWVkaWEobWVkaWEpKTtcbiAgICB9XG59XG5SZXNwb25zaXZlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEV4Y2VsU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2F2ZVRvRXhjZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZXhwb3J0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubG9hZGluZ0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgc2F2ZShjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2F2ZVRvRXhjZWwub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYXZpbmcgZXhjZWwgcmVxdWlyZXMgaW5jbHVkaW5nIHRoZSBFeGNlbE1vZHVsZSBhbmQgYWRkaW5nIHRoZSA8a2VuZG8tdHJlZWxpc3QtZXhjZWw+IGNvbXBvbmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZVRvRXhjZWwuZW1pdChjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZUxvYWRpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMubG9hZGluZ0NoYW5nZS5lbWl0KCk7XG4gICAgfVxufVxuRXhjZWxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG5jb25zdCBmb3JFYWNoQ29sdW1uID0gKGxpc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgbGlzdC5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgY2FsbGJhY2soY29sdW1uKTtcbiAgICAgICAgaWYgKGNvbHVtbi5pc0NvbHVtbkdyb3VwICYmIGNvbHVtbi5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yRWFjaENvbHVtbihjb2x1bW4uY2hpbGRyZW5BcnJheSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgZm9yRWFjaExldmVsID0gKGxpc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgc29ydENvbHVtbnMobGlzdClcbiAgICAgICAgLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICBjYWxsYmFjayhjb2x1bW4pO1xuICAgICAgICBpZiAoY29sdW1uLmlzQ29sdW1uR3JvdXAgJiYgY29sdW1uLmhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3JFYWNoTGV2ZWwoY29sdW1uLmNoaWxkcmVuQXJyYXksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IGZpbHRlckhpZXJhcmNoeSA9IChsaXN0LCBwcmVkaWNhdGUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzb3J0Q29sdW1ucyhsaXN0KVxuICAgICAgICAuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY29sdW1uKSkge1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5pc0NvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4kJDEgPSBmaWx0ZXJIaWVyYXJjaHkoY29sdW1uLmNoaWxkcmVuQXJyYXksIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuJCQxLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2x1bW4sIC4uLmNoaWxkcmVuJCQxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29sdW1uLmlzU3BhbkNvbHVtbiB8fCBmaWx0ZXJIaWVyYXJjaHkoY29sdW1uLmNoaWxkcmVuQXJyYXksIHByZWRpY2F0ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbHVtbkxpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbHVtbkxpc3QobmV3IFF1ZXJ5TGlzdCgpKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICBmb3JFYWNoQ29sdW1uKHRoaXMuY29sdW1ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvckVhY2hDb2x1bW4odGhpcy5jb2x1bW5zLCAoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soY29sdW1uKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaWx0ZXJIaWVyYXJjaHkocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJIaWVyYXJjaHkodGhpcy5jb2x1bW5zLnRvQXJyYXkoKSwgcHJlZGljYXRlKTtcbiAgICB9XG4gICAgZmlsdGVyU29ydChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yRWFjaExldmVsKHRoaXMuY29sdW1ucy50b0FycmF5KCksIChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JFYWNoQ29sdW1uKHRoaXMuY29sdW1ucywgKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29sdW1uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJvb3RDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLnRvQXJyYXkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdG9vbGJhciB0ZW1wbGF0ZSBvZiB0aGUgVHJlZUxpc3QuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGQ6XG4gKiAtIGBwb3NpdGlvbmAmbWRhc2g7VGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSB0b29sYmFyIHRlbXBsYXRlIGlzIHJlbmRlcmVkLiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZSBcInRvcFwiIGFuZCBcImJvdHRvbVwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiB7JSBtZXRhIGhlaWdodDo0NzAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29uZmlndXJhdGlvbi90b29sYmFyLXRlbXBsYXRlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvbWFpbi50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZW1wbG95ZWVzLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYsIG9wdGlvbkNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgICAgICB0aGlzLm9wdGlvbkNoYW5nZXMgPSBvcHRpb25DaGFuZ2VzO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IFwidG9wXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRvb2xiYXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSkpLlxuICAgICAqXG4gICAgICogVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgdG9wYCZtZGFzaDtQb3NpdGlvbnMgdGhlIHRvb2xiYXIgYWJvdmUgdGhlIGdyb3VwIHBhbmVsIG9yIGhlYWRlci5cbiAgICAgKiAtIGBib3R0b21gJm1kYXNoO1Bvc2l0aW9ucyB0aGUgdG9vbGJhciBiZWxvdyB0aGUgcGFnZXIuXG4gICAgICogLSBgYm90aGAmbWRhc2g7RGlzcGxheXMgdHdvIHRvb2xiYXIgaW5zdGFuY2VzLiBQb3NpdGlvbnMgdGhlIGZpcnN0IG9uZSBhYm92ZVxuICAgICAqIHRoZSBncm91cCBwYW5lbCBvciBoZWFkZXIgYW5kIHRoZSBzZWNvbmQgb25lIGJlbG93IHRoZSBwYWdlci5cbiAgICAgKi9cbiAgICBzZXQgcG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5vcHRpb25DaGFuZ2VzLm9wdGlvbkNoYW5nZWQoKTtcbiAgICB9XG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgfVxufVxuVG9vbGJhclRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdFRvb2xiYXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgIHsgdHlwZTogT3B0aW9uQ2hhbmdlc1NlcnZpY2UgfVxuXTtcblRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBwb3NpdGlvbjogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcInBvc2l0aW9uXCIsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNjcm9sbFN5bmNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmhlYWRlclN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY2hhbmdlcy5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLnNjcm9sbExlZnQoYXJncykpKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFbWl0dGVyKGVsLCBzb3VyY2VUeXBlKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlcihzb3VyY2VUeXBlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKHsgZWxlbWVudDogZWwsIHNvdXJjZVR5cGUgfSk7XG4gICAgICAgIGlmIChzb3VyY2VUeXBlID09PSBcImJvZHlcIiB8fCBzb3VyY2VUeXBlID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzID0gZnJvbUV2ZW50KGVsLCBcInNjcm9sbFwiKS5waXBlKG1hcCgoeyB0YXJnZXQ6IHsgc2Nyb2xsTGVmdCB9IH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGVcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9icy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCh4LCB5KSA9PiAoeC5zY3JvbGxMZWZ0ID09PSB5LnNjcm9sbExlZnQpKSwgZmlsdGVyKHggPT4gIXRoaXMuc291cmNlIHx8IHRoaXMuc291cmNlID09PSB4LnNvdXJjZVR5cGUpLCB0YXAoeCA9PiB0aGlzLnNvdXJjZSA9IHguc291cmNlVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHgpID0+IHRoaXMuY2hhbmdlcy5uZXh0KHgpKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKG9icy5waXBlKGZpbHRlcih4ID0+IHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlICE9PSB4LnNvdXJjZVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc291cmNlID0gdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVR5cGUgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keVN1YnNjcmlwdGlvbi5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyU3Vic2NyaXB0aW9uLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHNjcm9sbExlZnQoeyBzY3JvbGxMZWZ0LCBzb3VyY2VUeXBlIH0pIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiBzb3VyY2VUeXBlICE9PSB4LnNvdXJjZVR5cGUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoc291cmNlVHlwZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZWxlbWVudHMuZmluZEluZGV4KHggPT4geC5zb3VyY2VUeXBlID09PSBzb3VyY2VUeXBlKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlclN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuU2Nyb2xsU3luY1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNjcm9sbFN5bmNTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptZW1iZXItb3JkZXJpbmdcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5kaXNwYXRjaGVyLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGhyb3R0bGVUaW1lKDEwMCkpO1xuICAgIH1cbiAgICBjb25uZWN0KHJlc2l6ZXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTdWJzY3JpcHRpb24uYWRkKHJlc2l6ZXMuc3Vic2NyaWJlKHRoaXMuZGlzcGF0Y2hlcikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5SZXNpemVTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG5jb25zdCBmb2N1c2FibGVSZWdleCA9IC9eKD86YXxpbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pO1xuY29uc3QgTk9ERV9OQU1FX1BSRURJQ0FURVMgPSB7fTtcbmNvbnN0IHRvQ2xhc3NMaXN0ID0gKGNsYXNzTmFtZXMpID0+IFN0cmluZyhjbGFzc05hbWVzKS50cmltKCkuc3BsaXQoJyAnKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNDbGFzc2VzID0gKGVsZW1lbnQsIGNsYXNzTmFtZXMpID0+IHtcbiAgICBjb25zdCBuYW1lc0xpc3QgPSB0b0NsYXNzTGlzdChjbGFzc05hbWVzKTtcbiAgICByZXR1cm4gQm9vbGVhbih0b0NsYXNzTGlzdChlbGVtZW50LmNsYXNzTmFtZSkuZmluZCgoY2xhc3NOYW1lKSA9PiBuYW1lc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpID49IDApKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hlc0NsYXNzZXMgPSAoY2xhc3NOYW1lcykgPT4gKGVsZW1lbnQpID0+IGhhc0NsYXNzZXMoZWxlbWVudCwgY2xhc3NOYW1lcyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbWF0Y2hlc05vZGVOYW1lID0gKG5vZGVOYW1lKSA9PiB7XG4gICAgaWYgKCFOT0RFX05BTUVfUFJFRElDQVRFU1tub2RlTmFtZV0pIHtcbiAgICAgICAgTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdID0gKGVsZW1lbnQpID0+IFN0cmluZyhlbGVtZW50Lm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0ID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb3Nlc3RJblNjb3BlID0gKG5vZGUsIHByZWRpY2F0ZSwgc2NvcGUpID0+IHtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBzY29wZSAmJiAhcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlICE9PSBzY29wZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNvbnRhaW5zID0gKHBhcmVudCwgbm9kZSwgbWF0Y2hTZWxmID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBvdXRzaWRlID0gIWNsb3Nlc3Qobm9kZSwgKGNoaWxkKSA9PiBjaGlsZCA9PT0gcGFyZW50KTtcbiAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gY2xvc2VzdChub2RlLCAoY2hpbGQpID0+IGNoaWxkID09PSBub2RlKTtcbiAgICByZXR1cm4gZWwgJiYgKG1hdGNoU2VsZiB8fCBlbCAhPT0gcGFyZW50KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNWaXNpYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBoYXNTaXplID0gcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICAgIGNvbnN0IGhhc1Bvc2l0aW9uID0gcmVjdC54ICE9PSAwICYmIHJlY3QueSAhPT0gMDtcbiAgICAvLyBFbGVtZW50cyBjYW4gaGF2ZSB6ZXJvIHNpemUgZHVlIHRvIHN0eWxpbmcsIGJ1dCB0aGV5IHdpbGwgc3RpbGwgY291bnQgYXMgdmlzaWJsZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIHNlbGVjdGlvbiBjaGVja2JveCBoYXMgbm8gc2l6ZSwgYnV0IGlzIG1hZGUgdmlzaWJsZSB0aHJvdWdoIHN0eWxpbmcuXG4gICAgcmV0dXJuIChoYXNTaXplIHx8IGhhc1Bvc2l0aW9uKSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNGb2N1c2FibGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmICghZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc1RhYkluZGV4ID0gQm9vbGVhbihlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKSk7XG4gICAgY29uc3QgZm9jdXNhYmxlID0gIWVsZW1lbnQuZGlzYWJsZWQgJiYgZm9jdXNhYmxlUmVnZXgudGVzdCh0YWdOYW1lKTtcbiAgICByZXR1cm4gZm9jdXNhYmxlIHx8IGhhc1RhYkluZGV4O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGNvbnN0IHZpc2libGUgPSAhY2hlY2tWaXNpYmlsaXR5IHx8IGlzVmlzaWJsZShlbGVtZW50KTtcbiAgICByZXR1cm4gdmlzaWJsZSAmJiB0YWJJbmRleCAhPT0gJy0xJztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZmluZEVsZW1lbnQgPSAobm9kZSwgcHJlZGljYXRlLCBtYXRjaFNlbGYgPSB0cnVlKSA9PiB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoU2VsZiAmJiBwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBmaW5kRWxlbWVudChub2RlLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbmRGb2N1c2FibGUgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBmaW5kRWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSkpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmaW5kRm9jdXNhYmxlQ2hpbGQgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIHJldHVybiBmaW5kRWxlbWVudChlbGVtZW50LCAobm9kZSkgPT4gaXNGb2N1c2FibGVXaXRoVGFiS2V5KG5vZGUsIGNoZWNrVmlzaWJpbGl0eSksIGZhbHNlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gcnRsU2Nyb2xsUG9zaXRpb24ocG9zaXRpb24sIGVsZW1lbnQsIGluaXRpYWwpIHtcbiAgICBsZXQgcmVzdWx0ID0gcG9zaXRpb247XG4gICAgaWYgKGluaXRpYWwgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IC1wb3NpdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5pdGlhbCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQub2Zmc2V0V2lkdGggLSBwb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERvbUV2ZW50c1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNlbGxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jZWxsTW91c2Vkb3duID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZm9jdXNJbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5mb2N1c091dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy53aW5kb3dCbHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbn1cbkRvbUV2ZW50c1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0xvY2tlZCA9IGNvbHVtbiA9PiBjb2x1bW4ucGFyZW50ID8gaXNMb2NrZWQoY29sdW1uLnBhcmVudCkgOiAhIWNvbHVtbi5sb2NrZWQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVzaXplQXJncyA9IChjb2x1bW4sIGV4dHJhKSA9PiBPYmplY3QuYXNzaWduKHtcbiAgICBjb2x1bW5zOiBsZWFmQ29sdW1ucyhbY29sdW1uXSksXG4gICAgbG9ja2VkOiBpc0xvY2tlZChjb2x1bW4pXG59LCBleHRyYSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudGFibGVzID0gW107XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBudWxsO1xuICAgIH1cbiAgICBzdGFydChjb2x1bW4pIHtcbiAgICAgICAgdGhpcy50cmFja0NvbHVtbnMoY29sdW1uKTtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9ICh0aGlzLmNvbHVtbi5pc0NvbHVtbkdyb3VwID8gW2NvbHVtbl0gOiBbXSlcbiAgICAgICAgICAgIC5jb25jYXQobGVhZkNvbHVtbnMoW2NvbHVtbl0pKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoe1xuICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgIGxvY2tlZDogaXNMb2NrZWQodGhpcy5jb2x1bW4pLFxuICAgICAgICAgICAgdHlwZTogJ3N0YXJ0J1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzaXplQ29sdW1ucyhkZWx0YVBlcmNlbnQpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gcmVzaXplQXJncyh0aGlzLmNvbHVtbiwge1xuICAgICAgICAgICAgZGVsdGFQZXJjZW50LFxuICAgICAgICAgICAgdHlwZTogJ3Jlc2l6ZUNvbHVtbidcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KGFjdGlvbik7XG4gICAgfVxuICAgIHJlc2l6ZVRhYmxlKGNvbHVtbiwgZGVsdGEpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gcmVzaXplQXJncyhjb2x1bW4sIHtcbiAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgdHlwZTogJ3Jlc2l6ZVRhYmxlJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoYWN0aW9uKTtcbiAgICB9XG4gICAgcmVzaXplZENvbHVtbihzdGF0ZSQkMSkge1xuICAgICAgICB0aGlzLnJlc2l6ZWRDb2x1bW5zLnB1c2goc3RhdGUkJDEpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxuICAgICAgICAgICAgcmVzaXplZENvbHVtbnM6IHRoaXMucmVzaXplZENvbHVtbnMsXG4gICAgICAgICAgICB0eXBlOiAnZW5kJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJUYWJsZSh0YWJsZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMudGFibGVzLnB1c2godGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHVucmVnaXN0ZXJUYWJsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFibGVzLnNwbGljZSh0aGlzLnRhYmxlcy5pbmRleE9mKHRhYmxlTWV0YWRhdGEpLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHVucmVnaXN0ZXJUYWJsZTtcbiAgICB9XG4gICAgbWVhc3VyZUNvbHVtbnMoaW5mbykge1xuICAgICAgICBpZiAodGhpcy5iYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaC5wdXNoKC4uLmluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdXRvRml0QmF0Y2goaW5mbywgKCkgPT4gdGhpcy5lbmQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXV0b0ZpdCguLi5jb2x1bW5zKSB7XG4gICAgICAgIGNvbnN0IG5vbkxvY2tlZENvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIWNvbHVtbi5pc0xvY2tlZCk7XG4gICAgICAgIHRoaXMuYXV0b0ZpdFN0YXJ0KG5vbkxvY2tlZENvbHVtbnMpO1xuICAgICAgICB0aGlzLmF1dG9GaXRCYXRjaCh0aGlzLmJhdGNoLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9uTG9ja2VkQ29sdW1ucy5sZW5ndGggPCBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2tlZENvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmlzTG9ja2VkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9GaXRTdGFydChsb2NrZWRDb2x1bW5zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9GaXRCYXRjaCh0aGlzLmJhdGNoLCAoKSA9PiB0aGlzLmVuZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFja0NvbHVtbnMoY29sdW1uKSB7XG4gICAgICAgIHRoaXMucmVzaXplZENvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgfVxuICAgIGF1dG9GaXRTdGFydChjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBbXTtcbiAgICAgICAgdGhpcy5yZXNpemVkQ29sdW1ucyA9IFtdO1xuICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NrZWQgPSBjb2x1bW5zWzBdLmlzTG9ja2VkO1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiAnc3RhcnQnLFxuICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgIGxvY2tlZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoe1xuICAgICAgICAgICAgdHlwZTogJ3RyaWdnZXJBdXRvRml0JyxcbiAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICBsb2NrZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dG9GaXRCYXRjaChpbmZvLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIGNvbnN0IGxvY2tlZCA9IGluZm8ubGVuZ3RoID4gMCA/IGluZm9bMF0uY29sdW1uLmlzTG9ja2VkIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVzID0gdGhpcy50YWJsZXNcbiAgICAgICAgICAgIC5maWx0ZXIodGFibGUgPT4gdGFibGUubG9ja2VkID09PSBsb2NrZWQpXG4gICAgICAgICAgICAubWFwKHRhYmxlID0+IHRhYmxlLmF1dG9GaXQoaW5mbykpO1xuICAgICAgICB6aXAoLi4ub2JzZXJ2YWJsZXMpXG4gICAgICAgICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh3aWR0aHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbnM6IGluZm8ubWFwKGkgPT4gaS5jb2x1bW4pLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhdXRvRml0Q29tcGxldGUnLFxuICAgICAgICAgICAgICAgIHdpZHRocyxcbiAgICAgICAgICAgICAgICBsb2NrZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoID0gbnVsbDtcbiAgICB9XG59XG5Db2x1bW5SZXNpemluZ1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzRmlsdGVyTWVudSA9IChzZXR0aW5ncykgPT4gdHlwZW9mIHNldHRpbmdzID09PSAnc3RyaW5nJyAmJiBzZXR0aW5ncy5pbmRleE9mKCdtZW51JykgPiAtMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNGaWx0ZXJSb3cgPSAoc2V0dGluZ3MpID0+IHNldHRpbmdzID09PSB0cnVlIHx8ICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdzdHJpbmcnICYmIHNldHRpbmdzLmluZGV4T2YoJ3JvdycpID4gLTEpO1xuXG5jb25zdCBjb250YWlucyQxID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjbG9zZWAgZXZlbnQgb2YgdGhlIGZpbHRlciBhbmQgY29sdW1uLW1lbnUgcG9wdXAuXG4gKi9cbmNsYXNzIFBvcHVwQ2xvc2VFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZTtcbiAgICB9XG59XG5jb25zdCBERUZBVUxUX1BPUFVQX0NMQVNTID0gJ2stZ3JpZC1maWx0ZXItcG9wdXAnO1xuLyoqXG4gKiBUaGUgc2VydmljZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBwb3B1cHMgb2YgdGhlIGZpbHRlciBhbmQgY29sdW1uIG1lbnVzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHJldXNhYmxlY3VzdG9tZmlsdGVyc190cmVlbGlzdCAlfSN0b2MtZmlsdGVyLW1lbnUtd2l0aC1wb3B1cCkpLlxuICovXG5jbGFzcyBTaW5nbGVQb3B1cFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBvcHVwU2VydmljZSwgcmVuZGVyZXIsIG5nWm9uZSwgc2Nyb2xsU3luY1NlcnZpY2UsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBmaWx0ZXIgb3IgY29sdW1uIG1lbnVzIGFyZSBhYm91dCB0byBjbG9zZSBiZWNhdXNlIHRoZSB1c2VyIGNsaWNrZWQgb3V0c2lkZSB0aGVpciBwb3B1cHMuXG4gICAgICAgICAqIFVzZWQgdG8gcHJldmVudCB0aGUgcG9wdXAgZnJvbSBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSBzY3JvbGxTeW5jU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRlc3Ryb3koKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvcGVuKGFuY2hvciwgdGVtcGxhdGUsIHBvcHVwUmVmLCBwb3B1cENsYXNzID0gREVGQVVMVF9QT1BVUF9DTEFTUykge1xuICAgICAgICBjb25zdCB0b2dnbGUgPSBpc1ByZXNlbnQocG9wdXBSZWYpICYmIHRoaXMucG9wdXBSZWYgPT09IHBvcHVwUmVmO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKCF0b2dnbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICAgICAgYW5jaG9yQWxpZ246IHsgdmVydGljYWw6ICdib3R0b20nLCBob3Jpem9udGFsOiBkaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICBwb3B1cEFsaWduOiB7IHZlcnRpY2FsOiAndG9wJywgaG9yaXpvbnRhbDogZGlyZWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgcG9wdXBDbGFzczogcG9wdXBDbGFzcyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6IFwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudCwgJ2RpcicsIHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cicpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hDbG9zZShhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVwUmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgZGV0YWNoQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW92ZUNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoQ2xvc2Uoc2tpcEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hDbG9zZSgpO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLnJlbW92ZUNsaWNrID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oXCJkb2N1bWVudFwiLCBcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zJDEoZS50YXJnZXQsIHggPT4gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQgPT09IHggfHwgeCA9PT0gc2tpcEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IG5ldyBQb3B1cENsb3NlRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlLm5leHQoYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblNpbmdsZVBvcHVwU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU2luZ2xlUG9wdXBTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUG9wdXBTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogU2Nyb2xsU3luY1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyogdHNsaW50OmRpc2FibGU6IG5vLWJpdHdpc2UgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBhcHBlbmQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGxldCBhcHBlbmRlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghYXBwZW5kZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICBhcHBlbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0RG9jdW1lbnQgPSBlbGVtZW50ID0+IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZ2V0V2luZG93ID0gZWxlbWVudCA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZWxlbWVudCA9PiB7XG4gICAgY29uc3QgeyBjbGllbnRUb3AsIGNsaWVudExlZnQgfSA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xuICAgIGNvbnN0IHsgcGFnZVlPZmZzZXQsIHBhZ2VYT2Zmc2V0IH0gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3AgKyBwYWdlWU9mZnNldCAtIGNsaWVudFRvcCxcbiAgICAgICAgbGVmdDogbGVmdCArIHBhZ2VYT2Zmc2V0IC0gY2xpZW50TGVmdFxuICAgIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKiBJZiB0aGUgdGFyZ2V0IGlzIGJlZm9yZSB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQsIHJldHVybnMgYHRydWVgLlxuICpcbiAqIERPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA9IDRcbiAqL1xuY29uc3QgaXNUYXJnZXRCZWZvcmUgPSAoZHJhZ2dhYmxlLCB0YXJnZXQpID0+ICh0YXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZHJhZ2dhYmxlKSAmIDQpICE9PSAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKiBJZiB0aGUgY29udGFpbmVyIGFuZCB0aGUgZWxlbWVudCBhcmUgdGhlIHNhbWVcbiAqIG9yIGlmIHRoZSBjb250YWluZXIgaG9sZHMgKGNvbnRhaW5zKSB0aGUgZWxlbWVudCwgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZID0gMTZcbiAqL1xuY29uc3QgY29udGFpbnMkMiA9IChlbGVtZW50LCBjb250YWluZXIpID0+IGVsZW1lbnQgPT09IGNvbnRhaW5lciB8fFxuICAgIChjb250YWluZXIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiAxNikgIT09IDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcG9zaXRpb24gPSAodGFyZ2V0LCBiZWZvcmUpID0+IHtcbiAgICBjb25zdCB0YXJnZXRSZWN0ID0gb2Zmc2V0KHRhcmdldCk7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSB0YXJnZXQ7XG4gICAgY29uc3QgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIChiZWZvcmUgPyAwIDogb2Zmc2V0V2lkdGgpO1xuICAgIGNvbnN0IHRvcCA9IHRhcmdldFJlY3QudG9wO1xuICAgIGNvbnN0IGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgICByZXR1cm4geyBsZWZ0LCB0b3AsIGhlaWdodCB9O1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYWdBbmREcm9wU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IFtdO1xuICAgICAgICB0aGlzLmxhc3RUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgICBhZGQodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZW1vdmUodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIgPSB0aGlzLnJlZ2lzdGVyLmZpbHRlcihjdXJyZW50ID0+IGN1cnJlbnQgIT09IHRhcmdldCk7XG4gICAgfVxuICAgIG5vdGlmeURyYWcoZHJhZ2dhYmxlLCBlbGVtZW50LCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0Rm9yKGVsZW1lbnQpO1xuICAgICAgICBpZiAodGhpcy5sYXN0VGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7XG4gICAgICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgICAgICBtb3VzZUV2ZW50LFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmxhc3RUYXJnZXQsXG4gICAgICAgICAgICB0eXBlOiAnbGVhdmUnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7XG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIG1vdXNlRXZlbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdlbnRlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICB9XG4gICAgbm90aWZ5RHJvcChkcmFnZ2FibGUsIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoe1xuICAgICAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICAgICAgbW91c2VFdmVudCxcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5sYXN0VGFyZ2V0LFxuICAgICAgICAgICAgdHlwZTogJ2Ryb3AnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgICB0YXJnZXRGb3IoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb21wYXJlciA9IGNvbnRhaW5zJDIuYmluZChudWxsLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXIuZmluZCgoeyBlbGVtZW50OiB7IG5hdGl2ZUVsZW1lbnQgfSB9KSA9PiBjb21wYXJlcihuYXRpdmVFbGVtZW50KSk7XG4gICAgfVxufVxuRHJhZ0FuZERyb3BTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG5jb25zdCB1cGRhdGVDbGFzcyA9IChlbGVtZW50LCB2YWxpZCkgPT4ge1xuICAgIGNvbnN0IGljb24gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5rLWljb24nKTtcbiAgICBpY29uLmNsYXNzTmFtZSA9IGljb24uY2xhc3NOYW1lXG4gICAgICAgIC5yZXBsYWNlKC8ocGx1c3xjYW5jZWwpLywgdmFsaWQgPyAncGx1cycgOiAnY2FuY2VsJyk7XG59O1xuY29uc3QgdXBkYXRlTG9jayA9IChlbGVtZW50LCBsb2NrZWQgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgaWNvbiA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmstaWNvbicpWzFdO1xuICAgIGNvbnN0IHZhbHVlID0gbG9ja2VkID09IG51bGwgPyAnJyA6IChsb2NrZWQgPyAnay1pLWxvY2snIDogJ2staS11bmxvY2snKTtcbiAgICBpY29uLmNsYXNzTmFtZSA9IGljb24uY2xhc3NOYW1lXG4gICAgICAgIC5yZXBsYWNlKC8oay1pLXVubG9ja3xrLWktbG9jaykvLCAnJykgKyBgICR7dmFsdWV9YDtcbn07XG5jb25zdCBkZWNvcmF0ZSA9IChlbGVtZW50LCB0YXJnZXQpID0+IHtcbiAgICBjb25zdCB0YXJnZXRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSAnay1oZWFkZXIgay1kcmFnLWNsdWUnO1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsZW1lbnQuc3R5bGUuekluZGV4ID0gJzIwMDAwJztcbiAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gdGFyZ2V0U3R5bGVzLnBhZGRpbmdMZWZ0O1xuICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IHRhcmdldFN0eWxlcy5wYWRkaW5nVG9wO1xuICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHRhcmdldFN0eWxlcy5wYWRkaW5nQm90dG9tO1xuICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gdGFyZ2V0U3R5bGVzLnBhZGRpbmdSaWdodDtcbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gdGFyZ2V0U3R5bGVzLndpZHRoO1xuICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0U3R5bGVzLmhlaWdodDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRHJhZ0hpbnRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzYW50aXplcikge1xuICAgICAgICB0aGlzLnNhbnRpemVyID0gc2FudGl6ZXI7XG4gICAgfVxuICAgIGNyZWF0ZShkb3duLCB0YXJnZXQsIHRpdGxlKSB7XG4gICAgICAgIHRoaXMuaW5pdENvb3Jkcyhkb3duKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkZWNvcmF0ZSh0aGlzLmRvbSwgdGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgc2FmZVRpdGxlID0gdGhpcy5zYW50aXplci5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuSFRNTCwgdGl0bGUpO1xuICAgICAgICB0aGlzLmRvbS5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWRyYWctc3RhdHVzIGstaS1jYW5jZWwgay1pY29uLXdpdGgtbW9kaWZpZXJcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImstaWNvbiBrLWljb24tbW9kaWZpZXJcIj48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAke3NhZmVUaXRsZX1cbiAgICAgICAgYDtcbiAgICB9XG4gICAgYXR0YWNoKCkge1xuICAgICAgICByZXR1cm4gYXBwZW5kKHRoaXMuZG9tKTtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCkpO1xuICAgICAgICAgICAgfSkodGhpcy5kb20pOyAvLyBoYWNrIGZvciBJRSArIHBvaW50ZXIgZXZlbnRzIVxuICAgICAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdXBkYXRlQ2xhc3ModGhpcy5kb20sIHRydWUpO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB1cGRhdGVDbGFzcyh0aGlzLmRvbSwgZmFsc2UpO1xuICAgIH1cbiAgICByZW1vdmVMb2NrKCkge1xuICAgICAgICB1cGRhdGVMb2NrKHRoaXMuZG9tKTtcbiAgICB9XG4gICAgdG9nZ2xlTG9jayhsb2NrZWQpIHtcbiAgICAgICAgdXBkYXRlTG9jayh0aGlzLmRvbSwgbG9ja2VkKTtcbiAgICB9XG4gICAgbW92ZShtb3ZlKSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLnRvcCA9IHRoaXMuaW5pdGlhbFRvcCArIG1vdmUucGFnZVkgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5sZWZ0ID0gdGhpcy5pbml0aWFsTGVmdCArIG1vdmUucGFnZVggKyAncHgnO1xuICAgIH1cbiAgICBpbml0Q29vcmRzKGRvd24pIHtcbiAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IG9mZnNldChkb3duLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5pbml0aWFsVG9wID0gdG9wIC0gZG93bi5wYWdlWTtcbiAgICAgICAgdGhpcy5pbml0aWFsTGVmdCA9IGxlZnQgLSBkb3duLnBhZ2VYO1xuICAgIH1cbn1cbkRyYWdIaW50U2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHJhZ0hpbnRTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEcm9wQ3VlU2VydmljZSB7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9ICdrLWdyb3VwaW5nLWRyb3BjbHVlJztcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICAgIGF0dGFjaCgpIHtcbiAgICAgICAgcmV0dXJuIGFwcGVuZCh0aGlzLmRvbSk7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMuZG9tLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcG9zaXRpb24oeyBsZWZ0LCB0b3AsIGhlaWdodCB9KSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZG9tLm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubGVmdCA9IGxlZnQgLSB3aWR0aCArICdweCc7XG4gICAgfVxufVxuRHJvcEN1ZVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5SZW9yZGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgcmVvcmRlcihlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KGUpO1xuICAgIH1cbn1cbkNvbHVtblJlb3JkZXJTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjb2x1bW5SZW9yZGVyYCBldmVudC5cbiAqL1xuY2xhc3MgQ29sdW1uUmVvcmRlckV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29sdW1uLCBuZXdJbmRleCwgb2xkSW5kZXggfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy5uZXdJbmRleCA9IG5ld0luZGV4O1xuICAgICAgICB0aGlzLm9sZEluZGV4ID0gb2xkSW5kZXg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRm9jdXNSb290IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzLmFkZChncm91cCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWdpc3Rlckdyb3VwKGdyb3VwKSB7XG4gICAgICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3Vwcy5kZWxldGUoZ3JvdXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5hbGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cHMuZm9yRWFjaChmID0+IGYuYWN0aXZhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzLmZvckVhY2goZiA9PiBmLmRlYWN0aXZhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Gb2N1c1Jvb3QuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbmNvbnN0IGlzQnV0dG9uID0gbWF0Y2hlc05vZGVOYW1lKCdidXR0b24nKTtcbmNvbnN0IGlzSW5wdXRUYWcgPSBtYXRjaGVzTm9kZU5hbWUoJ2lucHV0Jyk7XG5jb25zdCBuYXZpZ2FibGVSZWdleCA9IC8oYnV0dG9ufGNoZWNrYm94fGNvbG9yfGZpbGV8cmFkaW98cmVzZXR8c3VibWl0KS9pO1xuY29uc3QgaXNOYXZpZ2FibGVJbnB1dCA9IGVsZW1lbnQgPT4gaXNJbnB1dFRhZyhlbGVtZW50KSAmJiBuYXZpZ2FibGVSZWdleC50ZXN0KGVsZW1lbnQudHlwZSk7XG5jb25zdCBpc05hdmlnYWJsZSA9IGVsZW1lbnQgPT4gIWVsZW1lbnQuZGlzYWJsZWQgJiYgKGlzQnV0dG9uKGVsZW1lbnQpIHx8IGlzTmF2aWdhYmxlSW5wdXQoZWxlbWVudCkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERlZmF1bHRGb2N1c2FibGVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGhvc3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5mb2N1c2FibGUgPSBmaW5kRm9jdXNhYmxlKHRoaXMuZWxlbWVudCwgZmFsc2UpIHx8IHRoaXMuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzYWJsZSAmJiAhdGhpcy5mb2N1c2FibGUuZGlzYWJsZWQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2FibGUgJiYgaXNWaXNpYmxlKHRoaXMuZm9jdXNhYmxlKTtcbiAgICB9XG4gICAgaXNOYXZpZ2FibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbkZvY3VzKCkgJiYgaXNOYXZpZ2FibGUodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgdG9nZ2xlKGFjdGl2ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmZvY3VzYWJsZSwgJ3RhYkluZGV4JywgYWN0aXZlID8gJzAnIDogJy0xJyk7XG4gICAgfVxuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuRm9jdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGUgJiYgdGhpcy5lbmFibGVkO1xuICAgIH1cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuZWxlbWVudCAmJiBjbG9zZXN0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIGUgPT4gZSA9PT0gdGhpcy5lbGVtZW50KTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBncm91cCBvZiBjb21wb25lbnRzIHRoYXQgY2FuIGJlIGFjdGl2YXRlZCBvciBmb2N1c2VkLlxuICpcbiAqIEEgZm9jdXMgZ3JvdXAgbWF5IGNvbnRhaW4gZm9jdXNhYmxlIGVsZW1lbnRzLCBzdWNoIGFzIHJvd3MsIGNlbGxzIGFuZCBpbnB1dCBlbGVtZW50cy5cbiAqXG4gKiBFbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlIGZvY3VzIGdyb3VwIGJ5IHRhZ2dpbmcgdGhlbSB3aXRoIHRoZSBga2VuZG9UcmVlTGlzdEZvY3VzYWJsZWAgZGlyZWN0aXZlLlxuICogU2VlIFtDb250cm9sbGluZyB0aGUgRm9jdXNdKHslIHNsdWcga2V5Ym9hcmRfbmF2aWdhdGlvbl90cmVlbGlzdCAlfSN0b2MtY29udHJvbGxpbmctdGhlLWZvY3VzKS5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZvY3VzR3JvdXAge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QucmVnaXN0ZXJHcm91cCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGZvY3VzYWJsZUNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoZWwgPT4gZWwuY2FuRm9jdXMoKSk7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb290LnVucmVnaXN0ZXJHcm91cCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKGYgPT4gZiAhPT0gZWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgZ3JvdXAgd2lsbCByZWNlaXZlIGZvY3VzIHdoZW4gdGhlIGNlbGwgaXMgZm9jdXNlZC5cbiAgICAgKiBFdmFsdWF0ZXMgdG8gYHRydWVgIHdoZW4gdGhlIGZvY3VzIGdyb3VwIGhhcyBhIHNpbmdsZSBmb2N1c2FibGUgZWxlbWVudCBzdWNoIGFzIGEgYnV0dG9uIG9yIGEgY2hlY2tib3guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBncm91cCB3aWxsIHJlY2VpdmUgZm9jdXMgd2hlbiB0aGUgY2VsbCBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIGlzTmF2aWdhYmxlKCkge1xuICAgICAgICBjb25zdCBmb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZUNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gZm9jdXNhYmxlLmxlbmd0aCA9PT0gMSAmJiBmb2N1c2FibGVbMF0uaXNOYXZpZ2FibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBmb2N1cyBncm91cCBjb250YWlucyBmb2N1c2FibGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgZm9jdXMgZ3JvdXAgY29udGFpbnMgZm9jdXNhYmxlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNhYmxlQ2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgZmlyc3QgZm9jdXNhYmxlIGNvbXBvbmVudCwgaWYgYW55LlxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Gb2N1cygpICYmICF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNhYmxlQ2hpbGRyZW5bMF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU3RhdGUodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlKGZhbHNlKTtcbiAgICB9XG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZSgoZm9jdXNlZCwgZWxlbWVudCkgPT4gZm9jdXNlZCB8fCBlbGVtZW50Lmhhc0ZvY3VzKCksIGZhbHNlKTtcbiAgICB9XG4gICAgdG9nZ2xlU3RhdGUoYWN0aXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmID0+IGYudG9nZ2xlKGFjdGl2ZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuRm9jdXNHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRm9jdXNHcm91cC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEZvY3VzUm9vdCB9XG5dO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgY29udHJvbHMgdGhlIHdheSBmb2N1c2FibGUgY2VsbCBlbGVtZW50cyByZWNlaXZlXG4gKiBbZm9jdXMgaW4gYSBuYXZpZ2FibGUgVHJlZUxpc3RdKHslIHNsdWcga2V5Ym9hcmRfbmF2aWdhdGlvbl90cmVlbGlzdCAlfSkuXG4gKlxuICogVGhlIGRpcmVjdGl2ZSB0YWtlcyBhcyBpbnB1dCB0aGUgYGNlbGxDb250ZXh0YCBmcm9tIHRoZSBjZWxsIHRlbXBsYXRlLlxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAqICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWNlbGxDb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiay1idXR0b25cIiBba2VuZG9UcmVlTGlzdEZvY3VzYWJsZV09XCJjZWxsQ29udGV4dFwiIHZhbHVlPVwiRm9jdXMgbWUhXCIgLz5cbiAqICAgPC9uZy10ZW1wbGF0ZT5cbiAqIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICogYGBgXG4gKi9cbmNsYXNzIEZvY3VzYWJsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaG9zdEVsZW1lbnQsIHJlbmRlcmVyLCBncm91cCkge1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgYWRkQ2VsbENvbnRleHQodmFsdWUpIHsgdGhpcy5jZWxsQ29udGV4dCA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBlZGl0Q2VsbENvbnRleHQodmFsdWUpIHsgdGhpcy5jZWxsQ29udGV4dCA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCByZW1vdmVDZWxsQ29udGV4dCh2YWx1ZSkgeyB0aGlzLmNlbGxDb250ZXh0ID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHNhdmVDZWxsQ29udGV4dCh2YWx1ZSkgeyB0aGlzLmNlbGxDb250ZXh0ID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGNhbmNlbENlbGxDb250ZXh0KHZhbHVlKSB7IHRoaXMuY2VsbENvbnRleHQgPSB2YWx1ZTsgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsQ29udGV4dCAmJiB0aGlzLmNlbGxDb250ZXh0LmZvY3VzR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSB0aGlzLmNlbGxDb250ZXh0LmZvY3VzR3JvdXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVnaXN0ZXJFbGVtZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG5ldyBEZWZhdWx0Rm9jdXNhYmxlRWxlbWVudCh0aGlzLmhvc3RFbGVtZW50LCB0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLmdyb3VwLmlzQWN0aXZlO1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoaXNBY3RpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC51bnJlZ2lzdGVyRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9nZ2xlKGFjdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50ICYmIGFjdGl2ZSAhPT0gdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRvZ2dsZShhY3RpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQuY2FuRm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGlzTmF2aWdhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50ICYmIHRoaXMuZWxlbWVudC5pc05hdmlnYWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQuaGFzRm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxufVxuRm9jdXNhYmxlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEZvY3VzYWJsZV0nICsgYCxcbiAgICAgICAgW2tlbmRvVHJlZUxpc3RBZGRDb21tYW5kXSxcbiAgICAgICAgW2tlbmRvVHJlZUxpc3RFZGl0Q29tbWFuZF0sXG4gICAgICAgIFtrZW5kb1RyZWVMaXN0UmVtb3ZlQ29tbWFuZF0sXG4gICAgICAgIFtrZW5kb1RyZWVMaXN0U2F2ZUNvbW1hbmRdLFxuICAgICAgICBba2VuZG9UcmVlTGlzdENhbmNlbENvbW1hbmRdXG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Gb2N1c2FibGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IEZvY3VzR3JvdXAsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5Gb2N1c2FibGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2VsbENvbnRleHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvVHJlZUxpc3RGb2N1c2FibGUnLF0gfV0sXG4gICAgYWRkQ2VsbENvbnRleHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvVHJlZUxpc3RBZGRDb21tYW5kJyxdIH1dLFxuICAgIGVkaXRDZWxsQ29udGV4dDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9UcmVlTGlzdEVkaXRDb21tYW5kJyxdIH1dLFxuICAgIHJlbW92ZUNlbGxDb250ZXh0OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb1RyZWVMaXN0UmVtb3ZlQ29tbWFuZCcsXSB9XSxcbiAgICBzYXZlQ2VsbENvbnRleHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvVHJlZUxpc3RTYXZlQ29tbWFuZCcsXSB9XSxcbiAgICBjYW5jZWxDZWxsQ29udGV4dDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9UcmVlTGlzdENhbmNlbENvbW1hbmQnLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOYXZpZ2F0aW9uQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuYWN0aXZlUm93ID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmVDb2wgPSAwO1xuICAgICAgICB0aGlzLnZpcnR1YWxDb2wgPSAwO1xuICAgICAgICB0aGlzLnZpcnR1YWxSb3cgPSAwO1xuICAgIH1cbiAgICBnZXQgcm93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maW5kUm93KHRoaXMuYWN0aXZlUm93KTtcbiAgICB9XG4gICAgZ2V0IGNlbGwoKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMucm93O1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maW5kQ2VsbCh0aGlzLmFjdGl2ZUNvbCwgcm93KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGF0YVJvd0luZGV4KCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLnJvdztcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5kYXRhUm93SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3N1bWVzIGFuZCBhbm5vdW5jZXMgYSBuZXcgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHJlc2V0KHJvd0luZGV4ID0gdGhpcy5hY3RpdmVSb3csIGNvbEluZGV4ID0gdGhpcy5hY3RpdmVDb2wsIGZvcmNlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZShyb3dJbmRleCwgY29sSW5kZXgsIGZvcmNlKSkge1xuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUm93ID0gcm93SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxDb2wgPSBjb2xJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmF0ZShyb3dJbmRleCwgY29sSW5kZXgsIGZvcmNlKSB7XG4gICAgICAgIGlmICghZm9yY2UgJiYgdGhpcy5pc0FjdGl2ZVJhbmdlKHJvd0luZGV4LCBjb2xJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2Q29sSW5kZXggPSB0aGlzLmFjdGl2ZUNvbDtcbiAgICAgICAgY29uc3QgcHJldlJvd0luZGV4ID0gdGhpcy5hY3RpdmVSb3c7XG4gICAgICAgIHRoaXMuYWN0aXZlQ29sID0gY29sSW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aXZlUm93ID0gcm93SW5kZXg7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHtcbiAgICAgICAgICAgIGNvbEluZGV4LFxuICAgICAgICAgICAgcHJldkNvbEluZGV4LFxuICAgICAgICAgICAgcHJldlJvd0luZGV4LFxuICAgICAgICAgICAgcm93SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0FjdGl2ZVJhbmdlKHJvd0luZGV4LCBjb2xJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVSb3cgIT09IHJvd0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2VsbDtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLm1vZGVsLmNlbGxSYW5nZShjZWxsKTtcbiAgICAgICAgcmV0dXJuICFCb29sZWFuKGNlbGwpIHx8IChzdGFydCA8PSBjb2xJbmRleCAmJiBjb2xJbmRleCA8PSBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3N1bWVzIGEgbmV3IGN1cnNvciBwb3NpdGlvbiB3aXRob3V0IGFubm91bmNpbmcgaXQuXG4gICAgICovXG4gICAgYXNzdW1lKHJvd0luZGV4ID0gdGhpcy5hY3RpdmVSb3csIGNvbEluZGV4ID0gdGhpcy5hY3RpdmVDb2wpIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsUm93ID0gcm93SW5kZXg7XG4gICAgICAgIHRoaXMudmlydHVhbENvbCA9IGNvbEluZGV4O1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbCA9IGNvbEluZGV4O1xuICAgICAgICB0aGlzLmFjdGl2ZVJvdyA9IHJvd0luZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbm5vdW5jZXMgYSBjdXJyZW50IGN1cnNvciBwb3NpdGlvbiB0byBzdWJzY3JpYmVycy5cbiAgICAgKi9cbiAgICBhbm5vdW5jZSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoe1xuICAgICAgICAgICAgY29sSW5kZXg6IHRoaXMuYWN0aXZlQ29sLFxuICAgICAgICAgICAgcHJldkNvbEluZGV4OiB0aGlzLmFjdGl2ZUNvbCxcbiAgICAgICAgICAgIHByZXZSb3dJbmRleDogdGhpcy5hY3RpdmVSb3csXG4gICAgICAgICAgICByb3dJbmRleDogdGhpcy5hY3RpdmVSb3dcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjdGl2YXRlVmlydHVhbENlbGwoY2VsbCkge1xuICAgICAgICBjb25zdCByb3dSYW5nZSA9IHRoaXMubW9kZWwucm93UmFuZ2UoY2VsbCk7XG4gICAgICAgIGNvbnN0IGNlbGxSYW5nZSA9IHRoaXMubW9kZWwuY2VsbFJhbmdlKGNlbGwpO1xuICAgICAgICBjb25zdCBhY3RpdmVDb2wgPSB0aGlzLmFjdGl2ZUNvbDtcbiAgICAgICAgY29uc3QgYWN0aXZlUm93ID0gdGhpcy5hY3RpdmVSb3c7XG4gICAgICAgIGlmIChyb3dSYW5nZS5zdGFydCA8PSBhY3RpdmVSb3cgJiYgYWN0aXZlUm93IDw9IHJvd1JhbmdlLmVuZCAmJlxuICAgICAgICAgICAgY2VsbFJhbmdlLnN0YXJ0IDw9IGFjdGl2ZUNvbCAmJiBhY3RpdmVDb2wgPD0gY2VsbFJhbmdlLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3cgPSBjZWxsLnJvd0luZGV4O1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDb2wgPSBjZWxsLmNvbEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNBY3RpdmUocm93SW5kZXgsIGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUNvbCA9PT0gY29sSW5kZXggJiYgdGhpcy5hY3RpdmVSb3cgPT09IHJvd0luZGV4O1xuICAgIH1cbiAgICBtb3ZlVXAob2Zmc2V0ID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRSb3coLW9mZnNldCk7XG4gICAgfVxuICAgIG1vdmVEb3duKG9mZnNldCA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0Um93KG9mZnNldCk7XG4gICAgfVxuICAgIG1vdmVMZWZ0KG9mZnNldCA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0Q29sKC1vZmZzZXQpO1xuICAgIH1cbiAgICBtb3ZlUmlnaHQob2Zmc2V0ID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRDb2wob2Zmc2V0KTtcbiAgICB9XG4gICAgbGFzdENlbGxJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEuY29sdW1ucy5sZWFmQ29sdW1uc1RvUmVuZGVyLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIG9mZnNldENvbChvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgcHJldlJvdyA9IHRoaXMubW9kZWwuZmluZFJvdyh0aGlzLnZpcnR1YWxSb3cpO1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLmxhc3RDZWxsSW5kZXgoKTtcbiAgICAgICAgY29uc3QgdmlydHVhbENvbCA9IHRoaXMudmlydHVhbENvbDtcbiAgICAgICAgdGhpcy52aXJ0dWFsQ29sID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmlydHVhbENvbCArIG9mZnNldCwgbGFzdEluZGV4KSk7XG4gICAgICAgIGxldCBuZXh0Q29sSW5kZXggPSB0aGlzLnZpcnR1YWxDb2w7XG4gICAgICAgIGxldCBuZXh0Um93SW5kZXggPSB0aGlzLnZpcnR1YWxSb3c7XG4gICAgICAgIGxldCBjZWxsID0gdGhpcy5tb2RlbC5maW5kQ2VsbCh0aGlzLnZpcnR1YWxDb2wsIHByZXZSb3cpO1xuICAgICAgICBpZiAoIWNlbGwgJiYgdGhpcy5tZXRhZGF0YS52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGUobmV4dFJvd0luZGV4LCBuZXh0Q29sSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsLmNvbFNwYW4gPiAxICYmIGNlbGwuY29sSW5kZXggPD0gdmlydHVhbENvbCAmJiB2aXJ0dWFsQ29sIDwgY2VsbC5jb2xJbmRleCArIGNlbGwuY29sU3Bhbikge1xuICAgICAgICAgICAgbmV4dENvbEluZGV4ID0gb2Zmc2V0ID4gMCA/IE1hdGgubWluKGNlbGwuY29sSW5kZXggKyBjZWxsLmNvbFNwYW4sIGxhc3RJbmRleCkgOiBNYXRoLm1heCgwLCBjZWxsLmNvbEluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDZWxsID0gdGhpcy5tb2RlbC5maW5kQ2VsbChuZXh0Q29sSW5kZXgsIHByZXZSb3cpO1xuICAgICAgICAgICAgaWYgKGNlbGwgIT09IG5leHRDZWxsKSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IG5leHRDZWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbENvbCA9IGNlbGwuY29sSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxDb2wgPSB2aXJ0dWFsQ29sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKGNlbGwucm93SW5kZXgsIGNlbGwuY29sSW5kZXgpO1xuICAgIH1cbiAgICBvZmZzZXRSb3cob2Zmc2V0KSB7XG4gICAgICAgIGxldCBuZXh0Q29sSW5kZXggPSB0aGlzLnZpcnR1YWxDb2w7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICYmIHRoaXMubWV0YWRhdGEuaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhJbmRleCA9IHRoaXMubWV0YWRhdGEubWF4TG9naWNhbFJvd0luZGV4O1xuICAgICAgICAgICAgbGV0IG5leHRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYWN0aXZlUm93ICsgb2Zmc2V0LCBtYXhJbmRleCkpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFJvdyA9IHRoaXMubW9kZWwuZmluZFJvdyhuZXh0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5leHRSb3cpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRpb25cbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMubW9kZWwuZmluZENlbGwodGhpcy52aXJ0dWFsQ29sLCBuZXh0Um93KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5yb3dJbmRleCA8PSB0aGlzLnZpcnR1YWxSb3cgJiYgb2Zmc2V0ID4gMCAmJiBjZWxsLnJvd1NwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwgPSB0aGlzLm1vZGVsLmZpbmRDZWxsKHRoaXMudmlydHVhbENvbCwgdGhpcy5tb2RlbC5maW5kUm93KGNlbGwucm93SW5kZXggKyBjZWxsLnJvd1NwYW4gLSAxICsgb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGNlbGwucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgbmV4dENvbEluZGV4ID0gY2VsbC5jb2xJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJvdyA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKG5leHRJbmRleCwgbmV4dENvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0Um93ID0gdGhpcy5tb2RlbC5maW5kUm93KHRoaXMudmlydHVhbFJvdyArIG9mZnNldCkgfHwgdGhpcy5tb2RlbC5uZXh0Um93KHRoaXMudmlydHVhbFJvdywgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFuZXh0Um93KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNlbGwgPSB0aGlzLm1vZGVsLmZpbmRDZWxsKHRoaXMudmlydHVhbENvbCwgbmV4dFJvdyk7XG4gICAgICAgIGlmIChjZWxsICYmIGNlbGwucm93SW5kZXggPD0gdGhpcy52aXJ0dWFsUm93ICYmIG9mZnNldCA+IDAgJiYgY2VsbC5yb3dTcGFuID4gMSkgeyAvLyBzcGFubmVkIGNlbGwgZ28gdG8gbmV4dFxuICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGNlbGwucm93SW5kZXggKyBjZWxsLnJvd1NwYW4gLSAxICsgb2Zmc2V0O1xuICAgICAgICAgICAgY2VsbCA9IHRoaXMubW9kZWwuZmluZENlbGwodGhpcy52aXJ0dWFsQ29sLCB0aGlzLm1vZGVsLmZpbmRSb3cobmV4dFBvcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2VsbCAmJiB0aGlzLm1ldGFkYXRhLnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZSh0aGlzLnZpcnR1YWxSb3cgKyBvZmZzZXQsIHRoaXMudmlydHVhbENvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXJ0dWFsUm93ID0gY2VsbC5yb3dJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGUodGhpcy52aXJ0dWFsUm93LCBjZWxsLmNvbEluZGV4KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBJdGVtTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5pdGVtcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1trZXlzW2tleXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLml0ZW1zW2tleV07XG4gICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SXRlbShrZXksIGl0ZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW1zW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zW2tleV0gPSBpdGVtO1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1trZXldO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGNhbGxiYWNrKHRoaXMuaXRlbXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmQoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTW9kZWxDZWxsIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbFJvdywgY2VsbCkge1xuICAgICAgICB0aGlzLnVpZCA9IGNlbGwudWlkO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNlbGwuY29sdW1uO1xuICAgICAgICB0aGlzLmNvbEluZGV4ID0gY2VsbC5sb2dpY2FsQ29sSW5kZXg7XG4gICAgICAgIHRoaXMucm93SW5kZXggPSBtb2RlbFJvdy5pbmRleDtcbiAgICAgICAgdGhpcy5jb2xTcGFuID0gY2VsbC5jb2xTcGFuO1xuICAgICAgICB0aGlzLnJvd1NwYW4gPSBjZWxsLnJvd1NwYW47XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBtb2RlbFJvdy5kYXRhSXRlbTtcbiAgICAgICAgdGhpcy5kYXRhUm93SW5kZXggPSBtb2RlbFJvdy5kYXRhUm93SW5kZXg7XG4gICAgICAgIHRoaXMuZm9jdXNHcm91cCA9IGNlbGwuZm9jdXNHcm91cDtcbiAgICAgICAgdGhpcy5leHBhbmRhYmxlID0gY2VsbC5leHBhbmRhYmxlO1xuICAgIH1cbiAgICBmb2N1c0NvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNHcm91cC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnRseSByZW5kZXJlZCByb3dzIGFuZCBjZWxscy5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvbk1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yb3dzID0gbmV3IEl0ZW1NYXAoKTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Um93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzLmZpcnN0O1xuICAgIH1cbiAgICBnZXQgbGFzdFJvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5sYXN0O1xuICAgIH1cbiAgICByZWdpc3RlckNlbGwoY2VsbCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLnJvd3MuZ2V0SXRlbShjZWxsLmxvZ2ljYWxSb3dJbmRleCk7XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxDZWxsID0gbmV3IE1vZGVsQ2VsbChyb3csIGNlbGwpO1xuICAgICAgICByb3cuY2VsbHMuc2V0SXRlbShjZWxsLmxvZ2ljYWxDb2xJbmRleCwgbW9kZWxDZWxsKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsQ2VsbDtcbiAgICB9XG4gICAgdW5yZWdpc3RlckNlbGwoaW5kZXgsIHJvd0luZGV4LCBjZWxsKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMucm93cy5nZXRJdGVtKHJvd0luZGV4KTtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByb3cuY2VsbHMuZ2V0SXRlbShpbmRleCk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gudWlkID09PSBjZWxsLnVpZCkge1xuICAgICAgICAgICAgICAgIHJvdy5jZWxscy5yZW1vdmVJdGVtKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlclJvdyhyb3cpIHtcbiAgICAgICAgY29uc3QgbW9kZWxSb3cgPSB7XG4gICAgICAgICAgICB1aWQ6IHJvdy51aWQsXG4gICAgICAgICAgICBpbmRleDogcm93LmxvZ2ljYWxSb3dJbmRleCxcbiAgICAgICAgICAgIGRhdGFJdGVtOiByb3cuZGF0YUl0ZW0sXG4gICAgICAgICAgICBkYXRhUm93SW5kZXg6IHJvdy5kYXRhUm93SW5kZXgsXG4gICAgICAgICAgICBjZWxsczogbmV3IEl0ZW1NYXAoKSxcbiAgICAgICAgICAgIGlzTmV3OiByb3cuaXNOZXdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yb3dzLnNldEl0ZW0ocm93LmxvZ2ljYWxSb3dJbmRleCwgbW9kZWxSb3cpO1xuICAgIH1cbiAgICB1cGRhdGVSb3cocm93KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnJvd3MuZ2V0SXRlbShyb3cubG9naWNhbFJvd0luZGV4KTtcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3VycmVudCwge1xuICAgICAgICAgICAgICAgIGRhdGFJdGVtOiByb3cuZGF0YUl0ZW0sXG4gICAgICAgICAgICAgICAgZGF0YVJvd0luZGV4OiByb3cuZGF0YVJvd0luZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZ2lzdGVyUm93KGluZGV4LCByb3cpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLnJvd3MuZ2V0SXRlbShpbmRleCk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC51aWQgPT09IHJvdy51aWQpIHtcbiAgICAgICAgICAgIHRoaXMucm93cy5yZW1vdmVJdGVtKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjZWxsUmFuZ2UoY2VsbCkge1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjZWxsLmNvbEluZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gY2VsbC5jb2xJbmRleCArIChjZWxsLmNvbFNwYW4gfHwgMSkgLSAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByb3dSYW5nZShjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGNlbGwucm93SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBjZWxsLnJvd0luZGV4ICsgKGNlbGwucm93U3BhbiB8fCAxKSAtIDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIG5leHRSb3cocm93SW5kZXgsIG9mZnNldCkge1xuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5yb3dzLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzLmdldEl0ZW0ocm93SW5kZXgpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHJvd3MuaW5kZXhPZihyb3cpO1xuICAgICAgICBjb25zdCBuZXh0ID0gcm93c1twb3NpdGlvbiArIG9mZnNldF07XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBmaW5kUm93KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3MuZ2V0SXRlbShpbmRleCk7XG4gICAgfVxuICAgIGZpbmRDZWxsKGluZGV4LCByb3cpIHtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3dJbmRleCA9IHJvdy5pbmRleDtcbiAgICAgICAgbGV0IGNlbGwgPSByb3cuY2VsbHMuZ2V0SXRlbShpbmRleCk7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSByb3dJbmRleDtcbiAgICAgICAgd2hpbGUgKCFjZWxsICYmIHJvdykge1xuICAgICAgICAgICAgcm93ID0gdGhpcy5yb3dzLmdldEl0ZW0oY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLnJvd0NlbGwoaW5kZXgsIHJvdyk7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbCAmJiByb3dJbmRleCA8PSByb3cuaW5kZXggKyAoY2VsbC5yb3dTcGFuIHx8IDEpIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcm93Q2VsbChpbmRleCwgcm93KSB7XG4gICAgICAgIGlmICghcm93IHx8ICFyb3cuY2VsbHMuY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdENlbGwgPSByb3cuY2VsbHMuZmlyc3Q7XG4gICAgICAgIGxldCBjZWxsLCBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgd2hpbGUgKCFjZWxsICYmIGN1cnJlbnRJbmRleCA+PSBmaXJzdENlbGwuY29sSW5kZXgpIHtcbiAgICAgICAgICAgIGNlbGwgPSByb3cuY2VsbHMuZ2V0SXRlbShjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgY3VycmVudEluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGwgJiYgaW5kZXggPD0gY2VsbC5jb2xJbmRleCArIChjZWxsLmNvbFNwYW4gfHwgMSkgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFRyZWVMaXN0Rm9jdXNhYmxlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgIH1cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c0NlbGwoKTtcbiAgICB9XG4gICAgdG9nZ2xlKGFjdGl2ZSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnRvZ2dsZShhY3RpdmUpO1xuICAgIH1cbiAgICBjYW5Gb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5oYXNGb2N1cygpO1xuICAgIH1cbiAgICBpc05hdmlnYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBUcmVlTGlzdCBleHBhbmQgYW5kIGNvbGxhcHNlIGV2ZW50cy5cbiAqL1xuY2xhc3MgRXhwYW5kRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cGFuZCA9IGFyZ3MuZXhwYW5kO1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gYXJncy5kYXRhSXRlbTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZWZhdWx0RXhwYW5kZWQgPSAoX2l0ZW0pID0+IHRydWU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRXhwYW5kU3RhdGVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZGVmYXVsdEV4cGFuZGVkO1xuICAgIH1cbiAgICB0b2dnbGVTdGF0ZShkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gdGhpcy5pc0V4cGFuZGVkKGRhdGFJdGVtKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQobmV3IEV4cGFuZEV2ZW50KHsgZGF0YUl0ZW06IGRhdGFJdGVtLCBleHBhbmQ6ICFpc0V4cGFuZGVkIH0pKTtcbiAgICB9XG4gICAgZXhwYW5kKGRhdGFJdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0V4cGFuZGVkKGRhdGFJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQobmV3IEV4cGFuZEV2ZW50KHsgZGF0YUl0ZW06IGRhdGFJdGVtLCBleHBhbmQ6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlKGRhdGFJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwYW5kZWQoZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMubmV4dChuZXcgRXhwYW5kRXZlbnQoeyBkYXRhSXRlbTogZGF0YUl0ZW0sIGV4cGFuZDogZmFsc2UgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuRXhwYW5kU3RhdGVTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2Nyb2xsUmVxdWVzdFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RzID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgc2Nyb2xsVG8ocmVxdWVzdCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RzLm5leHQocmVxdWVzdCk7XG4gICAgfVxufVxuU2Nyb2xsUmVxdWVzdFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgVHJlZUxpc3QgYHNlbGVjdGlvbkNoYW5nZWAgZXZlbnQuXG4gKi9cbmNsYXNzIFNlbGVjdGlvbkNoYW5nZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWN0aW9uLCBpdGVtcykge1xuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlZmF1bHRTZWxlY3RlZCA9IChfaXRlbSkgPT4gZmFsc2U7XG5jb25zdCBub29wID0gKCkgPT4gZmFsc2U7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VsZWN0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IGRlZmF1bHRTZWxlY3RlZDtcbiAgICAgICAgdGhpcy5pc1Jvd1NlbGVjdGVkID0gbm9vcDtcbiAgICAgICAgdGhpcy5pc0NlbGxTZWxlY3RlZCA9IG5vb3A7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnRhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIHNldCBzZXR0aW5ncyh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuX3NldHRpbmdzLmVuYWJsZWQgIT09IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubW9kZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NlbGxTZWxlY3RlZCA9IHRoaXMuY2VsbFNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSb3dTZWxlY3RlZCA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ2VsbFNlbGVjdGVkID0gbm9vcDtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUm93U2VsZWN0ZWQgPSB0aGlzLnJvd1NlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0NlbGxTZWxlY3RlZCA9IG5vb3A7XG4gICAgICAgICAgICB0aGlzLmlzUm93U2VsZWN0ZWQgPSBub29wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlTWFycXVlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCAmJiB0aGlzLnNldHRpbmdzLmRyYWcgIT09IGZhbHNlICYmIHRoaXMuc2V0dGluZ3MubXVsdGlwbGU7XG4gICAgfVxuICAgIGdldCBlbmFibGVNdWx0aXBsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCAmJiB0aGlzLnNldHRpbmdzLm11bHRpcGxlO1xuICAgIH1cbiAgICBnZXQgcm93U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkICYmIHRoaXMuc2V0dGluZ3MubW9kZSAhPT0gJ2NlbGwnO1xuICAgIH1cbiAgICBpbml0KHRyZWVsaXN0KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHRyZWVsaXN0LnZpZXc7XG4gICAgICAgIHRoaXMuY29sdW1uc0NvbnRhaW5lciA9IHRyZWVsaXN0LmNvbHVtbnNDb250YWluZXI7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQobWVyZ2UodHJlZWxpc3QucGFnZUNoYW5nZSwgdHJlZWxpc3QuZGF0YVN0YXRlQ2hhbmdlKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodHJlZWxpc3QuZG9tRXZlbnRzLmNlbGxNb3VzZWRvd24uc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuX3NldHRpbmdzLm11bHRpcGxlICYmIGFyZ3Mub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGFyZ3Mub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJUYWJsZSh0YWJsZSkge1xuICAgICAgICB0aGlzLnRhYmxlcy5wdXNoKHRhYmxlKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlclRhYmxlKHRhYmxlKSB7XG4gICAgICAgIHRoaXMudGFibGVzID0gdGhpcy50YWJsZXMuZmlsdGVyKHQgPT4gdCAhPT0gdGFibGUpO1xuICAgIH1cbiAgICBjbGljayhhcmdzLCB0b2dnbGUpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhSXRlbSwgY29sdW1uLCBjb2x1bW5JbmRleCwgb3JpZ2luYWxFdmVudCB9ID0gYXJncztcbiAgICAgICAgaWYgKG9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5pc1NlbGVjdGVkKGRhdGFJdGVtLCBjb2x1bW4sIGNvbHVtbkluZGV4KTtcbiAgICAgICAgY29uc3QgdG9nZ2xlU2VsZWN0ZWQgPSBvcmlnaW5hbEV2ZW50LmN0cmxLZXkgfHwgdG9nZ2xlO1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5zZWxlY3Rpb25PcmlnaW4gfHwge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxlYWZDb2x1bW5zWzBdLFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiB0aGlzLnZpZXcuZmlyc3RJdGVtLmRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0UmFuZ2UoeyBpdGVtOiBkYXRhSXRlbSwgY29sdW1uLCBjb2x1bW5JbmRleCB9LCBvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25PcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGFJdGVtLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSB0b2dnbGVTZWxlY3RlZCA/IChzZWxlY3RlZCA/ICdyZW1vdmUnIDogJ2FkZCcpIDogJ3NlbGVjdCc7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQobmV3IFNlbGVjdGlvbkNoYW5nZUV2ZW50KGFjdGlvbiwgW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsZWN0ZWQgfHwgdG9nZ2xlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHNlbGVjdGVkICYmIHRvZ2dsZVNlbGVjdGVkID8gJ3JlbW92ZScgOiAnc2VsZWN0JztcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KG5ldyBTZWxlY3Rpb25DaGFuZ2VFdmVudChhY3Rpb24sIFt7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luYWxFdmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tib3hDbGljayhhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmNvbHVtbi5jaGVja0NoaWxkcmVuICYmIGFyZ3Mudmlld0l0ZW0uaGFzQ2hpbGRyZW4gJiYgIWFyZ3Mub3JpZ2luYWxFdmVudC5zaGlmdEtleSAmJiAhYXJncy5vcmlnaW5hbEV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbYXJncy5kYXRhSXRlbV07XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IEJvb2xlYW4oYXJncy52aWV3SXRlbS5zZWxlY3RlZCk7XG4gICAgICAgICAgICBWaWV3Q29sbGVjdGlvbi5sb2FkVmlldyh7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcuZmllbGRBY2Nlc3NvcigpLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGhhc0Zvb3RlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXJ0dWFsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogdGhpcy52aWV3LmxvYWRlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZTogdGhpcy52aWV3LnNlbGVjdGlvblN0YXRlXG4gICAgICAgICAgICB9KS5zdWJzY3JpYmUodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtcyA9IHZpZXcuZGF0YS5maWx0ZXIoaXRlbSA9PiBCb29sZWFuKGl0ZW0uc2VsZWN0ZWQpID09PSBzZWxlY3RlZCkubWFwKGl0ZW0gPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW06IGl0ZW0uZGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMubmV4dChuZXcgU2VsZWN0aW9uQ2hhbmdlRXZlbnQoc2VsZWN0ZWQgPyAncmVtb3ZlJyA6ICdhZGQnLCBzZWxlY3RlZEl0ZW1zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2soYXJncywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlQWxsKHNlbGVjdCkge1xuICAgICAgICBWaWV3Q29sbGVjdGlvbi5sb2FkVmlldyh7XG4gICAgICAgICAgICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlldy5maWVsZEFjY2Vzc29yKCksIHtcbiAgICAgICAgICAgICAgICBoYXNGb290ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhZ2VhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1ZpcnR1YWw6IGZhbHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxvYWRlZDogdGhpcy52aWV3LmxvYWRlZCxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlOiB0aGlzLnZpZXcuc2VsZWN0aW9uU3RhdGVcbiAgICAgICAgfSkuc3Vic2NyaWJlKHZpZXcgPT4ge1xuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtcyA9IHZpZXcuZGF0YS5maWx0ZXIoaXRlbSA9PiBCb29sZWFuKGl0ZW0uc2VsZWN0ZWQpICE9PSBzZWxlY3QpLm1hcChpdGVtID0+ICh7XG4gICAgICAgICAgICAgICAgZGF0YUl0ZW06IGl0ZW0uZGF0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQobmV3IFNlbGVjdGlvbkNoYW5nZUV2ZW50KHNlbGVjdCA/ICdhZGQnIDogJ3JlbW92ZScsIHNlbGVjdGVkSXRlbXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGVjdFJhbmdlKGZpcnN0UG9pbnQsIHNlY29uZFBvaW50KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlSXRlbXMgPSB0aGlzLnJhbmdlSXRlbXMoZmlyc3RQb2ludCwgc2Vjb25kUG9pbnQpO1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dChuZXcgU2VsZWN0aW9uQ2hhbmdlRXZlbnQoJ3NlbGVjdCcsIHJhbmdlSXRlbXMpKTtcbiAgICB9XG4gICAgcmFuZ2VJdGVtcyhmaXJzdFBvaW50LCBzZWNvbmRQb2ludCkge1xuICAgICAgICBjb25zdCBmaXJzdEluZGV4ID0gdGhpcy52aWV3LmZpbmRJbmRleChpdGVtID0+IGl0ZW0uZGF0YSA9PT0gZmlyc3RQb2ludC5pdGVtIHx8IGl0ZW0gPT09IGZpcnN0UG9pbnQuaXRlbSk7XG4gICAgICAgIGNvbnN0IHNlY29uZEluZGV4ID0gdGhpcy52aWV3LmZpbmRJbmRleChpdGVtID0+IGl0ZW0uZGF0YSA9PT0gc2Vjb25kUG9pbnQuaXRlbSB8fCBpdGVtID09PSBzZWNvbmRQb2ludC5pdGVtKTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IE1hdGgubWluKGZpcnN0SW5kZXgsIHNlY29uZEluZGV4KTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBNYXRoLm1heChmaXJzdEluZGV4LCBzZWNvbmRJbmRleCk7XG4gICAgICAgIGNvbnN0IHJhbmdlSXRlbXMgPSB0aGlzLnZpZXcuZGF0YS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gJ2RhdGEnKTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1vZGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSB0aGlzLmxlYWZDb2x1bW5zO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW5JbmRleCA9IE1hdGgubWluKGZpcnN0UG9pbnQuY29sdW1uSW5kZXgsIHNlY29uZFBvaW50LmNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZENvbHVtbkluZGV4ID0gTWF0aC5tYXgoZmlyc3RQb2ludC5jb2x1bW5JbmRleCwgc2Vjb25kUG9pbnQuY29sdW1uSW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmFuZ2VJdGVtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uSWR4ID0gc3RhcnRDb2x1bW5JbmRleDsgY29sdW1uSWR4IDw9IGVuZENvbHVtbkluZGV4OyBjb2x1bW5JZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW06IHJhbmdlSXRlbXNbaWR4XS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBsZWFmQ29sdW1uc1tjb2x1bW5JZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbklkeFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRJdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VJdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgICAgZGF0YUl0ZW06IGl0ZW0uZGF0YVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGVkU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVNlbGVjdGVkU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXRBcmdzKHRhcmdldCwgc2tpcEZvY3VzYWJsZSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0aGlzLnRhYmxlcy5zb21lKHQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ID0gdC50YXJnZXRBcmdzKHRhcmdldCwgc2tpcEZvY3VzYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcm93U2VsZWN0ZWQoZGF0YUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZChkYXRhSXRlbSk7XG4gICAgfVxuICAgIGNlbGxTZWxlY3RlZChkYXRhSXRlbSwgY29sdW1uLCBjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkKGRhdGFJdGVtLCBjb2x1bW4sIGNvbHVtbkluZGV4KTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIGluIHRoZSB0cmVlbGlzdD9cbiAgICBnZXQgbGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubG9ja2VkTGVhZkNvbHVtbnMudG9BcnJheSgpLmNvbmNhdCh0aGlzLmNvbHVtbnNDb250YWluZXIubm9uTG9ja2VkTGVhZkNvbHVtbnMudG9BcnJheSgpKTtcbiAgICB9XG59XG5TZWxlY3Rpb25TZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG5jb25zdCBpc0luU2FtZVRyZWVMaXN0ID0gKGVsZW1lbnQsIHRyZWVsaXN0RWxlbWVudCkgPT4gY2xvc2VzdChlbGVtZW50LCBtYXRjaGVzTm9kZU5hbWUoJ2tlbmRvLXRyZWVsaXN0JykpID09PSB0cmVlbGlzdEVsZW1lbnQ7XG5jb25zdCBtYXRjaEhlYWRlckNlbGwgPSBtYXRjaGVzTm9kZU5hbWUoJ3RoJyk7XG5jb25zdCBtYXRjaERhdGFDZWxsID0gbWF0Y2hlc05vZGVOYW1lKCd0ZCcpO1xuY29uc3QgbWF0Y2hDZWxsID0gKGVsZW1lbnQpID0+IG1hdGNoRGF0YUNlbGwoZWxlbWVudCkgfHwgbWF0Y2hIZWFkZXJDZWxsKGVsZW1lbnQpO1xuY29uc3QgdHJlZWxpc3RDZWxsID0gKGVsZW1lbnQsIHRyZWVsaXN0RWxlbWVudCkgPT4ge1xuICAgIGxldCB0YXJnZXQgPSBjbG9zZXN0KGVsZW1lbnQsIG1hdGNoQ2VsbCk7XG4gICAgd2hpbGUgKHRhcmdldCAmJiAhaXNJblNhbWVUcmVlTGlzdCh0YXJnZXQsIHRyZWVsaXN0RWxlbWVudCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQucGFyZW50RWxlbWVudCwgbWF0Y2hDZWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCB0YXJnZXRDZWxsID0gKHRhcmdldCwgdHJlZWxpc3RFbGVtZW50KSA9PiB7XG4gICAgY29uc3QgY2VsbCA9IHRyZWVsaXN0Q2VsbCh0YXJnZXQsIHRyZWVsaXN0RWxlbWVudCk7XG4gICAgY29uc3Qgcm93ID0gY2xvc2VzdChjZWxsLCBtYXRjaGVzTm9kZU5hbWUoJ3RyJykpO1xuICAgIGlmIChjZWxsICYmIHJvdykge1xuICAgICAgICBsZXQgcm93SW5kZXggPSByb3cuZ2V0QXR0cmlidXRlKCdhcmlhLXJvd2luZGV4Jyk7XG4gICAgICAgIHJvd0luZGV4ID0gcm93SW5kZXggPyBwYXJzZUludChyb3dJbmRleCwgMTApIC0gMSA6IG51bGw7XG4gICAgICAgIGxldCBjb2xJbmRleCA9IGNlbGwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbGluZGV4Jyk7XG4gICAgICAgIGNvbEluZGV4ID0gY29sSW5kZXggPyBwYXJzZUludChjb2xJbmRleCwgMTApIC0gMSA6IG51bGw7XG4gICAgICAgIGlmIChyb3dJbmRleCAhPT0gbnVsbCAmJiBjb2xJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29sSW5kZXgsIHJvd0luZGV4LCBlbGVtZW50OiBjZWxsIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaXNBcnJvd0tleSA9IGtleUNvZGUgPT4ga2V5Q29kZSA9PT0gS2V5cy5BcnJvd0xlZnQgfHwga2V5Q29kZSA9PT0gS2V5cy5BcnJvd1JpZ2h0IHx8XG4gICAga2V5Q29kZSA9PT0gS2V5cy5BcnJvd1VwIHx8IGtleUNvZGUgPT09IEtleXMuQXJyb3dEb3duO1xuY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID0ga2V5Q29kZSA9PiBpc0Fycm93S2V5KGtleUNvZGUpIHx8XG4gICAga2V5Q29kZSA9PT0gS2V5cy5QYWdlVXAgfHwga2V5Q29kZSA9PT0gS2V5cy5QYWdlRG93biB8fFxuICAgIGtleUNvZGUgPT09IEtleXMuSG9tZSB8fCBrZXlDb2RlID09PSBLZXlzLkVuZDtcbmNvbnN0IGlzSW5wdXQgPSBtYXRjaGVzTm9kZU5hbWUoJ2lucHV0Jyk7XG5jb25zdCBpc1RleHRJbnB1dCA9IGVsZW1lbnQgPT4gZWxlbWVudCAmJiBpc0lucHV0KGVsZW1lbnQpICYmIGVsZW1lbnQudHlwZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dCc7XG5jb25zdCBpc1ByaW50YWJsZUNoYXJhY3RlciA9IChzdHIpID0+IHN0ci5sZW5ndGggPT09IDEgJiYgc3RyLm1hdGNoKC9cXFMvKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOYXZpZ2F0aW9uVmlld3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGZpcnN0SXRlbUluZGV4LCBsYXN0SXRlbUluZGV4KSB7XG4gICAgICAgIHRoaXMuZmlyc3RJdGVtSW5kZXggPSBmaXJzdEl0ZW1JbmRleDtcbiAgICAgICAgdGhpcy5sYXN0SXRlbUluZGV4ID0gbGFzdEl0ZW1JbmRleDtcbiAgICB9XG4gICAgY29udGFpbnNSb3coZGF0YVJvd0luZGV4KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlclJvdyA9IGRhdGFSb3dJbmRleCA8IDA7XG4gICAgICAgIHJldHVybiBoZWFkZXJSb3cgfHwgKGRhdGFSb3dJbmRleCA+PSB0aGlzLmZpcnN0SXRlbUluZGV4ICYmIGRhdGFSb3dJbmRleCA8PSB0aGlzLmxhc3RJdGVtSW5kZXgpO1xuICAgIH1cbiAgICBpbnRlcnNlY3RzKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIChzdGFydCA8PSB0aGlzLmZpcnN0SXRlbUluZGV4ICYmIHRoaXMubGFzdEl0ZW1JbmRleCA8PSBlbmQpIHx8XG4gICAgICAgICAgICAodGhpcy5maXJzdEl0ZW1JbmRleCA8PSBzdGFydCAmJiBzdGFydCA8PSB0aGlzLmxhc3RJdGVtSW5kZXgpIHx8XG4gICAgICAgICAgICAodGhpcy5maXJzdEl0ZW1JbmRleCA8PSBlbmQgJiYgZW5kIDw9IHRoaXMubGFzdEl0ZW1JbmRleCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih6b25lLCBkb21FdmVudHMsIHBhZ2VyQ29udGV4dFNlcnZpY2UsIHNjcm9sbFJlcXVlc3RTZXJ2aWNlLCBmb2N1c1Jvb3QsIGVkaXRTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGV4cGFuZFN0YXRlLCBzZWxlY3Rpb25TZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvciwgZm9jdXNhYmxlUGFyZW50KSB7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gZG9tRXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VyQ29udGV4dFNlcnZpY2UgPSBwYWdlckNvbnRleHRTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNjcm9sbFJlcXVlc3RTZXJ2aWNlID0gc2Nyb2xsUmVxdWVzdFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZm9jdXNSb290ID0gZm9jdXNSb290O1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlID0gZWRpdFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmV4cGFuZFN0YXRlID0gZXhwYW5kU3RhdGU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5mb2N1c2FibGVQYXJlbnQgPSBmb2N1c2FibGVQYXJlbnQ7XG4gICAgICAgIHRoaXMuY2VsbEtleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tb2RlID0gMCAvKiBTdGFuZGJ5ICovO1xuICAgICAgICB0aGlzLm1vZGVsID0gbmV3IE5hdmlnYXRpb25Nb2RlbCgpO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG5ldyBOYXZpZ2F0aW9uQ3Vyc29yKHRoaXMubW9kZWwpO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmN1cnNvci5jaGFuZ2VzO1xuICAgIH1cbiAgICBzZXQgbWV0YWRhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yLm1ldGFkYXRhID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YTtcbiAgICB9XG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaXZlO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlQ2VsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gMCAvKiBTdGFuZGJ5ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IuY2VsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWN0aXZlUm93KCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAwIC8qIFN0YW5kYnkgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmN1cnNvci5yb3csIHtcbiAgICAgICAgICAgICAgICBjZWxsczogdGhpcy5jdXJzb3Iucm93LmNlbGxzLnRvQXJyYXkoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZURhdGFSb3coKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmFjdGl2ZVJvd0luZGV4IC0gdGhpcy5tZXRhLmhlYWRlclJvd3MpO1xuICAgIH1cbiAgICBpbml0KG1ldGEpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZm9jdXNSb290LmFsaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IG9uU3RhYmxlU3Vic2NyaWJlciA9ICguLi5vcGVyYXRvcnMpID0+IChhcmdzKSA9PiB0aGlzLnpvbmUuaXNTdGFibGUgP1xuICAgICAgICAgICAgZnJvbShbdHJ1ZV0pLnBpcGUobWFwKCgpID0+IGFyZ3MpKSA6XG4gICAgICAgICAgICB0aGlzLnpvbmUub25TdGFibGUucGlwZSh0YWtlKDEpLCBtYXAoKCkgPT4gYXJncyksIC4uLm9wZXJhdG9ycyk7XG4gICAgICAgIGNvbnN0IG9uU3RhYmxlID0gb25TdGFibGVTdWJzY3JpYmVyKCk7XG4gICAgICAgIHRoaXMuc3VicyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmN1cnNvci5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGFyZ3MgPT4gdGhpcy5vbkN1cnNvckNoYW5nZXMoYXJncykpKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRvbUV2ZW50cy5mb2N1cy5waXBlKHN3aXRjaE1hcChvblN0YWJsZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChhcmdzKSA9PiB0aGlzLm5hdmlnYXRlVG8oYXJncy50YXJnZXQpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5kb21FdmVudHMuZm9jdXNPdXQucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5tb2RlICE9PSAwIC8qIFN0YW5kYnkgKi8pLCBzd2l0Y2hNYXAob25TdGFibGVTdWJzY3JpYmVyKHRha2VVbnRpbCh0aGlzLmRvbUV2ZW50cy5mb2N1cykpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLm9uRm9jdXNPdXQoYXJncykpKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRvbUV2ZW50cy53aW5kb3dCbHVyLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMubW9kZSAhPT0gMCAvKiBTdGFuZGJ5ICovKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbldpbmRvd0JsdXIoKSkpO1xuICAgICAgICB0aGlzLnN1YnMuYWRkKFxuICAgICAgICAvLyBDbG9zaW5nIHRoZSBlZGl0b3Igd2lsbCBub3QgYWx3YXlzIHRyaWdnZXIgZm9jdXNvdXQgaW4gRmlyZWZveC5cbiAgICAgICAgLy8gVG8gZ2V0IGFyb3VuZCB0aGlzLCB3ZSBlbnN1cmUgdGhhdCB0aGUgY2VsbCBpcyBjbG9zZWQgYWZ0ZXIgZWRpdGluZy5cbiAgICAgICAgdGhpcy5lZGl0U2VydmljZS5jaGFuZ2VzLnBpcGUoZmlsdGVyKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENlbGxDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGUuYWN0aW9uICE9PSAnZWRpdCcgJiYgdGhpcy5tb2RlID09PSAyIC8qIENvbnRlbnQgKi87XG4gICAgICAgIH0pLCBzd2l0Y2hNYXAob25TdGFibGUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxlYXZlQ2VsbCgpKSk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQodGhpcy5wYWdlckNvbnRleHRTZXJ2aWNlLnBhZ2VDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jdXJzb3IucmVzZXQoMCwgMCkpKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRvbUV2ZW50cy5rZXlkb3duXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGFyZ3MgPT4gdGhpcy5vbktleWRvd24oYXJncykpKTtcbiAgICAgICAgdGhpcy5zdWJzLmFkZCh0aGlzLmRvbUV2ZW50cy5rZXlkb3duLnBpcGUoZmlsdGVyKGFyZ3MgPT4gYXJncy5rZXlDb2RlID09PSBLZXlzLlRhYiAmJiB0aGlzLm1vZGUgPT09IDIgLyogQ29udGVudCAqLyksIHN3aXRjaE1hcFRvKHRoaXMuZG9tRXZlbnRzLmZvY3VzT3V0LnBpcGUodGFrZVVudGlsKFxuICAgICAgICAvLyBUaW1lb3V0IGlmIGZvY3VzT3V0IGRvZXNuJ3QgZmlyZSB2ZXJ5IHNvb25cbiAgICAgICAgaW50ZXJ2YWwoMCkucGlwZSh0YWtlKDEpKSkpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vblRhYm91dCgpKSk7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzYWJsZVBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBUcmVlTGlzdEZvY3VzYWJsZUVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzYWJsZVBhcmVudC5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vicy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDZWxsKGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwubG9naWNhbFJvd0luZGV4ICE9PSB0aGlzLnBlbmRpbmdSb3dJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxDZWxsID0gdGhpcy5tb2RlbC5yZWdpc3RlckNlbGwoY2VsbCk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXJ0dWFsQ2VsbCAmJiB0aGlzLmN1cnNvci5hY3RpdmF0ZVZpcnR1YWxDZWxsKG1vZGVsQ2VsbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxDZWxsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJDZWxsT25DdXJyZW50Um93KGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwubG9naWNhbFJvd0luZGV4ID09PSB0aGlzLnBlbmRpbmdSb3dJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5yZWdpc3RlckNlbGwoY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWdpc3RlckNlbGwoaW5kZXgsIHJvd0luZGV4LCBjZWxsKSB7XG4gICAgICAgIHRoaXMubW9kZWwudW5yZWdpc3RlckNlbGwoaW5kZXgsIHJvd0luZGV4LCBjZWxsKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSb3cocm93KSB7XG4gICAgICAgIHRoaXMubW9kZWwucmVnaXN0ZXJSb3cocm93KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUm93SW5kZXggPSByb3cubG9naWNhbFJvd0luZGV4O1xuICAgIH1cbiAgICB1cGRhdGVSb3cocm93KSB7XG4gICAgICAgIHRoaXMubW9kZWwudXBkYXRlUm93KHJvdyk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJSb3coaW5kZXgsIHJvdykge1xuICAgICAgICB0aGlzLm1vZGVsLnVucmVnaXN0ZXJSb3coaW5kZXgsIHJvdyk7XG4gICAgfVxuICAgIGlzQ2VsbEZvY3VzYWJsZShjZWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaXZlICYmXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy5tb2RlICE9PSAyIC8qIENvbnRlbnQgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLmlzQWN0aXZlKGNlbGwubG9naWNhbFJvd0luZGV4LCBjZWxsLmxvZ2ljYWxDb2xJbmRleCk7XG4gICAgfVxuICAgIGlzQ2VsbEZvY3VzZWQoY2VsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAxIC8qIEN1cnNvciAqLyAmJiB0aGlzLmlzQ2VsbEZvY3VzYWJsZShjZWxsKTtcbiAgICB9XG4gICAgbmF2aWdhdGVUbyhlbCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZWxsID0gdGFyZ2V0Q2VsbChlbCwgdGhpcy5tZXRhLnRyZWVsaXN0RWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkTW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgY29uc3QgZm9jdXNJbkNlbGwgPSBjb250YWlucyhjZWxsLmVsZW1lbnQsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBmb2N1c0luQWN0aXZlUm93Q29udGVudCA9IHRoaXMubW9kZSA9PT0gMiAvKiBDb250ZW50ICovICYmXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJvd0luZGV4ID09PSBjZWxsLnJvd0luZGV4ICYmXG4gICAgICAgICAgICBlbCAhPT0gY2VsbC5lbGVtZW50O1xuICAgICAgICBpZiAoZm9jdXNJbkNlbGwpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IDIgLyogQ29udGVudCAqLztcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KGNlbGwucm93SW5kZXgsIGNlbGwuY29sSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVJvdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmb2N1c0luQWN0aXZlUm93Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gMSAvKiBDdXJzb3IgKi87XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVFbGVtZW50cygpO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeUFjdGl2ZSA9IHRoaXMuY3Vyc29yLmlzQWN0aXZlKGNlbGwucm93SW5kZXgsIGNlbGwuY29sSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgaXNDdXJzb3IgPSBvbGRNb2RlID09PSAxIC8qIEN1cnNvciAqLyAmJiBhbHJlYWR5QWN0aXZlO1xuICAgICAgICAgICAgaWYgKCFpc0N1cnNvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KGNlbGwucm93SW5kZXgsIGNlbGwuY29sSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyeUZvY3VzKGVsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVFbGVtZW50cygpO1xuICAgICAgICBjb25zdCBmb2N1c2FibGUgPSBmaW5kRm9jdXNhYmxlQ2hpbGQoZWwpO1xuICAgICAgICBpZiAoZm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGFyZ2V0Q2VsbChmb2N1c2FibGUsIHRoaXMubWV0YS50cmVlbGlzdEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KGNlbGwucm93SW5kZXgsIGNlbGwuY29sSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUVsZW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlckNlbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFmb2N1c2FibGU7XG4gICAgfVxuICAgIG5lZWRzVmlld3BvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGEgJiYgdGhpcy5tZXRhLmlzVmlydHVhbDtcbiAgICB9XG4gICAgc2V0Vmlld3BvcnQoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBOYXZpZ2F0aW9uVmlld3BvcnQoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMubWV0YSAmJiB0aGlzLm1ldGEuaXNWaXJ0dWFsICYmIHRoaXMuYWN0aXZlRGF0YVJvdyA+IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhUm93SW5kZXggPSB0aGlzLmFjdGl2ZURhdGFSb3c7XG4gICAgICAgICAgICBjb25zdCBhaGVhZCA9IGZpcnN0SXRlbUluZGV4IC0gZGF0YVJvd0luZGV4O1xuICAgICAgICAgICAgY29uc3QgYmVoaW5kID0gZGF0YVJvd0luZGV4IC0gbGFzdEl0ZW1JbmRleDtcbiAgICAgICAgICAgIGlmIChhaGVhZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChmaXJzdEl0ZW1JbmRleCArIHRoaXMubWV0YS5oZWFkZXJSb3dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlaGluZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChsYXN0SXRlbUluZGV4IC0gdGhpcy5tZXRhLmhlYWRlclJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbHVtblZpZXdwb3J0KGZpcnN0SXRlbUluZGV4LCBsYXN0SXRlbUluZGV4KSB7XG4gICAgICAgIHRoaXMuY29sdW1uVmlld3BvcnQgPSBuZXcgTmF2aWdhdGlvblZpZXdwb3J0KGZpcnN0SXRlbUluZGV4LCBsYXN0SXRlbUluZGV4KTtcbiAgICB9XG4gICAgZm9jdXNDZWxsKHJvd0luZGV4ID0gdW5kZWZpbmVkLCBjb2xJbmRleCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1vZGUgPSAxIC8qIEN1cnNvciAqLztcbiAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQocm93SW5kZXgsIGNvbEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlQ2VsbDtcbiAgICB9XG4gICAgZm9jdXNOZXh0Q2VsbCh3cmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c0FkamFjZW50Q2VsbCh0cnVlLCB3cmFwKTtcbiAgICB9XG4gICAgZm9jdXNQcmV2Q2VsbCh3cmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c0FkamFjZW50Q2VsbChmYWxzZSwgd3JhcCk7XG4gICAgfVxuICAgIHRvZ2dsZShhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuY3Vyc29yLmFubm91bmNlKCk7XG4gICAgfVxuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAxIC8qIEN1cnNvciAqLyB8fCB0aGlzLm1vZGUgPT09IDIgLyogQ29udGVudCAqLztcbiAgICB9XG4gICAgYXV0b0ZvY3VzQ2VsbChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5tZXRhLnZpcnR1YWxDb2x1bW5zIHx8IGVuZCA8IHRoaXMubWV0YS5jb2x1bW5zLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCB8fCB0aGlzLmNvbHVtblZpZXdwb3J0LmludGVyc2VjdHMoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZvY3VzQWRqYWNlbnRDZWxsKGZ3ZCwgd3JhcCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2VsbCgpO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZ3ZCA/IHRoaXMubW92ZUN1cnNvckZ3ZCgpIDogdGhpcy5tb3ZlQ3Vyc29yQndkKCk7XG4gICAgICAgIGlmICh3cmFwICYmICFzdWNjZXNzKSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gZndkID8gdGhpcy5jdXJzb3IubW92ZURvd24oMSkgOiB0aGlzLmN1cnNvci5tb3ZlVXAoMSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuY3Vyc29yLnJvdztcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZHggPSBmd2QgPyAwIDogdGhpcy5jdXJzb3IubGFzdENlbGxJbmRleCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KHJvdy5pbmRleCwgY29sSWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlQ2VsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IDAgLyogU3RhbmRieSAqLztcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLmFubm91bmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVudGVyQ2VsbCgpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY3Vyc29yLmNlbGw7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwID0gY2VsbC5mb2N1c0dyb3VwO1xuICAgICAgICBjb25zdCBmb2N1c2FibGUgPSBncm91cCAmJiBncm91cC5jYW5Gb2N1cygpO1xuICAgICAgICB0aGlzLm1vZGUgPSBmb2N1c2FibGUgPyAyIC8qIENvbnRlbnQgKi8gOiAxIC8qIEN1cnNvciAqLztcbiAgICAgICAgdGhpcy5jdXJzb3IuYW5ub3VuY2UoKTtcbiAgICAgICAgaWYgKGZvY3VzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVJvdygpO1xuICAgICAgICAgICAgZ3JvdXAuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZWF2ZUNlbGwoKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmN1cnNvci5jZWxsO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cCA9IGNlbGwuZm9jdXNHcm91cDtcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlID0gZ3JvdXAgJiYgZ3JvdXAuY2FuRm9jdXMoKTtcbiAgICAgICAgaWYgKCFmb2N1c2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlID0gMSAvKiBDdXJzb3IgKi87XG4gICAgICAgIHRoaXMuY3Vyc29yLmFubm91bmNlKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlRWxlbWVudHMoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNSb290LmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGVFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5mb2N1c1Jvb3QuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgICBhY3RpdmF0ZVJvdygpIHtcbiAgICAgICAgdGhpcy5jdXJzb3Iucm93LmNlbGxzXG4gICAgICAgICAgICAuZm9yRWFjaChjZWxsID0+IGNlbGwuZm9jdXNHcm91cCAmJiBjZWxsLmZvY3VzR3JvdXAuYWN0aXZhdGUoKSk7XG4gICAgfVxuICAgIG1vdmVDdXJzb3JGd2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyB0aGlzLmN1cnNvci5tb3ZlTGVmdCgpIDogdGhpcy5jdXJzb3IubW92ZVJpZ2h0KCk7XG4gICAgfVxuICAgIG1vdmVDdXJzb3JCd2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyB0aGlzLmN1cnNvci5tb3ZlUmlnaHQoKSA6IHRoaXMuY3Vyc29yLm1vdmVMZWZ0KCk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGlvbihhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblNlcnZpY2UuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrKHtcbiAgICAgICAgICAgICAgICBkYXRhSXRlbTogdGhpcy5jdXJzb3Iucm93LmRhdGFJdGVtLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jdXJzb3IuY2VsbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IHRoaXMuY3Vyc29yLmNlbGwuY29sSW5kZXgsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogYXJnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DdXJzb3JLZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgbGV0IHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gYXJncy5jdHJsS2V5IHx8IGFyZ3MubWV0YUtleTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IG1vZGlmaWVyID8gNSA6IDE7XG4gICAgICAgIGlmICghdGhpcy5vbkNlbGxLZXlkb3duKGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5jdXJzb3Iucm93O1xuICAgICAgICBzd2l0Y2ggKGFyZ3Mua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLZXlzLlNwYWNlOlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuS2V5QTpcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5jdHJsS2V5ICYmIHRoaXMuc2VsZWN0aW9uU2VydmljZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnRvZ2dsZUFsbCh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuQXJyb3dEb3duOlxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdGhpcy5jdXJzb3IubW92ZURvd24oc3RlcCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ICYmIGFyZ3Muc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93VXA6XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0aGlzLmN1cnNvci5tb3ZlVXAoc3RlcCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ICYmIGFyZ3Muc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkFycm93UmlnaHQ6XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGF0ZS5leHBhbmQocm93LmRhdGFJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdGhpcy5tb3ZlQ3Vyc29yRndkKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCAmJiBhcmdzLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2V5cy5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGF0ZS5jb2xsYXBzZShyb3cuZGF0YUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0aGlzLm1vdmVDdXJzb3JCd2QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ICYmIGFyZ3Muc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLlBhZ2VEb3duOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmlzVmlydHVhbCAmJiB0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0SXRlbUluZGV4ID0gdGhpcy5tZXRhLmhlYWRlclJvd3MgKyB0aGlzLnZpZXdwb3J0Lmxhc3RJdGVtSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBuZXh0SXRlbUluZGV4ID0gTWF0aC5taW4odGhpcy5tZXRhLm1heExvZ2ljYWxSb3dJbmRleCwgbmV4dEl0ZW1JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KG5leHRJdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWV0YWRhdGEuaGFzUGFnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLnBhZ2VyQ29udGV4dFNlcnZpY2UubmV4dFBhZ2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtleXMuUGFnZVVwOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmlzVmlydHVhbCAmJiB0aGlzLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2aWV3cG9ydFNpemUgPSB0aGlzLnZpZXdwb3J0Lmxhc3RJdGVtSW5kZXggLSB0aGlzLnZpZXdwb3J0LmZpcnN0SXRlbUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RJdGVtSW5kZXggPSB0aGlzLnZpZXdwb3J0LmZpcnN0SXRlbUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dEl0ZW1JbmRleCA9IE1hdGgubWF4KHRoaXMubWV0YS5oZWFkZXJSb3dzLCBmaXJzdEl0ZW1JbmRleCAtIHZpZXdwb3J0U2l6ZSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChuZXh0SXRlbUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1ldGFkYXRhLmhhc1BhZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5wYWdlckNvbnRleHRTZXJ2aWNlLnByZXZQYWdlKCkpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkhvbWU6XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGEuaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldCh0aGlzLm1ldGEuaGVhZGVyUm93cywgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQodGhpcy5tb2RlbC5maXJzdFJvdy5pbmRleCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChyb3cuaW5kZXgsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkVuZDpcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YS5pc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0Um93SW5kZXggPSB0aGlzLm1ldGEubWF4TG9naWNhbFJvd0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQobGFzdFJvd0luZGV4LCB0aGlzLmN1cnNvci5sYXN0Q2VsbEluZGV4KCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlc2V0KHRoaXMubW9kZWwubGFzdFJvdy5pbmRleCwgdGhpcy5jdXJzb3IubGFzdENlbGxJbmRleCgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMuY3Vyc29yLmxhc3RDZWxsSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMubW9kZWwuZmluZENlbGwobGFzdEluZGV4LCByb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQoY2VsbC5yb3dJbmRleCwgY2VsbC5jb2xJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZXNldChyb3cuaW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLZXlzLkVudGVyOlxuICAgICAgICAgICAgICAgIGlmICghYXJncy5jdHJsS2V5ICYmICFhcmdzLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRpbmcgPSB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZ0NlbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY3Vyc29yLmNlbGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWRpdGluZyAmJiBjZWxsLmV4cGFuZGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU3RhdGUudG9nZ2xlU3RhdGUocm93LmRhdGFJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRlckNlbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2VsbC5mb2N1c0dyb3VwLmlzTmF2aWdhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghYXJncy5jdHJsS2V5ICYmICFhcmdzLmFsdEtleSAmJiBpc1ByaW50YWJsZUNoYXJhY3RlcihhcmdzLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRlckNlbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBhcmdzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Db250ZW50S2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5vbkNlbGxLZXlkb3duKGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlybSA9ICFhcmdzLmRlZmF1bHRQcmV2ZW50ZWQgJiYgYXJncy5rZXlDb2RlID09PSBLZXlzLkVudGVyICYmIGlzVGV4dElucHV0KGFyZ3Muc3JjRWxlbWVudCk7XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRXNjYXBlIHx8IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5GMiB8fCBjb25maXJtKSB7XG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2VsbCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQoKTtcbiAgICAgICAgICAgIGFyZ3Muc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOYXZpZ2F0aW9uS2V5KGFyZ3Mua2V5Q29kZSkgJiYgdGhpcy5jdXJzb3IuY2VsbC5mb2N1c0dyb3VwLmlzTmF2aWdhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMub25DdXJzb3JLZXlkb3duKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGFyZ3MuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVDZWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DZWxsS2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZ0NlbGwoKSkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlybSA9IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5FbnRlcjtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9IGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5Fc2NhcGU7XG4gICAgICAgICAgICBjb25zdCBuYXZpZ2F0ZSA9IGlzTmF2aWdhdGlvbktleShhcmdzLmtleUNvZGUpO1xuICAgICAgICAgICAgaWYgKGNvbmZpcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuZWRpdFNlcnZpY2UuY2xvc2VDZWxsKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5jYW5jZWxDZWxsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhLnZpZXcudXBkYXRlRWRpdGVkU3RhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2VsbEtleWRvd24uZW1pdChhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9uQ3Vyc29yQ2hhbmdlcyhhcmdzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUm93SW5kZXggPSBhcmdzLnJvd0luZGV4O1xuICAgICAgICBjb25zdCBkYXRhUm93SW5kZXggPSB0aGlzLmFjdGl2ZURhdGFSb3c7XG4gICAgICAgIGlmICh0aGlzLm1ldGEgJiYgKHRoaXMubWV0YS5pc1ZpcnR1YWwgJiYgdGhpcy52aWV3cG9ydCAmJlxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnQuY29udGFpbnNSb3coZGF0YVJvd0luZGV4KSAmJiBkYXRhUm93SW5kZXggPiAtMSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVxdWVzdFNlcnZpY2Uuc2Nyb2xsVG8oeyByb3c6IGRhdGFSb3dJbmRleCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhLnZpcnR1YWxDb2x1bW5zICYmIGFyZ3MuY29sSW5kZXggPj0gdGhpcy5tZXRhLmNvbHVtbnMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLm1vZGVsLmNlbGxSYW5nZShjZWxsKTtcbiAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbENlbGwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghY2VsbCAmJiB0aGlzLm1vZGUgIT09IDAgLyogU3RhbmRieSAqLykgfHwgKGNlbGwgJiYgIXRoaXMuY29sdW1uVmlld3BvcnQuaW50ZXJzZWN0cyhzdGFydCwgZW5kKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFJlcXVlc3RTZXJ2aWNlLnNjcm9sbFRvKHsgY29sdW1uOiBhcmdzLmNvbEluZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uRm9jdXNPdXQoYXJncykge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKGFyZ3MudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gMCAvKiBTdGFuZGJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9jdXNlZCB0YXJnZXQgaXMgbm8gbG9uZ2VyIHZpc2libGUsXG4gICAgICAgICAgICAvLyByZXNldCB0byBjdXJzb3IgbW9kZSBhbmQgcmVjYXB0dXJlIGZvY3VzLlxuICAgICAgICAgICAgdGhpcy5tb2RlID0gMSAvKiBDdXJzb3IgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlRWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5jdXJzb3IuYW5ub3VuY2UoKTtcbiAgICB9XG4gICAgb25XaW5kb3dCbHVyKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSAwIC8qIFN0YW5kYnkgKi87XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUVsZW1lbnRzKCk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmFubm91bmNlKCk7XG4gICAgfVxuICAgIG9uS2V5ZG93bihhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IDEgLyogQ3Vyc29yICovKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ3Vyc29yS2V5ZG93bihhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IDIgLyogQ29udGVudCAqLykge1xuICAgICAgICAgICAgdGhpcy5vbkNvbnRlbnRLZXlkb3duKGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uVGFib3V0KCkge1xuICAgICAgICAvLyBUYWJiZWQgb3V0IG9mIHRoZSBsYXN0IGZvY3VzYWJsZSBjb250ZW50IGVsZW1lbnRcbiAgICAgICAgLy8gcmVzZXQgdG8gY3Vyc29yIG1vZGUgYW5kIHJlY2FwdHVyZSBmb2N1cy5cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yLmNlbGwuZm9jdXNHcm91cC5pc05hdmlnYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBVbmxlc3MgdGhlIGNlbGwgaGFzIGEgc2luZ2xlIGZvY3VzYWJsZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlJ2QgcmV0dXJuIHRvIENvbnRlbnQgbW9kZSBhbmQgZW50ZXIgYW4gZW5kbGVzcyBsb29wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWF2ZUNlbGwoKTtcbiAgICAgICAgdGhpcy5jdXJzb3IucmVzZXQoKTtcbiAgICB9XG59XG5OYXZpZ2F0aW9uU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTmF2aWdhdGlvblNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IERvbUV2ZW50c1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFBhZ2VyQ29udGV4dFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNjcm9sbFJlcXVlc3RTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBGb2N1c1Jvb3QgfSxcbiAgICB7IHR5cGU6IEVkaXRTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFeHBhbmRTdGF0ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNlbGVjdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBGb2N1c2FibGVEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOYXZpZ2F0aW9uTWV0YWRhdGEge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhlYWRlclJvd3MsIGlzVmlydHVhbCwgaGFzUGFnZXIsIHRyZWVsaXN0RWxlbWVudCwgdmlydHVhbENvbHVtbnMsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oZWFkZXJSb3dzID0gaGVhZGVyUm93cztcbiAgICAgICAgdGhpcy5pc1ZpcnR1YWwgPSBpc1ZpcnR1YWw7XG4gICAgICAgIHRoaXMuaGFzUGFnZXIgPSBoYXNQYWdlcjtcbiAgICAgICAgdGhpcy50cmVlbGlzdEVsZW1lbnQgPSB0cmVlbGlzdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlydHVhbENvbHVtbnMgPSB2aXJ0dWFsQ29sdW1ucztcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICB9XG4gICAgZ2V0IG1heExvZ2ljYWxSb3dJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyUm93cyArIHRoaXMuZGF0YVJvd3MgLSAxO1xuICAgIH1cbiAgICBnZXQgZGF0YVJvd3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcudG90YWxSb3dzO1xuICAgIH1cbn1cblxuLy8gSW5jcmVtZW50ZWQgZWFjaCB0aW1lIHRoZSBzZXJ2aWNlIGlzIGluc3RhbnRpYXRlZC5cbmxldCBzZXF1ZW5jZSA9IDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSWRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBgay10cmVlbGlzdCR7c2VxdWVuY2UrK31gO1xuICAgIH1cbiAgICBjZWxsSWQocm93SW5kZXgsIGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0tciR7cm93SW5kZXh9YyR7Y29sSW5kZXh9YDtcbiAgICB9XG59XG5JZFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbklkU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtdO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sdW1uSW5mb1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubG9ja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbHVtblJhbmdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbHVtbnNDb250YWluZXIgPSBuZXcgQ29sdW1uc0NvbnRhaW5lcigoKSA9PiBbXSk7XG4gICAgfVxuICAgIGdldCBsb2NrZWRMZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5sb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IG5vbkxvY2tlZExlYWZDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zQ29udGFpbmVyLm5vbkxvY2tlZExlYWZDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCB0b3RhbExldmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci50b3RhbExldmVscztcbiAgICB9XG4gICAgZ2V0IGxlYWZOYW1lZENvbHVtbnMoKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBleHBhbmRDb2x1bW5zKHRoaXMubGlzdCgpLmZpbHRlclNvcnQoY29sdW1uID0+ICFjb2x1bW4uaXNDb2x1bW5Hcm91cCkpXG4gICAgICAgICAgICAuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4ubWF0Y2hlc01lZGlhICYmIGNvbHVtbi5kaXNwbGF5VGl0bGUpO1xuICAgICAgICByZXR1cm4gb3JkZXJCeShjb2x1bW5zLCBbeyBmaWVsZDogJ2xvY2tlZCcsIGRpcjogJ2Rlc2MnIH1dKTtcbiAgICB9XG4gICAgZ2V0IHVubG9ja2VkUm9vdENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0KCkucm9vdENvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4ubG9ja2VkICYmIGNvbHVtbi5pc1Zpc2libGUpLmxlbmd0aDtcbiAgICB9XG4gICAgaW5pdChjb2x1bW5zLCBsaXN0KSB7XG4gICAgICAgIHRoaXMuY29sdW1uc0NvbnRhaW5lciA9IGNvbHVtbnM7XG4gICAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgfVxuICAgIGNoYW5nZVZpc2liaWxpdHkoY29sdW1ucykge1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2UuZW1pdChjb2x1bW5zKTtcbiAgICB9XG4gICAgY2hhbmdlTG9ja2VkKGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5sb2NrZWRDaGFuZ2UuZW1pdChjb2x1bW5zKTtcbiAgICB9XG59XG5Db2x1bW5JbmZvU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNvcnRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgc29ydCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh2YWx1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBjb2x1bW5WaXNpYmlsaXR5Q2hhbmdlYCBldmVudC5cbiAqL1xuY2xhc3MgQ29sdW1uVmlzaWJpbGl0eUNoYW5nZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29sdW1ucykge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgY29sdW1uTG9ja2VkQ2hhbmdlYCBldmVudC5cbiAqL1xuY2xhc3MgQ29sdW1uTG9ja2VkQ2hhbmdlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRyYWNrQnkoaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS50eXBlID09PSAnZGF0YScgJiYgaXRlbS5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9jYWxFZGl0U2VydmljZSB7XG4gICAgY3JlYXRlKF9pdGVtLCBfcGFyZW50LCBfaWQpIHtcbiAgICAgICAgdGhpcy50aHJvd1Vuc3VwcG9ydGVkRXJyb3IoKTtcbiAgICB9XG4gICAgdXBkYXRlKF9pdGVtKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgcmVtb3ZlKF9pdGVtKSB7XG4gICAgICAgIHRoaXMudGhyb3dVbnN1cHBvcnRlZEVycm9yKCk7XG4gICAgfVxuICAgIGFzc2lnblZhbHVlcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKTtcbiAgICB9XG4gICAgdGhyb3dVbnN1cHBvcnRlZEVycm9yKCkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZWRpdCBzZXJ2aWNlIG9mIHRoZSBlZGl0aW5nIGRpcmVjdGl2ZXMgY2FuIG9ubHkgdXBkYXRlIHRoZSBpdGVtcy4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHByb3ZpZGUgYW4gZWRpdFNlcnZpY2UuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMb2NhbERhdGFDaGFuZ2VzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG59XG5Mb2NhbERhdGFDaGFuZ2VzU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuY29uc3QgY3JlYXRlQ29udHJvbCA9IChzb3VyY2UpID0+IChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gbmV3IEZvcm1Db250cm9sKHNvdXJjZVtrZXldKTtcbiAgICByZXR1cm4gYWNjO1xufTtcbmNvbnN0IHZhbGlkYXRlQ29sdW1uc0ZpZWxkID0gKGNvbHVtbnMpID0+IGV4cGFuZENvbHVtbnMoY29sdW1ucy50b0FycmF5KCkpXG4gICAgLmZpbHRlcihpc0NvbHVtbkNvbXBvbmVudClcbiAgICAuZmlsdGVyKCh7IGZpZWxkIH0pID0+ICFpc1ZhbGlkRmllbGROYW1lKGZpZWxkKSlcbiAgICAuZm9yRWFjaCgoeyBmaWVsZCB9KSA9PiBjb25zb2xlLndhcm4oYFxuICAgICAgICAgICAgICAgIFRyZWVMaXN0IGNvbHVtbiBmaWVsZCBuYW1lICcke2ZpZWxkfScgZG9lcyBub3QgbG9vayBsaWtlIGEgdmFsaWQgSmF2YVNjcmlwdCBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgIElkZW50aWZpZXJzIGNhbiBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgKGluY2x1ZGluZyBcIiRcIiBvciBcIl9cIiksIGFuZCBtYXkgbm90IHN0YXJ0IHdpdGggYSBkaWdpdC5cbiAgICAgICAgICAgICAgICBQbGVhc2UgdXNlIG9ubHkgdmFsaWQgaWRlbnRpZmllciBuYW1lcyB0byBlbnN1cmUgZXJyb3ItZnJlZSBvcGVyYXRpb24uXG4gICAgICAgICAgICBgKSk7XG5jb25zdCBpc0luRWRpdGVkQ2VsbCA9IChlbGVtZW50LCB0cmVlbGlzdEVsZW1lbnQpID0+IGNsb3Nlc3QoZWxlbWVudCwgbWF0Y2hlc0NsYXNzZXMoJ2stZ3JpZC1lZGl0LWNlbGwnKSkgJiZcbiAgICBjbG9zZXN0KGVsZW1lbnQsIG1hdGNoZXNOb2RlTmFtZSgna2VuZG8tdHJlZWxpc3QnKSkgPT09IHRyZWVsaXN0RWxlbWVudDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgS2VuZG8gVUkgVHJlZUxpc3QgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjQ3MCAlfVxuICogeyUgZW1iZWRfZmlsZSBkYXRhLWJpbmRpbmcvZmxhdC9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2VtcGxveWVlcy50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBUcmVlTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3VwcG9ydFNlcnZpY2UsIHdyYXBwZXIsIGNoYW5nZU5vdGlmaWNhdGlvbiwgZWRpdFNlcnZpY2UsIGZpbHRlclNlcnZpY2UsIHBkZlNlcnZpY2UsIHJlc3BvbnNpdmVTZXJ2aWNlLCByZW5kZXJlciwgZXhjZWxTZXJ2aWNlLCBuZ1pvbmUsIHNjcm9sbFN5bmNTZXJ2aWNlLCBkb21FdmVudHMsIGNvbHVtblJlc2l6aW5nU2VydmljZSwgY2hhbmdlRGV0ZWN0b3JSZWYsIGNvbHVtblJlb3JkZXJTZXJ2aWNlLCBjb2x1bW5JbmZvU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIHNvcnRTZXJ2aWNlLCBzY3JvbGxSZXF1ZXN0U2VydmljZSwgZXhwYW5kU3RhdGVTZXJ2aWNlLCBvcHRpb25DaGFuZ2VzLCBzZWxlY3Rpb25TZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5zdXBwb3J0U2VydmljZSA9IHN1cHBvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLmNoYW5nZU5vdGlmaWNhdGlvbiA9IGNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZSA9IGVkaXRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UgPSBmaWx0ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnBkZlNlcnZpY2UgPSBwZGZTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVTZXJ2aWNlID0gcmVzcG9uc2l2ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5leGNlbFNlcnZpY2UgPSBleGNlbFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnNjcm9sbFN5bmNTZXJ2aWNlID0gc2Nyb2xsU3luY1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzID0gZG9tRXZlbnRzO1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZSA9IGNvbHVtblJlc2l6aW5nU2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmNvbHVtblJlb3JkZXJTZXJ2aWNlID0gY29sdW1uUmVvcmRlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnNvcnRTZXJ2aWNlID0gc29ydFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVxdWVzdFNlcnZpY2UgPSBzY3JvbGxSZXF1ZXN0U2VydmljZTtcbiAgICAgICAgdGhpcy5leHBhbmRTdGF0ZVNlcnZpY2UgPSBleHBhbmRTdGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMub3B0aW9uQ2hhbmdlcyA9IG9wdGlvbkNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBwYWdlIHNpemUgdXNlZCBieSB0aGUgVHJlZUxpc3Qgd2hlbiBbcGFnaW5nXSh7JSBzbHVnIHBhZ2luZ190cmVlbGlzdCAlfSkgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZVNpemUgPSAxMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHNjcm9sbCBtb2RlIHVzZWQgYnkgdGhlIFRyZWVMaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAgICAgKiAgLSBgbm9uZWAmbWRhc2g7UmVuZGVycyBubyBzY3JvbGxiYXIuXG4gICAgICAgICAqICAtIGBzY3JvbGxhYmxlYCZtZGFzaDtUaGUgZGVmYXVsdCBzY3JvbGwgbW9kZS4gSXQgcmVxdWlyZXMgdGhlIHNldHRpbmcgb2YgdGhlIGBoZWlnaHRgIG9wdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZSA9ICdzY3JvbGxhYmxlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGhvdyB0byB0cmFjayBjaGFuZ2VzIGZvciB0aGUgZGF0YSByb3dzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgVHJlZUxpc3QgdHJhY2tzIGNoYW5nZXMgYnkgdGhlIGluZGV4IG9mIHRoZSBkYXRhIGl0ZW0uXG4gICAgICAgICAqIEVkaXRlZCByb3dzIGFyZSB0cmFja2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgICogSW4gc29tZSBjYXNlcywgeW91IG1pZ2h0IG5lZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3IsXG4gICAgICAgICAqIGZvciBleGFtcGxlLCB3aGVuIHlvdSBpbXBsZW1lbnQgZWRpdGluZyB3aXRoIGltbXV0YWJsZSBkYXRhIGl0ZW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVtb25zdHJhdGVzIGhvdyB0byB0cmFjayBpdGVtcyBvbmx5IGJ5IGluZGV4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgICAgICogaW1wb3J0IHsgVHJlZUxpc3RJdGVtIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZWxpc3QnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICogICAgICAgIDxrZW5kby10cmVlbGlzdCBbZGF0YV09XCJ0cmVlbGlzdERhdGFcIiBbdHJhY2tCeV09XCJ0cmFja0J5XCI+XG4gICAgICAgICAqICAgICAgICA8L2tlbmRvLXRyZWVsaXN0PlxuICAgICAgICAgKiAgICBgXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgIHB1YmxpYyB0cmVlbGlzdERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIHB1YmxpYyB0cmFja0J5KGluZGV4OiBudW1iZXIsIGl0ZW06IFRyZWVMaXN0SXRlbSk6IGFueSB7XG4gICAgICAgICAqICAgICAgICBjb25zb2xlLmxvZyhpdGVtKTtcbiAgICAgICAgICogICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICogICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAgICAgICAgICogICAgXCJQcm9kdWN0SURcIjogMSxcbiAgICAgICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgICAgICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAgICAgICAgICogICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICAgICAgICAgKiAgfSwge1xuICAgICAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICAgICAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAgICAgICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgICAgICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAgICAgICAgICogIH1cbiAgICAgICAgICogXTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrQnkgPSBkZWZhdWx0VHJhY2tCeTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB0cmVlbGlzdCB3aWxsIHJlbmRlciBvbmx5IHRoZSBjb2x1bW5zIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXJ0dWFsQ29sdW1ucyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyB0aGUgW2ZpbHRlcmluZ10oeyUgc2x1ZyBmaWx0ZXJpbmdfdHJlZWxpc3QgJX0pIG9mIHRoZSBUcmVlTGlzdCBjb2x1bW5zIHRoYXQgaGF2ZSB0aGVpciBgZmllbGRgIG9wdGlvbiBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIFtzb3J0aW5nXSh7JSBzbHVnIHNvcnRpbmdfdHJlZWxpc3QgJX0pIG9mIHRoZSBUcmVlTGlzdCBjb2x1bW5zIHRoYXQgaGF2ZSB0aGVpciBgZmllbGRgIG9wdGlvbiBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSBwYWdlciBvZiB0aGUgVHJlZUxpc3QgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwYWdpbmdfdHJlZWxpc3QgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgICAgICogLSBgYnV0dG9uQ291bnQ6IE51bWJlcmAmbWRhc2g7U2V0cyB0aGUgbWF4aW11bSBudW1lcmljIGJ1dHRvbnMgY291bnQgYmVmb3JlIHRoZSBidXR0b25zIGFyZSBjb2xsYXBzZWQuXG4gICAgICAgICAqIC0gYGluZm86IEJvb2xlYW5gJm1kYXNoO1RvZ2dsZXMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHBhZ2UgYW5kIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkcy5cbiAgICAgICAgICogLSBgdHlwZTogUGFnZXJUeXBlYCZtZGFzaDtBY2NlcHRzIHRoZSBgbnVtZXJpY2AgKGJ1dHRvbnMgd2l0aCBudW1iZXJzKSBhbmQgYGlucHV0YCAoaW5wdXQgZm9yIHR5cGluZyB0aGUgcGFnZSBudW1iZXIpIHZhbHVlcy5cbiAgICAgICAgICogLSBgcGFnZVNpemVzOiBCb29sZWFuYCBvciBgQXJyYXk8bnVtYmVyPmAmbWRhc2g7U2hvd3MgYSBtZW51IGZvciBzZWxlY3RpbmcgdGhlIHBhZ2Ugc2l6ZS5cbiAgICAgICAgICogLSBgcHJldmlvdXNOZXh0OiBCb29sZWFuYCZtZGFzaDtUb2dnbGVzIHRoZSAqKlByZXZpb3VzKiogYW5kICoqTmV4dCoqIGJ1dHRvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2VhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGUgdXNlciBjYW4gdXNlIGRlZGljYXRlZCBzaG9ydGN1dHMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVHJlZUxpc3QuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIG5hdmlnYXRpb24gaXMgZGlzYWJsZWQgYW5kIHRoZSBUcmVlTGlzdCBjb250ZW50IGlzIGFjY2Vzc2libGUgaW4gdGhlIG5vcm1hbCB0YWIgc2VxdWVuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIFRyZWVMaXN0IGNvbHVtbnMgd2lsbCBiZSByZXNpemVkIGR1cmluZyBpbml0aWFsaXphdGlvbiBzbyB0aGF0XG4gICAgICAgICAqIHRoZXkgZml0IHRoZWlyIGhlYWRlcnMgYW5kIHJvdyBjb250ZW50LiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKiBDb2x1bW5zIHdpdGggYGF1dG9TaXplYCBzZXQgdG8gYGZhbHNlYCBhcmUgZXhjbHVkZWQuXG4gICAgICAgICAqIFRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgY29sdW1uIHdpZHRoIHRvIG1hdGNoIHRoZSBuZXcgY29udGVudCxcbiAgICAgICAgICogcmVmZXIgdG8gW3RoaXMgZXhhbXBsZV0oeyUgc2x1ZyByZXNpemluZ19jb2x1bW5zX3RyZWVsaXN0ICV9KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1NpemUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSB1c2VyIGNhbiByZXNpemUgY29sdW1ucyBieSBkcmFnZ2luZyB0aGUgZWRnZXMgKHJlc2l6ZSBoYW5kbGVzKSBvZiB0aGVpciBoZWFkZXIgY2VsbHNcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZXNpemluZ19jb2x1bW5zX3RyZWVsaXN0ICV9KSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHVzZXIgY2FuIHJlb3JkZXIgY29sdW1ucyBieSBkcmFnZ2luZyB0aGVpciBoZWFkZXIgY2VsbHNcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZW9yZGVyaW5nX2NvbHVtbnNfdHJlZWxpc3QgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVvcmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgbG9hZGluZyBpbmRpY2F0b3Igb2YgdGhlIFRyZWVMaXN0IHdpbGwgYmUgZGlzcGxheWVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZWxpc3QgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBjb2x1bW4gbWVudSBvZiB0aGUgY29sdW1ucyB3aWxsIGJlIGRpc3BsYXllZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbm1lbnVfdHJlZWxpc3QgJX0pKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1uTWVudSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIHRoZSBoZWFkZXIgb2YgdGhlIHRyZWVsaXN0IHdpbGwgYmUgaGlkZGVuLiBUaGUgaGVhZGVyIGlzIHZpc2libGUgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBUaGUgaGVhZGVyIGluY2x1ZGVzIGNvbHVtbiBoZWFkZXJzIGFuZCB0aGUgW2ZpbHRlciByb3ddKHslIHNsdWcgZmlsdGVyaW5nX3RyZWVsaXN0ICV9I3RvYy1maWx0ZXItcm93KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGlkZUhlYWRlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgVHJlZUxpc3Qgc2VsZWN0aW9uIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIFRyZWVMaXN0IGZpbHRlciBpcyBtb2RpZmllZCB0aHJvdWdoIHRoZSBVSS5cbiAgICAgICAgICogWW91IGhhdmUgdG8gaGFuZGxlIHRoZSBldmVudCB5b3Vyc2VsZiBhbmQgZmlsdGVyIHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYWdlIG9mIHRoZSBUcmVlTGlzdCBpcyBjaGFuZ2VkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFnaW5nX3RyZWVsaXN0ICV9KSkuXG4gICAgICAgICAqIFlvdSBoYXZlIHRvIGhhbmRsZSB0aGUgZXZlbnQgeW91cnNlbGYgYW5kIHBhZ2UgdGhlIGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzb3J0aW5nIG9mIHRoZSBUcmVlTGlzdCBpcyBjaGFuZ2VkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc29ydGluZ190cmVlbGlzdCAlfSkpLlxuICAgICAgICAgKiBZb3UgaGF2ZSB0byBoYW5kbGUgdGhlIGV2ZW50IHlvdXJzZWxmIGFuZCBzb3J0IHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZGF0YSBzdGF0ZSBvZiB0aGUgVHJlZUxpc3QgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqRWRpdCoqIGNvbW1hbmQgYnV0dG9uIHRvIGVkaXQgYSByb3dcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX3RyZWVsaXN0ICV9I3RvYy1lZGl0aW5nLXJlY29yZHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKkNhbmNlbCoqIGNvbW1hbmQgYnV0dG9uIHRvIGNsb3NlIGEgcm93XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2MtY2FuY2VsbGluZy1lZGl0aW5nKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKlNhdmUqKiBjb21tYW5kIGJ1dHRvbiB0byBzYXZlIGNoYW5nZXMgaW4gYSByb3dcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX3RyZWVsaXN0ICV9I3RvYy1zYXZpbmctcmVjb3JkcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqUmVtb3ZlKiogY29tbWFuZCBidXR0b24gdG8gcmVtb3ZlIGEgcm93XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2MtcmVtb3ZpbmctcmVjb3JkcykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgKipBZGQqKiBjb21tYW5kIGJ1dHRvbiB0byBhZGQgYSBuZXcgcm93XG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ190ZW1wbGF0ZV9mb3Jtc190cmVlbGlzdCAlfSN0b2MtYWRkaW5nLXJlY29yZHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBsZWF2ZXMgYW4gZWRpdGVkIGNlbGwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2luY2VsbF90cmVlbGlzdCAlfSN0b2MtYmFzaWMtY29uY2VwdHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2VsbENsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBjZWxsIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZWRpdGluZ19pbmNlbGxfdHJlZWxpc3QgJX0jdG9jLWJhc2ljLWNvbmNlcHRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbGxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSAqKkV4cG9ydCB0byBQREYqKiBjb21tYW5kIGJ1dHRvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGRmRXhwb3J0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlICoqRXhwb3J0IHRvIEV4Y2VsKiogY29tbWFuZCBidXR0b24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4Y2VsRXhwb3J0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIHJlc2l6aW5nIG9mIHRoZSBjb2x1bW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSByZW9yZGVyaW5nIG9mIHRoZSBjb2x1bW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtblJlb3JkZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbHVtbnMgZnJvbSB0aGUgY29sdW1uIG1lbnUgb3IgY29sdW1uIGNob29zZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtblZpc2liaWxpdHlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGxvY2tlZCBzdGF0ZSBvZiB0aGUgY29sdW1ucyBmcm9tIHRoZSBjb2x1bW4gbWVudSBvciBieSByZW9yZGVyaW5nIHRoZSBjb2x1bW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5Mb2NrZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgdG8gdGhlIGxhc3QgcmVjb3JkIG9uIHRoZSBwYWdlIGFuZCBlbmFibGVzIGVuZGxlc3Mgc2Nyb2xsaW5nXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2Nyb2xsbW1vZGVzX3RyZWVsaXN0ICV9I3RvYy1lbmRsZXNzLXNjcm9sbGluZykpLlxuICAgICAgICAgKiBZb3UgaGF2ZSB0byBoYW5kbGUgdGhlIGV2ZW50IHlvdXJzZWxmIGFuZCBwYWdlIHRoZSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JvbGxCb3R0b20gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0cmVlbGlzdCBjb250ZW50IGlzIHNjcm9sbGVkLlxuICAgICAgICAgKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmUuIEVudGVyIHRoZSBBbmd1bGFyIHpvbmUgaWYgeW91IG1ha2UgYW55IGNoYW5nZXMgdGhhdCByZXF1aXJlIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRlbnRTY3JvbGwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGFuIGl0ZW0gaXMgZXhwYW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZEV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhbiBpdGVtIGlzIGNvbGxhcHNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2VFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbk9yZGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBxdWVyeSBsaXN0IG9mIGFsbCBkZWNsYXJlZCBjb2x1bW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLmZvb3RlciA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyID0gbmV3IENvbHVtbnNDb250YWluZXIoKCkgPT4gdGhpcy5jb2x1bW5MaXN0LmZpbHRlckhpZXJhcmNoeShjb2x1bW4gPT4ge1xuICAgICAgICAgICAgY29sdW1uLm1hdGNoZXNNZWRpYSA9IHRoaXMubWF0Y2hlc01lZGlhKGNvbHVtbik7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmlzVmlzaWJsZTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmlkR2V0dGVyID0gZ2V0dGVyKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMubG9jYWxFZGl0U2VydmljZSA9IG5ldyBMb2NhbEVkaXRTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBWaWV3Q29sbGVjdGlvbih0aGlzLnZpZXdGaWVsZEFjY2Vzc29yLmJpbmQodGhpcyksIHRoaXMuZXhwYW5kU3RhdGVTZXJ2aWNlLCB0aGlzLmVkaXRTZXJ2aWNlLCB0aGlzLnNlbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gKCgpID0+IGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnJ0bCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZEdlbmVyYXRlQ29sdW1ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fc29ydCA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl9za2lwID0gMDtcbiAgICAgICAgdGhpcy5jYWNoZWRXaW5kb3dXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3Jvd0NsYXNzID0gKCkgPT4gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChsb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKHsgcnRsIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMucnRsID0gcnRsO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmluaXQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMuc2VsZWN0aW9uQ2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3Muc2VuZGVyID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnVwZGF0ZVNlbGVjdGVkU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmluaXQodGhpcy5jb2x1bW5zQ29udGFpbmVyLCAoKSA9PiB0aGlzLmNvbHVtbkxpc3QpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY29sdW1uSW5mb1NlcnZpY2UudmlzaWJpbGl0eUNoYW5nZS5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uVmlzaWJpbGl0eUNoYW5nZS5lbWl0KG5ldyBDb2x1bW5WaXNpYmlsaXR5Q2hhbmdlRXZlbnQoY2hhbmdlZCkpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuY29sdW1uSW5mb1NlcnZpY2UubG9ja2VkQ2hhbmdlLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5Mb2NrZWRDaGFuZ2UuZW1pdChuZXcgQ29sdW1uTG9ja2VkQ2hhbmdlRXZlbnQoY2hhbmdlZCkpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKG1lcmdlKHRoaXMub3B0aW9uQ2hhbmdlcy5jb2x1bW5zLCB0aGlzLm9wdGlvbkNoYW5nZXMub3B0aW9ucykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmZpbHRlclNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoeCA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNoYW5nZS5lbWl0KHgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5zb3J0U2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh4ID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ydENoYW5nZS5lbWl0KHgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuYXR0YWNoU3RhdGVDaGFuZ2VzRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmF0dGFjaEVkaXRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmF0dGFjaERvbUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnBkZlNlcnZpY2UuZXhwb3J0Q2xpY2suc3Vic2NyaWJlKHRoaXMuZW1pdFBERkV4cG9ydEV2ZW50LmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmV4Y2VsU2VydmljZS5leHBvcnRDbGljay5zdWJzY3JpYmUodGhpcy5zYXZlQXNFeGNlbC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5leGNlbFNlcnZpY2UubG9hZGluZ0NoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ29udGFpbmVyQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29sdW1uUmVzaXplKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTGlzdCA9IG5ldyBDb2x1bW5MaXN0KHRoaXMuY29sdW1ucyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5jb2x1bW5SZW9yZGVyU2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMucmVvcmRlci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5jb2x1bW5JbmZvU2VydmljZS5jb2x1bW5SYW5nZUNoYW5nZS5zdWJzY3JpYmUodGhpcy5vbkNvbHVtblJhbmdlQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmV4cGFuZFN0YXRlU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3MuZXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRFdmVudC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUV2ZW50LmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU3RhdGVDaGFuZ2UuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudmlldy5jaGlsZHJlbkxvYWRlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnZpZXcucmVzZXRQYWdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwID4gMCAmJiBoYXNPYnNlcnZlcnModGhpcy5wYWdlQ2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHRoaW5rIHRoZXJlIGlzIGEgd2F5IHRvIGF2b2lkIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBldmVyeSBjYWxsYmFjayBpbiB3aGljaCB0aGUgdmlldyBjYW4gYmUgY29tcHV0ZWQgaXMgYWxyZWFkeSBwYXNzZWQgdGhlIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRpbmcgdGhlIGN1cnJlbnQgcGFnZSBpbiBhZHZhbmNlIGFsc28gZG9lcyBub3Qgc2VlbSBmZWFzaWJsZSBmb3Igc3VjaCBhIHJhcmUgY2FzZVxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUNoYW5nZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQoeyBza2lwOiAwLCB0YWtlOiB0aGlzLnBhZ2VTaXplIH0pO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmRhdGFMb2FkZWQgPSB0aGlzLmRhdGFMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZS5pZEdldHRlciA9IHRoaXMuaWRHZXR0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGEgb2YgdGhlIFRyZWVMaXN0LiBJZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgdGhlIFRyZWVMaXN0IGF1dG9tYXRpY2FsbHkgZ2V0cyB0aGUgdG90YWwgY291bnRcbiAgICAgKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXcucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvYWRlZERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRGF0YUxvYWRlZCgpO1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhTG9hZGVkU3Vic2NyaXB0aW9uID0gdmFsdWUuc3Vic2NyaWJlKHRoaXMuZGF0YUxvYWRlZCk7IC8vIGhhbmRsZSBlcnJvclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhTG9hZGVkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMgdG8gYmUgc2tpcHBlZCBieSB0aGUgcGFnZXIuXG4gICAgICogUmVxdWlyZWQgYnkgdGhlIFtwYWdpbmddKHslIHNsdWcgcGFnaW5nX3RyZWVsaXN0ICV9KSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIGdldCBza2lwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2tpcDtcbiAgICB9XG4gICAgc2V0IHNraXAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NraXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudmlldy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdG9ycyBieSB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIHNvcnRlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNvcnRpbmdfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgc29ydCh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc29ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd1RvcFRvb2xiYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xiYXJUZW1wbGF0ZSAmJiBbJ3RvcCcsICdib3RoJ10uaW5kZXhPZih0aGlzLnRvb2xiYXJUZW1wbGF0ZS5wb3NpdGlvbikgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzaG93Qm90dG9tVG9vbGJhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhclRlbXBsYXRlICYmIFsnYm90dG9tJywgJ2JvdGgnXS5pbmRleE9mKHRoaXMudG9vbGJhclRlbXBsYXRlLnBvc2l0aW9uKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHNob3dQYWdlcigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzVmlydHVhbCAmJiB0aGlzLnBhZ2VhYmxlICE9PSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG1hcnF1ZWVTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZW5hYmxlTWFycXVlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQW4gYWxpYXMgZm9yIGBuYXZpZ2FibGVgIGZvciB1c2VycyB3aG8gbWlncmF0ZSBmcm9tIEtlbmRvIFVJIGZvciBqUXVlcnkuXG4gICAgICovXG4gICAgc2V0IG5hdmlnYXRhYmxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubmF2aWdhYmxlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbmF2aWdhdGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgZm9yIGV2ZXJ5IGRhdGEgcm93IGluIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7IFJvd0NsYXNzQXJncyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXRyZWVsaXN0JztcbiAgICAgKlxuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgKiAgICBzdHlsZXM6IFtgXG4gICAgICogICAgICAgIC5rLXRyZWVsaXN0IHRyLmV2ZW4geyBiYWNrZ3JvdW5kLWNvbG9yOiAjZjQ1YzQyOyB9XG4gICAgICogICAgICAgIC5rLXRyZWVsaXN0IHRyLm9kZCB7IGJhY2tncm91bmQtY29sb3I6ICM0MWY0ZGY7IH1cbiAgICAgKiAgICBgXSxcbiAgICAgKiAgICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICAgICA8a2VuZG8tdHJlZWxpc3QgW2RhdGFdPVwidHJlZWxpc3REYXRhXCIgW3Jvd0NsYXNzXT1cInJvd0NhbGxiYWNrXCI+XG4gICAgICogICAgICAgIDwva2VuZG8tdHJlZWxpc3Q+XG4gICAgICogICAgYFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICBwdWJsaWMgdHJlZWxpc3REYXRhOiBhbnlbXSA9IHByb2R1Y3RzO1xuICAgICAqXG4gICAgICogICAgcHVibGljIHJvd0NhbGxiYWNrKGNvbnRleHQ6IFJvd0NsYXNzQXJncykge1xuICAgICAqICAgICAgICBjb25zdCBpc0V2ZW4gPSBjb250ZXh0LmluZGV4ICUgMiA9PSAwO1xuICAgICAqICAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgICAgZXZlbjogaXNFdmVuLFxuICAgICAqICAgICAgICAgICAgb2RkOiAhaXNFdmVuXG4gICAgICogICAgICAgIH07XG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IHByb2R1Y3RzID0gW3tcbiAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAxLFxuICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFpXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTguMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiB0cnVlXG4gICAgICogIH0sIHtcbiAgICAgKiAgICBcIlByb2R1Y3RJRFwiOiAyLFxuICAgICAqICAgIFwiUHJvZHVjdE5hbWVcIjogXCJDaGFuZ1wiLFxuICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE5LjAwMDAsXG4gICAgICogICAgXCJEaXNjb250aW51ZWRcIjogZmFsc2VcbiAgICAgKiAgfVxuICAgICAqIF07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHJvd0NsYXNzKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcm93Q2xhc3MgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShmbil9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvd0NsYXNzID0gZm47XG4gICAgfVxuICAgIGdldCByb3dDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0NsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBjZWxsIChpZiBhbnkpLlxuICAgICAqL1xuICAgIGdldCBhY3RpdmVDZWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmVDZWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgZm9jdXNlZCByb3cgKGlmIGFueSkuXG4gICAgICovXG4gICAgZ2V0IGFjdGl2ZVJvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWN0aXZlUm93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2hpY2ggY29udGFpbnMgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgXCJpZFwiXG4gICAgICovXG4gICAgc2V0IGlkRmllbGQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmlkR2V0dGVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlkR2V0dGVyID0gZ2V0dGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmlkR2V0dGVyID0gdGhpcy5pZEdldHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVkIHRoZSB0cmVlbGlzdCBzZWxlY3Rpb24gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0YWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2V0dGluZ3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBjYWxsYmFjayB0aGF0IGRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJvdyAvIGNlbGwgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2V0IGlzU2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpc1NlbGVjdGVkIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkIFwiJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNldHRpbmdzID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNldHRpbmdzO1xuICAgIH1cbiAgICBnZXQgZGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBsb2NrZWRDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgdmlydHVhbENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmlydHVhbDtcbiAgICB9XG4gICAgZ2V0IG5vU2Nyb2xsYmFyQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbGJhcldpZHRoID09PSAwO1xuICAgIH1cbiAgICBnZXQgbm9SZWNvcmRzVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21Ob1JlY29yZHNUZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbU5vUmVjb3Jkc1RlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vUmVjb3Jkc1RlbXBsYXRlQ2hpbGRyZW4gPyB0aGlzLm5vUmVjb3Jkc1RlbXBsYXRlQ2hpbGRyZW4uZmlyc3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldCBub1JlY29yZHNUZW1wbGF0ZShjdXN0b21Ob1JlY29yZHNUZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLl9jdXN0b21Ob1JlY29yZHNUZW1wbGF0ZSA9IGN1c3RvbU5vUmVjb3Jkc1RlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgcGFnZXJUZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1c3RvbVBhZ2VyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21QYWdlclRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VyVGVtcGxhdGVDaGlsZHJlbiA/IHRoaXMucGFnZXJUZW1wbGF0ZUNoaWxkcmVuLmZpcnN0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQgcGFnZXJUZW1wbGF0ZShjdXN0b21QYWdlclRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbVBhZ2VyVGVtcGxhdGUgPSBjdXN0b21QYWdlclRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgdG9vbGJhclRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VzdG9tVG9vbGJhclRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tVG9vbGJhclRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xiYXJUZW1wbGF0ZUNoaWxkcmVuID8gdGhpcy50b29sYmFyVGVtcGxhdGVDaGlsZHJlbi5maXJzdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0IHRvb2xiYXJUZW1wbGF0ZShjdXN0b21Ub29sYmFyVGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5fY3VzdG9tVG9vbGJhclRlbXBsYXRlID0gY3VzdG9tVG9vbGJhclRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRTZXJ2aWNlLnNjcm9sbGJhcldpZHRoO1xuICAgIH1cbiAgICBnZXQgaGVhZGVyUGFkZGluZygpIHtcbiAgICAgICAgaWYgKGlzVW5pdmVyc2FsKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBNYXRoLm1heCgwLCB0aGlzLnNjcm9sbGJhcldpZHRoIC0gMSkgKyAncHgnO1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucnRsID8gMCA6IHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnJ0bCA/IHBhZGRpbmcgOiAwO1xuICAgICAgICByZXR1cm4gYDAgJHtyaWdodH0gMCAke2xlZnR9YDtcbiAgICB9XG4gICAgZ2V0IHNob3dMb2FkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8IChpc09ic2VydmFibGUodGhpcy5fZGF0YSkgJiYgIXRoaXMubG9hZGVkRGF0YSkgfHwgdGhpcy5leGNlbFNlcnZpY2UubG9hZGluZztcbiAgICB9XG4gICAgZ2V0IHNob3dGb290ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIuaGFzRm9vdGVyO1xuICAgIH1cbiAgICBnZXQgYXJpYVJvd0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbENvbHVtbkxldmVscyArIDEgKyB0aGlzLnRvdGFsQ291bnQ7XG4gICAgfVxuICAgIGdldCBhcmlhQ29sQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubGVhZkNvbHVtbnNUb1JlbmRlci5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBhcmlhTXVsdGlzZWxlY3RhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZW5hYmxlTXVsdGlwbGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzVmlydHVhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsYWJsZSA9PT0gJ3ZpcnR1YWwnO1xuICAgIH1cbiAgICBnZXQgaXNTY3JvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxhYmxlICE9PSAnbm9uZSc7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5hbGxDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5sb2NrZWRDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgbm9uTG9ja2VkQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5ub25Mb2NrZWRDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgbG9ja2VkTGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIubG9ja2VkTGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGdldCBub25Mb2NrZWRMZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5ub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IGxlYWZDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zQ29udGFpbmVyLmxlYWZDb2x1bW5zO1xuICAgIH1cbiAgICBnZXQgdG90YWxDb2x1bW5MZXZlbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXIudG90YWxMZXZlbHM7XG4gICAgfVxuICAgIGdldCBoZWFkZXJDb2x1bW5zKCkge1xuICAgICAgICBpZiAodGhpcy52aXJ0dWFsQ29sdW1ucyAmJiAhdGhpcy5wZGZTZXJ2aWNlLmV4cG9ydGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vbkxvY2tlZENvbHVtbnM7XG4gICAgfVxuICAgIGdldCBoZWFkZXJMZWFmQ29sdW1ucygpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMgJiYgIXRoaXMucGRmU2VydmljZS5leHBvcnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlYWZWaWV3cG9ydENvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9uTG9ja2VkTGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGdldCBsb2NrZWRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbHVtbnModGhpcy5sb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCkpLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIChjdXJyLndpZHRoIHx8IDApLCAwKTtcbiAgICB9XG4gICAgZ2V0IG5vbkxvY2tlZFdpZHRoKCkge1xuICAgICAgICBpZiAoKCF0aGlzLnJ0bCAmJiB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCkgfHwgdGhpcy52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnZpcnR1YWxDb2x1bW5zID8gdGhpcy5jb2x1bW5zQ29udGFpbmVyLnVubG9ja2VkV2lkdGggOlxuICAgICAgICAgICAgICAgIHRoaXMubGVhZlZpZXdwb3J0Q29sdW1ucy5yZWR1Y2UoKGFjYywgY29sdW1uKSA9PiBhY2MgKyAoY29sdW1uLndpZHRoIHx8IDApLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgY29sdW1uTWVudVRlbXBsYXRlKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuY29sdW1uTWVudVRlbXBsYXRlcy5maXJzdDtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlID8gdGVtcGxhdGUudGVtcGxhdGVSZWYgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgdG90YWxDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy50b3RhbFJvd3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZXMgdGhlIGNoaWxkIG5vZGVzIGZvciBhIHBhcnRpY3VsYXIgbm9kZS5cbiAgICAgKi9cbiAgICBzZXQgZmV0Y2hDaGlsZHJlbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mZXRjaENoaWxkcmVuID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBmZXRjaENoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hDaGlsZHJlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyBpZiBhIHBhcnRpY3VsYXIgbm9kZSBoYXMgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgc2V0IGhhc0NoaWxkcmVuKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyBpZiBhIHBhcnRpY3VsYXIgaXRlbSBpcyBleHBhbmRlZC5cbiAgICAgKi9cbiAgICBzZXQgaXNFeHBhbmRlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmV4cGFuZFN0YXRlU2VydmljZS5pc0V4cGFuZGVkID0gdmFsdWUgfHwgZGVmYXVsdEV4cGFuZGVkO1xuICAgICAgICB0aGlzLmV4cGFuZEljb25zID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB2aWV3RmllbGRBY2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZldGNoQ2hpbGRyZW46IHRoaXMuZmV0Y2hDaGlsZHJlbixcbiAgICAgICAgICAgIGhhc0NoaWxkcmVuOiB0aGlzLmhhc0NoaWxkcmVuLFxuICAgICAgICAgICAgaWRHZXR0ZXI6IHRoaXMuaWRHZXR0ZXIsXG4gICAgICAgICAgICBza2lwOiB0aGlzLnNraXAsXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIHBhZ2VhYmxlOiB0aGlzLnBhZ2VhYmxlLFxuICAgICAgICAgICAgaXNWaXJ0dWFsOiB0aGlzLmlzVmlydHVhbCxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMubG9hZGVkRGF0YSxcbiAgICAgICAgICAgIGhhc0Zvb3RlcjogdGhpcy5jb2x1bW5zQ29udGFpbmVyLmhhc0Zvb3RlclxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25EYXRhQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmF1dG9HZW5lcmF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VOb3RpZmljYXRpb24ubm90aWZ5KCk7XG4gICAgICAgIHRoaXMucGRmU2VydmljZS5kYXRhQ2hhbmdlZC5lbWl0KCk7XG4gICAgICAgIHRoaXMudXBkYXRlTmF2aWdhdGlvbk1ldGFkYXRhKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoICYmIGFueUNoYW5nZWQoW1wicGFnZVNpemVcIiwgXCJza2lwXCIsIFwic29ydFwiXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTm90aWZpY2F0aW9uLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFtcInBhZ2VTaXplXCIsIFwic2Nyb2xsYWJsZVwiLCAndmlydHVhbENvbHVtbnMnXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTmF2aWdhdGlvbk1ldGFkYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcInZpcnR1YWxDb2x1bW5zXCIsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0Q29sdW1ucyA9IHRoaXMubGVhZlZpZXdwb3J0Q29sdW1ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcImhlaWdodFwiLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBgJHt0aGlzLmhlaWdodH1weGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NoYW5nZWQoXCJmaWx0ZXJhYmxlXCIsIGNoYW5nZXMpICYmIHRoaXMubG9ja2VkQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0hlYWRlckhlaWdodCh0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlZChbXCJjb2x1bW5NZW51XCIsIFwic29ydGFibGVcIiwgXCJmaWx0ZXJhYmxlXCJdLCBjaGFuZ2VzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTWVudU9wdGlvbnMgPSB0aGlzLmNvbHVtbk1lbnUgJiYgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBCb29sZWFuKHRoaXMuZmlsdGVyYWJsZSksXG4gICAgICAgICAgICAgICAgc29ydDogQm9vbGVhbih0aGlzLnNvcnRhYmxlKVxuICAgICAgICAgICAgfSwgdGhpcy5jb2x1bW5NZW51KTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTphbGlnblxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NoYW5nZWQoXCJzY3JvbGxhYmxlXCIsIGNoYW5nZXMpICYmIHRoaXMuaXNTY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5vblN0YWJsZS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmF0dGFjaFNjcm9sbFN5bmMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmF0dGFjaFNjcm9sbFN5bmMoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFbGVtZW50RXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZU5hdmlnYXRpb25NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmFwcGx5QXV0b1NpemUoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbnNDb250YWluZXIucmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnZlcmlmeVNldHRpbmdzKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zaG91bGRHZW5lcmF0ZUNvbHVtbnMgPSAhdGhpcy5jb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hdXRvR2VuZXJhdGVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTGlzdCA9IG5ldyBDb2x1bW5MaXN0KHRoaXMuY29sdW1ucyk7XG4gICAgICAgIC8vIGlzIHRoaXMgbmVlZGVkPyBhZnRlciBjb250ZW50IGNoZWNrZWQgYWxyZWFkeSBkb2VzIHRoaXNcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmNvbHVtbnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25DaGFuZ2VzLmNvbHVtbkNoYW5nZWQoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmluaXQodGhpcy5uYXZpZ2F0aW9uTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5kZXRhY2hFbGVtZW50RXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hFbGVtZW50RXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvY3VzRWxlbWVudFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRGF0YUxvYWRlZCgpO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG51bGw7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhZ2VDaGFuZ2VUaW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGF0dGFjaFNjcm9sbFN5bmMoKSB7XG4gICAgICAgIGlmIChpc1VuaXZlcnNhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN5bmNTZXJ2aWNlLnJlZ2lzdGVyRW1pdHRlcih0aGlzLmhlYWRlci5uYXRpdmVFbGVtZW50LCBcImhlYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb290ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQob2JzZXJ2ZSh0aGlzLmZvb3RlcilcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZvb3RlcnMgPT4gZm9vdGVyc1xuICAgICAgICAgICAgICAgIC5tYXAoZm9vdGVyID0+IGZvb3Rlci5uYXRpdmVFbGVtZW50KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXNQcmVzZW50KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gdGhpcy5zY3JvbGxTeW5jU2VydmljZS5yZWdpc3RlckVtaXR0ZXIoZWxlbWVudCwgXCJmb290ZXJcIikpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgdGhlIHNwZWNpZmllZCB0YWJsZSByb3cgaW4gdGhlIGVkaXQgbW9kZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfdHJlZWxpc3QgJX0jdG9jLWVkaXRpbmctcmVjb3JkcykpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIHJvdyBpbmRleCB0aGF0IHdpbGwgYmUgc3dpdGNoZWQgaW4gdGhlIGVkaXQgbW9kZS5cbiAgICAgKiBAcGFyYW0gZ3JvdXAgLSBUaGUgW2BGb3JtR3JvdXBgXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWydmb3JtZ3JvdXBhcGknXSB9fSlcbiAgICAgKiB0aGF0IGRlc2NyaWJlcyB0aGUgZWRpdCBmb3JtLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLiBVc2Ugc2tpcEZvY3VzIHRvIGRldGVybWluZSBpZiB0aGUgcm93J3MgZWRpdCBlbGVtZW50IHNob3VsZCBiZSBmb2N1c2VkLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqL1xuICAgIGVkaXRSb3coaXRlbSwgZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZS5lZGl0Um93KGl0ZW0sIGdyb3VwKTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZUVkaXRlZFN0YXRlKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2tpcEZvY3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2N1c0VkaXRFbGVtZW50KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgdHJbZGF0YS10cmVlbGlzdC12aWV3LWluZGV4PVwiJHt0aGlzLnZpZXcuaXRlbUluZGV4KGl0ZW0pfVwiXWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGVkaXRvciBmb3IgYSBnaXZlbiByb3cgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RlbXBsYXRlX2Zvcm1zX3RyZWVsaXN0ICV9I3RvYy1jYW5jZWxsaW5nLWVkaXRpbmcpKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSByb3cgaW5kZXggdGhhdCB3aWxsIGJlIHN3aXRjaGVkIG91dCBvZiB0aGUgZWRpdCBtb2RlLiBJZiBubyBpbmRleCBpcyBwcm92aWRlZCwgaXQgaXMgYXNzdW1lZFxuICAgICAqIHRoYXQgdGhlIG5ldyBpdGVtIGVkaXRvciB3aWxsIGJlIGNsb3NlZC5cbiAgICAgKi9cbiAgICBjbG9zZVJvdyhpdGVtLCBpc05ldykge1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNsb3NlKGl0ZW0sIGlzTmV3KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGVFZGl0ZWRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcm93IGVkaXRvciAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdGVtcGxhdGVfZm9ybXNfdHJlZWxpc3QgJX0jdG9jLWFkZGluZy1yZWNvcmRzKSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zvcm1Hcm91cH0gZ3JvdXAgLSBUaGUgW2BGb3JtR3JvdXBgXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWydmb3JtZ3JvdXBhcGknXSB9fSkgdGhhdCBkZXNjcmliZXNcbiAgICAgKiB0aGUgZWRpdCBmb3JtLiBJZiBjYWxsZWQgd2l0aCBhIGRhdGEgaXRlbSwgaXQgd2lsbCBidWlsZCB0aGUgYEZvcm1Hcm91cGAgZnJvbSB0aGUgZGF0YSBpdGVtIGZpZWxkcy5cbiAgICAgKi9cbiAgICBhZGRSb3coZ3JvdXAsIHBhcmVudCkge1xuICAgICAgICBjb25zdCBpc0Zvcm1Hcm91cCA9IGdyb3VwIGluc3RhbmNlb2YgRm9ybUdyb3VwO1xuICAgICAgICBpZiAoIWlzRm9ybUdyb3VwKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhncm91cCkucmVkdWNlKGNyZWF0ZUNvbnRyb2woZ3JvdXApLCB7fSk7IC8vIEZvcm1CdWlsZGVyP1xuICAgICAgICAgICAgZ3JvdXAgPSBuZXcgRm9ybUdyb3VwKGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNWaXJ0dWFsICYmICFwYXJlbnQgJiYgdGhpcy5za2lwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZpc2libGUgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnZpZXdwb3J0LmZpcnN0SXRlbUluZGV4O1xuICAgICAgICAgICAgaWYgKGZpcnN0VmlzaWJsZSAhPT0gdGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwID0gZmlyc3RWaXNpYmxlO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcDogdGhpcy5za2lwLFxuICAgICAgICAgICAgICAgICAgICB0YWtlOiB0aGlzLnBhZ2VTaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0U2VydmljZS5hZGRSb3cocGFyZW50LCBncm91cCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMudmlldy5jbGVhcigpO1xuICAgICAgICB0aGlzLmZvY3VzRWRpdEVsZW1lbnQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCA/IGB0cltkYXRhLXRyZWVsaXN0LXZpZXctaW5kZXg9XCIke3RoaXMudmlldy5pdGVtSW5kZXgocGFyZW50KSArIDF9XCJdYCA6ICcuay1ncmlkLWFkZC1yb3cnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHV0cyB0aGUgY2VsbCB0aGF0IGlzIHNwZWNpZmllZCBieSB0aGUgdGFibGUgcm93IGFuZCBjb2x1bW4gaW4gZWRpdCBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4IHRoYXQgd2lsbCBiZSBzd2l0Y2hlZCBpbiB0aGUgZWRpdCBtb2RlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xhbnl9IGNvbHVtbiAtIFRoZSBsZWFmIGNvbHVtbiBpbmRleCwgb3IgdGhlIGZpZWxkIG5hbWUgb3IgdGhlIGNvbHVtbiBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBlZGl0ZWQuXG4gICAgICogQHBhcmFtIHtGb3JtR3JvdXB9IGdyb3VwIC0gVGhlIFtgRm9ybUdyb3VwYF0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnZm9ybWdyb3VwYXBpJ10gfX0pXG4gICAgICogdGhhdCBkZXNjcmliZXMgdGhlIGVkaXQgZm9ybS5cbiAgICAgKi9cbiAgICBlZGl0Q2VsbChkYXRhSXRlbSwgY29sdW1uLCBncm91cCkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuY29sdW1uSW5zdGFuY2UoY29sdW1uKTtcbiAgICAgICAgdGhpcy5lZGl0U2VydmljZS5lZGl0Q2VsbChkYXRhSXRlbSwgaW5zdGFuY2UsIGdyb3VwKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZUVkaXRlZFN0YXRlKCk7XG4gICAgICAgIHRoaXMuZm9jdXNFZGl0RWxlbWVudCgoKSA9PiAnLmstZ3JpZC1lZGl0LWNlbGwnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IGNlbGwgaW4gZWRpdCBtb2RlIGFuZCBmaXJlc1xuICAgICAqIHRoZSBbYGNlbGxDbG9zZWBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X3RyZWVsaXN0Y29tcG9uZW50ICV9I3RvYy1jZWxsY2xvc2UpIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVkaXRlZCBjZWxsIHdhcyBjbG9zZWQuXG4gICAgICogQSBgZmFsc2VgIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZVxuICAgICAqIFtgY2VsbENsb3NlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfdHJlZWxpc3Rjb21wb25lbnQgJX0jdG9jLWNlbGxjbG9zZSkgZXZlbnQgd2FzIHByZXZlbnRlZC5cbiAgICAgKi9cbiAgICBjbG9zZUNlbGwoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lZGl0U2VydmljZS5jbG9zZUNlbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IGNlbGwgaW4gZWRpdCBtb2RlLlxuICAgICAqL1xuICAgIGNhbmNlbENlbGwoKSB7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuY2FuY2VsQ2VsbCgpO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlRWRpdGVkU3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGEgcm93IG9yIGEgY2VsbCBpcyBjdXJyZW50bHkgZWRpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQSBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhIHJvdyBvciBhIGNlbGwgaXMgY3VycmVudGx5IGVkaXRlZC5cbiAgICAgKi9cbiAgICBpc0VkaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYSBjZWxsIGlzIGN1cnJlbnRseSBlZGl0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBBIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGEgY2VsbCBpcyBjdXJyZW50bHkgYmVpbmcgZWRpdGVkLlxuICAgICAqL1xuICAgIGlzRWRpdGluZ0NlbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZygpICYmIHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0aW5nQ2VsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgdGhlIFBERiBleHBvcnQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwZGZleHBvcnRfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBzYXZlQXNQREYoKSB7XG4gICAgICAgIHRoaXMucGRmU2VydmljZS5zYXZlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBUcmVlTGlzdCBlbGVtZW50IHRvIGEgRHJhd2luZyBbYEdyb3VwYF0oeyUgc2x1ZyBhcGlfa2VuZG8tZHJhd2luZ19ncm91cCAlfSkgYnkgdXNpbmcgdGhlIGBrZW5kby10cmVlbGlzdC1wZGZgIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGRmZXhwb3J0X3RyZWVsaXN0ICV9I3RvYy1leHBvcnRpbmctbXVsdGlwbGUtdHJlZWxpc3RzLXRvLXRoZS1zYW1lLXBkZikpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIERyYXdpbmcgYEdyb3VwYC5cbiAgICAgKi9cbiAgICBkcmF3UERGKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLnBkZlNlcnZpY2UuZHJhdyh0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyB0aGUgRXhjZWwgZXhwb3J0IChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhjZWxleHBvcnRfdHJlZWxpc3QgJX0pKS5cbiAgICAgKi9cbiAgICBzYXZlQXNFeGNlbCgpIHtcbiAgICAgICAgdGhpcy5leGNlbFNlcnZpY2Uuc2F2ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgbWluaW11bSBwb3NzaWJsZSB3aWR0aCBmb3IgdGhlIHNwZWNpZmllZCBjb2x1bW4sXG4gICAgICogc28gdGhhdCB0aGUgd2hvbGUgdGV4dCBmaXRzIHdpdGhvdXQgd3JhcHBpbmcuIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhlIFRyZWVMaXN0XG4gICAgICogdG8gYmUgcmVzaXphYmxlIChzZXQgYHJlc2l6YWJsZWAgdG8gYHRydWVgKS5cbiAgICAgKiBNYWtlcyBzZW5zZSB0byBleGVjdXRlIHRoaXMgbWV0aG9kIG9ubHlcbiAgICAgKiBhZnRlciB0aGUgVHJlZUxpc3QgaXMgYWxyZWFkeSBwb3B1bGF0ZWQgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgICAgPGtlbmRvLXRyZWVsaXN0XG4gICAgICogICAgICAgICAgICAjdHJlZWxpc3RcbiAgICAgKiAgICAgICAgICAgIFtkYXRhXT1cInRyZWVsaXN0RGF0YVwiXG4gICAgICogICAgICAgICAgICBbcmVzaXphYmxlXT1cInRydWVcIlxuICAgICAqICAgICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDMwMHB4XCI+XG4gICAgICogICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdFRvb2xiYXJUZW1wbGF0ZT5cbiAgICAgKiAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cInRyZWVsaXN0LmF1dG9GaXRDb2x1bW4oZ3JvdXBDb2x1bW4pXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgICBBdXRvLWZpdCB0aGUgZ3JvdXAgY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW4tZ3JvdXAgI2dyb3VwQ29sdW1uIHRpdGxlPVwiUHJvZHVjdCBJbmZvXCI+XG4gICAgICogICAgICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3RJRFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgIFt3aWR0aF09XCI1MFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgIFttaW5SZXNpemFibGVXaWR0aF09XCIzMFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiSURcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZmllbGQ9XCJQcm9kdWN0TmFtZVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCI+XG4gICAgICogICAgICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICogICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbi1ncm91cD5cbiAgICAgKlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgIGZpZWxkPVwiVW5pdFByaWNlXCJcbiAgICAgKiAgICAgICAgICAgICAgICB0aXRsZT1cIlVuaXQgUHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICAgIFt3aWR0aF09XCIxODBcIlxuICAgICAqICAgICAgICAgICAgICAgIGZpbHRlcj1cIm51bWVyaWNcIlxuICAgICAqICAgICAgICAgICAgICAgIGZvcm1hdD1cInswOmN9XCI+XG4gICAgICogICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgPC9rZW5kby10cmVlbGlzdD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyB0cmVlbGlzdERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhdXRvRml0Q29sdW1uKGNvbHVtbikge1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZS5hdXRvRml0KGNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIHdpZHRoIG9mIHRoZSBzcGVjaWZpZWQgY29sdW1ucyB0byBmaXQgdGhlIGVudGlyZSBjb250ZW50LCBpbmNsdWRpbmcgaGVhZGVycywgd2l0aG91dCB3cmFwcGluZy5cbiAgICAgKiBJZiBubyBjb2x1bW5zIGFyZSBzcGVjaWZpZWQsIGBhdXRvRml0Q29sdW1uc2AgaXMgYXBwbGllZCB0byBhbGwgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoZSBUcmVlTGlzdCB0byBiZSByZXNpemFibGUgKHNldCBgcmVzaXphYmxlYCB0byBgdHJ1ZWApLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgIDxrZW5kby10cmVlbGlzdFxuICAgICAqICAgICAgICAgICN0cmVlbGlzdFxuICAgICAqICAgICAgICAgIFtkYXRhXT1cInRyZWVsaXN0RGF0YVwiXG4gICAgICogICAgICAgICAgW3Jlc2l6YWJsZV09XCJ0cnVlXCJcbiAgICAgKiAgICAgICAgICBzdHlsZT1cImhlaWdodDogMzAwcHhcIj5cbiAgICAgKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdFRvb2xiYXJUZW1wbGF0ZT5cbiAgICAgKiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cInRyZWVsaXN0LmF1dG9GaXRDb2x1bW5zKFtmaXJzdENvbHVtbiwgbGFzdENvbHVtbl0pXCI+XG4gICAgICogICAgICAgICAgICAgICAgICBBdXRvLWZpdCB0aGUgZmlyc3QgYW5kIGxhc3QgY29sdW1uXG4gICAgICogICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAqICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiay1idXR0b25cIiAoY2xpY2spPVwidHJlZWxpc3QuYXV0b0ZpdENvbHVtbnMoKVwiPlxuICAgICAqICAgICAgICAgICAgICAgICAgQXV0by1maXQgYWxsIGNvbHVtbnNcbiAgICAgKiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uLWdyb3VwIHRpdGxlPVwiUHJvZHVjdCBJbmZvXCI+XG4gICAgICogICAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgICNmaXJzdENvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgZmllbGQ9XCJQcm9kdWN0SURcIlxuICAgICAqICAgICAgICAgICAgICAgICAgW3dpZHRoXT1cIjUwXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgIFttaW5SZXNpemFibGVXaWR0aF09XCIzMFwiXG4gICAgICogICAgICAgICAgICAgICAgICB0aXRsZT1cIklEXCI+XG4gICAgICogICAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgICAgIGZpZWxkPVwiUHJvZHVjdE5hbWVcIlxuICAgICAqICAgICAgICAgICAgICAgICAgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIlxuICAgICAqICAgICAgICAgICAgICAgICAgPlxuICAgICAqICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbi1ncm91cD5cbiAgICAgKlxuICAgICAqICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgI2xhc3RDb2x1bW5cbiAgICAgKiAgICAgICAgICAgICAgZmllbGQ9XCJVbml0UHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICB0aXRsZT1cIlVuaXQgUHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICBbd2lkdGhdPVwiMTgwXCJcbiAgICAgKiAgICAgICAgICAgICAgZmlsdGVyPVwibnVtZXJpY1wiXG4gICAgICogICAgICAgICAgICAgIGZvcm1hdD1cInswOmN9XCI+XG4gICAgICogICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4+XG4gICAgICogICAgICA8L2tlbmRvLXRyZWVsaXN0PlxuICAgICAqICAgIGBcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICAgcHVibGljIHRyZWVsaXN0RGF0YTogYW55W10gPSBwcm9kdWN0cztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBwcm9kdWN0cyA9IFt7XG4gICAgICogICAgXCJQcm9kdWN0SURcIjogMSxcbiAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhaVwiLFxuICAgICAqICAgIFwiVW5pdFByaWNlXCI6IDE4LjAwMDAsXG4gICAgICogICAgXCJEaXNjb250aW51ZWRcIjogdHJ1ZVxuICAgICAqICB9LCB7XG4gICAgICogICAgXCJQcm9kdWN0SURcIjogMixcbiAgICAgKiAgICBcIlByb2R1Y3ROYW1lXCI6IFwiQ2hhbmdcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOS4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBdO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGF1dG9GaXRDb2x1bW5zKGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgbGV0IGNvbHM7XG4gICAgICAgIGlmIChjb2x1bW5zIGluc3RhbmNlb2YgUXVlcnlMaXN0KSB7XG4gICAgICAgICAgICBjb2xzID0gY29sdW1ucy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xzID0gY29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZS5hdXRvRml0KC4uLmNvbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbm90aWZ5UGFnZUNoYW5nZShzb3VyY2UsIGV2ZW50KSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT09IFwibGlzdFwiICYmICF0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcCA9IGV2ZW50LnNraXA7XG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBldmVudC50YWtlO1xuICAgICAgICB0aGlzLmNsb3NlQ2VsbCgpO1xuICAgICAgICB0aGlzLmNhbmNlbENlbGwoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbm90aWZ5U2Nyb2xsQm90dG9tKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMuc2Nyb2xsQm90dG9tKSkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMuc2Nyb2xsQm90dG9tLmVtaXQoeyBzZW5kZXI6IHRoaXMgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb2N1c0VkaXRFbGVtZW50KGNvbnRhaW5lclNlbGVjdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzRWxlbWVudFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzRWxlbWVudFN1YnNjcmlwdGlvbiA9IHRoaXMubmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBjb250YWluZXJTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXRFZGl0Rm9jdXMod3JhcHBlci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkgJiYgdGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVkaXRGb2N1cyh3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoYC5rLWdyaWQtY29udGVudCAke3NlbGVjdG9yfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBsYXN0IGFjdGl2ZSBvciB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgVHJlZUxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0TmF2aWdhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzQ2VsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBjZWxsIHdpdGggdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBpbmRleC5cbiAgICAgKlxuICAgICAqIFRoZSByb3cgaW5kZXggaXMgYmFzZWQgb24gdGhlIGxvZ2ljYWwgc3RydWN0dXJlIG9mIHRoZSBUcmVlTGlzdCBhbmQgZG9lcyBub3QgY29ycmVzcG9uZCB0byB0aGUgZGF0YSBpdGVtIGluZGV4OlxuICAgICAqICogSGVhZGVyIHJvd3MgYXJlIGluY2x1ZGVkLCBzdGFydGluZyBhdCBpbmRleCAwLlxuICAgICAqICogVGhlIHJvdyBpbmRleGluZyBpcyBhYnNvbHV0ZSBhbmQgZG9lcyBub3QgY2hhbmdlIHdpdGggcGFnaW5nLlxuICAgICAqXG4gICAgICogSWYgdGhlIFRyZWVMaXN0IGlzIGNvbmZpZ3VyZWQgZm9yIHNjcm9sbGluZywgaW5jbHVkaW5nIHZpcnR1YWwgc2Nyb2xsaW5nLCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgKiBJZiB0aGUgcm93IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBjdXJyZW50IHBhZ2UsIHRoZSBtZXRob2Qgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleCAtIFRoZSBsb2dpY2FsIHJvdyBpbmRleCB0byBmb2N1cy4gVGhlIHRvcCBoZWFkZXIgcm93IGhhcyBhbiBpbmRleCAwLlxuICAgICAqIEBwYXJhbSBjb2xJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggdG8gZm9jdXMuXG4gICAgICogQHJldHVybnMge05hdmlnYXRpb25DZWxsfSBUaGUgZm9jdXNlZCBjZWxsLlxuICAgICAqXG4gICAgICovXG4gICAgZm9jdXNDZWxsKHJvd0luZGV4LCBjb2xJbmRleCkge1xuICAgICAgICB0aGlzLmFzc2VydE5hdmlnYWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c0NlbGwocm93SW5kZXgsIGNvbEluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbmV4dCBjZWxsLCBvcHRpb25hbGx5IHdyYXBwaW5nIHRvIHRoZSBuZXh0IHJvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3cmFwIC0gQSBCb29sZWFuIHZhbHVlIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgZm9jdXMgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IHJvdy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAqIEByZXR1cm5zIHtOYXZpZ2F0aW9uQ2VsbH0gVGhlIGZvY3VzZWQgY2VsbC4gSWYgdGhlIGZvY3VzIGlzIGFscmVhZHkgb24gdGhlIGxhc3QgY2VsbCwgcmV0dXJucyBgbnVsbGAuXG4gICAgICovXG4gICAgZm9jdXNOZXh0Q2VsbCh3cmFwID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydE5hdmlnYWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5mb2N1c05leHRDZWxsKHdyYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBwcmV2aW91cyBjZWxsLiBPcHRpb25hbGx5IHdyYXBzIHRvIHRoZSBwcmV2aW91cyByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd3JhcCAtIEEgQm9vbGVhbiB2YWx1ZSB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGZvY3VzIHdpbGwgbW92ZSB0byB0aGUgbmV4dCByb3cuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7TmF2aWdhdGlvbkNlbGx9IFRoZSBmb2N1c2VkIGNlbGwuIElmIHRoZSBmb2N1cyBpcyBhbHJlYWR5IG9uIHRoZSBmaXJzdCBjZWxsLCByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cbiAgICBmb2N1c1ByZXZDZWxsKHdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0TmF2aWdhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzUHJldkNlbGwod3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtblxuICAgICAqL1xuICAgIHNjcm9sbFRvKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXF1ZXN0U2VydmljZS5zY3JvbGxUbyhyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNwZWNpZmllZCBjb2x1bW4uXG4gICAgICogVGhlIHJlb3JkZXJpbmcgb2YgY29sdW1ucyBvcGVyYXRlcyBvbmx5IG9uIHRoZSBsZXZlbFxuICAgICAqIHdoaWNoIGlzIGluZmVycmVkIGJ5IHRoZSBzb3VyY2UgY29sdW1uLlxuICAgICAqIEZvciB0aGUgYHJlb3JkZXJDb2x1bW5gIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LFxuICAgICAqIHRoZSBgc291cmNlYCBjb2x1bW4gaGFzIHRvIGJlIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbHVtbkJhc2V9IHNvdXJjZSAtIFRoZSBjb2x1bW4gd2hvc2UgcG9zaXRpb24gd2lsbCBiZSBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0SW5kZXggLSBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtDb2x1bW5SZW9yZGVyQ29uZmlnfSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgICAgPGtlbmRvLXRyZWVsaXN0XG4gICAgICogICAgICAgICAgICAjdHJlZWxpc3RcbiAgICAgKiAgICAgICAgICAgIFtkYXRhXT1cInRyZWVsaXN0RGF0YVwiXG4gICAgICogICAgICAgICAgICBbcmVvcmRlcmFibGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMzAwcHhcIj5cbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0VG9vbGJhclRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiay1idXR0b25cIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRyZWVsaXN0LnJlb3JkZXJDb2x1bW4oZ3JvdXBDb2x1bW4sIDIsIHsgYmVmb3JlOiB0cnVlIH0pXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgICBNb3ZlIHRoZSBncm91cCBjb2x1bW4gYmVmb3JlIHRoZSBsYXN0IG9uZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbi1ncm91cCAjZ3JvdXBDb2x1bW4gdGl0bGU9XCJQcm9kdWN0IEluZm9cIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgICAgIGZpZWxkPVwiUHJvZHVjdElEXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgW3dpZHRoXT1cIjUwXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJJRFwiPlxuICAgICAqICAgICAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtblxuICAgICAqICAgICAgICAgICAgICAgICAgICBmaWVsZD1cIlByb2R1Y3ROYW1lXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAgICAgKiAgICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uLWdyb3VwPlxuICAgICAqXG4gICAgICogICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJVbml0UHJpY2VcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiVW5pdCBQcmljZVwiXG4gICAgICogICAgICAgICAgICAgICAgW3dpZHRoXT1cIjE4MFwiXG4gICAgICogICAgICAgICAgICAgICAgZm9ybWF0PVwiezA6Y31cIj5cbiAgICAgKiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICAgICAqXG4gICAgICogICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uXG4gICAgICogICAgICAgICAgICAgICAgZmllbGQ9XCJEaXNjb250aW51ZWRcIlxuICAgICAqICAgICAgICAgICAgICAgIHRpdGxlPVwiRGlzY29udGludWVkXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbd2lkdGhdPVwiMTAwXCI+XG4gICAgICogICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAgICAgKiAgICAgICAgPC9rZW5kby10cmVlbGlzdD5cbiAgICAgKiAgICBgXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgIHB1YmxpYyB0cmVlbGlzdERhdGE6IGFueVtdID0gcHJvZHVjdHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgcHJvZHVjdHMgPSBbe1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDEsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYWlcIixcbiAgICAgKiAgICBcIlVuaXRQcmljZVwiOiAxOC4wMDAwLFxuICAgICAqICAgIFwiRGlzY29udGludWVkXCI6IHRydWVcbiAgICAgKiAgfSwge1xuICAgICAqICAgIFwiUHJvZHVjdElEXCI6IDIsXG4gICAgICogICAgXCJQcm9kdWN0TmFtZVwiOiBcIkNoYW5nXCIsXG4gICAgICogICAgXCJVbml0UHJpY2VcIjogMTkuMDAwMCxcbiAgICAgKiAgICBcIkRpc2NvbnRpbnVlZFwiOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogXTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZW9yZGVyQ29sdW1uKHNvdXJjZSwgZGVzdEluZGV4LCBvcHRpb25zID0geyBiZWZvcmU6IGZhbHNlIH0pIHtcbiAgICAgICAgY29uc3QgY29sdW1uc0ZvckxldmVsID0gdGhpcy5jb2x1bW5zRm9yTGV2ZWwoc291cmNlLmxldmVsKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGNvbHVtbnNGb3JMZXZlbFtkZXN0SW5kZXhdO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3ROb25Mb2NrZWQgPSB0YXJnZXQuaXNMb2NrZWQgJiZcbiAgICAgICAgICAgICFzb3VyY2UuaXNMb2NrZWQgJiZcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc0NvbnRhaW5lci5ub25Mb2NrZWRDb2x1bW5zLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgaWYgKGxhc3ROb25Mb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTcGFuQ29sdW1uQ29tcG9uZW50KHRhcmdldCkgJiYgIW9wdGlvbnMuYmVmb3JlKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuY2hpbGRDb2x1bW5zLmxhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW9yZGVyKHtcbiAgICAgICAgICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUsXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGFscmVhZHkgbG9hZGVkIGNoaWxkcmVuIGZvciB0aGUgZGF0YUl0ZW0gc28gdGhhdCB0aGUgVHJlZUxpc3Qgd2lsbCBmZXRjaCB0aGVtIGFnYWluIHRoZSBuZXh0IHRpbWUgaXQgaXMgcmVuZGVyZWQuXG4gICAgICovXG4gICAgcmVsb2FkKGRhdGFJdGVtLCByZWxvYWRDaGlsZHJlbikge1xuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXNldEl0ZW0oZGF0YUl0ZW0sIHJlbG9hZENoaWxkcmVuKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldyB3aXRob3V0IHJlbG9hZGluZyB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIENoZWNrcyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGl0ZW1zIGZvciBjaGFuZ2VzIGFuZFxuICAgICAqIHRyaWdnZXJzIHJlLWV2YWx1YXRpb24gb2YgdGhlIHRoZSBbaXNFeHBhbmRlZF0oI3RvYy1pc2V4cGFuZGVkKSBhbmRcbiAgICAgKiBbaXNTZWxlY3RlZF0oI3RvYy1pc1NlbGVjdGVkKSBjYWxsYmFja3MuXG4gICAgICovXG4gICAgdXBkYXRlVmlldygpIHtcbiAgICAgICAgdGhpcy52aWV3LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIHJvdyBmb3IgdGhlIHNwZWNpZmllZCBkYXRhSXRlbS5cbiAgICAgKi9cbiAgICBleHBhbmQoZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy5leHBhbmRTdGF0ZVNlcnZpY2UuZXhwYW5kKGRhdGFJdGVtKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSByb3cgZm9yIHRoZSBzcGVjaWZpZWQgZGF0YUl0ZW0uXG4gICAgICovXG4gICAgY29sbGFwc2UoZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy5leHBhbmRTdGF0ZVNlcnZpY2UuY29sbGFwc2UoZGF0YUl0ZW0pO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVvcmRlcih7IHRhcmdldCwgc291cmNlLCBiZWZvcmUsIGNoYW5nZUNvbnRhaW5lciB9KSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5zRm9yTGV2ZWwgPSB0aGlzLmNvbHVtbnNGb3JMZXZlbChzb3VyY2UubGV2ZWwpO1xuICAgICAgICAgICAgbGV0IG5ld0luZGV4ID0gY29sdW1uc0ZvckxldmVsLmluZGV4T2YodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQucGFyZW50ICYmIHRhcmdldC5wYXJlbnQuaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSBjb2x1bW5zRm9yTGV2ZWwuaW5kZXhPZih0YXJnZXQucGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9sZEluZGV4ID0gY29sdW1uc0ZvckxldmVsLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlICYmIDAgPCBuZXdJbmRleCAmJiBvbGRJbmRleCA8IG5ld0luZGV4KSB7IC8vIGRyb3BwZWQgYmVmb3JlIHRoZSBmaXJzdCBub3QgbG9ja2VkIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYmVmb3JlICYmIG9sZEluZGV4ID4gbmV3SW5kZXgpIHsgLy8gZHJvcHBlZCBhZnRlciB0aGUgbGFzdCBsb2NrZWQgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJncyA9IG5ldyBDb2x1bW5SZW9yZGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogc291cmNlLFxuICAgICAgICAgICAgICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICAgICAgICAgICAgICBuZXdJbmRleDogbmV3SW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5SZW9yZGVyLmVtaXQoYXJncyk7XG4gICAgICAgICAgICBpZiAoYXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkxvY2tlZENoYW5nZS5lbWl0KG5ldyBDb2x1bW5Mb2NrZWRDaGFuZ2VFdmVudChbc291cmNlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5JbmRpY2VzKHsgc291cmNlLCB0YXJnZXQsIGJlZm9yZSB9KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UubG9ja2VkICE9PSB0YXJnZXQubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLmxvY2tlZCA9IHRhcmdldC5sb2NrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbHVtbk9yZGVyQ2hhbmdlLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAvL3RoaXMuY29sdW1uc0NvbnRhaW5lci5yZWZyZXNoKCk7ICB3aHkgZm9yY2UgaXQgaGVyZSA/P1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtbkluZGljZXMoeyBzb3VyY2UsIHRhcmdldCwgYmVmb3JlIH0pIHtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRDb2x1bW5zID0gZXhwYW5kQ29sdW1uc1dpdGhTcGFuKHRoaXMuY29sdW1uc0ZvckxldmVsKHNvdXJjZS5sZXZlbCkpO1xuICAgICAgICBjb25zdCBzb3VyY2VDb2x1bW5JbmRleCA9IGV4cGFuZGVkQ29sdW1ucy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgIGxldCBuZXh0U291cmNlSW5kZXggPSAwO1xuICAgICAgICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHRvU2tpcCA9IDE7XG4gICAgICAgIC8vIFBvc3NpYmxlIG9ubHkgd2hlbiBjYWxsZWQgZnJvbSB0aGUgQVBJLlxuICAgICAgICBpZiAoc291cmNlLmlzU3BhbkNvbHVtbikge1xuICAgICAgICAgICAgdG9Ta2lwICs9IHNvdXJjZS5jaGlsZENvbHVtbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBleHBhbmRlZENvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gZXhwYW5kZWRDb2x1bW5zW2ldO1xuICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbmV4dFNvdXJjZUluZGV4ID0gYmVmb3JlID8gbmV4dEluZGV4IDogbmV4dEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBiZWZvcmUgPyBuZXh0SW5kZXggKyB0b1NraXAgOiBuZXh0SW5kZXg7XG4gICAgICAgICAgICAgICAgY29sdW1uLm9yZGVySW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VJbmRleCA9PT0gbmV4dEluZGV4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SW5kZXggKz0gdG9Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbiA9PT0gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaSArPSB0b1NraXA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4ub3JkZXJJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IHNvdXJjZUNvbHVtbkluZGV4OyBpIDwgc291cmNlQ29sdW1uSW5kZXggKyB0b1NraXA7IGkrKykge1xuICAgICAgICAgICAgZXhwYW5kZWRDb2x1bW5zW2ldLm9yZGVySW5kZXggPSBuZXh0U291cmNlSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUluZGljZXNGb3JMZXZlbChzb3VyY2UubGV2ZWwgKyAxKTtcbiAgICB9XG4gICAgdXBkYXRlSW5kaWNlc0ZvckxldmVsKGxldmVsKSB7XG4gICAgICAgIGNvbnN0IGNvbHNGb3JQYXJlbnRMZXZlbCA9IHRoaXMuY29sdW1uc0ZvckxldmVsKGxldmVsIC0gMSk7XG4gICAgICAgIGNvbnN0IGNvbHNGb3JMZXZlbCA9IFtdO1xuICAgICAgICBzb3J0Q29sdW1ucyhjb2xzRm9yUGFyZW50TGV2ZWwpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjLmlzQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjb2xzRm9yTGV2ZWwucHVzaCguLi5jLmNoaWxkcmVuQXJyYXkuc29ydCgoYSwgYikgPT4gYS5vcmRlckluZGV4IC0gYi5vcmRlckluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleHBhbmRDb2x1bW5zV2l0aFNwYW4oY29sc0ZvckxldmVsKS5tYXAoKGMsIGkpID0+IGMub3JkZXJJbmRleCA9IGkpO1xuICAgICAgICBpZiAobGV2ZWwgPCB0aGlzLmNvbHVtbnNDb250YWluZXIudG90YWxMZXZlbHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5kaWNlc0ZvckxldmVsKGxldmVsICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sdW1uc0ZvckxldmVsKGxldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNDb250YWluZXJcbiAgICAgICAgICAgIC5hbGxDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmxldmVsID09PSBsZXZlbCk7XG4gICAgfVxuICAgIHNldEVkaXRGb2N1cyhlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS50cnlGb2N1cyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2x1bW5JbnN0YW5jZShjb2x1bW4pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gdGhpcy5jb2x1bW5zQ29udGFpbmVyLmxvY2tlZExlYWZDb2x1bW5zLnRvQXJyYXkoKVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5jb2x1bW5zQ29udGFpbmVyLm5vbkxvY2tlZExlYWZDb2x1bW5zLnRvQXJyYXkoKSlbY29sdW1uXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29sdW1uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbHVtbkxpc3QuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmZpZWxkID09PSBjb2x1bW4pWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiAke2NvbHVtbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIHZlcmlmeVNldHRpbmdzKCkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2tlZCA9IHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoIHx8ICh0aGlzLmNvbHVtbk1lbnUgJiYgdGhpcy5jb2x1bW5NZW51LmxvY2spO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoICYmICF0aGlzLm5vbkxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IG9uZSBub24tbG9ja2VkIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsb2NrZWQgfHwgdGhpcy52aXJ0dWFsQ29sdW1ucykgJiYgZXhwYW5kQ29sdW1ucyh0aGlzLmNvbHVtbkxpc3QudG9BcnJheSgpKS5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4ud2lkdGggJiYgIWlzQ29sdW1uR3JvdXBDb21wb25lbnQoY29sdW1uKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChsb2NrZWQgPyAnTG9ja2VkJyA6ICdWaXJ0dWFsJykgKyAnIGNvbHVtbnMgZmVhdHVyZSByZXF1aXJlcyBhbGwgY29sdW1ucyB0byBoYXZlIHNldCB3aWR0aC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NrZWQgJiYgIXRoaXMuaXNTY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NrZWQgY29sdW1ucyBhcmUgb25seSBzdXBwb3J0ZWQgd2hlbiBzY3JvbGxpbmcgaXMgZW5hYmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkxpc3QuZmlsdGVyKGlzQ29sdW1uR3JvdXBDb21wb25lbnQpLmZpbHRlcigoeCkgPT4gIXguaGFzQ2hpbGRyZW4pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sdW1uR3JvdXBDb21wb25lbnQgc2hvdWxkIGNvbnRhaW4gQ29sdW1uQ29tcG9uZW50IG9yIENvbW1hbmRDb2x1bW5Db21wb25lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5MaXN0LmZpbHRlcih4ID0+IHgubG9ja2VkICYmIHgucGFyZW50ICYmICF4LnBhcmVudC5pc0xvY2tlZCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NrZWQgY2hpbGQgY29sdW1ucyByZXF1aXJlIHRoZWlyIHBhcmVudCBjb2x1bW5zIHRvIGJlIGxvY2tlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5yb3dIZWlnaHQpICYmICF0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm93IGhlaWdodCBzZXR0aW5nIHJlcXVpcmVzIHZpcnR1YWwgc2Nyb2xsaW5nIG1vZGUgdG8gYmUgZW5hYmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlQ29sdW1uc0ZpZWxkKHRoaXMuY29sdW1uTGlzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXV0b0dlbmVyYXRlQ29sdW1ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkR2VuZXJhdGVDb2x1bW5zICYmICF0aGlzLmNvbHVtbnMubGVuZ3RoICYmIHRoaXMudmlldy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSBPYmplY3Qua2V5cyh0aGlzLnZpZXcuYXQoMCkuZGF0YSkubWFwKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1uID0gbmV3IENvbHVtbkNvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgIGNvbHVtbi5maWVsZCA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbHVtbnNbMF0uZXhwYW5kYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucmVzZXQoY29sdW1ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoU3RhdGVDaGFuZ2VzRW1pdHRlcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChtZXJnZSh0aGlzLnNvcnRDaGFuZ2UucGlwZShtYXAoc29ydCA9PiAoeyBmaWx0ZXI6IHRoaXMuZmlsdGVyLCBza2lwOiB0aGlzLnNraXAsIHNvcnQ6IHNvcnQsIHRha2U6IHRoaXMucGFnZVNpemUgfSkpKSwgdGhpcy5maWx0ZXJDaGFuZ2UucGlwZShtYXAoZmlsdGVyJCQxID0+ICh7XG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlciQkMSwgc2tpcDogMCwgc29ydDogdGhpcy5zb3J0LCB0YWtlOiB0aGlzLnBhZ2VTaXplXG4gICAgICAgIH0pKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHggPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNlbGwoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQ2VsbCgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhU3RhdGVDaGFuZ2UuZW1pdCh4KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhdHRhY2hFZGl0SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0U2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5lZGl0U2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMuZW1pdENSVURFdmVudC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIGVtaXRDUlVERXZlbnQoYXJncykge1xuICAgICAgICBsZXQgeyBhY3Rpb24sIGZvcm1Hcm91cCwgZGF0YUl0ZW0gfSA9IGFyZ3M7XG4gICAgICAgIGlmIChhY3Rpb24gIT09ICdhZGQnICYmICFkYXRhSXRlbSkge1xuICAgICAgICAgICAgZGF0YUl0ZW0gPSBmb3JtR3JvdXAudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDZWxsKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXJncywge1xuICAgICAgICAgICAgZGF0YUl0ZW06IGRhdGFJdGVtLFxuICAgICAgICAgICAgc2VuZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmFkZC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZWRpdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0LmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzYXZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmUuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbGxDbG9zZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsQ2xvc2UuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaERvbUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5kb21FdmVudHMuY2VsbENsaWNrLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLmNlbGxDbGljaykgfHwgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHsgLy8gZW5hYmxlZCBvbmx5IGlmIGlzU2VsZWN0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsQ2xpY2suZW1pdChPYmplY3QuYXNzaWduKHsgc2VuZGVyOiB0aGlzIH0sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGF0dGFjaEVsZW1lbnRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgYXJpYVJvb3QgPSB0aGlzLmFyaWFSb290Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUNoZWNrID0gdGhpcy5yZXNpemVDaGVjay5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ3dpbmRvdycsICdyZXNpemUnLCByZXNpemVDaGVjayk7XG4gICAgICAgICAgICBjb25zdCBvcmllbnRhdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCByZXNpemVDaGVjayk7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudENsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGl0U2VydmljZS5zaG91bGRDbG9zZUNlbGwoKSAmJlxuICAgICAgICAgICAgICAgICAgICAhY2xvc2VzdChhcmdzLnRhcmdldCwgbWF0Y2hlc0NsYXNzZXMoJ2stYW5pbWF0aW9uLWNvbnRhaW5lciBrLXRyZWVsaXN0LWlnbm9yZS1jbGljaycpKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKGFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbG9zZXN0KGFjdGl2ZUVsZW1lbnQsIG1hdGNoZXNDbGFzc2VzKCdrLWFuaW1hdGlvbi1jb250YWluZXInKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0luRWRpdGVkQ2VsbChhY3RpdmVFbGVtZW50LCB0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCkpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNsb3NlQ2VsbChhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvd0JsdXJTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbignd2luZG93JywgJ2JsdXInLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmICEobWF0Y2hlc05vZGVOYW1lKCdpbnB1dCcpKGFjdGl2ZUVsZW1lbnQpICYmIGFjdGl2ZUVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5FZGl0ZWRDZWxsKGFjdGl2ZUVsZW1lbnQsIHRoaXMud3JhcHBlci5uYXRpdmVFbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5jbG9zZUNlbGwoYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLndpbmRvd0JsdXIuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih3cmFwcGVyLCAnY2xpY2snLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmNsaWNrLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGtleWRvd25TdWJzY3JpcHRpb24gPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih3cmFwcGVyLCAna2V5ZG93bicsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21FdmVudHMua2V5ZG93bi5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBmb2N1c0luIGFuZCBmb2N1c091dCBhcmUgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgd2l0aCBBUklBIHJvbGUgXCJ0cmVlZ3JpZFwiXG4gICAgICAgICAgICBsZXQgZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZm9jdXNJblN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGFyaWFSb290LCAnZm9jdXNpbicsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21FdmVudHMuZm9jdXMuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb21FdmVudHMuZm9jdXNJbi5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzT3V0U3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oYXJpYVJvb3QsICdmb2N1c291dCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGFyZ3MucmVsYXRlZFRhcmdldCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHNpZGUgPSAhY2xvc2VzdChuZXh0LCAobm9kZSkgPT4gbm9kZSA9PT0gYXJpYVJvb3QpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRzaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmZvY3VzT3V0LmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRWxlbWVudEV2ZW50SGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzaXplU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb25TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudENsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgd2luZG93Qmx1clN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGNsaWNrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAga2V5ZG93blN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvY3VzSW5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBmb2N1c091dFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoZXNNZWRpYShjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNpdmVTZXJ2aWNlLm1hdGNoZXNNZWRpYShjLm1lZGlhKTtcbiAgICB9XG4gICAgcmVzaXplQ2hlY2soKSB7XG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAhPT0gdGhpcy5jYWNoZWRXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTGlzdC5maWx0ZXJIaWVyYXJjaHkoY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzTWVkaWEgPSB0aGlzLm1hdGNoZXNNZWRpYShjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ubWF0Y2hlc01lZGlhICE9PSBtYXRjaGVzTWVkaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5tYXRjaGVzTWVkaWEgPSBtYXRjaGVzTWVkaWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4uaXNWaXNpYmxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdFBERkV4cG9ydEV2ZW50KCkge1xuICAgICAgICBjb25zdCBhcmdzID0gbmV3IFBERkV4cG9ydEV2ZW50KCk7XG4gICAgICAgIHRoaXMucGRmRXhwb3J0LmVtaXQoYXJncyk7XG4gICAgICAgIGlmICghYXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zYXZlQXNQREYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jSGVhZGVySGVpZ2h0KG9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiBpc1ByZXNlbnQodGhpcy5sb2NrZWRIZWFkZXIpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gc3luY1Jvd3NIZWlnaHQodGhpcy5sb2NrZWRIZWFkZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSwgdGhpcy5oZWFkZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSkpO1xuICAgIH1cbiAgICBjb2x1bW5zQ29udGFpbmVyQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuc3luY0hlYWRlckhlaWdodCh0aGlzLmNvbHVtbnNDb250YWluZXIuY2hhbmdlcy5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmxvY2tlZENvbHVtbnMubGVuZ3RoID4gMCksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpKSkpKTtcbiAgICB9XG4gICAgaGFuZGxlQ29sdW1uUmVzaXplKCkge1xuICAgICAgICBjb25zdCByZXNpemVzID0gdGhpcy5jb2x1bW5SZXNpemluZ1NlcnZpY2UuY2hhbmdlcztcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChyZXNpemVzLnBpcGUodGFwKGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdrLWdyaWQtY29sdW1uLXJlc2l6aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnR5cGUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2stZ3JpZC1jb2x1bW4tcmVzaXppbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIGZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3N0YXJ0JyksIHN3aXRjaE1hcCgoKSA9PiByZXNpemVzLnBpcGUoXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcnhqcy1uby11bnNhZmUtdGFrZXVudGlsXG4gICAgICAgIHRha2VVbnRpbChyZXNpemVzLnBpcGUoZmlsdGVyKGUgPT4gZS50eXBlID09PSAndHJpZ2dlckF1dG9GaXQnKSkpLCBmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdlbmQnKSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLm5vdGlmeVJlc2l6ZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5vdGlmeVJlc2l6ZShlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBlLnJlc2l6ZWRDb2x1bW5zXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXNUcnV0aHkoaXRlbS5jb2x1bW4ucmVzaXphYmxlKSAmJiAhaXRlbS5jb2x1bW4uaXNDb2x1bW5Hcm91cClcbiAgICAgICAgICAgIC5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgICAgY29sdW1uOiBpdGVtLmNvbHVtbixcbiAgICAgICAgICAgIG5ld1dpZHRoOiBpdGVtLmNvbHVtbi53aWR0aCxcbiAgICAgICAgICAgIG9sZFdpZHRoOiBpdGVtLm9sZFdpZHRoXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLmNvbHVtblJlc2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5SZXNpemUuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydE5hdmlnYWJsZSgpIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmICF0aGlzLm5hdmlnYWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgVHJlZUxpc3Qgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYXMgW25hdmlnYWJsZV09XCJ0cnVlXCIgdG8gY29udHJvbCBmb2N1cycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5hdmlnYXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgaXNWaXJ0dWFsID0gdGhpcy5pc1ZpcnR1YWw7XG4gICAgICAgIGNvbnN0IGZpbHRlclJvd09mZnNldCA9IGhhc0ZpbHRlclJvdyh0aGlzLmZpbHRlcmFibGUpID8gMSA6IDA7XG4gICAgICAgIGNvbnN0IGhlYWRlclJvd3MgPSB0aGlzLnRvdGFsQ29sdW1uTGV2ZWxzICsgMSArIGZpbHRlclJvd09mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uTWV0YWRhdGEodGhpcy52aWV3LCBoZWFkZXJSb3dzLCBpc1ZpcnR1YWwsIHRoaXMuc2hvd1BhZ2VyLCB0aGlzLndyYXBwZXIsIHRoaXMudmlydHVhbENvbHVtbnMsIHRoaXMuY29sdW1uc0NvbnRhaW5lcik7XG4gICAgfVxuICAgIHVwZGF0ZU5hdmlnYXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5tZXRhZGF0YSA9IHRoaXMubmF2aWdhdGlvbk1ldGFkYXRhKCk7XG4gICAgfVxuICAgIGFwcGx5QXV0b1NpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLmNvbHVtbnMuZmlsdGVyKChjKSA9PiB0aGlzLmF1dG9TaXplID8gYy5hdXRvU2l6ZSAhPT0gZmFsc2UgOiBjLmF1dG9TaXplKTtcbiAgICAgICAgaWYgKGNvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUub25TdGFibGUucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoXyA9PiB0aGlzLmF1dG9GaXRDb2x1bW5zKGNvbHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNvbHVtblJhbmdlQ2hhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Q29sdW1ucyA9IHRoaXMudmlld3BvcnRDb2x1bW5zID0gW107XG4gICAgICAgIGNvbnN0IGxlYWZWaWV3cG9ydENvbHVtbnMgPSB0aGlzLmNvbHVtbnNDb250YWluZXJcbiAgICAgICAgICAgIC5ub25Mb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCkuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCArIDEpO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsZWFmVmlld3BvcnRDb2x1bW5zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBsZWFmVmlld3BvcnRDb2x1bW5zW2lkeF07XG4gICAgICAgICAgICB3aGlsZSAoY29sdW1uLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbi5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b0FkZCA9IFtjb2x1bW5dO1xuICAgICAgICAgICAgd2hpbGUgKHRvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRvQWRkLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmlzQ29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9BZGQudW5zaGlmdC5hcHBseSh0b0FkZCwgY29sdW1uLmNoaWxkcmVuQXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3RGcm9tR3JvdXAgPSB2aWV3cG9ydENvbHVtbnNbdmlld3BvcnRDb2x1bW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29sdW1uID0gbGVhZlZpZXdwb3J0Q29sdW1uc1tpZHhdO1xuICAgICAgICAgICAgd2hpbGUgKGNvbHVtbiAhPT0gbGFzdEZyb21Hcm91cCAmJiBpZHggPCBsZWFmVmlld3BvcnRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGxlYWZWaWV3cG9ydENvbHVtbnNbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGxlYWZWaWV3cG9ydENvbHVtbnNbMF07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmFuZ2Uub2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB2aWV3cG9ydENvbHVtbnNbMF07XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09IGN1cnJlbnQuaXNDb2x1bW5Hcm91cCA/IDAgOiBjdXJyZW50LndpZHRoO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZpZXdwb3J0Q29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsTGV2ZWxzID0gdGhpcy5jb2x1bW5zQ29udGFpbmVyLnRvdGFsTGV2ZWxzO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPD0gdG90YWxMZXZlbHM7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldENvbHVtbiA9IGlkeCA8IHRvdGFsTGV2ZWxzID8gbmV3IENvbHVtbkdyb3VwQ29tcG9uZW50KHByZXZpb3VzKSA6IG5ldyBDb2x1bW5CYXNlJDEocHJldmlvdXMpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG9mZnNldENvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Q29sdW1uLnRpdGxlID0gXCJcXHUwMEEwXCI7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldENvbHVtbi53aWR0aCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRDb2x1bW5zLnVuc2hpZnQob2Zmc2V0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWFmVmlld3BvcnRDb2x1bW5zID0gdmlld3BvcnRDb2x1bW5zLmZpbHRlcihjID0+ICFjLmlzQ29sdW1uR3JvdXApO1xuICAgIH1cbiAgICBkYXRhTG9hZGVkKHJlc3VsdCkge1xuICAgICAgICB0aGlzLmxvYWRlZERhdGEgPSByZXN1bHQgfHwgW107XG4gICAgICAgIHRoaXMudmlldy5yZXNldCgpO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVEYXRhTG9hZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhTG9hZGVkU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMb2FkZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxvYWRlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5UcmVlTGlzdENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RyZWVMaXN0JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgQnJvd3NlclN1cHBvcnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5JbmZvU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRWRpdFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFBERlNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFN1c3BlbmRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8udHJlZWxpc3QnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIEZpbHRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFJlc3BvbnNpdmVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBQYWdlckNvbnRleHRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBFeGNlbFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBSZXNpemVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBEb21FdmVudHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIFNpbmdsZVBvcHVwU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRHJhZ0FuZERyb3BTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBEcmFnSGludFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIERyb3BDdWVTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5SZW9yZGVyU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIEZvY3VzUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgSWRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBTY3JvbGxSZXF1ZXN0U2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgU29ydFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIEV4cGFuZFN0YXRlU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIE9wdGlvbkNoYW5nZXNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBTZWxlY3Rpb25TZXJ2aWNlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIGtlbmRvVHJlZUxpc3RMb2NhbGl6ZWRNZXNzYWdlc1xuXG4gICAgICAgICAgICBpMThuLW5vUmVjb3Jkcz1cImtlbmRvLnRyZWVsaXN0Lm5vUmVjb3Jkc3xUaGUgbGFiZWwgdmlzaWJsZSBpbiB0aGUgVHJlZUxpc3Qgd2hlbiB0aGVyZSBhcmUgbm8gcmVjb3Jkc1wiXG4gICAgICAgICAgICBub1JlY29yZHM9XCJObyByZWNvcmRzIGF2YWlsYWJsZS5cIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VyRmlyc3RQYWdlPVwia2VuZG8udHJlZWxpc3QucGFnZXJGaXJzdFBhZ2V8VGhlIGxhYmVsIGZvciB0aGUgZmlyc3QgcGFnZSBidXR0b24gaW4gVHJlZUxpc3QgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJGaXJzdFBhZ2U9XCJHbyB0byB0aGUgZmlyc3QgcGFnZVwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJQcmV2aW91c1BhZ2U9XCJrZW5kby50cmVlbGlzdC5wYWdlclByZXZpb3VzUGFnZXxUaGUgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyBwYWdlIGJ1dHRvbiBpbiBUcmVlTGlzdCBwYWdlclwiXG4gICAgICAgICAgICBwYWdlclByZXZpb3VzUGFnZT1cIkdvIHRvIHRoZSBwcmV2aW91cyBwYWdlXCJcblxuICAgICAgICAgICAgaTE4bi1wYWdlck5leHRQYWdlPVwia2VuZG8udHJlZWxpc3QucGFnZXJOZXh0UGFnZXxUaGUgbGFiZWwgZm9yIHRoZSBuZXh0IHBhZ2UgYnV0dG9uIGluIFRyZWVMaXN0IHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VyTmV4dFBhZ2U9XCJHbyB0byB0aGUgbmV4dCBwYWdlXCJcblxuICAgICAgICAgICAgaTE4bi1wYWdlckxhc3RQYWdlPVwia2VuZG8udHJlZWxpc3QucGFnZXJMYXN0UGFnZXxUaGUgbGFiZWwgZm9yIHRoZSBsYXN0IHBhZ2UgYnV0dG9uIGluIFRyZWVMaXN0IHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VyTGFzdFBhZ2U9XCJHbyB0byB0aGUgbGFzdCBwYWdlXCJcblxuICAgICAgICAgICAgaTE4bi1wYWdlclBhZ2U9XCJrZW5kby50cmVlbGlzdC5wYWdlclBhZ2V8VGhlIGxhYmVsIGJlZm9yZSB0aGUgY3VycmVudCBwYWdlIG51bWJlciBpbiB0aGUgVHJlZUxpc3QgcGFnZXJcIlxuICAgICAgICAgICAgcGFnZXJQYWdlPVwiUGFnZVwiXG5cbiAgICAgICAgICAgIGkxOG4tcGFnZXJPZj1cImtlbmRvLnRyZWVsaXN0LnBhZ2VyT2Z8VGhlIGxhYmVsIGJlZm9yZSB0aGUgdG90YWwgcGFnZXMgbnVtYmVyIGluIHRoZSBUcmVlTGlzdCBwYWdlclwiXG4gICAgICAgICAgICBwYWdlck9mPVwib2ZcIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VyUGFnZU51bWJlcklucHV0VGl0bGU9XCJrZW5kby50cmVlbGlzdC5wYWdlclBhZ2VOdW1iZXJJbnB1dFRpdGxlfFRoZSBsYWJlbCBmb3IgdGhlIHBhZ2VyIGlucHV0IGluIHRoZSBUcmVlbGlzdCBwYWdlclwiXG4gICAgICAgICAgICBwYWdlclBhZ2VOdW1iZXJJbnB1dFRpdGxlPVwiUGFnZSBOdW1iZXJcIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VySXRlbXNQZXJQYWdlPVwia2VuZG8udHJlZWxpc3QucGFnZXJJdGVtc1BlclBhZ2V8VGhlIGxhYmVsIGZvciB0aGUgcGFnZSBzaXplIGNob29zZXIgaW4gdGhlIFRyZWVMaXN0IHBhZ2VyXCJcbiAgICAgICAgICAgIHBhZ2VySXRlbXNQZXJQYWdlPVwiaXRlbXMgcGVyIHBhZ2VcIlxuXG4gICAgICAgICAgICBpMThuLXBhZ2VySXRlbXNUb3RhbD1cImtlbmRvLnRyZWVsaXN0LnBhZ2VySXRlbXNUb3RhbHxUaGUgbGFiZWwgYWZ0ZXIgdGhlIHRvdGFsIGl0ZW1zIGNvdW50IGluIHRoZSBUcmVlTGlzdCBwYWdlclwiXG4gICAgICAgICAgICBwYWdlckl0ZW1zVG90YWw9XCJpdGVtcyB0b3RhbFwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyfFRoZSBsYWJlbCBvZiB0aGUgZmlsdGVyIGNlbGwgb3IgaWNvblwiXG4gICAgICAgICAgICBmaWx0ZXI9XCJGaWx0ZXJcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckVxT3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJFcU9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBlcXVhbCBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyRXFPcGVyYXRvcj1cIklzIGVxdWFsIHRvXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJOb3RFcU9wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyTm90RXFPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgbm90IGVxdWFsIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJOb3RFcU9wZXJhdG9yPVwiSXMgbm90IGVxdWFsIHRvXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJJc051bGxPcGVyYXRvcj1cImtlbmRvLnRyZWVsaXN0LmZpbHRlcklzTnVsbE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBpcyBudWxsIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJJc051bGxPcGVyYXRvcj1cIklzIG51bGxcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlcklzTm90TnVsbE9wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVySXNOb3ROdWxsT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGlzIG5vdCBudWxsIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJJc05vdE51bGxPcGVyYXRvcj1cIklzIG5vdCBudWxsXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJJc0VtcHR5T3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJJc0VtcHR5T3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGlzIGVtcHR5IGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJJc0VtcHR5T3BlcmF0b3I9XCJJcyBlbXB0eVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVySXNOb3RFbXB0eU9wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVySXNOb3RFbXB0eU9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBpcyBub3QgZW1wdHkgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlcklzTm90RW1wdHlPcGVyYXRvcj1cIklzIG5vdCBlbXB0eVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBzdGFydHMgd2l0aCBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yPVwiU3RhcnRzIHdpdGhcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckNvbnRhaW5zT3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJDb250YWluc09wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBjb250YWlucyBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyQ29udGFpbnNPcGVyYXRvcj1cIkNvbnRhaW5zXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJOb3RDb250YWluc09wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgZG9lcyBub3QgY29udGFpbiBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvcj1cIkRvZXMgbm90IGNvbnRhaW5cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckVuZHNXaXRoT3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJFbmRzV2l0aE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBlbmRzIHdpdGggZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckVuZHNXaXRoT3BlcmF0b3I9XCJFbmRzIHdpdGhcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckd0ZU9wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyR3RlT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyR3RlT3BlcmF0b3I9XCJJcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckd0T3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJHdE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBncmVhdGVyIHRoYW4gZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckd0T3BlcmF0b3I9XCJJcyBncmVhdGVyIHRoYW5cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckx0ZU9wZXJhdG9yPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyTHRlT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGxlc3MgdGhhbiBvciBlcXVhbCBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyTHRlT3BlcmF0b3I9XCJJcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckx0T3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJMdE9wZXJhdG9yfFRoZSB0ZXh0IG9mIHRoZSBsZXNzIHRoYW4gZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckx0T3BlcmF0b3I9XCJJcyBsZXNzIHRoYW5cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlcklzVHJ1ZT1cImtlbmRvLnRyZWVsaXN0LmZpbHRlcklzVHJ1ZXxUaGUgdGV4dCBvZiB0aGUgSXNUcnVlIGJvb2xlYW4gZmlsdGVyIG9wdGlvblwiXG4gICAgICAgICAgICBmaWx0ZXJJc1RydWU9XCJJcyBUcnVlXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJJc0ZhbHNlPVwia2VuZG8udHJlZWxpc3QuZmlsdGVySXNGYWxzZXxUaGUgdGV4dCBvZiB0aGUgSXNGYWxzZSBib29sZWFuIGZpbHRlciBvcHRpb25cIlxuICAgICAgICAgICAgZmlsdGVySXNGYWxzZT1cIklzIEZhbHNlXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJCb29sZWFuQWxsPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyQm9vbGVhbkFsbHxUaGUgdGV4dCBvZiB0aGUgKEFsbCkgYm9vbGVhbiBmaWx0ZXIgb3B0aW9uXCJcbiAgICAgICAgICAgIGZpbHRlckJvb2xlYW5BbGw9XCIoQWxsKVwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQWZ0ZXJPckVxdWFsT3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJBZnRlck9yRXF1YWxPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgYWZ0ZXIgb3IgZXF1YWwgZGF0ZSBmaWx0ZXIgb3BlcmF0b3JcIlxuICAgICAgICAgICAgZmlsdGVyQWZ0ZXJPckVxdWFsT3BlcmF0b3I9XCJJcyBhZnRlciBvciBlcXVhbCB0b1wiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQWZ0ZXJPcGVyYXRvcj1cImtlbmRvLnRyZWVsaXN0LmZpbHRlckFmdGVyT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGFmdGVyIGRhdGUgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckFmdGVyT3BlcmF0b3I9XCJJcyBhZnRlclwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQmVmb3JlT3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJCZWZvcmVPcGVyYXRvcnxUaGUgdGV4dCBvZiB0aGUgYmVmb3JlIGRhdGUgZmlsdGVyIG9wZXJhdG9yXCJcbiAgICAgICAgICAgIGZpbHRlckJlZm9yZU9wZXJhdG9yPVwiSXMgYmVmb3JlXCJcblxuICAgICAgICAgICAgaTE4bi1maWx0ZXJCZWZvcmVPckVxdWFsT3BlcmF0b3I9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJCZWZvcmVPckVxdWFsT3BlcmF0b3J8VGhlIHRleHQgb2YgdGhlIGJlZm9yZSBvciBlcXVhbCBkYXRlIGZpbHRlciBvcGVyYXRvclwiXG4gICAgICAgICAgICBmaWx0ZXJCZWZvcmVPckVxdWFsT3BlcmF0b3I9XCJJcyBiZWZvcmUgb3IgZXF1YWwgdG9cIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckZpbHRlckJ1dHRvbj1cImtlbmRvLnRyZWVsaXN0LmZpbHRlckZpbHRlckJ1dHRvbnxUaGUgdGV4dCBvZiB0aGUgZmlsdGVyIGJ1dHRvblwiXG4gICAgICAgICAgICBmaWx0ZXJGaWx0ZXJCdXR0b249XCJGaWx0ZXJcIlxuXG4gICAgICAgICAgICBpMThuLWZpbHRlckNsZWFyQnV0dG9uPVwia2VuZG8udHJlZWxpc3QuZmlsdGVyQ2xlYXJCdXR0b258VGhlIHRleHQgb2YgdGhlIGNsZWFyIGZpbHRlciBidXR0b25cIlxuICAgICAgICAgICAgZmlsdGVyQ2xlYXJCdXR0b249XCJDbGVhclwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyQW5kTG9naWM9XCJrZW5kby50cmVlbGlzdC5maWx0ZXJBbmRMb2dpY3xUaGUgdGV4dCBvZiB0aGUgQW5kIGZpbHRlciBsb2dpY1wiXG4gICAgICAgICAgICBmaWx0ZXJBbmRMb2dpYz1cIkFuZFwiXG5cbiAgICAgICAgICAgIGkxOG4tZmlsdGVyT3JMb2dpYz1cImtlbmRvLnRyZWVsaXN0LmZpbHRlck9yTG9naWN8VGhlIHRleHQgb2YgdGhlIE9yIGZpbHRlciBsb2dpY1wiXG4gICAgICAgICAgICBmaWx0ZXJPckxvZ2ljPVwiT3JcIlxuXG4gICAgICAgICAgICBpMThuLWxvYWRpbmc9XCJrZW5kby50cmVlbGlzdC5sb2FkaW5nfFRoZSBsb2FkaW5nIHRleHRcIlxuICAgICAgICAgICAgbG9hZGluZz1cIkxvYWRpbmdcIlxuXG4gICAgICAgICAgICBpMThuLWNvbHVtbk1lbnU9XCJrZW5kby50cmVlbGlzdC5jb2x1bW5NZW51fFRoZSB0aXRsZSBvZiB0aGUgY29sdW1uIG1lbnUgaWNvblwiXG4gICAgICAgICAgICBjb2x1bW5NZW51PVwiQ29sdW1uIE1lbnVcIlxuXG4gICAgICAgICAgICBpMThuLWNvbHVtbnM9XCJrZW5kby50cmVlbGlzdC5jb2x1bW5zfFRoZSB0ZXh0IHNob3duIGluIHRoZSBjb2x1bW4gbWVudSBmb3IgdGhlIGNvbHVtbnMgaXRlbVwiXG4gICAgICAgICAgICBjb2x1bW5zPVwiQ29sdW1uc1wiXG5cbiAgICAgICAgICAgIGkxOG4tbG9jaz1cImtlbmRvLnRyZWVsaXN0LmxvY2t8VGhlIHRleHQgc2hvd24gaW4gdGhlIGNvbHVtbiBtZW51IGZvciB0aGUgbG9jayBpdGVtXCJcbiAgICAgICAgICAgIGxvY2s9XCJMb2NrXCJcblxuICAgICAgICAgICAgaTE4bi11bmxvY2s9XCJrZW5kby50cmVlbGlzdC51bmxvY2t8VGhlIHRleHQgc2hvd24gaW4gdGhlIGNvbHVtbiBtZW51IGZvciB0aGUgdW5sb2NrIGl0ZW1cIlxuICAgICAgICAgICAgdW5sb2NrPVwiVW5sb2NrXCJcblxuICAgICAgICAgICAgaTE4bi1zb3J0YWJsZT1cImtlbmRvLnRyZWVsaXN0LnNvcnRhYmxlfFRoZSBsYWJlbCBvZiB0aGUgc29ydCBpY29uXCJcbiAgICAgICAgICAgIHNvcnRhYmxlPVwiU29ydGFibGVcIlxuXG4gICAgICAgICAgICBpMThuLXNvcnRBc2NlbmRpbmc9XCJrZW5kby50cmVlbGlzdC5zb3J0QXNjZW5kaW5nfFRoZSB0ZXh0IHNob3duIGluIHRoZSBjb2x1bW4gbWVudSBmb3IgdGhlIHNvcnQgYXNjZW5kaW5nIGl0ZW1cIlxuICAgICAgICAgICAgc29ydEFzY2VuZGluZz1cIlNvcnQgQXNjZW5kaW5nXCJcblxuICAgICAgICAgICAgaTE4bi1zb3J0RGVzY2VuZGluZz1cImtlbmRvLnRyZWVsaXN0LnNvcnREZXNjZW5kaW5nfFRoZSB0ZXh0IHNob3duIGluIHRoZSBjb2x1bW4gbWVudSBmb3IgdGhlIHNvcnQgZGVzY2VuZGluZyBpdGVtXCJcbiAgICAgICAgICAgIHNvcnREZXNjZW5kaW5nPVwiU29ydCBEZXNjZW5kaW5nXCJcblxuICAgICAgICAgICAgaTE4bi1zb3J0ZWRBc2NlbmRpbmc9XCJrZW5kby50cmVlbGlzdC5zb3J0ZWRBc2NlbmRpbmd8VGhlIHN0YXR1cyBhbm5vdW5jZW1lbnQgd2hlbiBhIGNvbHVtbiBpcyBzb3J0ZWQgYXNjZW5kaW5nXCJcbiAgICAgICAgICAgIHNvcnRlZEFzY2VuZGluZz1cIlNvcnRlZCBBc2NlbmRpbmdcIlxuXG4gICAgICAgICAgICBpMThuLXNvcnRlZERlc2NlbmRpbmc9XCJrZW5kby50cmVlbGlzdC5zb3J0ZWREZXNjZW5kaW5nfFRoZSBzdGF0dXMgYW5ub3VuY2VtZW50IHdoZW4gYSBjb2x1bW4gaXMgc29ydGVkIGRlc2NlbmRpbmdcIlxuICAgICAgICAgICAgc29ydGVkRGVzY2VuZGluZz1cIlNvcnRlZCBEZXNjZW5kaW5nXCJcblxuICAgICAgICAgICAgaTE4bi1zb3J0ZWREZWZhdWx0PVwia2VuZG8udHJlZWxpc3Quc29ydGVkRGVmYXVsdHxUaGUgc3RhdHVzIGFubm91bmNlbWVudCB3aGVuIGEgY29sdW1uIGlzIG5vIGxvbmdlciBzb3J0ZWRcIlxuICAgICAgICAgICAgc29ydGVkRGVmYXVsdD1cIk5vdCBTb3J0ZWRcIlxuXG4gICAgICAgICAgICBpMThuLWNvbHVtbnNBcHBseT1cImtlbmRvLnRyZWVsaXN0LmNvbHVtbnNBcHBseXxUaGUgdGV4dCBzaG93biBpbiB0aGUgY29sdW1uIG1lbnUgb3IgY29sdW1uIGNob29zZXIgZm9yIHRoZSBjb2x1bW5zIGFwcGx5IGJ1dHRvblwiXG4gICAgICAgICAgICBjb2x1bW5zQXBwbHk9XCJBcHBseVwiXG5cbiAgICAgICAgICAgIGkxOG4tY29sdW1uc1Jlc2V0PVwia2VuZG8udHJlZWxpc3QuY29sdW1uc1Jlc2V0fFRoZSB0ZXh0IHNob3duIGluIHRoZSBjb2x1bW4gbWVudSBvciBjb2x1bW4gY2hvb3NlciBmb3IgdGhlIGNvbHVtbnMgcmVzZXQgYnV0dG9uXCJcbiAgICAgICAgICAgIGNvbHVtbnNSZXNldD1cIlJlc2V0XCJcbiAgICAgICAgID5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxrZW5kby10cmVlbGlzdC10b29sYmFyICpuZ0lmPVwic2hvd1RvcFRvb2xiYXJcIiBwb3NpdGlvbj1cInRvcFwiPjwva2VuZG8tdHJlZWxpc3QtdG9vbGJhcj5cbiAgICAgICAgPGRpdiAjYXJpYVJvb3RcbiAgICAgICAgICAgIGNsYXNzPVwiay1ncmlkLWFyaWEtcm9vdFwiXG4gICAgICAgICAgICByb2xlPVwidHJlZWdyaWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1yb3djb3VudF09XCJhcmlhUm93Q291bnRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1jb2xjb3VudF09XCJhcmlhQ29sQ291bnRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdPVwiYXJpYU11bHRpc2VsZWN0YWJsZVwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG4gICAgICAgICAgICA+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc1Njcm9sbGFibGVcIj5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCIhaGlkZUhlYWRlclwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtaGVhZGVyXCJcbiAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUucGFkZGluZ109XCJoZWFkZXJQYWRkaW5nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImlzTG9ja2VkXCJcbiAgICAgICAgICAgICAgICAgICAgICNsb2NrZWRIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWdyaWQtaGVhZGVyLWxvY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgICBbc3R5bGUud2lkdGgucHhdPVwibG9ja2VkV2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIFtsb2NrZWRdPVwidHJ1ZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBbc3R5bGUud2lkdGgucHhdPVwibG9ja2VkV2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2xncm91cCBrZW5kb1RyZWVMaXN0Q29sR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJsb2NrZWRMZWFmQ29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2xncm91cD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZCBrZW5kb1RyZWVMaXN0SGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jlc2l6YWJsZV09XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzY3JvbGxhYmxlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxvY2tlZENvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbkxldmVsc109XCJ0b3RhbENvbHVtbkxldmVsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRdPVwic29ydFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW9yZGVyYWJsZV09XCJyZW9yZGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudV09XCJjb2x1bW5NZW51T3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbk1lbnVUZW1wbGF0ZV09XCJjb2x1bW5NZW51VGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbnNDb3VudF09XCJsZWFmQ29sdW1ucy5sZW5ndGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+PGRpdiAjaGVhZGVyIGNsYXNzPVwiay1ncmlkLWhlYWRlci13cmFwXCIgcm9sZT1cInByZXNlbnRhdGlvblwiIGRhdGEtc2Nyb2xsYWJsZVxuICAgICAgICAgICAgICAgICAgICBba2VuZG9UcmVlTGlzdFJlc2l6YWJsZUNvbnRhaW5lcl09XCJsb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgICAgICBbbG9ja2VkV2lkdGhdPVwibG9ja2VkV2lkdGggKyBzY3JvbGxiYXJXaWR0aCArIDJcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIHJvbGU9XCJwcmVzZW50YXRpb25cIiBbc3R5bGUud2lkdGgucHhdPVwibm9uTG9ja2VkV2lkdGhcIiBbdmlydHVhbENvbHVtbnNdPVwidmlydHVhbENvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2xncm91cCBrZW5kb1RyZWVMaXN0Q29sR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJoZWFkZXJMZWFmQ29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2xncm91cD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZCBrZW5kb1RyZWVMaXN0SGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jlc2l6YWJsZV09XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzY3JvbGxhYmxlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImhlYWRlckNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbkxldmVsc109XCJ0b3RhbENvbHVtbkxldmVsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRdPVwic29ydFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW9yZGVyYWJsZV09XCJyZW9yZGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudV09XCJjb2x1bW5NZW51T3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbk1lbnVUZW1wbGF0ZV09XCJjb2x1bW5NZW51VGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsb2NrZWRDb2x1bW5zQ291bnRdPVwibG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdG90YWxDb2x1bW5zQ291bnRdPVwibGVhZkNvbHVtbnMubGVuZ3RoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwidmlydHVhbENvbHVtbnNcIiBjbGFzcz1cImstd2lkdGgtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBbc3R5bGUud2lkdGgucHhdPVwiY29sdW1uc0NvbnRhaW5lci51bmxvY2tlZFdpZHRoXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtbGlzdFxuICAgICAgICAgICAgICAgIFt2aWV3XT1cInZpZXdcIlxuICAgICAgICAgICAgICAgIFtsb2FkaW5nXT1cInNob3dMb2FkaW5nXCJcbiAgICAgICAgICAgICAgICBbcm93SGVpZ2h0XT1cInJvd0hlaWdodFwiXG4gICAgICAgICAgICAgICAgW3RvdGFsXT1cInRvdGFsQ291bnRcIlxuICAgICAgICAgICAgICAgIFt0YWtlXT1cInBhZ2VTaXplXCJcbiAgICAgICAgICAgICAgICBbc2tpcF09XCJza2lwXCJcbiAgICAgICAgICAgICAgICBbdHJhY2tCeV09XCJ0cmFja0J5XCJcbiAgICAgICAgICAgICAgICBbY29sdW1uc109XCJjb2x1bW5zQ29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICBbZmlsdGVyYWJsZV09XCJmaWx0ZXJhYmxlXCJcbiAgICAgICAgICAgICAgICBbbm9SZWNvcmRzVGVtcGxhdGVdPVwibm9SZWNvcmRzVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIChwYWdlQ2hhbmdlKT1cIm5vdGlmeVBhZ2VDaGFuZ2UoJ2xpc3QnLCAkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICBbcm93Q2xhc3NdPVwicm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgIFtpc1ZpcnR1YWxdPVwiaXNWaXJ0dWFsXCJcbiAgICAgICAgICAgICAgICBbdmlydHVhbENvbHVtbnNdPVwidmlydHVhbENvbHVtbnNcIlxuICAgICAgICAgICAgICAgIFtleHBhbmRJY29uc109XCJleHBhbmRJY29uc1wiXG4gICAgICAgICAgICAgICAgKHNjcm9sbEJvdHRvbSk9XCJub3RpZnlTY3JvbGxCb3R0b20oKVwiXG4gICAgICAgICAgICAgICAgKGNvbnRlbnRTY3JvbGwpPVwiY29udGVudFNjcm9sbC5lbWl0KCRldmVudClcIlxuXG4gICAgICAgICAgICAgICAga2VuZG9EcmFnZ2FibGVcbiAgICAgICAgICAgICAgICBrZW5kb1RyZWVMaXN0U2VsZWN0aW9uTWFycXVlZVxuICAgICAgICAgICAgICAgIFtlbmFibGVEcmFnXT1cIm1hcnF1ZWVTZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtbGlzdD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc1Njcm9sbGFibGVcIj5cbiAgICAgICAgICAgIDx0YWJsZSBbc3R5bGUudGFibGUtbGF5b3V0XT1cInJlc2l6YWJsZSA/ICdmaXhlZCcgOiBudWxsXCI+XG4gICAgICAgICAgICAgICAgPGNvbGdyb3VwIGtlbmRvVHJlZUxpc3RDb2xHcm91cFxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJsZWFmQ29sdW1uc1wiPlxuICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgPHRoZWFkIGtlbmRvVHJlZUxpc3RIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCIhaGlkZUhlYWRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtyZXNpemFibGVdPVwicmVzaXphYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgW3Njcm9sbGFibGVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJ2aXNpYmxlQ29sdW1uc1wiXG4gICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbkxldmVsc109XCJ0b3RhbENvbHVtbkxldmVsc1wiXG4gICAgICAgICAgICAgICAgICAgIFtyZW9yZGVyYWJsZV09XCJyZW9yZGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzb3J0XT1cInNvcnRcIlxuICAgICAgICAgICAgICAgICAgICBbc29ydGFibGVdPVwic29ydGFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudV09XCJjb2x1bW5NZW51T3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5NZW51VGVtcGxhdGVdPVwiY29sdW1uTWVudVRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHkga2VuZG9UcmVlTGlzdFRhYmxlQm9keVxuICAgICAgICAgICAgICAgICAgICBbdmlld109XCJ2aWV3XCJcbiAgICAgICAgICAgICAgICAgICAgW3NraXBdPVwic2tpcFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcmFibGVdPVwiZmlsdGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtub1JlY29yZHNUZW1wbGF0ZV09XCJub1JlY29yZHNUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFt0cmFja0J5XT1cInRyYWNrQnlcIlxuICAgICAgICAgICAgICAgICAgICBbcm93Q2xhc3NdPVwicm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbZXhwYW5kSWNvbnNdPVwiZXhwYW5kSWNvbnNcIlxuXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RTZWxlY3Rpb25NYXJxdWVlXG4gICAgICAgICAgICAgICAgICAgIFtlbmFibGVEcmFnXT1cIm1hcnF1ZWVTZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd0xvYWRpbmdcIiBrZW5kb1RyZWVMaXN0TG9hZGluZz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LXBhZ2VyXG4gICAgICAgICAgICAqbmdJZj1cInNob3dQYWdlclwiXG4gICAgICAgICAgICBbdGVtcGxhdGVdPVwicGFnZXJUZW1wbGF0ZVwiXG4gICAgICAgICAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIlxuICAgICAgICAgICAgW3RvdGFsXT1cInZpZXcudG90YWxWaXNpYmxlXCJcbiAgICAgICAgICAgIFthbGxDb3VudF09XCJ2aWV3LnRvdGFsXCJcbiAgICAgICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICAgICAgW29wdGlvbnNdPVwicGFnZWFibGVcIlxuICAgICAgICAgICAgKHBhZ2VDaGFuZ2UpPVwibm90aWZ5UGFnZUNoYW5nZSgncGFnZXInLCAkZXZlbnQpXCI+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtcGFnZXI+XG4gICAgICAgIDxrZW5kby10cmVlbGlzdC10b29sYmFyICpuZ0lmPVwic2hvd0JvdHRvbVRvb2xiYXJcIiBwb3NpdGlvbj1cImJvdHRvbVwiPjwva2VuZG8tdHJlZWxpc3QtdG9vbGJhcj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRyZWVMaXN0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQnJvd3NlclN1cHBvcnRTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFZGl0U2VydmljZSB9LFxuICAgIHsgdHlwZTogRmlsdGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogUERGU2VydmljZSB9LFxuICAgIHsgdHlwZTogUmVzcG9uc2l2ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRXhjZWxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFNjcm9sbFN5bmNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBEb21FdmVudHNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDb2x1bW5SZXNpemluZ1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBDb2x1bW5SZW9yZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29sdW1uSW5mb1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5hdmlnYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTb3J0U2VydmljZSB9LFxuICAgIHsgdHlwZTogU2Nyb2xsUmVxdWVzdFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEV4cGFuZFN0YXRlU2VydmljZSB9LFxuICAgIHsgdHlwZTogT3B0aW9uQ2hhbmdlc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNlbGVjdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblRyZWVMaXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGFyaWFMYWJlbDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbCcsXSB9XSxcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWdlU2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGVpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByb3dIZWlnaHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNraXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNjcm9sbGFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRyYWNrQnk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmlydHVhbENvbHVtbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnRhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWdlYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbmF2aWdhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBuYXZpZ2F0YWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYXV0b1NpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJvd0NsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXNpemFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlb3JkZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2FkaW5nOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW5NZW51OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoaWRlSGVhZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpZEZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc1NlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Rpb25DaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBmaWx0ZXJDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBwYWdlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc29ydENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGRhdGFTdGF0ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGVkaXQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjYW5jZWw6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBzYXZlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcmVtb3ZlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgYWRkOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY2VsbENsb3NlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY2VsbENsaWNrOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcGRmRXhwb3J0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgZXhjZWxFeHBvcnQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2x1bW5SZXNpemU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2x1bW5SZW9yZGVyOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY29sdW1uVmlzaWJpbGl0eUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbHVtbkxvY2tlZENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNjcm9sbEJvdHRvbTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRlbnRTY3JvbGw6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBleHBhbmRFdmVudDogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2V4cGFuZCcsXSB9XSxcbiAgICBjb2xsYXBzZUV2ZW50OiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnY29sbGFwc2UnLF0gfV0sXG4gICAgY29sdW1uczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ29sdW1uQmFzZSQxLF0gfV0sXG4gICAgZGlyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpcicsXSB9XSxcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay13aWRnZXQnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRyZWVsaXN0JyxdIH1dLFxuICAgIGxvY2tlZENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZ3JpZC1sb2NrZWRjb2x1bW5zJyxdIH1dLFxuICAgIHZpcnR1YWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQtdmlydHVhbCcsXSB9XSxcbiAgICBub1Njcm9sbGJhckNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQtbm8tc2Nyb2xsYmFyJyxdIH1dLFxuICAgIG5vUmVjb3Jkc1RlbXBsYXRlQ2hpbGRyZW46IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgcGFnZXJUZW1wbGF0ZUNoaWxkcmVuOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtQYWdlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgdG9vbGJhclRlbXBsYXRlQ2hpbGRyZW46IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW1Rvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGNvbHVtbk1lbnVUZW1wbGF0ZXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0NvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGxvY2tlZEhlYWRlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbXCJsb2NrZWRIZWFkZXJcIixdIH1dLFxuICAgIGhlYWRlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbXCJoZWFkZXJcIixdIH1dLFxuICAgIGZvb3RlcjogW3sgdHlwZTogVmlld0NoaWxkcmVuLCBhcmdzOiBbXCJmb290ZXJcIixdIH1dLFxuICAgIGFyaWFSb290OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnYXJpYVJvb3QnLF0gfV0sXG4gICAgZmV0Y2hDaGlsZHJlbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGFzQ2hpbGRyZW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzRXhwYW5kZWQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUm93SGVpZ2h0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IodG90YWwgPSAwLCByb3dIZWlnaHQpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IHJvd0hlaWdodDtcbiAgICAgICAgdGhpcy5yb3dIZWlnaHQgPSByb3dIZWlnaHQgfHwgMDtcbiAgICB9XG4gICAgaW5kZXgocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5mbG9vcihwb3NpdGlvbiAvIHRoaXMucm93SGVpZ2h0KSwgdGhpcy50b3RhbCAtIDEpO1xuICAgIH1cbiAgICBvZmZzZXQocm93SW5kZXgpIHtcbiAgICAgICAgaWYgKDAgPD0gcm93SW5kZXggJiYgcm93SW5kZXggPCB0aGlzLnRvdGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gcm93SW5kZXggKiB0aGlzLnJvd0hlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b3RhbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWwgKiB0aGlzLnJvd0hlaWdodDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTY3JvbGxBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFnZUFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2tpcCwgdGFrZSQkMSkge1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnRha2UgPSB0YWtlJCQxO1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTY3JvbGxCb3R0b21BY3Rpb24ge1xufVxuY29uc3QgU0NST0xMX0JPVFRPTV9USFJFU0hPTEQgPSAxO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNjcm9sbGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsT2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLnNjcm9sbE9ic2VydmFibGUgPSBzY3JvbGxPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLmZpcnN0TG9hZGVkID0gMDtcbiAgICB9XG4gICAgY3JlYXRlKHJvd0hlaWdodFNlcnZpY2UsIHNraXAsIHRha2UkJDEsIHRvdGFsKSB7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0U2VydmljZSA9IHJvd0hlaWdodFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBza2lwO1xuICAgICAgICB0aGlzLmxhc3RMb2FkZWQgPSBza2lwICsgdGFrZSQkMTtcbiAgICAgICAgdGhpcy50YWtlID0gdGFrZSQkMTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChuZXcgU2Nyb2xsQWN0aW9uKHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQoc2tpcCkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsT2JzZXJ2YWJsZS5zdWJzY3JpYmUoeCA9PiB0aGlzLm9uU2Nyb2xsKHgsIG9ic2VydmVyKSk7XG4gICAgICAgIH0pLnN1YnNjcmliZSh4ID0+IHN1YmplY3QubmV4dCh4KSk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNjcm9sbCh7IHNjcm9sbFRvcCwgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9LCBvYnNlcnZlcikge1xuICAgICAgICBpZiAodGhpcy5sYXN0U2Nyb2xsVG9wID09PSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cCA9IHRoaXMubGFzdFNjcm9sbFRvcCA+PSBzY3JvbGxUb3A7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgbGV0IGZpcnN0SXRlbUluZGV4ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmluZGV4KHNjcm9sbFRvcCk7XG4gICAgICAgIGxldCBmaXJzdEl0ZW1PZmZzZXQgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KGZpcnN0SXRlbUluZGV4KTtcbiAgICAgICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5pbmRleChzY3JvbGxUb3AgKyBvZmZzZXRIZWlnaHQpO1xuICAgICAgICBpZiAoIXVwKSB7XG4gICAgICAgICAgICBpZiAobGFzdEl0ZW1JbmRleCA+PSB0aGlzLmxhc3RMb2FkZWQgJiYgdGhpcy5sYXN0TG9hZGVkIDwgdGhpcy50b3RhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gKGZpcnN0SXRlbUluZGV4ICsgdGhpcy50YWtlKSAtIHRoaXMudG90YWw7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEl0ZW1JbmRleCA9IGZpcnN0SXRlbUluZGV4IC0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SXRlbU9mZnNldCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQoZmlyc3RJdGVtSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0TG9hZGVkID0gZmlyc3RJdGVtSW5kZXg7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgU2Nyb2xsQWN0aW9uKGZpcnN0SXRlbU9mZnNldCkpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VGFrZSA9IHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0TG9hZGVkID0gTWF0aC5taW4obmV4dFRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgICAgIG5leHRUYWtlID0gbmV4dFRha2UgPiB0aGlzLnRvdGFsID8gdGhpcy50b3RhbCAtIHRoaXMuZmlyc3RMb2FkZWQgOiB0aGlzLnRha2U7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkLCB0aGlzLnRha2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0Qm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0IC0gc2Nyb2xsVG9wIDwgU0NST0xMX0JPVFRPTV9USFJFU0hPTEQ7XG4gICAgICAgICAgICAgICAgaWYgKGF0Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IFNjcm9sbEJvdHRvbUFjdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwICYmIGZpcnN0SXRlbUluZGV4IDwgdGhpcy5maXJzdExvYWRlZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9uVmlzaWJsZUJ1ZmZlciA9IE1hdGguZmxvb3IodGhpcy50YWtlICogMC4zKTtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RMb2FkZWQgPSBNYXRoLm1heChmaXJzdEl0ZW1JbmRleCAtIG5vblZpc2libGVCdWZmZXIsIDApO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgU2Nyb2xsQWN0aW9uKHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQodGhpcy5maXJzdExvYWRlZCkpKTtcbiAgICAgICAgICAgIHRoaXMubGFzdExvYWRlZCA9IE1hdGgubWluKHRoaXMuZmlyc3RMb2FkZWQgKyB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgUGFnZUFjdGlvbih0aGlzLmZpcnN0TG9hZGVkLCB0aGlzLnRha2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBOT05fREFUQV9DRUxMX0NMQVNTRVMgPSAnay1oaWVyYXJjaHktY2VsbCBrLWRldGFpbC1jZWxsIGstZ3JvdXAtY2VsbCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTk9OX0RBVEFfUk9XX0NMQVNTRVMgPSAnay1ncm91cGluZy1yb3cgay1ncm91cC1mb290ZXIgay1kZXRhaWwtcm93IGstZ3JpZC1ub3JlY29yZHMnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IElHTk9SRV9UQVJHRVRfQ0xBU1NTRVMgPSAnay1pY29uJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBJR05PUkVfQ09OVEFJTkVSX0NMQVNTRVMgPSAnay13aWRnZXQgay10cmVlbGlzdC1pZ25vcmUtY2xpY2snO1xuXG5jb25zdCBlbGVtZW50QXQgPSAoaW5kZXgsIGVsZW1lbnRzLCBlbGVtZW50T2Zmc2V0KSA9PiB7XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgZWxlbWVudElkeCA9IDA7IGlkeCA8IGVsZW1lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZWxlbWVudE9mZnNldChlbGVtZW50c1tpZHhdKTtcbiAgICAgICAgaWYgKGVsZW1lbnRJZHggPD0gaW5kZXggJiYgaW5kZXggPD0gZWxlbWVudElkeCArIG9mZnNldCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1tpZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRJZHggKz0gb2Zmc2V0O1xuICAgIH1cbn07XG5jb25zdCByb3dBdCA9IChpbmRleCwgcm93cykgPT4gZWxlbWVudEF0KGluZGV4LCByb3dzLCByb3cgPT4gcm93Lmhhc0F0dHJpYnV0ZSgnZGF0YS1rZW5kby10cmVlbGlzdC1pdGVtLWluZGV4JykgPyAxIDogMCk7XG5jb25zdCBjZWxsQXQgPSAoaW5kZXgsIGNlbGxzKSA9PiBlbGVtZW50QXQoaW5kZXgsIGNlbGxzLCBjZWxsID0+ICFoYXNDbGFzc2VzKGNlbGwsIE5PTl9EQVRBX0NFTExfQ0xBU1NFUykgPyBwYXJzZUludChjZWxsLmdldEF0dHJpYnV0ZSgnY29sU3BhbicpLCAxMCkgfHwgMSA6IDApO1xuY29uc3QgRU1QVFlfT0JKRUNUID0ge307XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0NST0xMRVJfRkFDVE9SWV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbigndHJlZWxpc3Qtc2Nyb2xsLXNlcnZpY2UtZmFjdG9yeScpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIERFRkFVTFRfU0NST0xMRVJfRkFDVE9SWShvYnNlcnZhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBTY3JvbGxlclNlcnZpY2Uob2JzZXJ2YWJsZSk7XG59XG5jb25zdCB3aGVlbERlbHRhWSA9IChlKSA9PiB7XG4gICAgY29uc3QgZGVsdGFZID0gZS53aGVlbERlbHRhWTtcbiAgICBpZiAoZS53aGVlbERlbHRhICYmIChkZWx0YVkgPT09IHVuZGVmaW5lZCB8fCBkZWx0YVkpKSB7XG4gICAgICAgIHJldHVybiBlLndoZWVsRGVsdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUuZGV0YWlsICYmIGUuYXhpcyA9PT0gZS5WRVJUSUNBTF9BWElTKSB7XG4gICAgICAgIHJldHVybiAoLWUuZGV0YWlsKSAqIDEwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBwcmV2ZW50TG9ja2VkU2Nyb2xsID0gZWwgPT4gZXZlbnQgPT4ge1xuICAgIGNvbnN0IGRlbHRhID0gd2hlZWxEZWx0YVkoZXZlbnQpO1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICBjb25zdCBhbGxvd1Njcm9sbCA9IChzY3JvbGxUb3AgPT09IDAgJiYgMCA8IGRlbHRhKSB8fCAoZWwuc2Nyb2xsSGVpZ2h0IDw9IGVsLm9mZnNldEhlaWdodCArIHNjcm9sbFRvcCAmJiBkZWx0YSA8IDApO1xuICAgIGlmICghYWxsb3dTY3JvbGwpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuY29uc3QgdHJhbnNsYXRlWSA9IChyZW5kZXJlciwgdmFsdWUpID0+IGVsID0+IHJlbmRlcmVyLnNldFN0eWxlKGVsLCBcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlWSgke3ZhbHVlfXB4KWApO1xuY29uc3QgbWF5YmVOYXRpdmVFbGVtZW50ID0gZWwgPT4gZWwgPyBlbC5uYXRpdmVFbGVtZW50IDogbnVsbDtcbmNvbnN0IGhhc1Njcm9sbGJhciA9IChlbCwgcGFyZW50KSA9PiBlbC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoID4gcGFyZW50Lm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGg7XG5jb25zdCBzZXRIZWlnaHQkMSA9IHJlbmRlcmVyID0+ICh7IGVsLCBoZWlnaHQgfSkgPT4gcmVuZGVyZXIuc2V0U3R5bGUoZWwsIFwiaGVpZ2h0XCIsIGAke2hlaWdodH1weGApO1xuY29uc3QgYnVmZmVyU2l6ZSA9IDE7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsZXJGYWN0b3J5LCBjaGFuZ2VOb3RpZmljYXRpb24sIHN1c3BlbmRTZXJ2aWNlLCBuZ1pvbmUsIHJlbmRlcmVyLCBzY3JvbGxTeW5jU2VydmljZSwgcmVzaXplU2VydmljZSwgZWRpdFNlcnZpY2UsIHN1cHBvcnRTZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZSwgc2Nyb2xsUmVxdWVzdFNlcnZpY2UsIGxvY2FsaXphdGlvbiwgY29sdW1uUmVzaXppbmdTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvciwgcGRmU2VydmljZSwgY29sdW1uSW5mbykge1xuICAgICAgICB0aGlzLmNoYW5nZU5vdGlmaWNhdGlvbiA9IGNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5zdXNwZW5kU2VydmljZSA9IHN1c3BlbmRTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnNjcm9sbFN5bmNTZXJ2aWNlID0gc2Nyb2xsU3luY1NlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IHJlc2l6ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0U2VydmljZSA9IHN1cHBvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZSA9IGNvbHVtblJlc2l6aW5nU2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLnBkZlNlcnZpY2UgPSBwZGZTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm8gPSBjb2x1bW5JbmZvO1xuICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBuZXcgQ29sdW1uc0NvbnRhaW5lcigoKSA9PiBbXSk7XG4gICAgICAgIHRoaXMudHJhY2tCeSA9IGRlZmF1bHRUcmFja0J5O1xuICAgICAgICB0aGlzLmNvbnRlbnRTY3JvbGwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCb3R0b20gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29sdW1uc1N0YXJ0SWR4ID0gMDtcbiAgICAgICAgdGhpcy5yZXNpemVTZW5zb3JzID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyU2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxlciA9IHNjcm9sbGVyRmFjdG9yeSh0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBzY3JvbGxSZXF1ZXN0U2VydmljZS5yZXF1ZXN0cy5zdWJzY3JpYmUoeCA9PiB0aGlzLnNjcm9sbFRvKHgpKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBob3N0Um9sZSgpIHtcbiAgICAgICAgcmV0dXJuICdwcmVzZW50YXRpb24nO1xuICAgIH1cbiAgICBnZXQgdG90YWxXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMgJiYgdGhpcy5jb2x1bW5zLnVubG9ja2VkV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMudW5sb2NrZWRXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbG9ja2VkTGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMubG9ja2VkTGVhZkNvbHVtbnM7XG4gICAgfVxuICAgIGdldCBub25Mb2NrZWRMZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy5ub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IG5vbkxvY2tlZENvbHVtbnNUb1JlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbENvbHVtbnMgJiYgIXRoaXMucGRmU2VydmljZS5leHBvcnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0Q29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub25Mb2NrZWRMZWFmQ29sdW1ucztcbiAgICB9XG4gICAgZ2V0IGxlYWZDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmxlYWZDb2x1bW5zVG9SZW5kZXI7XG4gICAgfVxuICAgIGdldCBsb2NrZWRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZENvbHVtbnModGhpcy5sb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCkpLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIChjdXJyLndpZHRoIHx8IDApLCAwKTtcbiAgICB9XG4gICAgZ2V0IG5vbkxvY2tlZFdpZHRoKCkge1xuICAgICAgICBpZiAoKCF0aGlzLnJ0bCAmJiB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCkgfHwgdGhpcy52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIHN1bUNvbHVtbldpZHRocyhleHBhbmRDb2x1bW5zKHRoaXMubm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyLnRvQXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKHRoaXMuaGFuZGxlUm93U3luYy5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIodGhpcy5oYW5kbGVSb3dOYXZpZ2F0aW9uTG9ja2VkLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChtZXJnZSh0aGlzLmNvbHVtbnMuY2hhbmdlcywgdGhpcy5yZXNpemVTZXJ2aWNlLmNoYW5nZXMpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRDb2x1bW5zKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4gdGhpcy5ydGwgPSBydGwpKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKFwic2tpcFwiLCBjaGFuZ2VzKSAmJiAhdGhpcy5yZWJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMucm93SGVpZ2h0U2VydmljZS5vZmZzZXQodGhpcy5za2lwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlZChbXCJ0b3RhbFwiLCBcInRha2VcIl0sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYmluZCA9IGZhbHNlO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxDb2x1bW5zICYmICghdGhpcy52aWV3cG9ydENvbHVtbnMgfHwgdGhpcy52aWV3cG9ydFdpZHRoQ2hhbmdlKCkpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0Q29sdW1ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2tpcCAmJiB0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2Uub2Zmc2V0KHRoaXMuc2tpcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpO1xuICAgICAgICB0aGlzLmF0dGFjaENvbnRhaW5lclNjcm9sbCgpO1xuICAgICAgICB0aGlzLmluaXRSZXNpemVTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHN5bmNSb3dzSGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHN5bmNSb3dzSGVpZ2h0KHRoaXMubG9ja2VkVGFibGUubmF0aXZlRWxlbWVudCwgdGhpcy50YWJsZS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzaXplU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFudXBTY3JvbGxlcigpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAodGhpcy5zdXNwZW5kU2VydmljZS5zY3JvbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0hlaWdodFNlcnZpY2UgPSBuZXcgUm93SGVpZ2h0U2VydmljZSh0aGlzLnRvdGFsLCB0aGlzLnJvd0hlaWdodCk7XG4gICAgICAgIHRoaXMudG90YWxIZWlnaHQgPSB0aGlzLnJvd0hlaWdodFNlcnZpY2UudG90YWxIZWlnaHQoKTtcbiAgICAgICAgaWYgKCFpc1VuaXZlcnNhbCgpKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcih0aGlzLmNyZWF0ZVNjcm9sbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaENvbnRhaW5lclNjcm9sbCgpIHtcbiAgICAgICAgaWYgKGlzVW5pdmVyc2FsKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGZyb21FdmVudCh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnc2Nyb2xsJykucGlwZShtYXAoKGV2ZW50KSA9PiBldmVudC50YXJnZXQpLCBmaWx0ZXIoKCkgPT4gIXRoaXMuc3VzcGVuZFNlcnZpY2Uuc2Nyb2xsKSwgdGFwKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29udGFpbmVyU2Nyb2xsKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29sdW1uU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvd1ZpZXdwb3J0ID0gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS52aWV3cG9ydCB8fCBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uVmlld3BvcnQgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNvbHVtblZpZXdwb3J0IHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTY3JvbGwuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQ6IHRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHRhcmdldC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Um93OiByb3dWaWV3cG9ydC5maXJzdEl0ZW1JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZW5kUm93OiByb3dWaWV3cG9ydC5sYXN0SXRlbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogY29sdW1uVmlld3BvcnQuZmlyc3RJdGVtSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZENvbHVtbjogY29sdW1uVmlld3BvcnQubGFzdEl0ZW1JbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnN1YnNjcmliZSh0aGlzLmRpc3BhdGNoZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luY1NlcnZpY2UucmVnaXN0ZXJFbWl0dGVyKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIFwiYm9keVwiKTtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChtZXJnZShmcm9tRXZlbnQodGhpcy5sb2NrZWRDb250YWluZXIubmF0aXZlRWxlbWVudCwgJ21vdXNld2hlZWwnKSwgZnJvbUV2ZW50KHRoaXMubG9ja2VkQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdET01Nb3VzZVNjcm9sbCcpKS5waXBlKGZpbHRlcigoZXZlbnQpID0+ICFldmVudC5jdHJsS2V5KSwgdGFwKHByZXZlbnRMb2NrZWRTY3JvbGwodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCkpLCBtYXAod2hlZWxEZWx0YVkpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHggPT4gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgLT0geCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoZnJvbUV2ZW50KHRoaXMubG9ja2VkQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdzY3JvbGwnKS5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5zdXNwZW5kU2VydmljZS5zY3JvbGwpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9ja2VkU2Nyb2xsVG9wID0gdGhpcy5sb2NrZWRDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NrZWRTY3JvbGxUb3AgIT09IHRoaXMuY29udGFpbmVyU2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuY29udGFpbmVyU2Nyb2xsVG9wID0gbG9ja2VkU2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoZnJvbUV2ZW50KHRoaXMubG9ja2VkQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdrZXlkb3duJykucGlwZShmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC5rZXlDb2RlID09PSBLZXlzLlBhZ2VEb3duIHx8IGV2ZW50LmtleUNvZGUgPT09IEtleXMuUGFnZVVwKSkuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBldmVudC5rZXlDb2RlID09PSBLZXlzLlBhZ2VEb3duID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiBkaXIgKiAwLjg7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNSb3dzSGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU2Nyb2xsZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFNjcm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGUgPSB0aGlzLnNjcm9sbGVyXG4gICAgICAgICAgICAuY3JlYXRlKHRoaXMucm93SGVpZ2h0U2VydmljZSwgdGhpcy5za2lwLCB0aGlzLnRha2UsIHRoaXMudG90YWwpO1xuICAgICAgICB0aGlzLnNraXBTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUucGlwZShmaWx0ZXIoKHgpID0+IHggaW5zdGFuY2VvZiBQYWdlQWN0aW9uKSwgZmlsdGVyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSB0aGlzLnNraXBTY3JvbGw7XG4gICAgICAgICAgICB0aGlzLnNraXBTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAhdGVtcDtcbiAgICAgICAgfSksIHRhcCgoKSA9PiB0aGlzLnJlYmluZCA9IHRydWUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeCkgPT4gdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMucGFnZUNoYW5nZS5lbWl0KHgpKSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJTdWJzY3JpcHRpb24uYWRkKG9ic2VydmFibGUucGlwZShmaWx0ZXIoKHgpID0+IHggaW5zdGFuY2VvZiBTY3JvbGxBY3Rpb24pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnNjcm9sbC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJTdWJzY3JpcHRpb24uYWRkKG9ic2VydmFibGUucGlwZShmaWx0ZXIoKHgpID0+IHggaW5zdGFuY2VvZiBTY3JvbGxCb3R0b21BY3Rpb24pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNjcm9sbEJvdHRvbS5lbWl0KCkpKTtcbiAgICB9XG4gICAgc2Nyb2xsKHsgb2Zmc2V0ID0gMCB9KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIG1heWJlTmF0aXZlRWxlbWVudCh0aGlzLnRhYmxlKSxcbiAgICAgICAgICAgICAgICBtYXliZU5hdGl2ZUVsZW1lbnQodGhpcy5sb2NrZWRUYWJsZSlcbiAgICAgICAgICAgIF0uZmlsdGVyKGlzUHJlc2VudCkuZm9yRWFjaCh0cmFuc2xhdGVZKHRoaXMucmVuZGVyZXIsIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXROYXZpZ2F0aW9uVmlld3BvcnQoKTtcbiAgICB9XG4gICAgb25Db250YWluZXJTY3JvbGwoeyBzY3JvbGxUb3AgfSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lclNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2tlZENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVSb3dTeW5jKCkge1xuICAgICAgICBjb25zdCBpc0xvY2tlZCA9ICgpID0+IGlzUHJlc2VudCh0aGlzLmxvY2tlZENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBtZXJnZSh0aGlzLmNoYW5nZU5vdGlmaWNhdGlvbi5jaGFuZ2VzLCB0aGlzLmVkaXRTZXJ2aWNlLmNoYW5nZWQsIHRoaXMucmVzaXplU2VydmljZS5jaGFuZ2VzLCB0aGlzLmNvbHVtblJlc2l6aW5nU2VydmljZS5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoY2hhbmdlID0+IGNoYW5nZS50eXBlID09PSAnZW5kJykpLCB0aGlzLnN1cHBvcnRTZXJ2aWNlLmNoYW5nZXMpXG4gICAgICAgICAgICAucGlwZSh0YXAoKCkgPT4gdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpKSwgZmlsdGVyKGlzTG9ja2VkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5zeW5jUm93c0hlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5zeW5jQ29udGFpbmVySGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLmxvY2tlZENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgLy8gZml4ZXMgc2Nyb2xsIGxlZnQgcG9zaXRpb24gaW4gSUUgd2hlbiBlZGl0aW5nXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hY2NlcHRTaXplKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUm93TmF2aWdhdGlvbkxvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY2hhbmdlcy5waXBlKGZpbHRlcigoKSA9PiBpc1ByZXNlbnQodGhpcy5sb2NrZWRDb250YWluZXIpKSwgZGVsYXkoMTApKS5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aCA8PSBhcmdzLnByZXZDb2xJbmRleCAmJiBhcmdzLmNvbEluZGV4IDwgdGhpcy5sb2NrZWRMZWFmQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuY29sSW5kZXggKyBjZWxsLmNvbFNwYW4gPCBhcmdzLnByZXZDb2xJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjcm9sbFRvVmlydHVhbFJvdyhpdGVtSW5kZXgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLm9mZnNldChpdGVtSW5kZXgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5yZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpO1xuICAgIH1cbiAgICBzY3JvbGxUbyh7IHJvdywgY29sdW1uIH0pIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHJvdykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmlydHVhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9WaXJ0dWFsUm93KHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcm93QXQocm93LCB0aGlzLnRhYmxlLm5hdGl2ZUVsZW1lbnQucm93cyk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNvbHVtbikpIHtcbiAgICAgICAgICAgIGNvbHVtbiAtPSB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucy5sZWFmQ29sdW1uc1RvUmVuZGVyO1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvbHVtbjsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNvbHVtbnNbaWR4XS53aWR0aCB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB0aGlzLm5vcm1hbGl6ZVNjcm9sbExlZnQob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Um93ID0gcm93QXQoMCwgdGhpcy50YWJsZS5uYXRpdmVFbGVtZW50LnJvd3MpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY2VsbEF0KGNvbHVtbiwgZmlyc3RSb3cuY2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50U2Nyb2xsTGVmdChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldE5hdmlnYXRpb25WaWV3cG9ydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lciB8fFxuICAgICAgICAgICAgIXRoaXMubmF2aWdhdGlvblNlcnZpY2UubmVlZHNWaWV3cG9ydCgpIHx8IHRoaXMudmlldy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgb2Zmc2V0SGVpZ2h0IH0gPSB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBzY3JvbGxCb3R0b20gPSBzY3JvbGxUb3AgKyBvZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGZpcnN0SXRlbUluZGV4ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmluZGV4KHNjcm9sbFRvcCk7XG4gICAgICAgIGxldCBsYXN0SXRlbUluZGV4ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLmluZGV4KHNjcm9sbEJvdHRvbSk7XG4gICAgICAgIGNvbnN0IGxhc3RJdGVtT2Zmc2V0ID0gdGhpcy5yb3dIZWlnaHRTZXJ2aWNlLm9mZnNldChsYXN0SXRlbUluZGV4KTtcbiAgICAgICAgY29uc3QgbGFzdEl0ZW1PdmVyZmxvd3MgPSBsYXN0SXRlbU9mZnNldCArIHRoaXMucm93SGVpZ2h0ID4gc2Nyb2xsQm90dG9tO1xuICAgICAgICBpZiAobGFzdEl0ZW1JbmRleCA+IDAgJiYgbGFzdEl0ZW1PdmVyZmxvd3MpIHtcbiAgICAgICAgICAgIGxhc3RJdGVtSW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNldFZpZXdwb3J0KGZpcnN0SXRlbUluZGV4LCBsYXN0SXRlbUluZGV4KTtcbiAgICB9XG4gICAgY2xlYW51cFNjcm9sbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxlclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UmVzaXplU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmNvbm5lY3QobWVyZ2UoLi4udGhpcy5yZXNpemVTZW5zb3JzLm1hcChzZW5zb3IgPT4gc2Vuc29yLnJlc2l6ZSkpKTtcbiAgICB9XG4gICAgc3luY0NvbnRhaW5lckhlaWdodCgpIHtcbiAgICAgICAgW21heWJlTmF0aXZlRWxlbWVudCh0aGlzLmxvY2tlZENvbnRhaW5lcildXG4gICAgICAgICAgICAuZmlsdGVyKGlzUHJlc2VudClcbiAgICAgICAgICAgIC5tYXAoZWwgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaGFzU2Nyb2xsYmFyKHRoaXMudGFibGUsIHRoaXMuY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLnN1cHBvcnRTZXJ2aWNlLnNjcm9sbGJhcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZWwsIGhlaWdodCB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goc2V0SGVpZ2h0JDEodGhpcy5yZW5kZXJlcikpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydENvbHVtbnMocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucy5ub25Mb2NrZWRMZWFmQ29sdW1ucy50b0FycmF5KCk7XG4gICAgICAgIGxldCB7IHN0YXJ0SWR4LCBlbmRJZHgsIG9mZnNldCB9ID0gcmFuZ2UgfHwgdGhpcy5jYWxjdWxhdGVWaWV3cG9ydENvbHVtbnMoKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydElkeCAtIGJ1ZmZlclNpemUpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRJZHggKyBidWZmZXJTaXplLCBjb2x1bW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoc3RhcnQgPCBzdGFydElkeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gc3RhcnRJZHggLSAxOyBpZHggPj0gc3RhcnQ7IGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09IGNvbHVtbnNbaWR4XS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudENvbHVtbnMgPSBjb2x1bW5zLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydENvbHVtbnNXaWR0aCA9IGN1cnJlbnRDb2x1bW5zLnJlZHVjZSgodG90YWwsIGNvbHVtbikgPT4gdG90YWwgKyBjb2x1bW4ud2lkdGgsIDApO1xuICAgICAgICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRDb2x1bW4gPSBuZXcgQ29sdW1uQmFzZSQxKCk7XG4gICAgICAgICAgICBvZmZzZXRDb2x1bW4ud2lkdGggPSBvZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1ucy51bnNoaWZ0KG9mZnNldENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydENvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMudmlld3BvcnRDb2x1bW5zLnJlc2V0KGN1cnJlbnRDb2x1bW5zKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU3RhcnRJZHggPSBzdGFydDtcbiAgICAgICAgdGhpcy5jb2x1bW5zRW5kSWR4ID0gZW5kO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm8uY29sdW1uUmFuZ2VDaGFuZ2UuZW1pdCh7IHN0YXJ0LCBlbmQsIG9mZnNldCB9KTtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5WaWV3cG9ydChzdGFydElkeCwgZW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDb2x1bW5TY3JvbGwoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBjb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdCAhPT0gc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jYWxjdWxhdGVWaWV3cG9ydENvbHVtbnMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1uVmlld3BvcnQocmFuZ2Uuc3RhcnRJZHgsIHJhbmdlLmVuZElkeCk7XG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRJZHggPCB0aGlzLmNvbHVtbnNTdGFydElkeCB8fCB0aGlzLmNvbHVtbnNFbmRJZHggPCByYW5nZS5lbmRJZHgpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNvbHVtblVwZGF0ZUZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblVwZGF0ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRDb2x1bW5zKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtblZpZXdwb3J0KHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgY29uc3QgbG9ja2VkQ291bnQgPSB0aGlzLmxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGVhZkNvbHVtbnMkJDEgPSB0aGlzLm5vbkxvY2tlZExlYWZDb2x1bW5zLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRTdGFydCA9IGxvY2tlZENvdW50ICsgc3RhcnRJZHg7XG4gICAgICAgIGxldCB2aWV3cG9ydEVuZCA9IGxvY2tlZENvdW50ICsgZW5kSWR4O1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsZWFmQ29sdW1ucyQkMS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBsZWFmQ29sdW1ucyQkMVtpZHhdO1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5pc1NwYW5Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydEVuZCArPSBjb2x1bW4uY2hpbGRDb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNldENvbHVtblZpZXdwb3J0KHZpZXdwb3J0U3RhcnQsIHZpZXdwb3J0RW5kKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlVmlld3BvcnRDb2x1bW5zKCkge1xuICAgICAgICBjb25zdCB7IHNjcm9sbExlZnQsIGNsaWVudFdpZHRoIH0gPSB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zLm5vbkxvY2tlZExlYWZDb2x1bW5zLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFNjcm9sbExlZnQgPSB0aGlzLm5vcm1hbGl6ZVNjcm9sbExlZnQoc2Nyb2xsTGVmdCk7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0RW5kID0gbm9ybWFsaXplZFNjcm9sbExlZnQgKyBjbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IHN0YXJ0SWR4O1xuICAgICAgICBsZXQgZW5kSWR4ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGlkeDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBjb2x1bW5zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaWR4XTtcbiAgICAgICAgICAgIGN1cnJlbnQgKz0gY29sdW1uLndpZHRoIHx8IDA7XG4gICAgICAgICAgICBpZiAoc3RhcnRJZHggPT09IHVuZGVmaW5lZCAmJiBjdXJyZW50ID4gbm9ybWFsaXplZFNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydElkeCA9IGlkeDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjdXJyZW50IC0gKGNvbHVtbi53aWR0aCB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID49IHZpZXdwb3J0RW5kKSB7XG4gICAgICAgICAgICAgICAgZW5kSWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kSWR4ICYmIGlkeCA+IDApIHtcbiAgICAgICAgICAgIGVuZElkeCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydElkeCwgZW5kSWR4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgdmlld3BvcnRXaWR0aENoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFdpZHRoID0gdGhpcy52aWV3cG9ydENvbHVtbnMudG9BcnJheSgpLnJlZHVjZSgodG90YWwsIGNvbHVtbikgPT4gdG90YWwgKyBjb2x1bW4ud2lkdGgsIDApO1xuICAgICAgICByZXR1cm4gY3VycmVudFdpZHRoICE9PSB0aGlzLnZpZXdwb3J0Q29sdW1uc1dpZHRoO1xuICAgIH1cbiAgICBub3JtYWxpemVTY3JvbGxMZWZ0KHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ0bCA/IHJ0bFNjcm9sbFBvc2l0aW9uKHBvc2l0aW9uLCB0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB0aGlzLnN1cHBvcnRTZXJ2aWNlLnJ0bFNjcm9sbExlZnQpIDogcG9zaXRpb247XG4gICAgfVxuICAgIGVsZW1lbnRTY3JvbGxMZWZ0KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucnRsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVTY3JvbGxMZWZ0KHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50Lm9mZnNldExlZnQgLSBlbGVtZW50Lm9mZnNldFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgIH1cbn1cbkxpc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogU0NST0xMRVJfRkFDVE9SWV9UT0tFTixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBERUZBVUxUX1NDUk9MTEVSX0ZBQ1RPUllcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1saXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgI2xvY2tlZENvbnRhaW5lciBjbGFzcz1cImstZ3JpZC1jb250ZW50LWxvY2tlZFwiIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAqbmdJZj1cImlzTG9ja2VkXCIgW3N0eWxlLndpZHRoLnB4XT1cImxvY2tlZFdpZHRoXCI+XG4gICAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiay1ncmlkLXRhYmxlLXdyYXBcIj5cbiAgICAgICAgICAgIDx0YWJsZSBbbG9ja2VkXT1cInRydWVcIiAjbG9ja2VkVGFibGUgY2xhc3M9XCJrLWdyaWQtdGFibGVcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgW3N0eWxlLndpZHRoLnB4XT1cImxvY2tlZFdpZHRoXCI+XG4gICAgICAgICAgICAgICAgPGNvbGdyb3VwIGtlbmRvVHJlZUxpc3RDb2xHcm91cFxuICAgICAgICAgICAgICAgICAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwibG9ja2VkTGVhZkNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgICAgICAgICAgIDx0Ym9keSBrZW5kb1RyZWVMaXN0VGFibGVCb2R5XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbaXNMb2NrZWRdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFt2aWV3XT1cInZpZXdcIlxuICAgICAgICAgICAgICAgICAgICBbbm9SZWNvcmRzVGV4dF09XCInJ1wiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxvY2tlZExlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICAgICAgW3RvdGFsQ29sdW1uc0NvdW50XT1cImxlYWZDb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgIFtza2lwXT1cInNraXBcIlxuICAgICAgICAgICAgICAgICAgICBbdHJhY2tCeV09XCJ0cmFja0J5XCJcbiAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcmFibGVdPVwiZmlsdGVyYWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtyb3dDbGFzc109XCJyb3dDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgIFtleHBhbmRJY29uc109XCJleHBhbmRJY29uc1wiPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3I+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstaGVpZ2h0LWNvbnRhaW5lclwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgICAgIDxkaXYgW3N0eWxlLmhlaWdodC5weF09XCJ0b3RhbEhlaWdodFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj48ZGl2ICNjb250YWluZXJcbiAgICAgICAgICAgICAgIGNsYXNzPVwiay1ncmlkLWNvbnRlbnQgay12aXJ0dWFsLWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgW2tlbmRvVHJlZUxpc3RSZXNpemFibGVDb250YWluZXJdPVwibG9ja2VkTGVhZkNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgIFtsb2NrZWRXaWR0aF09XCJsb2NrZWRXaWR0aCArIDFcIj5cbiAgICAgICAgPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJrLWdyaWQtdGFibGUtd3JhcFwiPlxuICAgICAgICAgICAgPHRhYmxlIFtzdHlsZS53aWR0aC5weF09XCJub25Mb2NrZWRXaWR0aFwiICN0YWJsZSBbdmlydHVhbENvbHVtbnNdPVwidmlydHVhbENvbHVtbnNcIlxuICAgICAgICAgICAgICBjbGFzcz1cImstZ3JpZC10YWJsZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgICAgICAgICA8Y29sZ3JvdXAga2VuZG9UcmVlTGlzdENvbEdyb3VwXG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJub25Mb2NrZWRDb2x1bW5zVG9SZW5kZXJcIj5cbiAgICAgICAgICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgICAgICAgICAgIDx0Ym9keSBrZW5kb1RyZWVMaXN0VGFibGVCb2R5XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbdmlld109XCJ2aWV3XCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwibm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2FsbENvbHVtbnNdPVwibm9uTG9ja2VkTGVhZkNvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICBbbm9SZWNvcmRzVGVtcGxhdGVdPVwibm9SZWNvcmRzVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbbG9ja2VkQ29sdW1uc0NvdW50XT1cImxvY2tlZExlYWZDb2x1bW5zLmxlbmd0aFwiXG4gICAgICAgICAgICAgICAgICAgIFt0b3RhbENvbHVtbnNDb3VudF09XCJsZWFmQ29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgICAgICBbc2tpcF09XCJza2lwXCJcbiAgICAgICAgICAgICAgICAgICAgW3RyYWNrQnldPVwidHJhY2tCeVwiXG4gICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJhYmxlXT1cImZpbHRlcmFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbcm93Q2xhc3NdPVwicm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICBbdmlydHVhbENvbHVtbnNdPVwidmlydHVhbENvbHVtbnNcIlxuICAgICAgICAgICAgICAgICAgICBbZXhwYW5kSWNvbnNdPVwiZXhwYW5kSWNvbnNcIj5cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yICpuZ0lmPVwiaXNMb2NrZWRcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAqbmdJZj1cImlzTG9ja2VkIHx8IHZpcnR1YWxDb2x1bW5zXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1oZWlnaHQtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBbc3R5bGUuaGVpZ2h0LnB4XT1cInRvdGFsSGVpZ2h0XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2ICpuZ0lmPVwidmlydHVhbENvbHVtbnNcIiBjbGFzcz1cImstd2lkdGgtY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICAgICAgPGRpdiBbc3R5bGUud2lkdGgucHhdPVwidG90YWxXaWR0aFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2ICpuZ0lmPVwibG9hZGluZ1wiIGtlbmRvVHJlZUxpc3RMb2FkaW5nPlxuICAgIDwvZGl2PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTGlzdENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbU0NST0xMRVJfRkFDVE9SWV9UT0tFTixdIH1dIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTdXNwZW5kU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IFNjcm9sbFN5bmNTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZXNpemVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFZGl0U2VydmljZSB9LFxuICAgIHsgdHlwZTogQnJvd3NlclN1cHBvcnRTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYXZpZ2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogU2Nyb2xsUmVxdWVzdFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENvbHVtblJlc2l6aW5nU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFBERlNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENvbHVtbkluZm9TZXJ2aWNlIH1cbl07XG5MaXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFtcImNsYXNzLmstZ3JpZC1jb250YWluZXJcIixdIH1dLFxuICAgIGhvc3RSb2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogW1wiYXR0ci5yb2xlXCIsXSB9XSxcbiAgICB2aWV3OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0b3RhbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm93SGVpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0YWtlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBza2lwOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW5zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBub1JlY29yZHNUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm93Q2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvYWRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRyYWNrQnk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpcnR1YWxDb2x1bW5zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc1ZpcnR1YWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGV4cGFuZEljb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb250ZW50U2Nyb2xsOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcGFnZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNjcm9sbEJvdHRvbTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRhaW5lcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbXCJjb250YWluZXJcIiwgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIGxvY2tlZENvbnRhaW5lcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbXCJsb2NrZWRDb250YWluZXJcIixdIH1dLFxuICAgIGxvY2tlZFRhYmxlOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtcImxvY2tlZFRhYmxlXCIsXSB9XSxcbiAgICB0YWJsZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbXCJ0YWJsZVwiLF0gfV0sXG4gICAgcmVzaXplU2Vuc29yczogW3sgdHlwZTogVmlld0NoaWxkcmVuLCBhcmdzOiBbUmVzaXplU2Vuc29yQ29tcG9uZW50LF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNZXNzYWdlcyBleHRlbmRzIENvbXBvbmVudE1lc3NhZ2VzIHtcbn1cbk1lc3NhZ2VzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGdyb3VwUGFuZWxFbXB0eTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbm9SZWNvcmRzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWdlckZpcnN0UGFnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFnZXJMYXN0UGFnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFnZXJQcmV2aW91c1BhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZ2VyTmV4dFBhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZ2VyUGFnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFnZXJQYWdlTnVtYmVySW5wdXRUaXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFnZXJJdGVtc1BlclBhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZ2VyT2Y6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZ2VySXRlbXNUb3RhbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJFcU9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJOb3RFcU9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJJc051bGxPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVySXNOb3ROdWxsT3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcklzRW1wdHlPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVySXNOb3RFbXB0eU9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJTdGFydHNXaXRoT3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlckNvbnRhaW5zT3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlck5vdENvbnRhaW5zT3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlckVuZHNXaXRoT3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlckd0ZU9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJHdE9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJMdGVPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyTHRPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVySXNUcnVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJJc0ZhbHNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJCb29sZWFuQWxsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJBZnRlck9yRXF1YWxPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyQWZ0ZXJPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyQmVmb3JlT3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlckJlZm9yZU9yRXF1YWxPcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyRmlsdGVyQnV0dG9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJDbGVhckJ1dHRvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyQW5kTG9naWM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlck9yTG9naWM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvYWRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbk1lbnU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvY2s6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHVubG9jazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc29ydGFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnRBc2NlbmRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnREZXNjZW5kaW5nOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzb3J0ZWRBc2NlbmRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnRlZERlc2NlbmRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnRlZERlZmF1bHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbnNBcHBseTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uc1Jlc2V0OiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlIGV4dGVuZHMgTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB9XG59XG5Mb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0TG9jYWxpemVkTWVzc2FnZXNdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Mb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBDdXN0b20gY29tcG9uZW50IG1lc3NhZ2VzIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50IG1lc3NhZ2VzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGdsb2JhbGl6YXRpb25fdHJlZWxpc3QgJX0jdG9jLWxvY2FsaXphdGlvbikpLlxuICovXG5jbGFzcyBDdXN0b21NZXNzYWdlc0NvbXBvbmVudCBleHRlbmRzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuQ3VzdG9tTWVzc2FnZXNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDdXN0b21NZXNzYWdlc0NvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1tZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVyUm93Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmZpbHRlclJvd0NsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJMYWJlbCA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgnZmlsdGVyJyk7XG4gICAgfVxufVxuRmlsdGVyUm93Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEZpbHRlclJvd10nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zOyBsZXQgY29sdW1uSW5kZXggPSBpbmRleFwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJmaWx0ZXJMYWJlbFwiXG4gICAgICAgICAga2VuZG9UcmVlTGlzdEZpbHRlckNlbGxcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICBrZW5kb1RyZWVMaXN0TG9naWNhbENlbGxcbiAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4XCJcbiAgICAgICAgICAgIFtsb2dpY2FsQ29sSW5kZXhdPVwibG9ja2VkQ29sdW1uc0NvdW50ICsgY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2NvbEluZGV4XT1cImNvbHVtbkluZGV4XCJcbiAgICAgID48L3RkPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRmlsdGVyUm93Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuRmlsdGVyUm93Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9naWNhbFJvd0luZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2NrZWRDb2x1bW5zQ291bnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlclJvd0NsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZpbHRlci1yb3cnLF0gfV1cbn07XG5cbmNvbnN0IGNvcHlPYmplY3QgPSAob2JqKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIG9iaik7XG4gICAgaWYgKG9iai5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdjb25zdHJ1Y3RvcicgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IG9ialtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGNsb25lRmlsdGVyID0gKGZpbHRlciQkMSkgPT4gY29weU9iamVjdChmaWx0ZXIkJDEpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNsb25lRmlsdGVycyA9IChmaWx0ZXIkJDEpID0+IHtcbiAgICBpZiAoIWZpbHRlciQkMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3IoZmlsdGVyJCQxKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsdGVyczogY2xvbmVGaWx0ZXJzKGZpbHRlciQkMS5maWx0ZXJzKSxcbiAgICAgICAgICAgIGxvZ2ljOiBmaWx0ZXIkJDEubG9naWNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIkJDEpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIkJDEubWFwKGNsb25lRmlsdGVycyk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZUZpbHRlcihmaWx0ZXIkJDEpO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZvY3VzR3JvdXApIHtcbiAgICAgICAgdGhpcy5mb2N1c0dyb3VwID0gZm9jdXNHcm91cDtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0ID0ge307XG4gICAgfVxuICAgIGdldCBmaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXI7XG4gICAgfVxuICAgIHNldCBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyID0gY2xvbmVGaWx0ZXJzKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0LiRpbXBsaWNpdCA9IHRoaXMuZmlsdGVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQuY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dC5maWx0ZXIgPSB0aGlzLmZpbHRlcjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0LmNlbGxDb250ZXh0ID0geyBmb2N1c0dyb3VwOiB0aGlzLmZvY3VzR3JvdXAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IGhhc1RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZVJlZik7XG4gICAgfVxuICAgIGdldCBpc0ZpbHRlcmFibGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb2x1bW4pICYmICFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMuY29sdW1uLmZpZWxkKSAmJiB0aGlzLmNvbHVtbi5maWx0ZXJhYmxlO1xuICAgIH1cbn1cbkZpbHRlckNlbGxDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0RmlsdGVyQ2VsbF0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc0ZpbHRlcmFibGVcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cImhhc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBrZW5kb0ZpbHRlckNlbGxIb3N0IFtjb2x1bW5dPVwiY29sdW1uXCIgW2ZpbHRlcl09XCJmaWx0ZXJcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJjb2x1bW4uZmlsdGVyQ2VsbFRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5maWx0ZXJDZWxsVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInRlbXBsYXRlQ29udGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJDZWxsQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRm9jdXNHcm91cCB9XG5dO1xuRmlsdGVyQ2VsbENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb2x1bW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbmNvbnN0IGxvY2FsaXplT3BlcmF0b3JzID0gb3BlcmF0b3JzID0+IGxvY2FsaXphdGlvbiA9PiBPYmplY3Qua2V5cyhvcGVyYXRvcnMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nbb3BlcmF0b3JzW2tleV1dID0gbG9jYWxpemF0aW9uLmdldChrZXkpO1xuICAgIHJldHVybiBhY2M7XG59LCB7fSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6YWxpZ25cbmNvbnN0IG9wZXJhdG9yVGV4dHMgPSBsb2NhbGl6ZU9wZXJhdG9ycyh7XG4gICAgXCJmaWx0ZXJFcU9wZXJhdG9yXCI6IFwiZXFcIixcbiAgICBcImZpbHRlck5vdEVxT3BlcmF0b3JcIjogXCJuZXFcIixcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG4gICAgXCJmaWx0ZXJHdGVPcGVyYXRvclwiOiBcImd0ZVwiLFxuICAgIFwiZmlsdGVyR3RPcGVyYXRvclwiOiBcImd0XCIsXG4gICAgXCJmaWx0ZXJMdGVPcGVyYXRvclwiOiBcImx0ZVwiLFxuICAgIFwiZmlsdGVyTHRPcGVyYXRvclwiOiBcImx0XCIsXG4gICAgXCJmaWx0ZXJJc051bGxPcGVyYXRvclwiOiBcImlzbnVsbFwiLFxuICAgIFwiZmlsdGVySXNOb3ROdWxsT3BlcmF0b3JcIjogXCJpc25vdG51bGxcIixcbiAgICBcImZpbHRlcklzRW1wdHlPcGVyYXRvclwiOiBcImlzZW1wdHlcIixcbiAgICBcImZpbHRlcklzTm90RW1wdHlPcGVyYXRvclwiOiBcImlzbm90ZW1wdHlcIixcbiAgICBcImZpbHRlckNvbnRhaW5zT3BlcmF0b3JcIjogXCJjb250YWluc1wiLFxuICAgIFwiZmlsdGVyTm90Q29udGFpbnNPcGVyYXRvclwiOiBcImRvZXNub3Rjb250YWluXCIsXG4gICAgXCJmaWx0ZXJTdGFydHNXaXRoT3BlcmF0b3JcIjogXCJzdGFydHN3aXRoXCIsXG4gICAgXCJmaWx0ZXJFbmRzV2l0aE9wZXJhdG9yXCI6IFwiZW5kc3dpdGhcIixcbiAgICBcImZpbHRlckFmdGVyT3JFcXVhbE9wZXJhdG9yXCI6IFwiYWZ0ZXItZXFcIixcbiAgICBcImZpbHRlckFmdGVyT3BlcmF0b3JcIjogXCJhZnRlclwiLFxuICAgIFwiZmlsdGVyQmVmb3JlT3JFcXVhbE9wZXJhdG9yXCI6IFwiYmVmb3JlLWVxXCIsXG4gICAgXCJmaWx0ZXJCZWZvcmVPcGVyYXRvclwiOiBcImJlZm9yZVwiXG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b0pTT04gPSAoeHMpID0+IHhzLm1hcCh4ID0+IHgudG9KU09OKCkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gb3BlcmF0b3JUZXh0cyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMuX3RleHQgPSB0aGlzLm1lc3NhZ2VzW3RoaXMub3BlcmF0b3JdO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLnJlZnJlc2hUZXh0LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBkcm9wLWRvd24gbGlzdC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJPcGVyYXRvckJhc2VcbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHRleHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGV4dCA9IGlzTnVsbE9yRW1wdHlTdHJpbmcodmFsdWUpID8gdGhpcy5tZXNzYWdlc1t0aGlzLm9wZXJhdG9yXSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMub3BlcmF0b3JcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVmcmVzaFRleHQoKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3RleHQgPT09IHRoaXMubWVzc2FnZXNbdGhpcy5vcGVyYXRvcl07XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBvcGVyYXRvclRleHRzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRoaXMubWVzc2FnZXNbdGhpcy5vcGVyYXRvcl07XG4gICAgICAgIH1cbiAgICB9XG59XG5GaWx0ZXJPcGVyYXRvckJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGV4dDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbmNvbnN0IGluc2VydERlZmF1bHRGaWx0ZXIgPSAoaW5kZXgsIHJvb3RGaWx0ZXIsIGZpbHRlciQkMSkgPT4ge1xuICAgIHJvb3RGaWx0ZXIgPSAocm9vdEZpbHRlciB8fCB7IGZpbHRlcnM6IFtdLCBsb2dpYzogXCJhbmRcIiB9KTtcbiAgICByb290RmlsdGVyLmZpbHRlcnNbaW5kZXhdID0gZmlsdGVyJCQxO1xuICAgIHJldHVybiBmaWx0ZXIkJDE7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNldEZpbHRlciA9IChpbmRleCwgZmlsdGVyJCQxLCBmaWVsZCwgZGVmYXVsdE9wZXJhdG9yKSA9PiB7XG4gICAgaWYgKGlzUHJlc2VudChmaWx0ZXIkJDEpICYmIGlzUHJlc2VudChmaWx0ZXIkJDEuZmlsdGVycykgJiYgZmlsdGVyJCQxLmZpbHRlcnMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlciQkMS5maWx0ZXJzW2luZGV4XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnNlcnREZWZhdWx0RmlsdGVyKGluZGV4LCBmaWx0ZXIkJDEsIHtcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGRlZmF1bHRPcGVyYXRvclxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxvZ2ljT3BlcmF0b3JzID0gKGxvY2FsaXphdGlvbikgPT4gW1xuICAgIHsgdGV4dDogbG9jYWxpemF0aW9uLmdldChcImZpbHRlckFuZExvZ2ljXCIpLCB2YWx1ZTogXCJhbmRcIiB9LFxuICAgIHsgdGV4dDogbG9jYWxpemF0aW9uLmdldChcImZpbHRlck9yTG9naWNcIiksIHZhbHVlOiBcIm9yXCIgfVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmbGF0dGVuID0gKGZpbHRlciQkMSkgPT4ge1xuICAgIGlmIChpc1ByZXNlbnQoZmlsdGVyJCQxLmZpbHRlcnMpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIkJDEuZmlsdGVycy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLmNvbmNhdChpc0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3IoY3VycikgPyBmbGF0dGVuKGN1cnIpIDogW2N1cnJdKSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuY29uc3QgdHJpbUZpbHRlckJ5RmllbGQgPSAoZmlsdGVyJCQxLCBmaWVsZCkgPT4ge1xuICAgIGlmIChpc1ByZXNlbnQoZmlsdGVyJCQxKSAmJiBpc1ByZXNlbnQoZmlsdGVyJCQxLmZpbHRlcnMpKSB7XG4gICAgICAgIGZpbHRlciQkMS5maWx0ZXJzID0gZmlsdGVyJCQxLmZpbHRlcnMuZmlsdGVyKHggPT4ge1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcih4KSkge1xuICAgICAgICAgICAgICAgIHRyaW1GaWx0ZXJCeUZpZWxkKHgsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5maWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LmZpZWxkICE9PSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmaWx0ZXJzQnlGaWVsZCA9IChmaWx0ZXIkJDEsIGZpZWxkKSA9PiBmbGF0dGVuKGZpbHRlciQkMSB8fCB7fSkuZmlsdGVyKHggPT4geC5maWVsZCA9PT0gZmllbGQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpbHRlckJ5RmllbGQgPSAoZmlsdGVyJCQxLCBmaWVsZCkgPT4ge1xuICAgIGxldCBbY3VycmVudEZpbHRlcl0gPSBmaWx0ZXJzQnlGaWVsZChmaWx0ZXIkJDEsIGZpZWxkKTtcbiAgICByZXR1cm4gY3VycmVudEZpbHRlcjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcmVtb3ZlRmlsdGVyID0gKGZpbHRlciQkMSwgZmllbGQpID0+IHtcbiAgICB0cmltRmlsdGVyQnlGaWVsZChmaWx0ZXIkJDEsIGZpZWxkKTtcbiAgICByZXR1cm4gZmlsdGVyJCQxO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsb2NhbGl6ZU9wZXJhdG9ycyQxID0gb3BlcmF0b3JzID0+IGxvY2FsaXphdGlvbiA9PiBPYmplY3Qua2V5cyhvcGVyYXRvcnMpLm1hcChrZXkgPT4gKHtcbiAgICB0ZXh0OiBsb2NhbGl6YXRpb24uZ2V0KGtleSksXG4gICAgdmFsdWU6IG9wZXJhdG9yc1trZXldXG59KSk7XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRoZSBmaWx0ZXItY2VsbCBjb21wb25lbnQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyByZXVzYWJsZWN1c3RvbWZpbHRlcnNfdHJlZWxpc3QgJX0jdG9jLWZpbHRlci1yb3cpKS5cbiAqL1xuY2xhc3MgQmFzZUZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlID0gZmlsdGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5vcGVyYXRvckxpc3QgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BlcmF0b3JzLmxlbmd0aCA/IHRoaXMuX29wZXJhdG9ycyA6IHRoaXMuZGVmYXVsdE9wZXJhdG9ycztcbiAgICB9XG4gICAgc2V0IG9wZXJhdG9ycyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0b3JzID0gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbkxpc3RTdWJzY3JpcHRpb24gPSBvYnNlcnZlKHRoaXMub3BlcmF0b3JMaXN0KVxuICAgICAgICAgICAgLnBpcGUobWFwKHEgPT4gcS50b0FycmF5KCkpLCBtYXAodG9KU09OKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoeCA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uTGlzdFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25MaXN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlsdGVyQnlGaWVsZChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyQnlGaWVsZCh0aGlzLmZpbHRlciwgZmllbGQpO1xuICAgIH1cbiAgICBmaWx0ZXJzQnlGaWVsZChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyc0J5RmllbGQodGhpcy5maWx0ZXIsIGZpZWxkKTtcbiAgICB9XG4gICAgcmVtb3ZlRmlsdGVyKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVGaWx0ZXIodGhpcy5maWx0ZXIsIGZpZWxkKTtcbiAgICB9XG4gICAgdXBkYXRlRmlsdGVyKGZpbHRlciQkMSkge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5maWx0ZXIgfHwge1xuICAgICAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgICAgICBsb2dpYzogXCJhbmRcIlxuICAgICAgICB9O1xuICAgICAgICBsZXQgW2N1cnJlbnRGaWx0ZXJdID0gZmxhdHRlbihyb290KS5maWx0ZXIoeCA9PiB4LmZpZWxkID09PSBmaWx0ZXIkJDEuZmllbGQpO1xuICAgICAgICBpZiAoIWlzUHJlc2VudChjdXJyZW50RmlsdGVyKSkge1xuICAgICAgICAgICAgcm9vdC5maWx0ZXJzLnB1c2goZmlsdGVyJCQxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3VycmVudEZpbHRlciwgZmlsdGVyJCQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgYXBwbHlGaWx0ZXIoZmlsdGVyJCQxKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5maWx0ZXIoZmlsdGVyJCQxKTtcbiAgICB9XG59XG5CYXNlRmlsdGVyQ2VsbENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1maWx0ZXJjZWxsJyxdIH1dLFxuICAgIG9wZXJhdG9yTGlzdDogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbRmlsdGVyT3BlcmF0b3JCYXNlLF0gfV1cbn07XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlclxuY29uc3QgbnVtZXJpY09wZXJhdG9ycyA9IGxvY2FsaXplT3BlcmF0b3JzJDEoe1xuICAgIFwiZmlsdGVyRXFPcGVyYXRvclwiOiBcImVxXCIsXG4gICAgXCJmaWx0ZXJOb3RFcU9wZXJhdG9yXCI6IFwibmVxXCIsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuICAgIFwiZmlsdGVyR3RlT3BlcmF0b3JcIjogXCJndGVcIixcbiAgICBcImZpbHRlckd0T3BlcmF0b3JcIjogXCJndFwiLFxuICAgIFwiZmlsdGVyTHRlT3BlcmF0b3JcIjogXCJsdGVcIixcbiAgICBcImZpbHRlckx0T3BlcmF0b3JcIjogXCJsdFwiLFxuICAgIFwiZmlsdGVySXNOdWxsT3BlcmF0b3JcIjogXCJpc251bGxcIixcbiAgICBcImZpbHRlcklzTm90TnVsbE9wZXJhdG9yXCI6IFwiaXNub3RudWxsXCJcbn0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmFzZSBudW1lcmljIGZpbHRlciBjb21wb25lbnQuXG4gKi9cbmNsYXNzIE51bWVyaWNGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRmlsdGVyQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvci4gRGVmYXVsdHMgdG8gYGVxYC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBcImVxXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHZhbHVlIHRoYXQgaXMgdXNlZCB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBjb21wb25lbnQgdmFsdWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1lcmljfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSAqKlVwKiogYW5kICoqRG93bioqIHNwaW4gYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcGVyYXRvcnMgPSBudW1lcmljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgZm9ybWF0IHVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBmb2N1c2VkLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgY29sdW1uLmZvcm1hdGAgdmFsdWUgaXMgdXNlZCAoaWYgc2V0KS5cbiAgICAgKi9cbiAgICBzZXQgZm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciBmb3JtYXQgdXNlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGZvY3VzZWQuXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGBjb2x1bW4uZm9ybWF0YCB2YWx1ZSBpcyB1c2VkIChpZiBzZXQpLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gIWlzTnVsbE9yRW1wdHlTdHJpbmcodGhpcy5fZm9ybWF0KSA/IHRoaXMuX2Zvcm1hdCA6IHRoaXMuY29sdW1uRm9ybWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7RmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlGaWVsZCh0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBvcGVyYXRvciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZpbHRlciA/IHRoaXMuY3VycmVudEZpbHRlci5vcGVyYXRvciA6IHRoaXMub3BlcmF0b3I7XG4gICAgfVxuICAgIGdldCBjb2x1bW5Gb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbiAmJiAhaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLmNvbHVtbi5mb3JtYXQpID9cbiAgICAgICAgICAgIGV4dHJhY3RGb3JtYXQodGhpcy5jb2x1bW4uZm9ybWF0KSA6IFwibjJcIjtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5sb2NhbGl6YXRpb25DaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICB9XG4gICAgbG9jYWxpemF0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRPcGVyYXRvcnMgPSBudW1lcmljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvcnMgPSB0b0pTT04odGhpcy5vcGVyYXRvckxpc3QudG9BcnJheSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk51bWVyaWNGaWx0ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGVwOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3Bpbm5lcnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRlY2ltYWxzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBudW1lcmljIGZpbHRlciBjZWxsLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgYGBgaHRtbC1uby1ydW5cbiAqICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0RmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1maWx0ZXIgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICogICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LW51bWVyaWMtZmlsdGVyLWNlbGxcbiAqICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gKiAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIj5cbiAqICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtbnVtZXJpYy1maWx0ZXItY2VsbD5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICogICBgYGBcbiAqL1xuY2xhc3MgTnVtZXJpY0ZpbHRlckNlbGxDb21wb25lbnQgZXh0ZW5kcyBOdW1lcmljRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBkZWxheSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJlZm9yZSB0aGUgZmlsdGVyIHZhbHVlIGlzIHN1Ym1pdHRlZC5cbiAgICAgICAgICogQSB2YWx1ZSBvZiBgMGAgaW5kaWNhdGVzIG5vIGRlbGF5LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNTAwYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckRlbGF5ID0gNTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZHJvcC1kb3duIGZpbHRlciBvcGVyYXRvcnMgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPcGVyYXRvcnMgPSB0cnVlO1xuICAgIH1cbn1cbk51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1udW1lcmljLWZpbHRlci1jZWxsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tdHJlZWxpc3QtZmlsdGVyLXdyYXBwZXItY2VsbFxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2RlZmF1bHRPcGVyYXRvcl09XCJvcGVyYXRvclwiXG4gICAgICAgICAgICBbc2hvd09wZXJhdG9yc109XCJzaG93T3BlcmF0b3JzXCI+XG4gICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgICAgICBrZW5kb1RyZWVMaXN0Rm9jdXNhYmxlXG4gICAgICAgICAgICAgICAga2VuZG9GaWx0ZXJJbnB1dFxuICAgICAgICAgICAgICAgIFtmaWx0ZXJEZWxheV09XCJmaWx0ZXJEZWxheVwiXG4gICAgICAgICAgICAgICAgW2F1dG9Db3JyZWN0XT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJjdXJyZW50RmlsdGVyPy52YWx1ZVwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFtkZWNpbWFsc109XCJkZWNpbWFsc1wiXG4gICAgICAgICAgICAgICAgW3NwaW5uZXJzXT1cInNwaW5uZXJzXCJcbiAgICAgICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgICAgIFtzdGVwXT1cInN0ZXBcIj5cbiAgICAgICAgICAgIDwva2VuZG8tbnVtZXJpY3RleHRib3g+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZmlsdGVyLXdyYXBwZXItY2VsbD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRmlsdGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuTnVtZXJpY0ZpbHRlckNlbGxDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmlsdGVyRGVsYXk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dPcGVyYXRvcnM6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVySW5wdXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlQWNjZXNzb3JzLCBuZ1pvbmUsIGVsZW1lbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpbHRlckRlbGF5ID0gNTAwO1xuICAgICAgICB0aGlzLmNoYW5nZVJlcXVlc3RzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NvciA9IHZhbHVlQWNjZXNzb3JzWzBdO1xuICAgICAgICBuZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVTdGFydCA9IHJlbmRlcmVyLmxpc3RlbihlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdjb21wb3NpdGlvbnN0YXJ0JywgKCkgPT4gdGhpcy5jb21wb3NpbmcgPSB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlRW5kID0gcmVuZGVyZXIubGlzdGVuKGVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2NvbXBvc2l0aW9uZW5kJywgKCkgPT4gdGhpcy5jb21wb3NpbmcgPSBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZUVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFjY2Vzc29yLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKHZhbHVlKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoeCA9PiB0aGlzLmZpbHRlckRlbGF5ID4gMCA/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVJlcXVlc3RzLm5leHQoeCkgOlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdCh4KSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlQ2hhbmdlcygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2ZpbHRlckRlbGF5JywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNoYW5nZXMoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUV2ZW50cygpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVJlcXVlc3RzU3Vic2NyaXB0aW9uID0gdGhpcy5jaGFuZ2VSZXF1ZXN0c1xuICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKHRoaXMuZmlsdGVyRGVsYXkpLCBmaWx0ZXIoKCkgPT4gIXRoaXMuY29tcG9zaW5nKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoeCA9PiB0aGlzLmNoYW5nZS5lbWl0KHgpKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VSZXF1ZXN0c1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VSZXF1ZXN0c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuRmlsdGVySW5wdXREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0ZpbHRlcklucHV0XSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRmlsdGVySW5wdXREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogU2VsZiB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfV0gfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH1cbl07XG5GaWx0ZXJJbnB1dERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmaWx0ZXJEZWxheTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBFTVBUWV9WQUxVRV9PUEVSQVRPUlMgPSBuZXcgU2V0KFsnaXNudWxsJywgJ2lzbm90bnVsbCcsICdpc2VtcHR5JywgJ2lzbm90ZW1wdHknXSk7XG5jb25zdCBpc0VtcHR5VmFsdWVPcGVyYXRvciA9IChvcGVyYXRvcikgPT4gRU1QVFlfVkFMVUVfT1BFUkFUT1JTLmhhcyhvcGVyYXRvcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVySW5wdXRXcmFwcGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSk7XG4gICAgICAgIHRoaXMub3BlcmF0b3JzID0gW107XG4gICAgfVxuICAgIGdldCBjdXJyZW50RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeUZpZWxkKHRoaXMuY29sdW1uLmZpZWxkKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRPcGVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyJCQxID0gdGhpcy5jdXJyZW50RmlsdGVyO1xuICAgICAgICBpZiAoIXRoaXMuX29wZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVyYXRvciA9IGZpbHRlciQkMSA/IGZpbHRlciQkMS5vcGVyYXRvciA6IHRoaXMuZGVmYXVsdE9wZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVyYXRvcjtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRPcGVyYXRvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vcGVyYXRvciA9IHZhbHVlO1xuICAgICAgICBjb25zdCBlbXB0eVZhbHVlT3BlcmF0b3IgPSBpc0VtcHR5VmFsdWVPcGVyYXRvcih2YWx1ZSk7XG4gICAgICAgIHRoaXMuZmlsdGVySW5wdXREaXNhYmxlZCA9IGVtcHR5VmFsdWVPcGVyYXRvcjtcbiAgICAgICAgaWYgKGVtcHR5VmFsdWVPcGVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5hcHBseU5vVmFsdWVGaWx0ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0JsYW5rKHZhbHVlKSAmJiBpc1ByZXNlbnQodGhpcy5jdXJyZW50RmlsdGVyKSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLmN1cnJlbnRGaWx0ZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkZWZhdWx0T3BlcmF0b3IoKSB7XG4gICAgICAgIGlmICghaXNOdWxsT3JFbXB0eVN0cmluZyh0aGlzLl9kZWZhdWx0T3BlcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE9wZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3BlcmF0b3JzICYmIHRoaXMub3BlcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3JzWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImVxXCI7XG4gICAgfVxuICAgIHNldCBkZWZhdWx0T3BlcmF0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9wZXJhdG9yID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBmaWx0ZXJJbnB1dERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMuaW5wdXQuY2hhbmdlLnN1YnNjcmliZSh0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJJbnB1dERpc2FibGVkID0gaXNFbXB0eVZhbHVlT3BlcmF0b3IodGhpcy5jdXJyZW50T3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc051bGxPckVtcHR5U3RyaW5nKHZhbHVlKSB8fCB0aGlzLmZpbHRlckJ5RmllbGQodGhpcy5jb2x1bW4uZmllbGQpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckNoYW5nZShpc051bGxPckVtcHR5U3RyaW5nKHZhbHVlKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXIodGhpcy5jb2x1bW4uZmllbGQpIDpcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlcih7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLmNvbHVtbi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRoaXMuY3VycmVudE9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DbGVhcigpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShudWxsKTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbnB1dERpc2FibGVkID0gaXNFbXB0eVZhbHVlT3BlcmF0b3IodGhpcy5kZWZhdWx0T3BlcmF0b3IpO1xuICAgIH1cbiAgICBhcHBseU5vVmFsdWVGaWx0ZXIob3BlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJDaGFuZ2UodGhpcy51cGRhdGVGaWx0ZXIoe1xuICAgICAgICAgICAgZmllbGQ6IHRoaXMuY29sdW1uLmZpZWxkLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoXCJmaWx0ZXJcIiwgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVyYXRvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcklucHV0RGlzYWJsZWQgPSBpc0VtcHR5VmFsdWVPcGVyYXRvcih0aGlzLmN1cnJlbnRPcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5GaWx0ZXJJbnB1dFdyYXBwZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb3BlcmF0b3JzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW5wdXQ6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0ZpbHRlcklucHV0RGlyZWN0aXZlLF0gfV0sXG4gICAgZGVmYXVsdE9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuY29uc3QgRU1QVFlfRklMVEVSX09QRVJBVE9SUyA9IFsnaXNudWxsJywgJ2lzbm90bnVsbCcsICdpc2VtcHR5JywgJ2lzbm90ZW1wdHknXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWx0ZXJDZWxsV3JhcHBlckNvbXBvbmVudCBleHRlbmRzIEZpbHRlcklucHV0V3JhcHBlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSkge1xuICAgICAgICBzdXBlcihmaWx0ZXJTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5zaG93T3BlcmF0b3JzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlQmFzZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNob3dCdXR0b24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciQkMSA9IHRoaXMuY3VycmVudEZpbHRlcjtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChmaWx0ZXIkJDEpICYmICghaXNOdWxsT3JFbXB0eVN0cmluZyhmaWx0ZXIkJDEudmFsdWUpIHx8XG4gICAgICAgICAgICBFTVBUWV9GSUxURVJfT1BFUkFUT1JTLmluZGV4T2YoU3RyaW5nKGZpbHRlciQkMS5vcGVyYXRvcikpID49IDApO1xuICAgIH1cbiAgICBmaWx0ZXJDaGFuZ2UoZmlsdGVyJCQxKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoZmlsdGVyJCQxKTtcbiAgICB9XG59XG5GaWx0ZXJDZWxsV3JhcHBlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtZmlsdGVyLXdyYXBwZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8a2VuZG8tdHJlZWxpc3QtZmlsdGVyLWNlbGwtb3BlcmF0b3JzXG4gICAgICAgICAgICBbc2hvd09wZXJhdG9yc109XCJzaG93T3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIChjbGVhcik9XCJvbkNsZWFyKClcIlxuICAgICAgICAgICAgW3Nob3dCdXR0b25dPVwic2hvd0J1dHRvblwiXG4gICAgICAgICAgICBbKHZhbHVlKV09XCJjdXJyZW50T3BlcmF0b3JcIj5cbiAgICAgICAgPC9rZW5kby10cmVlbGlzdC1maWx0ZXItY2VsbC1vcGVyYXRvcnM+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJDZWxsV3JhcHBlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEZpbHRlclNlcnZpY2UgfVxuXTtcbkZpbHRlckNlbGxXcmFwcGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZpbHRlcmNlbGwtd3JhcHBlcicsXSB9XSxcbiAgICBvdmVycmlkZUJhc2VDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZpbHRlcmNlbGwnLF0gfV0sXG4gICAgc2hvd09wZXJhdG9yczogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlclxuY29uc3Qgc3RyaW5nT3BlcmF0b3JzID0gbG9jYWxpemVPcGVyYXRvcnMkMSh7XG4gICAgXCJmaWx0ZXJFcU9wZXJhdG9yXCI6IFwiZXFcIixcbiAgICBcImZpbHRlck5vdEVxT3BlcmF0b3JcIjogXCJuZXFcIixcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG4gICAgXCJmaWx0ZXJDb250YWluc09wZXJhdG9yXCI6IFwiY29udGFpbnNcIixcbiAgICBcImZpbHRlck5vdENvbnRhaW5zT3BlcmF0b3JcIjogXCJkb2Vzbm90Y29udGFpblwiLFxuICAgIFwiZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yXCI6IFwic3RhcnRzd2l0aFwiLFxuICAgIFwiZmlsdGVyRW5kc1dpdGhPcGVyYXRvclwiOiBcImVuZHN3aXRoXCIsXG4gICAgXCJmaWx0ZXJJc051bGxPcGVyYXRvclwiOiBcImlzbnVsbFwiLFxuICAgIFwiZmlsdGVySXNOb3ROdWxsT3BlcmF0b3JcIjogXCJpc25vdG51bGxcIixcbiAgICBcImZpbHRlcklzRW1wdHlPcGVyYXRvclwiOiBcImlzZW1wdHlcIixcbiAgICBcImZpbHRlcklzTm90RW1wdHlPcGVyYXRvclwiOiBcImlzbm90ZW1wdHlcIlxufSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBiYXNlIHN0cmluZyBmaWx0ZXIgY29tcG9uZW50LlxuICovXG5jbGFzcyBTdHJpbmdGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRmlsdGVyQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvci4gRGVmYXVsdHMgdG8gYGNvbnRhaW5zYC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBcImNvbnRhaW5zXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtGaWx0ZXJEZXNjcmlwdG9yfVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeUZpZWxkKCh0aGlzLmNvbHVtbiB8fCB7fSkuZmllbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgb3BlcmF0b3IgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50T3BlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIgPyB0aGlzLmN1cnJlbnRGaWx0ZXIub3BlcmF0b3IgOiB0aGlzLm9wZXJhdG9yO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmxvY2FsaXphdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIH1cbiAgICBsb2NhbGl6YXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wZXJhdG9ycyA9IHN0cmluZ09wZXJhdG9ycyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3JzID0gdG9KU09OKHRoaXMub3BlcmF0b3JMaXN0LnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5TdHJpbmdGaWx0ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RyaW5nLWZpbHRlciBjZWxsIGNvbXBvbmVudFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLWNvbmZpZ3VyYXRpb24tY29tcG9uZW50cy1mb3ItZmlsdGVyLXRlbXBsYXRlcykpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogIGBgYGh0bWwtbm8tcnVuXG4gKiAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW4gZmllbGQ9XCJQcm9kdWN0TmFtZVwiIHRpdGxlPVwiUHJvZHVjdCBOYW1lXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdEZpbHRlckNlbGxUZW1wbGF0ZSBsZXQtZmlsdGVyIGxldC1jb2x1bW49XCJjb2x1bW5cIj5cbiAqICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1zdHJpbmctZmlsdGVyLWNlbGxcbiAqICAgICAgICAgICAgICBbc2hvd09wZXJhdG9yc109XCJmYWxzZVwiXG4gKiAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICogICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCI+XG4gKiAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LXN0cmluZy1maWx0ZXItY2VsbD5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICogICBgYGBcbiAqL1xuY2xhc3MgU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudCBleHRlbmRzIFN0cmluZ0ZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBkZWxheSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJlZm9yZSB0aGUgZmlsdGVyIHZhbHVlIGlzIHN1Ym1pdHRlZC5cbiAgICAgICAgICogQSB2YWx1ZSBvZiBgMGAgaW5kaWNhdGVzIG5vIGRlbGF5LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNTAwYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckRlbGF5ID0gNTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZHJvcC1kb3duIGZpbHRlciBvcGVyYXRvcnMgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dPcGVyYXRvcnMgPSB0cnVlO1xuICAgIH1cbn1cblN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LXN0cmluZy1maWx0ZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWZpbHRlci13cmFwcGVyLWNlbGxcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtkZWZhdWx0T3BlcmF0b3JdPVwib3BlcmF0b3JcIlxuICAgICAgICAgICAgW3Nob3dPcGVyYXRvcnNdPVwic2hvd09wZXJhdG9yc1wiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJrLXRleHRib3hcIlxuICAgICAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RGb2N1c2FibGVcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW2ZpbHRlckRlbGF5XT1cImZpbHRlckRlbGF5XCJcbiAgICAgICAgICAgICAgICBbbmdNb2RlbF09XCJjdXJyZW50RmlsdGVyPy52YWx1ZVwiIC8+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZmlsdGVyLXdyYXBwZXItY2VsbD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBGaWx0ZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5TdHJpbmdGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZpbHRlckRlbGF5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93T3BlcmF0b3JzOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29tcG9uZW50IHdoaWNoIGFjY29tbW9kYXRlcyB0aGUgZmlsdGVyIG9wZXJhdG9ycy5cbiAqL1xuY2xhc3MgRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNsZWFyVGV4dCA9ICdDbGVhcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIG9wZXJhdG9ycyB0aGF0IHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGxpc3Qgb2Ygb3BlcmF0b3JzIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd09wZXJhdG9ycyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBvcGVyYXRvciBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlICoqQ2xlYXIqKiBidXR0b24gaXMgY2xpY2tlZC5cbiAgICAgICAgICogQHR5cGUge0V2ZW50RW1pdHRlcjx7fT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChkYXRhSXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbGVhckNsaWNrKCkge1xuICAgICAgICB0aGlzLmNsZWFyLmVtaXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xlYXJLZXlkb3duKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5FbnRlciB8fCBhcmdzLmtleUNvZGUgPT09IEtleXMuU3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkcm9wZG93bktleWRvd24oYXJncykge1xuICAgICAgICBpZiAoYXJncy5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5FbnRlciAmJiAhdGhpcy5kcm9wZG93bi5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24udG9nZ2xlKHRydWUpO1xuICAgICAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsZWFyVGV4dCA9IHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlckNsZWFyQnV0dG9uXCIpKTtcbiAgICB9XG59XG5GaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1maWx0ZXItY2VsbC1vcGVyYXRvcnMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgICNkcm9wZG93blxuICAgICAgICAgICAgKm5nSWY9XCJzaG93T3BlcmF0b3JzXCJcbiAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RGb2N1c2FibGVcbiAgICAgICAgICAgIFtkYXRhXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBjbGFzcz1cImstZHJvcGRvd24tb3BlcmF0b3JcIlxuICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgIGljb25DbGFzcz1cImstaS1maWx0ZXJcIlxuICAgICAgICAgICAgW3ZhbHVlUHJpbWl0aXZlXT1cInRydWVcIlxuICAgICAgICAgICAgdGV4dEZpZWxkPVwidGV4dFwiXG4gICAgICAgICAgICBbcG9wdXBTZXR0aW5nc109XCJ7IHdpZHRoOiAnYXV0bycgfVwiXG4gICAgICAgICAgICB2YWx1ZUZpZWxkPVwidmFsdWVcIlxuICAgICAgICAgICAgKGtleWRvd24pPVwiZHJvcGRvd25LZXlkb3duKCRldmVudClcIj5cbiAgICAgICAgPC9rZW5kby1kcm9wZG93bmxpc3Q+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBrZW5kb1RyZWVMaXN0Rm9jdXNhYmxlXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7J2stY2xlYXItYnV0dG9uLXZpc2libGUnOiBzaG93QnV0dG9ufVwiXG4gICAgICAgICAgICBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLWljb25cIlxuICAgICAgICAgICAgW3RpdGxlXT1cImNsZWFyVGV4dFwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xlYXJDbGljaygpXCJcbiAgICAgICAgICAgIChrZXlkb3duKT1cImNsZWFyS2V5ZG93bigkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWZpbHRlci1jbGVhclwiPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuRmlsdGVyQ2VsbE9wZXJhdG9yc0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1maWx0ZXJjZWxsLW9wZXJhdG9yJyxdIH1dLFxuICAgIGRyb3Bkb3duOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnZHJvcGRvd24nLF0gfV0sXG4gICAgb3BlcmF0b3JzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93QnV0dG9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93T3BlcmF0b3JzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmFsdWVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjbGVhcjogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXJcbmNvbnN0IHN0cmluZ09wZXJhdG9ycyQxID0gbG9jYWxpemVPcGVyYXRvcnMkMSh7XG4gICAgXCJmaWx0ZXJDb250YWluc09wZXJhdG9yXCI6IFwiY29udGFpbnNcIixcbiAgICBcImZpbHRlck5vdENvbnRhaW5zT3BlcmF0b3JcIjogXCJkb2Vzbm90Y29udGFpblwiLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXNcbiAgICBcImZpbHRlckVxT3BlcmF0b3JcIjogXCJlcVwiLFxuICAgIFwiZmlsdGVyTm90RXFPcGVyYXRvclwiOiBcIm5lcVwiLFxuICAgIFwiZmlsdGVyU3RhcnRzV2l0aE9wZXJhdG9yXCI6IFwic3RhcnRzd2l0aFwiLFxuICAgIFwiZmlsdGVyRW5kc1dpdGhPcGVyYXRvclwiOiBcImVuZHN3aXRoXCIsXG4gICAgXCJmaWx0ZXJJc051bGxPcGVyYXRvclwiOiBcImlzbnVsbFwiLFxuICAgIFwiZmlsdGVySXNOb3ROdWxsT3BlcmF0b3JcIjogXCJpc25vdG51bGxcIixcbiAgICBcImZpbHRlcklzRW1wdHlPcGVyYXRvclwiOiBcImlzZW1wdHlcIixcbiAgICBcImZpbHRlcklzTm90RW1wdHlPcGVyYXRvclwiOiBcImlzbm90ZW1wdHlcIlxufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudCBleHRlbmRzIEJhc2VGaWx0ZXJDZWxsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBjb2x1bW4sIGxvY2FsaXphdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc2hvd09wZXJhdG9ycyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wZXJhdG9ycyA9IHN0cmluZ09wZXJhdG9ycyQxKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgfVxuICAgIHNldCB2YWx1ZUZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlRmllbGQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlRmllbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUZpZWxkID8gdGhpcy5fdmFsdWVGaWVsZCA6IHRoaXMuY29sdW1uLmZpZWxkO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlGaWVsZCh0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50T3BlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIgPyB0aGlzLmN1cnJlbnRGaWx0ZXIub3BlcmF0b3IgOiBcImNvbnRhaW5zXCI7XG4gICAgfVxufVxuQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtYXV0b2NvbXBsZXRlLWZpbHRlci1jZWxsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tdHJlZWxpc3QtZmlsdGVyLXdyYXBwZXItY2VsbFxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW3Nob3dPcGVyYXRvcnNdPVwic2hvd09wZXJhdG9yc1wiPlxuICAgICAgICAgICAgPGtlbmRvLWF1dG9jb21wbGV0ZVxuICAgICAgICAgICAgICAgIGtlbmRvRmlsdGVySW5wdXRcbiAgICAgICAgICAgICAgICBbZGF0YV09XCJkYXRhXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVGaWVsZF09XCJ2YWx1ZUZpZWxkXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIj5cbiAgICAgICAgICAgIDwva2VuZG8tYXV0b2NvbXBsZXRlPlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWZpbHRlci13cmFwcGVyLWNlbGw+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5BdXRvQ29tcGxldGVGaWx0ZXJDZWxsQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRmlsdGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29sdW1uQ29tcG9uZW50IH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5BdXRvQ29tcGxldGVGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNob3dPcGVyYXRvcnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLy8gdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQm9vbGVhbkZpbHRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGaWx0ZXJDZWxsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSk7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IFwiZXFcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXG4gICAgICAgICAgICB7IHRleHQ6IHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlcklzVHJ1ZVwiKSwgdmFsdWU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdGV4dDogdGhpcy5sb2NhbGl6YXRpb24uZ2V0KFwiZmlsdGVySXNGYWxzZVwiKSwgdmFsdWU6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdEl0ZW0gPSB7IHRleHQ6IHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlckJvb2xlYW5BbGxcIiksIHZhbHVlOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7RmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlGaWVsZCh0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBvcGVyYXRvciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZpbHRlciA/IHRoaXMuY3VycmVudEZpbHRlci5vcGVyYXRvciA6IHRoaXMub3BlcmF0b3I7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgfVxuICAgIGxvY2FsaXphdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtcbiAgICAgICAgICAgIHsgdGV4dDogdGhpcy5sb2NhbGl6YXRpb24uZ2V0KFwiZmlsdGVySXNUcnVlXCIpLCB2YWx1ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB0ZXh0OiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoXCJmaWx0ZXJJc0ZhbHNlXCIpLCB2YWx1ZTogZmFsc2UgfVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmRlZmF1bHRJdGVtID0geyB0ZXh0OiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoXCJmaWx0ZXJCb29sZWFuQWxsXCIpLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cbn1cbkJvb2xlYW5GaWx0ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZmlsdGVyY2VsbC1ib29sZWFuJyxdIH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgQm9vbGVhbiBmaWx0ZXItY2VsbCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgYGBgaHRtbC1uby1ydW5cbiAqICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIlByb2R1Y3ROYW1lXCIgdGl0bGU9XCJQcm9kdWN0IE5hbWVcIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0RmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1maWx0ZXIgbGV0LWNvbHVtbj1cImNvbHVtblwiPlxuICogICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWJvb2xlYW4tZmlsdGVyLWNlbGxcbiAqICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gKiAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIj5cbiAqICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtYm9vbGVhbi1maWx0ZXItY2VsbD5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICogICBgYGBcbiAqL1xuY2xhc3MgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQgZXh0ZW5kcyBCb29sZWFuRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGNkKSB7XG4gICAgICAgIHN1cGVyKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICB9XG4gICAgbG9jYWxpemF0aW9uQ2hhbmdlKCkge1xuICAgICAgICBzdXBlci5sb2NhbGl6YXRpb25DaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59XG5Cb29sZWFuRmlsdGVyQ2VsbENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtYm9vbGVhbi1maWx0ZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWZpbHRlci13cmFwcGVyLWNlbGxcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtzaG93T3BlcmF0b3JzXT1cImZhbHNlXCJcbiAgICAgICAgICAgIFtkZWZhdWx0T3BlcmF0b3JdPVwib3BlcmF0b3JcIj5cbiAgICAgICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW2RlZmF1bHRJdGVtXT1cImRlZmF1bHRJdGVtXCJcbiAgICAgICAgICAgICAgICBbZGF0YV09XCJpdGVtc1wiXG4gICAgICAgICAgICAgICAgdGV4dEZpZWxkPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFsdWVGaWVsZD1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICBbcG9wdXBTZXR0aW5nc109XCJ7IHdpZHRoOiAnYXV0bycgfVwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlUHJpbWl0aXZlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJjdXJyZW50RmlsdGVyPy52YWx1ZVwiPlxuICAgICAgICAgICAgPC9rZW5kby1kcm9wZG93bmxpc3Q+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZmlsdGVyLXdyYXBwZXItY2VsbD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkJvb2xlYW5GaWx0ZXJDZWxsQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRmlsdGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcblxuLy8gdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyXG5jb25zdCBkYXRlT3BlcmF0b3JzID0gbG9jYWxpemVPcGVyYXRvcnMkMSh7XG4gICAgXCJmaWx0ZXJFcU9wZXJhdG9yXCI6IFwiZXFcIixcbiAgICBcImZpbHRlck5vdEVxT3BlcmF0b3JcIjogXCJuZXFcIixcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG4gICAgXCJmaWx0ZXJBZnRlck9yRXF1YWxPcGVyYXRvclwiOiBcImd0ZVwiLFxuICAgIFwiZmlsdGVyQWZ0ZXJPcGVyYXRvclwiOiBcImd0XCIsXG4gICAgXCJmaWx0ZXJCZWZvcmVPckVxdWFsT3BlcmF0b3JcIjogXCJsdGVcIixcbiAgICBcImZpbHRlckJlZm9yZU9wZXJhdG9yXCI6IFwibHRcIixcbiAgICBcImZpbHRlcklzTnVsbE9wZXJhdG9yXCI6IFwiaXNudWxsXCIsXG4gICAgXCJmaWx0ZXJJc05vdE51bGxPcGVyYXRvclwiOiBcImlzbm90bnVsbFwiXG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEYXRlRmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZpbHRlckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UsIGxvY2FsaXphdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3IuIERlZmF1bHRzIHRvIGBjb250YWluc2AuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gXCJndGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGFjdGl2ZSB2aWV3IHRoYXQgdGhlIGNhbGVuZGFyIGluaXRpYWxseSByZW5kZXJzLlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYWN0aXZlIHZpZXcgaXMgYG1vbnRoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBZb3UgaGF2ZSB0byBzZXQgYGFjdGl2ZVZpZXdgIHdpdGhpbiB0aGUgYHRvcFZpZXdgLWBib3R0b21WaWV3YCByYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IFwibW9udGhcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGJvdHRvbW1vc3QgY2FsZW5kYXIgdmlldywgdG8gd2hpY2ggdGhlIHVzZXIgY2FuIG5hdmlnYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3R0b21WaWV3ID0gXCJtb250aFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgdG9wbW9zdCBjYWxlbmRhciB2aWV3LCB0byB3aGljaCB0aGUgdXNlciBjYW4gbmF2aWdhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFZpZXcgPSBcImNlbnR1cnlcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IGEgd2VlayBudW1iZXIgY29sdW1uIGluIHRoZSBgbW9udGhgIHZpZXcgb2YgdGhlIENhbGVuZGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wZXJhdG9ycyA9IGRhdGVPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7RmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlGaWVsZCh0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGF0ZSBmb3JtYXQgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgZm9jdXNlZC5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYGNvbHVtbi5mb3JtYXRgIHZhbHVlIGlzIHVzZWQgKGlmIHNldCkuXG4gICAgICovXG4gICAgc2V0IGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mb3JtYXQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBkYXRlIGZvcm1hdCB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBmb2N1c2VkLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgY29sdW1uLmZvcm1hdGAgdmFsdWUgaXMgdXNlZCAoaWYgc2V0KS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuICFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMuX2Zvcm1hdCkgPyB0aGlzLl9mb3JtYXQgOiB0aGlzLmNvbHVtbkZvcm1hdDtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbkZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uICYmICFpc051bGxPckVtcHR5U3RyaW5nKHRoaXMuY29sdW1uLmZvcm1hdCkgP1xuICAgICAgICAgICAgZXh0cmFjdEZvcm1hdCh0aGlzLmNvbHVtbi5mb3JtYXQpIDogXCJkXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBvcGVyYXRvciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZpbHRlciA/IHRoaXMuY3VycmVudEZpbHRlci5vcGVyYXRvciA6IHRoaXMub3BlcmF0b3I7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMubG9jYWxpemF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgfVxuICAgIGxvY2FsaXphdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0T3BlcmF0b3JzID0gZGF0ZU9wZXJhdG9ycyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3JzID0gdG9KU09OKHRoaXMub3BlcmF0b3JMaXN0LnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5EYXRlRmlsdGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0UGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBsYWNlaG9sZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhY3RpdmVWaWV3OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBib3R0b21WaWV3OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0b3BWaWV3OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB3ZWVrTnVtYmVyOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGF0ZS1maWx0ZXIgY2VsbCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgYGBgaHRtbC1uby1ydW5cbiAqICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIk9yZGVyRGF0ZVwiIHRpdGxlPVwiT3JkZXIgRGF0ZVwiPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RGaWx0ZXJDZWxsVGVtcGxhdGUgbGV0LWZpbHRlciBsZXQtY29sdW1uPVwiY29sdW1uXCI+XG4gKiAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtZGF0ZS1maWx0ZXItY2VsbFxuICogICAgICAgICAgICAgIFtzaG93T3BlcmF0b3JzXT1cImZhbHNlXCJcbiAqICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gKiAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIj5cbiAqICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZGF0ZS1maWx0ZXItY2VsbD5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uPlxuICogICBgYGBcbiAqL1xuY2xhc3MgRGF0ZUZpbHRlckNlbGxDb21wb25lbnQgZXh0ZW5kcyBEYXRlRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIoZmlsdGVyU2VydmljZSwgbG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBkcm9wLWRvd24gZmlsdGVyIG9wZXJhdG9ycyB3aWxsIGJlIGRpc3BsYXllZC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd09wZXJhdG9ycyA9IHRydWU7XG4gICAgfVxufVxuRGF0ZUZpbHRlckNlbGxDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWRhdGUtZmlsdGVyLWNlbGwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1maWx0ZXItd3JhcHBlci1jZWxsXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZGVmYXVsdE9wZXJhdG9yXT1cIm9wZXJhdG9yXCJcbiAgICAgICAgICAgIFtzaG93T3BlcmF0b3JzXT1cInNob3dPcGVyYXRvcnNcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgPGtlbmRvLWRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cImN1cnJlbnRGaWx0ZXI/LnZhbHVlXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdFBsYWNlaG9sZGVyXT1cImZvcm1hdFBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICAgICAgICAgIFtib3R0b21WaWV3XT1cImJvdHRvbVZpZXdcIlxuICAgICAgICAgICAgICAgIFt0b3BWaWV3XT1cInRvcFZpZXdcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1kYXRlcGlja2VyPlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWZpbHRlci13cmFwcGVyLWNlbGw+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EYXRlRmlsdGVyQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEZpbHRlclNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcbkRhdGVGaWx0ZXJDZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNob3dPcGVyYXRvcnM6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNoZWNrYm94IGZvciBzZWxlY3Rpbmcgcm93cyBpbiB0aGUgVHJlZUxpc3QuXG4gKi9cbmNsYXNzIENoZWNrYm94Q29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDaGVja2JveENvbHVtbiA9IHRydWU7XG4gICAgfVxuICAgIGdldCB0ZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUgPyB0aGlzLnRlbXBsYXRlLnRlbXBsYXRlUmVmIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbkNoZWNrYm94Q29sdW1uQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UkMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29sdW1uQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWNoZWNrYm94LWNvbHVtbicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNoZWNrYm94Q29sdW1uQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ29sdW1uQmFzZSQxLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBTa2lwU2VsZiB9LCB7IHR5cGU6IEhvc3QgfSwgeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuQ2hlY2tib3hDb2x1bW5Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc2hvd1NlbGVjdEFsbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hlY2tDaGlsZHJlbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXhwYW5kYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0NlbGxUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sR3JvdXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnNUb1JlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnNUb1JlbmRlcih0aGlzLmNvbHVtbnMpO1xuICAgIH1cbiAgICB0cmFja0J5KGluZGV4LCBfaXRlbSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuQ29sR3JvdXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0Q29sR3JvdXBdJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8Y29sICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uc1RvUmVuZGVyOyB0cmFja0J5OiB0cmFja0J5O1wiIFtzdHlsZS53aWR0aC5weF09XCJjb2x1bW4ud2lkdGhcIi8+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuQ29sR3JvdXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMb2FkaW5nQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGxvYWRpbmdUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdsb2FkaW5nJyk7XG4gICAgfVxufVxuTG9hZGluZ0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RMb2FkaW5nXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWxvYWRpbmctdGV4dFwiPnt7IGxvYWRpbmdUZXh0IH19PC9zcGFuPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1sb2FkaW5nLWltYWdlXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLWxvYWRpbmctY29sb3JcIj48L2Rpdj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxvYWRpbmdDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5Mb2FkaW5nQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1sb2FkaW5nLW1hc2snLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsLCByZW5kZXJlciwgcmVzaXplU2VydmljZSwgdHJlZWxpc3QpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IHJlc2l6ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMudHJlZWxpc3QgPSB0cmVlbGlzdDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNldCBsb2NrZWRXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2NrZWRXaWR0aCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFJlc2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQga2VuZG9UcmVlTGlzdFJlc2l6YWJsZUNvbnRhaW5lcihlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IHJlZnJlc2ggPSBlbmFibGVkICE9PSB0aGlzLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFJlc2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplU3Vic2NyaXB0aW9uICYmICF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbiAmJiB0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uID0gdGhpcy5yZXNpemVTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMucmVzaXplLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJlZWxpc3QgJiYgdGhpcy50cmVlbGlzdC53cmFwcGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gdGhpcy50cmVlbGlzdC53cmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KGNvbnRhaW5lckVsZW1lbnQuY2xpZW50V2lkdGggLSB0aGlzLl9sb2NrZWRXaWR0aCwgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmIHdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCBcIndpZHRoXCIsIHdpZHRoICsgXCJweFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCBcIndpZHRoXCIsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuUmVzaXphYmxlQ29udGFpbmVyRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdFJlc2l6YWJsZUNvbnRhaW5lcl0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblJlc2l6YWJsZUNvbnRhaW5lckRpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogUmVzaXplU2VydmljZSB9LFxuICAgIHsgdHlwZTogVHJlZUxpc3RDb21wb25lbnQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5SZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbG9ja2VkV2lkdGg6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2xvY2tlZFdpZHRoJyxdIH1dLFxuICAgIGtlbmRvVHJlZUxpc3RSZXNpemFibGVDb250YWluZXI6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgfVxuICAgIHNldCB0ZW1wbGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZVZpZXcoKTtcbiAgICAgICAgaWYgKGNvbnRleHQudGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0ZWRWaWV3UmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhjb250ZXh0LnRlbXBsYXRlUmVmLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVWaWV3KCk7XG4gICAgfVxuICAgIHJlbW92ZVZpZXcoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc2VydGVkVmlld1JlZikge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLnJlbW92ZSh0aGlzLnZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLmluc2VydGVkVmlld1JlZikpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRlZFZpZXdSZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5UZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1t0ZW1wbGF0ZUNvbnRleHRdJyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmIH1cbl07XG5UZW1wbGF0ZUNvbnRleHREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGVtcGxhdGVDb250ZXh0OiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxubGV0IGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgICByZXR1cm4gaWQrKztcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMb2dpY2FsQ2VsbERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZm9jdXNHcm91cCwgZWxlbWVudCwgY29sdW1uSW5mb1NlcnZpY2UsIGlkU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIHJlbmRlcmVyLCB6b25lKSB7XG4gICAgICAgIHRoaXMuZm9jdXNHcm91cCA9IGZvY3VzR3JvdXA7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5pZFNlcnZpY2UgPSBpZFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmxvZ2ljYWxTbGF2ZUNlbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xTcGFuID0gMTtcbiAgICAgICAgdGhpcy5yb3dTcGFuID0gMTtcbiAgICAgICAgdGhpcy5kYXRhUm93SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5leHBhbmRhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudWlkID0gbmV4dElkKCk7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvZ2ljYWxTbGF2ZUNlbGwgJiYgdGhpcy5jb2x1bW5JbmZvU2VydmljZS5pc0xvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRTZXJ2aWNlLmNlbGxJZCh0aGlzLmxvZ2ljYWxSb3dJbmRleCwgdGhpcy5sb2dpY2FsQ29sSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhcmlhQ29sSW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ2ljYWxTbGF2ZUNlbGwgfHwgdGhpcy5sb2dpY2FsQ29sSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2ljYWxDb2xJbmRleCArIDE7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkNoYW5nZSA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoKGUpID0+IHRoaXMub25OYXZpZ2F0aW9uQ2hhbmdlKGUpKTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhdGlvblNlcnZpY2UuZW5hYmxlZCB8fCB0aGlzLmxvZ2ljYWxDb2xJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyTm9DaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2dpY2FsQ29sSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhDaGFuZ2UgPSBjaGFuZ2VzLmxvZ2ljYWxDb2xJbmRleDtcbiAgICAgICAgY29uc3Qgcm93SW5kZXhDaGFuZ2UgPSBjaGFuZ2VzLmxvZ2ljYWxSb3dJbmRleDtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleENoYW5nZSAmJiAhaW5kZXhDaGFuZ2UuaXNGaXJzdENoYW5nZSgpID8gaW5kZXhDaGFuZ2UucHJldmlvdXNWYWx1ZSA6IHRoaXMubG9naWNhbENvbEluZGV4O1xuICAgICAgICBjb25zdCByb3dJbmRleCA9IHJvd0luZGV4Q2hhbmdlICYmICFyb3dJbmRleENoYW5nZS5pc0ZpcnN0Q2hhbmdlKCkgPyByb3dJbmRleENoYW5nZS5wcmV2aW91c1ZhbHVlIDogdGhpcy5sb2dpY2FsUm93SW5kZXg7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UudW5yZWdpc3RlckNlbGwoaW5kZXgsIHJvd0luZGV4LCB0aGlzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckNoYW5nZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25DaGFuZ2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnVucmVnaXN0ZXJDZWxsKHRoaXMubG9naWNhbENvbEluZGV4LCB0aGlzLmxvZ2ljYWxSb3dJbmRleCwgdGhpcyk7XG4gICAgfVxuICAgIG9uTmF2aWdhdGlvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMubG9naWNhbENvbEluZGV4ID09PSBlLmNvbEluZGV4ICYmIHRoaXMubG9naWNhbFJvd0luZGV4ID09PSBlLnJvd0luZGV4O1xuICAgICAgICBjb25zdCB3YXNBY3RpdmUgPSB0aGlzLmxvZ2ljYWxDb2xJbmRleCA9PT0gZS5wcmV2Q29sSW5kZXggJiYgdGhpcy5sb2dpY2FsUm93SW5kZXggPT09IGUucHJldlJvd0luZGV4O1xuICAgICAgICBpZiAoYWN0aXZlIHx8IHdhc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWwsICd0YWJJbmRleCcsIHRoaXMuaXNGb2N1c2FibGUoKSAmJiAhdGhpcy5sb2dpY2FsU2xhdmVDZWxsID8gJzAnIDogJy0xJyk7XG4gICAgICAgIGlmICh0aGlzLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1c0dyb3VwLmlzTmF2aWdhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzR3JvdXAuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sb2dpY2FsU2xhdmVDZWxsICYmIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYXV0b0ZvY3VzQ2VsbCh0aGlzLmxvZ2ljYWxDb2xJbmRleCwgdGhpcy5sb2dpY2FsQ29sSW5kZXggKyB0aGlzLmNvbFNwYW4gLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pY3JvdGFzaygoKSA9PiB0aGlzLmlzRm9jdXNlZCgpICYmIGVsLmZvY3VzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsLCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsLCAnay1zdGF0ZS1mb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWljcm90YXNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihjYWxsYmFjaykpO1xuICAgIH1cbiAgICByZWdpc3RlckNoYW5nZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dpY2FsU2xhdmVDZWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlZ2lzdGVyQ2VsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck5vQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvZ2ljYWxTbGF2ZUNlbGwpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UucmVnaXN0ZXJDZWxsT25DdXJyZW50Um93KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRm9jdXNhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5pc0NlbGxGb2N1c2FibGUodGhpcyk7XG4gICAgfVxuICAgIGlzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaXNDZWxsRm9jdXNlZCh0aGlzKTtcbiAgICB9XG59XG5Mb2dpY2FsQ2VsbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZvY3VzR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbRm9jdXNSb290XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBGb2N1c0dyb3VwXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RMb2dpY2FsQ2VsbF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxvZ2ljYWxDZWxsRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRm9jdXNHcm91cCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogQ29sdW1uSW5mb1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IElkU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5Mb2dpY2FsQ2VsbERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBsb2dpY2FsQ29sSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvZ2ljYWxSb3dJbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9naWNhbFNsYXZlQ2VsbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2xJbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sU3BhbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm93U3BhbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0YVJvd0luZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRhSXRlbTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXhwYW5kYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaWQnLF0gfV0sXG4gICAgYXJpYUNvbEluZGV4OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmFyaWEtY29saW5kZXgnLF0gfV1cbn07XG5cbmxldCBpZCQxID0gMDtcbmZ1bmN0aW9uIG5leHRJZCQxKCkge1xuICAgIHJldHVybiBpZCQxKys7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9naWNhbFJvd0RpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaWRTZXJ2aWNlLCBuYXZpZ2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaWRTZXJ2aWNlID0gaWRTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmxvZ2ljYWxTbGF2ZVJvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ2ljYWxTbGF2ZUNlbGxzQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmRhdGFSb3dJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmlzTmV3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudWlkID0gbmV4dElkJDEoKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RSb2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dpY2FsU2xhdmVSb3cgPyAncHJlc2VudGF0aW9uJyA6ICdyb3cnO1xuICAgIH1cbiAgICBnZXQgYXJpYVJvd0luZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ2ljYWxSb3dJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFyaWFPd25zKCkge1xuICAgICAgICBpZiAoIXRoaXMubmF2aWdhdGlvbi5lbmFibGVkIHx8IHRoaXMubG9naWNhbFNsYXZlUm93IHx8IHRoaXMubG9naWNhbFNsYXZlQ2VsbHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHMgPSBbXTtcbiAgICAgICAgY29uc3QgdG90YWwgPSB0aGlzLmxvZ2ljYWxDZWxsc0NvdW50ICsgdGhpcy5sb2dpY2FsU2xhdmVDZWxsc0NvdW50O1xuICAgICAgICBmb3IgKGxldCBjZWxsSW5kZXggPSB0aGlzLmxvZ2ljYWxDZWxsc0NvdW50OyBjZWxsSW5kZXggPCB0b3RhbDsgY2VsbEluZGV4KyspIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKHRoaXMuaWRTZXJ2aWNlLmNlbGxJZCh0aGlzLmxvZ2ljYWxSb3dJbmRleCwgY2VsbEluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkcy5qb2luKCcgJyk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hdmlnYXRpb24uZW5hYmxlZCB8fCB0aGlzLmxvZ2ljYWxTbGF2ZVJvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4Q2hhbmdlID0gY2hhbmdlcy5sb2dpY2FsUm93SW5kZXg7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWxTbGF2ZVJvd0NoYW5nZSA9IGNoYW5nZXMubG9naWNhbFNsYXZlUm93O1xuICAgICAgICBjb25zdCBpc05ld0NoYW5nZSA9IGNoYW5nZXMuaXNOZXc7XG4gICAgICAgIGlmIChpbmRleENoYW5nZSB8fCBsb2dpY2FsU2xhdmVSb3dDaGFuZ2UgfHwgaXNOZXdDaGFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhDaGFuZ2UgJiYgIWluZGV4Q2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSA/IGluZGV4Q2hhbmdlLnByZXZpb3VzVmFsdWUgOiB0aGlzLmxvZ2ljYWxSb3dJbmRleDtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi51bnJlZ2lzdGVyUm93KGluZGV4LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZWdpc3RlclJvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbnlDaGFuZ2VkKFsnZGF0YVJvd0luZGV4JywgJ2RhdGFJdGVtJ10sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24udXBkYXRlUm93KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24udW5yZWdpc3RlclJvdyh0aGlzLmxvZ2ljYWxSb3dJbmRleCwgdGhpcyk7XG4gICAgfVxufVxuTG9naWNhbFJvd0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RMb2dpY2FsUm93XSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTG9naWNhbFJvd0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IElkU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfVxuXTtcbkxvZ2ljYWxSb3dEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbG9naWNhbFJvd0luZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2dpY2FsU2xhdmVSb3c6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvZ2ljYWxDZWxsc0NvdW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2dpY2FsU2xhdmVDZWxsc0NvdW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRhUm93SW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGFJdGVtOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc05ldzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaG9zdFJvbGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XSxcbiAgICBhcmlhUm93SW5kZXg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1yb3dpbmRleCcsXSB9XSxcbiAgICBhcmlhT3duczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLW93bnMnLF0gfV1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOnBpcGUtbmFtaW5nICovXG5jb25zdCBGT1JNQVRfUkVHRVggPSAvXFx7XFxkKzo/Lztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWVsZEFjY2Vzc29yUGlwZSB7XG4gICAgY29uc3RydWN0b3IoaW50bFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pbnRsU2VydmljZSA9IGludGxTZXJ2aWNlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0oZGF0YUl0ZW0sIGZpZWxkTmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghaXNOdWxsT3JFbXB0eVN0cmluZyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlcihmaWVsZE5hbWUpKGRhdGFJdGVtKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JFbXB0eVN0cmluZyhmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWUoZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgIH1cbiAgICBmb3JtYXRWYWx1ZShmb3JtYXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGludGwgPSB0aGlzLmludGxTZXJ2aWNlO1xuICAgICAgICBpZiAoaXNTdHJpbmcoZm9ybWF0KSAmJiBmb3JtYXQubWF0Y2goRk9STUFUX1JFR0VYKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGwuZm9ybWF0KGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRsLnRvU3RyaW5nKHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbkZpZWxkQWNjZXNzb3JQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBQaXBlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZU9mJyxcbiAgICAgICAgICAgICAgICBwdXJlOiBmYWxzZVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWVsZEFjY2Vzc29yUGlwZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEludGxTZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjb2x1bW5zVG9SZXNpemUgPSAoeyBjb2x1bW5zIH0pID0+IE1hdGgubWF4KDEsIHJlc2l6YWJsZUNvbHVtbnMoY29sdW1ucykubGVuZ3RoKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByb3cgPSBzZWxlY3RvciA9PiBlbGVtZW50ID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGVhZGVyUm93ID0gaW5kZXggPT4gZWxlbWVudCA9PiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoZWFkPnRyJylbaW5kZXhdO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGNlbGwgPSAoaW5kZXgsIHNlbGVjdG9yID0gJ3RkJykgPT4gZWxlbWVudCA9PiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCR7c2VsZWN0b3J9Om5vdCguay1ncm91cC1jZWxsKTpub3QoLmstaGllcmFyY2h5LWNlbGwpYClbaW5kZXhdO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG9mZnNldFdpZHRoID0gZWxlbWVudCA9PiBlbGVtZW50Lm9mZnNldFdpZHRoO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBpcGUgPSAoLi4uZm5zKSA9PiBkYXRhID0+IGZucy5yZWR1Y2UoKHN0YXRlJCQxLCBmbikgPT4gc3RhdGUkJDEgPyBmbihzdGF0ZSQkMSkgOiAwLCBkYXRhKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUYWJsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgcmVuZGVyZXIsIHNlcnZpY2UsIHpvbmUsIGNkcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpcnN0UmVzaXplID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBtaW5XaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RSZXNpemUgPyAwIDogbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IG9icyA9IHRoaXMuc2VydmljZVxuICAgICAgICAgICAgLmNoYW5nZXMucGlwZShmaWx0ZXIoZSA9PiB0aGlzLmxvY2tlZCA9PT0gZS5sb2NrZWQpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBvYnMucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdzdGFydCcpLCB0YXAodGhpcy5pbml0U3RhdGUuYmluZCh0aGlzKSksIG1hcChjb2x1bW5zVG9SZXNpemUpLCBzd2l0Y2hNYXAoKHRha2UkJDEpID0+IG9icy5waXBlKGZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3Jlc2l6ZVRhYmxlJyksIG1hcChlID0+IGUuZGVsdGEpLCBidWZmZXJDb3VudCh0YWtlJCQxKSkpKS5zdWJzY3JpYmUodGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYXV0b0ZpdFN1YnNjcmlwdGlvbiA9IHRoaXMuc2VydmljZVxuICAgICAgICAgICAgLnJlZ2lzdGVyVGFibGUoe1xuICAgICAgICAgICAgYXV0b0ZpdDogdGhpcy5hdXRvRml0T2JzZXJ2YWJsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbG9ja2VkOiB0aGlzLmxvY2tlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvRml0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9GaXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b0ZpdFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFN0YXRlKCkge1xuICAgICAgICB0aGlzLmZpcnN0UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnZpcnR1YWxDb2x1bW5zIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsV2lkdGggPSBvZmZzZXRXaWR0aCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplKGRlbHRhcykge1xuICAgICAgICBpZiAoIXRoaXMudmlydHVhbENvbHVtbnMgfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZGVsdGFzLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5vcmlnaW5hbFdpZHRoICsgZGVsdGE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgYXV0b0ZpdE9ic2VydmFibGUoY29sdW1uSW5mbykge1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnay1hdXRvZml0dGluZycpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aHMgPSBjb2x1bW5JbmZvLm1hcCh0aGlzLm1lYXN1cmVDb2x1bW4uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2stYXV0b2ZpdHRpbmcnKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHdpZHRocyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1lYXN1cmVDb2x1bW4oaW5mbykge1xuICAgICAgICBjb25zdCBkb20gPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gcGlwZShoZWFkZXJSb3coaW5mby5sZXZlbCksIGNlbGwoaW5mby5oZWFkZXJJbmRleCwgJ3RoJyksIG9mZnNldFdpZHRoKShkb20pO1xuICAgICAgICBsZXQgZGF0YSA9IDA7XG4gICAgICAgIGlmICghaW5mby5pc1BhcmVudFNwYW4gfHwgKGluZm8uaXNQYXJlbnRTcGFuICYmIGluZm8uaXNMYXN0SW5TcGFuKSkge1xuICAgICAgICAgICAgZGF0YSA9IHBpcGUocm93KCd0Ym9keT50cjpub3QoLmstZ3JvdXBpbmctcm93KTpub3QoLmstZ3JpZC1ub3JlY29yZHMpJyksIGNlbGwoaW5mby5pbmRleCksIG9mZnNldFdpZHRoKShkb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heChoZWFkZXIsIGRhdGEpO1xuICAgIH1cbn1cblRhYmxlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICd0YWJsZScgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVGFibGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IENvbHVtblJlc2l6aW5nU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuVGFibGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbG9ja2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXJ0dWFsQ29sdW1uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluV2lkdGg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLm1pbi13aWR0aCcsXSB9XVxufTtcblxuY29uc3QgZXhwb3J0ZWRNb2R1bGVzID0gW1xuICAgIENvbHVtbkNvbXBvbmVudCxcbiAgICBDb2x1bW5Hcm91cENvbXBvbmVudCxcbiAgICBMb2dpY2FsQ2VsbERpcmVjdGl2ZSxcbiAgICBMb2dpY2FsUm93RGlyZWN0aXZlLFxuICAgIEZvY3VzYWJsZURpcmVjdGl2ZSxcbiAgICBDb2xHcm91cENvbXBvbmVudCxcbiAgICBSZXNpemFibGVDb250YWluZXJEaXJlY3RpdmUsXG4gICAgVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlLFxuICAgIEZpZWxkQWNjZXNzb3JQaXBlLFxuICAgIFNwYW5Db2x1bW5Db21wb25lbnQsXG4gICAgVGFibGVEaXJlY3RpdmUsXG4gICAgTG9hZGluZ0NvbXBvbmVudCxcbiAgICBDaGVja2JveENvbHVtbkNvbXBvbmVudFxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTaGFyZWRNb2R1bGUge1xuICAgIHN0YXRpYyBleHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgQ29sdW1uQ29tcG9uZW50LFxuICAgICAgICAgICAgU3BhbkNvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgICAgIENoZWNrYm94Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICAgICAgQ29sdW1uR3JvdXBDb21wb25lbnQsXG4gICAgICAgICAgICBGb2N1c2FibGVEaXJlY3RpdmVcbiAgICAgICAgXTtcbiAgICB9XG59XG5TaGFyZWRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2V4cG9ydGVkTW9kdWxlc10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcywgRHJhZ2dhYmxlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBDb250YWluc2AgKCoqQ29udGFpbnMqKikgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmNsYXNzIENvbnRhaW5zRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImNvbnRhaW5zXCIsIGxvY2FsaXphdGlvbik7IH1cbn1cbkNvbnRhaW5zRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29udGFpbnNGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItY29udGFpbnMtb3BlcmF0b3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db250YWluc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBEb2VzTm90Q29udGFpbmAgKCoqRG9lcyBub3QgY29udGFpbioqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgRG9lc05vdENvbnRhaW5GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiZG9lc25vdGNvbnRhaW5cIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuRG9lc05vdENvbnRhaW5GaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1ub3QtY29udGFpbnMtb3BlcmF0b3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Eb2VzTm90Q29udGFpbkZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBFbmRzV2l0aGAgKCoqRW5kcyB3aXRoKiopIHN0cmluZyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgRW5kc1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiZW5kc3dpdGhcIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuRW5kc1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBFbmRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1lbmRzd2l0aC1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkVuZHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYEVxdWFsYCAoKipJcyBlcXVhbCB0byoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgRXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiZXFcIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuRXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1lcS1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYElzRW1wdHlgICgqKklzIGVtcHR5KiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5jbGFzcyBJc0VtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImlzZW1wdHlcIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzRW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItaXNlbXB0eS1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbklzRW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgSXNOb3RFbXB0eWAgKCoqSXMgbm90IGVtcHR5KiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5jbGFzcyBJc05vdEVtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImlzbm90ZW1wdHlcIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuSXNOb3RFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItaXNub3RlbXB0eS1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbklzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgSXNOb3ROdWxsYCAoKipJcyBub3QgbnVsbCoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImlzbm90bnVsbFwiLCBsb2NhbGl6YXRpb24pOyB9XG59XG5Jc05vdE51bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJc05vdE51bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItaXNub3RudWxsLW9wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuSXNOb3ROdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYElzTnVsbGAgKCoqSXMgbnVsbCoqKSBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgSXNOdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImlzbnVsbFwiLCBsb2NhbGl6YXRpb24pOyB9XG59XG5Jc051bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJc051bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItaXNudWxsLW9wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuSXNOdWxsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYE5vdEVxdWFsYCAoKipJcyBub3QgZXF1YWwgdG8qKikgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmNsYXNzIE5vdEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcIm5lcVwiLCBsb2NhbGl6YXRpb24pOyB9XG59XG5Ob3RFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5vdEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLW5lcS1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk5vdEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYFN0YXJ0c1dpdGhgICgqKlN0YXJ0cyB3aXRoKiopIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5jbGFzcyBTdGFydHNXaXRoRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcInN0YXJ0c3dpdGhcIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFN0YXJ0c1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItc3RhcnRzd2l0aC1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblN0YXJ0c1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBHcmVhdGVyYCAoKipJcyBncmVhdGVyIHRoYW4qKikgbnVtZXJpYyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgR3JlYXRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJndFwiLCBsb2NhbGl6YXRpb24pOyB9XG59XG5HcmVhdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gR3JlYXRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1ndC1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkdyZWF0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgR3JlYXRlck9yRXF1YWxUb2AgKCoqSXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvKiopIG51bWVyaWMgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmNsYXNzIEdyZWF0ZXJPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiZ3RlXCIsIGxvY2FsaXphdGlvbik7IH1cbn1cbkdyZWF0ZXJPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLWd0ZS1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkdyZWF0ZXJPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBMZXNzYCAoKipJcyBsZXNzIHRoYW4qKikgbnVtZXJpYyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJsdFwiLCBsb2NhbGl6YXRpb24pOyB9XG59XG5MZXNzRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1sdC1vcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxlc3NGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBMZXNzT3JFcXVhbFRvYCAoKipJcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8qKikgbnVtZXJpYyBmaWx0ZXIgb3BlcmF0b3IuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLCByZWZlciB0bzpcbiAqICogW1NldHRpbmcgdGhlIGRlZmF1bHQgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLWRlZmF1bHQtZmlsdGVyLW9wZXJhdG9yKVxuICogKiBbU2V0dGluZyB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1vcmRlci1vZi10aGUtZmlsdGVyLW9wZXJhdG9ycylcbiAqL1xuY2xhc3MgTGVzc09yRXF1YWxUb0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJsdGVcIiwgbG9jYWxpemF0aW9uKTsgfVxufVxuTGVzc09yRXF1YWxUb0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExlc3NPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItbHRlLW9wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTGVzc09yRXF1YWxUb0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKlxuICogUmVwcmVzZW50cyB0aGUgYEdyZWF0ZXJgICgqKklzIGFmdGVyKiopIGRhdGUgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmNsYXNzIEFmdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJPcGVyYXRvckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikgeyBzdXBlcihcImFmdGVyXCIsIGxvY2FsaXphdGlvbik7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IFwiZ3RcIlxuICAgICAgICB9O1xuICAgIH1cbn1cbkFmdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQWZ0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItYWZ0ZXItb3BlcmF0b3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5BZnRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKlxuICogUmVwcmVzZW50cyB0aGUgYEdyZWF0ZXJPckVxdWFsVG9gICgqKklzIGFmdGVyIG9yIGVxdWFsIHRvKiopIGRhdGUgZmlsdGVyIG9wZXJhdG9yLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlcywgcmVmZXIgdG86XG4gKiAqIFtTZXR0aW5nIHRoZSBkZWZhdWx0IGZpbHRlciBvcGVyYXRvcnNdKHslIHNsdWcgYnVpbHRpbmZpbHRlcnRlbXBsYXRlX3RyZWVsaXN0ICV9I3RvYy1zZXR0aW5nLXRoZS1kZWZhdWx0LWZpbHRlci1vcGVyYXRvcilcbiAqICogW1NldHRpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtb3JkZXItb2YtdGhlLWZpbHRlci1vcGVyYXRvcnMpXG4gKi9cbmNsYXNzIEFmdGVyRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiYWZ0ZXItZXFcIiwgbG9jYWxpemF0aW9uKTsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogXCJndGVcIlxuICAgICAgICB9O1xuICAgIH1cbn1cbkFmdGVyRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBGaWx0ZXJPcGVyYXRvckJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZmlsdGVyLWFmdGVyLWVxLW9wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQWZ0ZXJFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKlxuICogUmVwcmVzZW50cyB0aGUgYExlc3NPckVxdWFsVG9gICgqKklzIGJlZm9yZSBvciBlcXVhbCB0byoqKSBkYXRlIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5jbGFzcyBCZWZvcmVFcUZpbHRlck9wZXJhdG9yQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyT3BlcmF0b3JCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHsgc3VwZXIoXCJiZWZvcmUtZXFcIiwgbG9jYWxpemF0aW9uKTsgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogXCJsdGVcIlxuICAgICAgICB9O1xuICAgIH1cbn1cbkJlZm9yZUVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogRmlsdGVyT3BlcmF0b3JCYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1maWx0ZXItYmVmb3JlLWVxLW9wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuLypcbiAqIFJlcHJlc2VudHMgdGhlIGBMZXNzIHRoZW5gICgqKklzIGJlZm9yZSoqKSBkYXRlIGZpbHRlciBvcGVyYXRvci5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZXMsIHJlZmVyIHRvOlxuICogKiBbU2V0dGluZyB0aGUgZGVmYXVsdCBmaWx0ZXIgb3BlcmF0b3JzXSh7JSBzbHVnIGJ1aWx0aW5maWx0ZXJ0ZW1wbGF0ZV90cmVlbGlzdCAlfSN0b2Mtc2V0dGluZy10aGUtZGVmYXVsdC1maWx0ZXItb3BlcmF0b3IpXG4gKiAqIFtTZXR0aW5nIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyIG9wZXJhdG9yc10oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLXNldHRpbmctdGhlLW9yZGVyLW9mLXRoZS1maWx0ZXItb3BlcmF0b3JzKVxuICovXG5jbGFzcyBCZWZvcmVGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCBleHRlbmRzIEZpbHRlck9wZXJhdG9yQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7IHN1cGVyKFwiYmVmb3JlXCIsIGxvY2FsaXphdGlvbik7IH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IFwibHRcIlxuICAgICAgICB9O1xuICAgIH1cbn1cbkJlZm9yZUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEZpbHRlck9wZXJhdG9yQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEJlZm9yZUZpbHRlck9wZXJhdG9yQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWZpbHRlci1iZWZvcmUtb3BlcmF0b3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5CZWZvcmVGaWx0ZXJPcGVyYXRvckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcblxuY29uc3QgRklMVEVSX09QRVJBVE9SUyA9IFtcbiAgICBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LFxuICAgIENvbnRhaW5zRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgRG9lc05vdENvbnRhaW5GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBFbmRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIEVxdWFsRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIElzTm90RW1wdHlGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBJc05vdE51bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBJc051bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBOb3RFcXVhbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIFN0YXJ0c1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBHcmVhdGVyRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgR3JlYXRlck9yRXF1YWxUb0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LFxuICAgIExlc3NGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBMZXNzT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgQWZ0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBBZnRlckVxRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsXG4gICAgQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCxcbiAgICBCZWZvcmVGaWx0ZXJPcGVyYXRvckNvbXBvbmVudFxuXTtcbmNvbnN0IGltcG9ydGVkTW9kdWxlcyA9IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBEcm9wRG93bkxpc3RNb2R1bGUsXG4gICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgIElucHV0c01vZHVsZSxcbiAgICBEYXRlUGlja2VyTW9kdWxlLFxuICAgIFBvcHVwTW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZVxuXTtcbmNvbnN0IENPTVBPTkVOVFMgPSBbXG4gICAgRmlsdGVySW5wdXREaXJlY3RpdmVcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2hhcmVkRmlsdGVyTW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLkZJTFRFUl9PUEVSQVRPUlNcbiAgICAgICAgXTtcbiAgICB9XG59XG5TaGFyZWRGaWx0ZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0ZJTFRFUl9PUEVSQVRPUlMsIENPTVBPTkVOVFNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtGSUxURVJfT1BFUkFUT1JTLCBpbXBvcnRlZE1vZHVsZXMsIENPTVBPTkVOVFNdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFsuLi5pbXBvcnRlZE1vZHVsZXNdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWx0ZXJIb3N0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCByZXNvbHZlcikge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHRoaXMuaG9zdC5jcmVhdGVDb21wb25lbnQodGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSh0aGlzLmNvbXBvbmVudFR5cGUoKSkpO1xuICAgICAgICB0aGlzLmluaXRDb21wb25lbnQoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFtcImNvbHVtblwiLCBcImZpbHRlclwiXSwgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q29tcG9uZW50KHsgY29sdW1uLCBmaWx0ZXI6IGZpbHRlciQkMSB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgaW5zdGFuY2UuZmlsdGVyID0gZmlsdGVyJCQxO1xuICAgIH1cbn1cbkZpbHRlckhvc3REaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiA+IExpc3QgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzIGluIHRoZSBUcmVlTGlzdE1vZHVsZSBhcyBgZW50cnlDb21wb25lbnRzYC5cbiAqL1xuY29uc3QgZmlsdGVyQ29tcG9uZW50RmFjdG9yeSA9ICh0eXBlKSA9PiAoe1xuICAgIFwiYm9vbGVhblwiOiBCb29sZWFuRmlsdGVyQ2VsbENvbXBvbmVudCxcbiAgICBcImRhdGVcIjogRGF0ZUZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgXCJudW1lcmljXCI6IE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIFwidGV4dFwiOiBTdHJpbmdGaWx0ZXJDZWxsQ29tcG9uZW50XG59W3R5cGVdKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZpbHRlckNlbGxIb3N0RGlyZWN0aXZlIGV4dGVuZHMgRmlsdGVySG9zdERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgcmVzb2x2ZXIpIHtcbiAgICAgICAgc3VwZXIoaG9zdCwgcmVzb2x2ZXIpO1xuICAgIH1cbiAgICBjb21wb25lbnRUeXBlKCkge1xuICAgICAgICBpZiAoIWlzTnVsbE9yRW1wdHlTdHJpbmcodGhpcy5jb2x1bW4uZmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckNvbXBvbmVudEZhY3RvcnkodGhpcy5jb2x1bW4uZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudDtcbiAgICB9XG59XG5GaWx0ZXJDZWxsSG9zdERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRmlsdGVyQ2VsbEhvc3RdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJDZWxsSG9zdERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYgfSxcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9XG5dO1xuXG5jb25zdCBJTlRFUk5BTF9DT01QT05FTlRTID0gW1xuICAgIEZpbHRlclJvd0NvbXBvbmVudCxcbiAgICBGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBTdHJpbmdGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgIEF1dG9Db21wbGV0ZUZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgRmlsdGVyQ2VsbEhvc3REaXJlY3RpdmUsXG4gICAgRmlsdGVyQ2VsbFdyYXBwZXJDb21wb25lbnQsXG4gICAgRGF0ZUZpbHRlckNlbGxDb21wb25lbnRcbl07XG5jb25zdCBFTlRSWV9DT01QT05FTlRTID0gW1xuICAgIFN0cmluZ0ZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgTnVtZXJpY0ZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgRGF0ZUZpbHRlckNlbGxDb21wb25lbnRcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUm93RmlsdGVyTW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZpbHRlclJvd0NvbXBvbmVudCxcbiAgICAgICAgICAgIEZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgICAgICAgICBGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LFxuICAgICAgICAgICAgU3RyaW5nRmlsdGVyQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgIE51bWVyaWNGaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgIEJvb2xlYW5GaWx0ZXJDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZUZpbHRlckNlbGxDb21wb25lbnQsXG4gICAgICAgICAgICBTaGFyZWRGaWx0ZXJNb2R1bGUuZXhwb3J0cygpXG4gICAgICAgIF07XG4gICAgfVxufVxuUm93RmlsdGVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtJTlRFUk5BTF9DT01QT05FTlRTXSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IEVOVFJZX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0lOVEVSTkFMX0NPTVBPTkVOVFMsIFNoYXJlZEZpbHRlck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1NoYXJlZEZpbHRlck1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVNldHRpbmdzID0gKHsgYnV0dG9uQ291bnQgPSAxMCwgaW5mbyA9IHRydWUsIHR5cGUgPSAnbnVtZXJpYycsIHBhZ2VTaXplcyA9IGZhbHNlLCBwcmV2aW91c05leHQgPSB0cnVlIH0pID0+ICh7XG4gICAgYnV0dG9uQ291bnQsXG4gICAgaW5mbyxcbiAgICBwYWdlU2l6ZXM6IHBhZ2VTaXplcyA9PT0gdHJ1ZSA/IFs1LCAxMCwgMjBdIDogcGFnZVNpemVzLFxuICAgIHByZXZpb3VzTmV4dCxcbiAgICB0eXBlXG59KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemUgPSAoc2V0dGluZ3MpID0+IG5vcm1hbGl6ZVNldHRpbmdzKHNldHRpbmdzID09PSB0cnVlID8ge30gOiBzZXR0aW5ncyk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQYWdlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocGFnZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGFnZXJDb250ZXh0ID0gcGFnZXJDb250ZXh0O1xuICAgICAgICB0aGlzLmFsbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgICAgIHRoaXMuc2tpcCA9IDE7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG5vcm1hbGl6ZSh7fSk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dCA9IHt9O1xuICAgIH1cbiAgICBzZXQgb3B0aW9ucyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gbm9ybWFsaXplKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHBhZ2VyV3JhcENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHRyZWVsaXN0UGFnZXJDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCB3aWRnZXRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCB0b3RhbFBhZ2VzKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLnRvdGFsIHx8IDApIC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuc2tpcCB8fCAwKSAvIHRoaXMucGFnZVNpemUpICsgMTtcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX3RlbXBsYXRlQ29udGV4dDtcbiAgICAgICAgY29udGV4dC50b3RhbFBhZ2VzID0gdGhpcy50b3RhbFBhZ2VzO1xuICAgICAgICBjb250ZXh0LnRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgY29udGV4dC5hbGxDb3VudCA9IHRoaXMuYWxsQ291bnQgfHwgdGhpcy50b3RhbDtcbiAgICAgICAgY29udGV4dC5za2lwID0gdGhpcy5za2lwO1xuICAgICAgICBjb250ZXh0LnBhZ2VTaXplID0gdGhpcy5wYWdlU2l6ZTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5wYWdlckNvbnRleHQucGFnZUNoYW5nZS5zdWJzY3JpYmUodGhpcy5jaGFuZ2VQYWdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFtcInBhZ2VTaXplXCIsIFwic2tpcFwiLCBcInRvdGFsXCIsIFwiYWxsQ291bnRcIl0sIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlckNvbnRleHQubm90aWZ5Q2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgc2tpcDogdGhpcy5za2lwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0aGlzLnRvdGFsLFxuICAgICAgICAgICAgICAgIGFsbENvdW50OiB0aGlzLmFsbENvdW50IHx8IHRoaXMudG90YWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5wYWdlQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VDaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VQYWdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucGFnZUNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9XG59XG5QYWdlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtcGFnZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ0lmPVwidGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlLnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ0ZW1wbGF0ZUNvbnRleHRcIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhdGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtcGFnZXItcHJldi1idXR0b25zICpuZ0lmPVwic2V0dGluZ3MucHJldmlvdXNOZXh0XCI+PC9rZW5kby10cmVlbGlzdC1wYWdlci1wcmV2LWJ1dHRvbnM+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtcGFnZXItbnVtZXJpYy1idXR0b25zXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzZXR0aW5ncy50eXBlID09PSAnbnVtZXJpYydcIlxuICAgICAgICAgICAgICAgIFtidXR0b25Db3VudF09XCJzZXR0aW5ncy5idXR0b25Db3VudFwiPlxuICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1wYWdlci1udW1lcmljLWJ1dHRvbnM+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtcGFnZXItaW5wdXQgKm5nSWY9XCJzZXR0aW5ncy50eXBlID09PSAnaW5wdXQnXCI+PC9rZW5kby10cmVlbGlzdC1wYWdlci1pbnB1dD5cbiAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1wYWdlci1uZXh0LWJ1dHRvbnMgKm5nSWY9XCJzZXR0aW5ncy5wcmV2aW91c05leHRcIj48L2tlbmRvLXRyZWVsaXN0LXBhZ2VyLW5leHQtYnV0dG9ucz5cbiAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1wYWdlci1pbmZvICpuZ0lmPSdzZXR0aW5ncy5pbmZvJz48L2tlbmRvLXRyZWVsaXN0LXBhZ2VyLWluZm8+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtcGFnZXItcGFnZS1zaXplcyAqbmdJZj1cInNldHRpbmdzLnBhZ2VTaXplc1wiIFtwYWdlU2l6ZXNdPVwic2V0dGluZ3MucGFnZVNpemVzXCI+PC9rZW5kby10cmVlbGlzdC1wYWdlci1wYWdlLXNpemVzPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5QYWdlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFBhZ2VyQ29udGV4dFNlcnZpY2UgfVxuXTtcblBhZ2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGFsbENvdW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0b3RhbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2tpcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFnZVNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWdlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcGFnZXJXcmFwQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstcGFnZXItd3JhcCcsXSB9XSxcbiAgICB0cmVlbGlzdFBhZ2VyQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZ3JpZC1wYWdlcicsXSB9XSxcbiAgICB3aWRnZXRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay13aWRnZXQnLF0gfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQYWdlckVsZW1lbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgcGFnZXJDb250ZXh0LCBjZCkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQgPSBwYWdlckNvbnRleHQ7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRoaXMucGFnZXJDb250ZXh0LnRvdGFsO1xuICAgICAgICB0aGlzLnNraXAgPSB0aGlzLnBhZ2VyQ29udGV4dC5za2lwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gdGhpcy5wYWdlckNvbnRleHQucGFnZVNpemU7XG4gICAgICAgIHRoaXMuYWxsQ291bnQgPSB0aGlzLnBhZ2VyQ29udGV4dC5hbGxDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJFbGVtZW50Q29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRQYWdlKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5za2lwIHx8IDApIC8gdGhpcy5wYWdlU2l6ZSkgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBQYWdlckVsZW1lbnRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdG90YWxQYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgodGhpcy50b3RhbCB8fCAwKSAvIHRoaXMucGFnZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBQYWdlckVsZW1lbnRDb21wb25lbnRcbiAgICAgKi9cbiAgICB0ZXh0Rm9yKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJFbGVtZW50Q29tcG9uZW50XG4gICAgICovXG4gICAgY2hhbmdlUGFnZShwYWdlKSB7XG4gICAgICAgIHRoaXMucGFnZXJDb250ZXh0LmNoYW5nZVBhZ2UocGFnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQG1lbWJlck9mIFBhZ2VyRWxlbWVudENvbXBvbmVudFxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLnBhZ2VyQ29udGV4dC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLm9uQ2hhbmdlcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyXG4vKipcbiAqIERpc3BsYXlzIGJ1dHRvbnMgZm9yIG5hdmlnYXRpbmcgdG8gdGhlIGZpcnN0IGFuZCB0byB0aGUgcHJldmlvdXMgcGFnZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBhZ2luZ190cmVlbGlzdCAlfSN0b2MtcGFnZXItdGVtcGxhdGVzKSkuXG4gKi9cbmNsYXNzIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQgZXh0ZW5kcyBQYWdlckVsZW1lbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgcGFnZXJDb250ZXh0LCBjZCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJQcmV2QnV0dG9uc0NvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2UgPT09IDEgfHwgIXRoaXMudG90YWw7XG4gICAgfVxuICAgIG9uQ2hhbmdlcyh7IHRvdGFsLCBza2lwLCBwYWdlU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbn1cblBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LXBhZ2VyLXByZXYtYnV0dG9ucycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGEgIGhyZWY9XCIjXCJcbiAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRleHRGb3IoJ3BhZ2VyRmlyc3RQYWdlJylcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImN1cnJlbnRQYWdlICE9PSAxID8gY2hhbmdlUGFnZSgwKSA6IGZhbHNlXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAnay1saW5rJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnay1wYWdlci1uYXYnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrLXN0YXRlLWRpc2FibGVkJzogZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgJ2stcGFnZXItZmlyc3QnOiB0cnVlXG4gICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICA8c3BhbiBbYXR0ci5hcmlhLWxhYmVsXT1cInRleHRGb3IoJ3BhZ2VyRmlyc3RQYWdlJylcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAgICAgJ2staWNvbic6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2staS1zZWVrLXcnOiB0cnVlXG4gICAgICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2E+XG4gICAgICAgIDxhICBocmVmPVwiI1wiXG4gICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJ0ZXh0Rm9yKCdwYWdlclByZXZpb3VzUGFnZScpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjdXJyZW50UGFnZSAhPT0gMSA/IGNoYW5nZVBhZ2UoY3VycmVudFBhZ2UtMikgOiBmYWxzZVwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAgICAgJ2stbGluayc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stcGFnZXItbmF2JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnay1zdGF0ZS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICcnOiB0cnVlXG4gICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICA8c3BhbiBbYXR0ci5hcmlhLWxhYmVsXT1cInRleHRGb3IoJ3BhZ2VyUHJldmlvdXNQYWdlJylcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAgICAgJ2staWNvbic6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2staS1hcnJvdy13JzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUGFnZXJQcmV2QnV0dG9uc0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFBhZ2VyQ29udGV4dFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5cbi8vIHRzbGludDpkaXNhYmxlOiBuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXJcbi8qKlxuICogRGlzcGxheXMgYnV0dG9ucyBmb3IgbmF2aWdhdGluZyB0byB0aGUgbmV4dCBhbmQgdG8gdGhlIGxhc3QgcGFnZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBhZ2luZ190cmVlbGlzdCAlfSN0b2MtcGFnZXItdGVtcGxhdGVzKSkuXG4gKi9cbmNsYXNzIFBhZ2VyTmV4dEJ1dHRvbnNDb21wb25lbnQgZXh0ZW5kcyBQYWdlckVsZW1lbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgcGFnZXJDb250ZXh0LCBjZCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJOZXh0QnV0dG9uc0NvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2UgPT09IHRoaXMudG90YWxQYWdlcyB8fCAhdGhpcy50b3RhbDtcbiAgICB9XG4gICAgb25DaGFuZ2VzKHsgdG90YWwsIHNraXAsIHBhZ2VTaXplIH0pIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuUGFnZXJOZXh0QnV0dG9uc0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtcGFnZXItbmV4dC1idXR0b25zJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YSAgaHJlZj1cIiNcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICBbdGl0bGVdPVwidGV4dEZvcigncGFnZXJOZXh0UGFnZScpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjdXJyZW50UGFnZSAhPT0gdG90YWxQYWdlcyA/IGNoYW5nZVBhZ2UoY3VycmVudFBhZ2UpIDogZmFsc2VcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICdrLWxpbmsnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrLXBhZ2VyLW5hdic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2stc3RhdGUtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAnJzogdHJ1ZVxuICAgICAgICAgICAgfVwiPlxuICAgICAgICAgICAgPHNwYW4gW2F0dHIuYXJpYS1sYWJlbF09XCJ0ZXh0Rm9yKCdwYWdlck5leHRQYWdlJylcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAgICAgJ2staWNvbic6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2staS1hcnJvdy1lJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgICAgICA8YSAgaHJlZj1cIiNcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICBbdGl0bGVdPVwidGV4dEZvcigncGFnZXJMYXN0UGFnZScpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjdXJyZW50UGFnZSAhPT0gdG90YWxQYWdlcyA/IGNoYW5nZVBhZ2UodG90YWxQYWdlcy0xKSA6IGZhbHNlXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAnay1saW5rJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnay1wYWdlci1uYXYnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdrLXN0YXRlLWRpc2FibGVkJzogZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgJ2stcGFnZXItbGFzdCc6IHRydWVcbiAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDxzcGFuIFthdHRyLmFyaWEtbGFiZWxdPVwidGV4dEZvcigncGFnZXJMYXN0UGFnZScpXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAgICAgICAgICdrLWljb24nOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICdrLWktc2Vlay1lJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUGFnZXJOZXh0QnV0dG9uc0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFBhZ2VyQ29udGV4dFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5cbi8qKlxuICogRGlzcGxheXMgbnVtZXJpYyBidXR0b25zIHRvIGVuYWJsZSBuYXZpZ2F0aW9uIGJldHdlZW4gdGhlIHBhZ2VzLlxuICovXG5jbGFzcyBQYWdlck51bWVyaWNCdXR0b25zQ29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNkLCBwYWdlckNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uLCBwYWdlckNvbnRleHQsIGNkKTtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQgPSBwYWdlckNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBidXR0b25zKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMuc3RhcnQ7IGlkeCA8PSB0aGlzLmVuZDsgaWR4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbigodGhpcy5zdGFydCArIHRoaXMuYnV0dG9uQ291bnQpIC0gMSwgdGhpcy50b3RhbFBhZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzdGFydCgpIHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgICAgIGNvbnN0IGJ1dHRvbkNvdW50ID0gdGhpcy5idXR0b25Db3VudDtcbiAgICAgICAgaWYgKHBhZ2UgPiBidXR0b25Db3VudCkge1xuICAgICAgICAgICAgY29uc3QgcmVtaW5kZXIgPSAocGFnZSAlIGJ1dHRvbkNvdW50KTtcbiAgICAgICAgICAgIHJldHVybiAocmVtaW5kZXIgPT09IDApID8gKHBhZ2UgLSBidXR0b25Db3VudCkgKyAxIDogKHBhZ2UgLSByZW1pbmRlcikgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcGFnZUxhYmVsKG51bSkge1xuICAgICAgICBjb25zdCBwYWdlVGV4dCA9IHRoaXMudGV4dEZvcigncGFnZXJQYWdlJyk7XG4gICAgICAgIGlmIChwYWdlVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2VUZXh0ICsgJyAnICsgbnVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW0udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgb25DaGFuZ2VzKHsgdG90YWwsIHNraXAsIHBhZ2VTaXplIH0pIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtcGFnZXItbnVtZXJpYy1idXR0b25zJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgIDx1bCBbbmdDbGFzc109XCJ7J2stcGFnZXItbnVtYmVycyc6IHRydWUsICdrLXJlc2V0JzogdHJ1ZX1cIj5cbiAgICAgICAgICAgIDxsaSAqbmdJZj1cInN0YXJ0ID4gMVwiPlxuICAgICAgICAgICAgICAgIDxhICBjbGFzcz1cImstbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicGFnZUxhYmVsKHN0YXJ0IC0gMSlcIlxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlUGFnZShzdGFydCAtIDIpXCI+Li4uPC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgbnVtIG9mIGJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICA8YSAgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInBhZ2VMYWJlbChudW0pXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnay1saW5rJzogdHJ1ZSwgJ2stc3RhdGUtc2VsZWN0ZWQnOmN1cnJlbnRQYWdlID09IG51bX1cIlxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlUGFnZShudW0gLSAxKVwiPlxuICAgICAgICAgICAgICAgICAgICB7e251bX19XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDxsaSAqbmdJZj1cImVuZCA8IHRvdGFsUGFnZXNcIj5cbiAgICAgICAgICAgICAgICA8YSAgY2xhc3M9XCJrLWxpbmtcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInBhZ2VMYWJlbChlbmQgKyAxKVwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjaGFuZ2VQYWdlKGVuZClcIj4uLi48L2E+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L3VsPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBQYWdlckNvbnRleHRTZXJ2aWNlIH1cbl07XG5QYWdlck51bWVyaWNCdXR0b25zQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGJ1dHRvbkNvdW50OiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBEaXNwbGF5cyBhbiBpbnB1dCBlbGVtZW50IHdoaWNoIGFsbG93cyB0aGUgdHlwaW5nIGFuZCByZW5kZXJpbmcgb2YgcGFnZSBudW1iZXJzLlxuICovXG5jbGFzcyBQYWdlcklucHV0Q29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgem9uZSwgY2QpIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uLCBwYWdlckNvbnRleHQsIGNkKTtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQgPSBwYWdlckNvbnRleHQ7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgUGFnZXJJbnB1dENvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5jb21pbmdWYWx1ZSA9IHRoaXMubnVtZXJpY0lucHV0LnZhbHVlIHx8IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLZXlzLkVudGVyKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jb21pbmdWYWx1ZSAhPT0gdGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKGluY29taW5nVmFsdWUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIFBhZ2VySW5wdXRDb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSB0aGlzLm51bWVyaWNJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIGlmICghaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtZXJpY0lucHV0LndyaXRlVmFsdWUodGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gdGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlUGFnZShpbnB1dFZhbHVlIC0gMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzUGFnZXMgPyB0aGlzLmN1cnJlbnRQYWdlIDogMDtcbiAgICB9XG4gICAgZ2V0IGhhc1BhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbFBhZ2VzICE9PSAwO1xuICAgIH1cbiAgICBvbkNoYW5nZXMoeyB0b3RhbCwgc2tpcCwgcGFnZVNpemUgfSkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBwYWdlU2l6ZTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59XG5QYWdlcklucHV0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1wYWdlci1pbnB1dCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgPHNwYW4gW25nQ2xhc3NdPVwieydrLXBhZ2VyLWlucHV0JzogdHJ1ZSwgJ2stbGFiZWwnOiB0cnVlfVwiPlxuICAgICAgICB7e3RleHRGb3IoJ3BhZ2VyUGFnZScpfX1cbiAgICAgICAgPGtlbmRvLW51bWVyaWN0ZXh0Ym94XG4gICAgICAgICAgICBbc3R5bGUubWFyZ2luXT1cIicwIDFleCdcIlxuICAgICAgICAgICAgW3N0eWxlLndpZHRoXT1cIiczZW0nXCJcbiAgICAgICAgICAgIFtzcGlubmVyc109XCJmYWxzZVwiXG4gICAgICAgICAgICBbZGVjaW1hbHNdPVwiMFwiXG4gICAgICAgICAgICBmb3JtYXQ9XCJuMFwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiIWhhc1BhZ2VzXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJjdXJyZW50XCJcbiAgICAgICAgICAgIFttaW5dPVwiaGFzUGFnZXMgPyAxIDogMFwiXG4gICAgICAgICAgICBbbWF4XT1cInRvdGFsUGFnZXNcIlxuICAgICAgICAgICAgW2F1dG9Db3JyZWN0XT1cInRydWVcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRleHRGb3IoJ3BhZ2VyUGFnZU51bWJlcklucHV0VGl0bGUnKVwiXG4gICAgICAgICAgICBba2VuZG9FdmVudHNPdXRzaWRlQW5ndWxhcl09XCJ7XG4gICAgICAgICAgICAgICAga2V5ZG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgICAgICBmb2N1c291dDogaGFuZGxlQmx1clxuICAgICAgICAgICAgfVwiPlxuICAgICAgICA8L2tlbmRvLW51bWVyaWN0ZXh0Ym94PlxuICAgICAgICAgICAge3t0ZXh0Rm9yKCdwYWdlck9mJyl9fSB7e3RvdGFsUGFnZXN9fVxuICAgICA8L3NwYW4+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5QYWdlcklucHV0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogUGFnZXJDb250ZXh0U2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuUGFnZXJJbnB1dENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBudW1lcmljSW5wdXQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW051bWVyaWNUZXh0Qm94Q29tcG9uZW50LF0gfV1cbn07XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlclxuLyoqXG4gKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBwYWdlIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwYWdpbmdfdHJlZWxpc3QgJX0jdG9jLXBhZ2VyLXRlbXBsYXRlcykpLlxuICovXG5jbGFzcyBQYWdlckluZm9Db21wb25lbnQgZXh0ZW5kcyBQYWdlckVsZW1lbnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgY2QsIHBhZ2VyQ29udGV4dCkge1xuICAgICAgICBzdXBlcihsb2NhbGl6YXRpb24sIHBhZ2VyQ29udGV4dCwgY2QpO1xuICAgICAgICB0aGlzLnBhZ2VyQ29udGV4dCA9IHBhZ2VyQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJJbmZvQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRQYWdlVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWwgPyB0aGlzLmN1cnJlbnRQYWdlIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJJbmZvQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IG1heFBhZ2UoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy50b3RhbCAvIHRoaXMucGFnZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgUGFnZXJJbmZvQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvbkNoYW5nZXMoeyBhbGxDb3VudCwgdG90YWwsIHNraXAsIHBhZ2VTaXplIH0pIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIHRoaXMuYWxsQ291bnQgPSBhbGxDb3VudDtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59XG5QYWdlckluZm9Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LXBhZ2VyLWluZm8nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBge3t0ZXh0Rm9yKCdwYWdlclBhZ2UnKX19IHt7Y3VycmVudFBhZ2VUZXh0fX0ge3t0ZXh0Rm9yKCdwYWdlck9mJyl9fSB7e21heFBhZ2V9fSAoe3thbGxDb3VudH19IHt7dGV4dEZvcigncGFnZXJJdGVtc1RvdGFsJyl9fSlgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBhZ2VySW5mb0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBQYWdlckNvbnRleHRTZXJ2aWNlIH1cbl07XG5QYWdlckluZm9Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFtcImNsYXNzLmstcGFnZXItaW5mb1wiLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogW1wiY2xhc3Muay1sYWJlbFwiLF0gfV1cbn07XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlclxuLyoqXG4gKiBEaXNwbGF5cyBhIGRyb3AtZG93biBsaXN0IGZvciB0aGUgcGFnZSBzaXplIHNlbGVjdGlvbiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBhZ2luZ190cmVlbGlzdCAlfSN0b2MtcGFnZXItdGVtcGxhdGVzKSkuXG4gKi9cbmNsYXNzIFBhZ2VyUGFnZVNpemVzQ29tcG9uZW50IGV4dGVuZHMgUGFnZXJFbGVtZW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNkLCBwYWdlckNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobG9jYWxpemF0aW9uLCBwYWdlckNvbnRleHQsIGNkKTtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQgPSBwYWdlckNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhZ2VTaXplcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgcGFnZVNpemVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZVNpemVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGFnZSBzaXplcyBjb2xsZWN0aW9uLiBDYW4gYmUgYW4gQXJyYXkgb2YgbnVtYmVycyBhbmQvb3IgUGFnZVNpemVJdGVtIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiB7JSBtZXRhIGhlaWdodDo1MDAgJX1cbiAgICAgKiB7JSBlbWJlZF9maWxlIGNvbmZpZ3VyYXRpb24vcGFnZXItdGVtcGxhdGUtcGFnZS1zaXplcy9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAgICAgKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzICV9XG4gICAgICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZmlsZXN5c3RlbS50cyAlfVxuICAgICAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgJX1cbiAgICAgKiB7JSBlbmRtZXRhICV9XG4gICAgICovXG4gICAgc2V0IHBhZ2VTaXplcyhwYWdlU2l6ZXMpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEl0ZW1zID0gW107XG4gICAgICAgIHBhZ2VTaXplcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wYWdlU2l6ZXMgPSBub3JtYWxpemVkSXRlbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBjbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IHNob3dJbml0aWFsUGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VTaXplc1xuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS52YWx1ZSA9PT0gTnVtYmVyKHRoaXMucGFnZVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWwgPT09IE51bWJlcih0aGlzLnBhZ2VTaXplKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwYWdlU2l6ZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgdGhpcy5wYWdlckNvbnRleHQuY2hhbmdlUGFnZVNpemUodGhpcy5wYWdlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZShwYWdlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcGFnZS52YWx1ZSA9PT0gJ251bWJlcicgPyBwYWdlLnZhbHVlIDogdGhpcy50b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkU3RhdGUocGFnZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhZ2UudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFnZS52YWx1ZSA9PT0gdGhpcy5wYWdlU2l6ZSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVNpemUgPT09IHRoaXMudG90YWw7XG4gICAgfVxuICAgIG9uQ2hhbmdlcyh7IHRvdGFsLCBza2lwLCBwYWdlU2l6ZSB9KSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHR5cGVvZiBwYWdlU2l6ZSA9PT0gJ251bWJlcicgPyBwYWdlU2l6ZSA6IHRoaXMudG90YWw7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuUGFnZXJQYWdlU2l6ZXNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LXBhZ2VyLXBhZ2Utc2l6ZXMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzZWxlY3QgI3NlbGVjdFxuICAgICAgICAgICAgKGNoYW5nZSk9XCJwYWdlU2l6ZUNoYW5nZShzZWxlY3QudmFsdWUpXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwidGV4dEZvcigncGFnZXJJdGVtc1BlclBhZ2UnKVwiPlxuICAgICAgICAgICAgPG9wdGlvbiAqbmdJZj1cInNob3dJbml0aWFsUGFnZVNpemVcIiBbdmFsdWVdPVwicGFnZVNpemVcIj57e3BhZ2VTaXplfX08L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IHBhZ2Ugb2YgcGFnZVNpemVzXCIgW3ZhbHVlXT1cImdldFZhbHVlKHBhZ2UpXCIgW3NlbGVjdGVkXT1cImdldFNlbGVjdGVkU3RhdGUocGFnZSlcIj5cbiAgICAgICAgICAgICAgICB7e3BhZ2VbJ3RleHQnXX19XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIHt7IHRleHRGb3IoJ3BhZ2VySXRlbXNQZXJQYWdlJykgfX1cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBhZ2VyUGFnZVNpemVzQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFBhZ2VyQ29udGV4dFNlcnZpY2UgfVxuXTtcblBhZ2VyUGFnZVNpemVzQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHBhZ2VTaXplczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFtcImNsYXNzLmstcGFnZXItc2l6ZXNcIixdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFtcImNsYXNzLmstbGFiZWxcIixdIH1dXG59O1xuXG5jb25zdCBpbXBvcnRlZE1vZHVsZXMkMSA9IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgSW5wdXRzTW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZSxcbiAgICBFdmVudHNNb2R1bGVcbl07XG5jb25zdCBJTlRFUk5BTF9DT01QT05FTlRTJDEgPSBbXG4gICAgUGFnZXJDb21wb25lbnQsXG4gICAgUGFnZXJQcmV2QnV0dG9uc0NvbXBvbmVudCxcbiAgICBQYWdlck5leHRCdXR0b25zQ29tcG9uZW50LFxuICAgIFBhZ2VyTnVtZXJpY0J1dHRvbnNDb21wb25lbnQsXG4gICAgUGFnZXJJbnB1dENvbXBvbmVudCxcbiAgICBQYWdlckluZm9Db21wb25lbnQsXG4gICAgUGFnZXJQYWdlU2l6ZXNDb21wb25lbnQsXG4gICAgUGFnZXJUZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQYWdlck1vZHVsZSB7XG4gICAgc3RhdGljIGV4cG9ydHMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBQYWdlckNvbXBvbmVudCxcbiAgICAgICAgICAgIFBhZ2VyUHJldkJ1dHRvbnNDb21wb25lbnQsXG4gICAgICAgICAgICBQYWdlck5leHRCdXR0b25zQ29tcG9uZW50LFxuICAgICAgICAgICAgUGFnZXJOdW1lcmljQnV0dG9uc0NvbXBvbmVudCxcbiAgICAgICAgICAgIFBhZ2VySW5wdXRDb21wb25lbnQsXG4gICAgICAgICAgICBQYWdlckluZm9Db21wb25lbnQsXG4gICAgICAgICAgICBQYWdlclBhZ2VTaXplc0NvbXBvbmVudCxcbiAgICAgICAgICAgIFBhZ2VyVGVtcGxhdGVEaXJlY3RpdmVcbiAgICAgICAgXTtcbiAgICB9XG59XG5QYWdlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbSU5URVJOQUxfQ09NUE9ORU5UUyQxXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbSU5URVJOQUxfQ09NUE9ORU5UUyQxXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbLi4uaW1wb3J0ZWRNb2R1bGVzJDFdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgICBhbGxvd1Vuc29ydDogdHJ1ZSxcbiAgICBtb2RlOiAnc2luZ2xlJyxcbiAgICBzaG93SW5kZXhlczogdHJ1ZSxcbiAgICBpbml0aWFsRGlyZWN0aW9uOiAnYXNjJ1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub3JtYWxpemUkMSA9ICguLi5zZXR0aW5ncykgPT4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFMsIC4uLnNldHRpbmdzKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyb3BUYXJnZXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgICAgIHRoaXMuZW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZHJvcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmFkZCh0aGlzKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuc2VydmljZS5jaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IHRhcmdldCB9KSA9PiB0YXJnZXQgPT09IHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChjaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gJ2xlYXZlJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5sZWF2ZS5uZXh0KHRoaXMuZXZlbnRBcmdzKGUpKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGNoYW5nZXMucGlwZShmaWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAnZW50ZXInKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVudGVyLm5leHQodGhpcy5ldmVudEFyZ3MoZSkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoY2hhbmdlcy5waXBlKGZpbHRlcigoeyB0eXBlIH0pID0+IHR5cGUgPT09ICdkcm9wJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcm9wLm5leHQodGhpcy5ldmVudEFyZ3MoZSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBldmVudEFyZ3MoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgbW91c2VFdmVudDogZS5tb3VzZUV2ZW50LFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBlLmRyYWdnYWJsZVxuICAgICAgICB9O1xuICAgIH1cbn1cbkRyb3BUYXJnZXREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0Ryb3BUYXJnZXRdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Ecm9wVGFyZ2V0RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogRHJhZ0FuZERyb3BTZXJ2aWNlIH1cbl07XG5Ecm9wVGFyZ2V0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbnRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGVudGVyOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgbGVhdmU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBkcm9wOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoYXNGaWx0ZXIgPSAoc2V0dGluZ3MsIGNvbHVtbikgPT4gc2V0dGluZ3MuZmlsdGVyICE9PSBmYWxzZSAmJiBjb2x1bW4uZmllbGQgJiYgY29sdW1uLmZpbHRlcmFibGU7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzU29ydCA9IChzZXR0aW5ncywgY29sdW1uKSA9PiBzZXR0aW5ncy5zb3J0ICE9PSBmYWxzZSAmJiBjb2x1bW4uZmllbGQgJiYgY29sdW1uLnNvcnRhYmxlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc0xvY2sgPSAoc2V0dGluZ3MsIGNvbHVtbikgPT4gc2V0dGluZ3MubG9jayAmJiBjb2x1bW4ubG9ja2FibGUgJiYgIShjb2x1bW4ucGFyZW50ICYmICFjb2x1bW4ucGFyZW50LmlzU3BhbkNvbHVtbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ29sdW1uQ2hvb3NlciA9IChzZXR0aW5ncykgPT4gc2V0dGluZ3MuY29sdW1uQ2hvb3NlciAhPT0gZmFsc2U7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzSXRlbXMgPSAoc2V0dGluZ3MsIGNvbHVtbikgPT4gaGFzQ29sdW1uQ2hvb3NlcihzZXR0aW5ncykgfHwgaGFzTG9jayhzZXR0aW5ncywgY29sdW1uKSB8fCBoYXNTb3J0KHNldHRpbmdzLCBjb2x1bW4pIHx8IGhhc0ZpbHRlcihzZXR0aW5ncywgY29sdW1uKTtcblxuY29uc3QgbWVyZ2VPYmplY3RzID0gKC4uLmFyZ3MpID0+IE9iamVjdC5hc3NpZ24uYXBwbHkobnVsbCwgW3t9XS5jb25jYXQoYXJncykpO1xuY29uc3QgZGlyZWN0aW9ucyA9IGluaXRpYWxEaXJlY3Rpb24gPT4gaW5pdGlhbERpcmVjdGlvbiA9PT0gXCJhc2NcIiA/IFtcImFzY1wiLCBcImRlc2NcIl0gOiBbXCJkZXNjXCIsIFwiYXNjXCJdO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzUm9vdExldmVsID0gKHsgcGFyZW50IH0pID0+ICFpc1RydXRoeShwYXJlbnQpO1xuY29uc3Qgb2ZDb2x1bW5UeXBlID0gKHsgZHJhZ2dhYmxlIH0pID0+IFsnY29sdW1uJywgJ2NvbHVtbkdyb3VwJ11cbiAgICAuaW5kZXhPZihkcmFnZ2FibGUuY29udGV4dC50eXBlKSA+PSAwO1xuY29uc3Qgbm90U2FtZUVsZW1lbnQgPSAoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiBkcmFnZ2FibGUuZWxlbWVudC5uYXRpdmVFbGVtZW50ICE9PSB0YXJnZXQuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuY29uc3QgaW5TYW1lUGFyZW50ID0gKHgsIHkpID0+IHgucGFyZW50ID09PSB5LnBhcmVudCB8fFxuICAgIChpc0luU3BhbkNvbHVtbih5KSAmJiBpblNhbWVQYXJlbnQoeCwgeS5wYXJlbnQpKTtcbmNvbnN0IHNhbWVQYXJlbnQgPSAoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiBpblNhbWVQYXJlbnQoZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uLCB0YXJnZXQuY29udGV4dC5jb2x1bW4pO1xuY29uc3QgbGFzdE5vbkxvY2tlZCA9ICh7IGRyYWdnYWJsZSB9KSA9PiAhaXNUcnV0aHkoZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uLmxvY2tlZCkgJiZcbiAgICBpc1Jvb3RMZXZlbChkcmFnZ2FibGUuY29udGV4dC5jb2x1bW4pICYmXG4gICAgZHJhZ2dhYmxlLmNvbnRleHQubGFzdENvbHVtbjtcbmNvbnN0IG5vdEluU3BhbkNvbHVtbiA9ICh7IGRyYWdnYWJsZSB9KSA9PiAhaXNJblNwYW5Db2x1bW4oZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uKTtcbmNvbnN0IHJlb3JkZXJhYmxlID0gKHsgZHJhZ2dhYmxlIH0pID0+IGRyYWdnYWJsZS5jb250ZXh0LmNvbHVtbi5yZW9yZGVyYWJsZTtcbmNvbnN0IGxvY2thYmxlID0gKHsgZHJhZ2dhYmxlLCB0YXJnZXQgfSkgPT4gZHJhZ2dhYmxlLmNvbnRleHQuY29sdW1uLmxvY2thYmxlICE9PSBmYWxzZSB8fFxuICAgIGRyYWdnYWJsZS5jb250ZXh0LmNvbHVtbi5pc0xvY2tlZCA9PT0gdGFyZ2V0LmNvbnRleHQuY29sdW1uLmlzTG9ja2VkO1xuY29uc3QgcnVsZXMgPSBhbmQob2ZDb2x1bW5UeXBlLCByZW9yZGVyYWJsZSwgbm90SW5TcGFuQ29sdW1uLCBub3RTYW1lRWxlbWVudCwgc2FtZVBhcmVudCwgbm90KGxhc3ROb25Mb2NrZWQpLCBsb2NrYWJsZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSGVhZGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGhpbnQsIGN1ZSwgcmVvcmRlclNlcnZpY2UsIHNvcnRTZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGNkKSB7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLmhpbnQgPSBoaW50O1xuICAgICAgICB0aGlzLmN1ZSA9IGN1ZTtcbiAgICAgICAgdGhpcy5yZW9yZGVyU2VydmljZSA9IHJlb3JkZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNvcnRTZXJ2aWNlID0gc29ydFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZSA9IHNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnNvcnQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zb3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvY2tlZENvbHVtbnNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVzaXphYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVvcmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2x1bW5NZW51ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG90YWxDb2x1bW5zQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnNvcnRlZEZpZWxkcyA9IHt9O1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRzID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgZ2V0IGhlYWRlckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2Nyb2xsYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNvcnRhYmxlTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ3NvcnRhYmxlJyk7XG4gICAgfVxuICAgIC8vIE51bWJlciBvZiB1bmxvY2tlZCBjb2x1bW5zIGluIHRoZSBuZXh0IHRhYmxlLCBpZiBhbnlcbiAgICBnZXQgdW5sb2NrZWRDb2x1bW5zQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29sdW1uc0NvdW50IC0gdGhpcy5sb2NrZWRDb2x1bW5zQ291bnQgLSB0aGlzLmNvbHVtbnMubGVuZ3RoO1xuICAgIH1cbiAgICBzb3J0Q29sdW1uKGNvbHVtbiwgZXZlbnQsIGxpbmspIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQgPyBldmVudC50YXJnZXQgOiBudWxsO1xuICAgICAgICBpZiAoY29sdW1uLmhlYWRlclRlbXBsYXRlUmVmICYmIHRhcmdldCAhPT0gbGluaykge1xuICAgICAgICAgICAgY29uc3QgaGFzRm9jdXNhYmxlUGFyZW50ID0gQm9vbGVhbihjbG9zZXN0SW5TY29wZSh0YXJnZXQsIGlzRm9jdXNhYmxlLCBsaW5rKSk7XG4gICAgICAgICAgICBpZiAoaGFzRm9jdXNhYmxlUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC50eXBlID09PSAnY2hlY2tib3gnOyAvLyBwcmV2ZW50IG5hdmlnYXRpb24gb25seSBpZiB0aGUgZWxlbWVudCBpcyBub3QgY2hlY2tib3hcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnRTZXJ2aWNlLnNvcnQodGhpcy50b2dnbGVTb3J0KGNvbHVtbikpO1xuICAgICAgICAvLyBQcmV2ZW50IG5hdmlnYXRpb25cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvbkhlYWRlcktleWRvd24oY29sdW1uLCBhcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3J0YWJsZSB8fCBhcmdzLmRlZmF1bHRQcmV2ZW50ZWQgfHwgY29sdW1uLnNvcnRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFNlcnZpY2Uuc29ydCh0aGlzLnRvZ2dsZVNvcnQoY29sdW1uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd1NvcnROdW1iZXJpbmcoY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHsgc2hvd0luZGV4ZXMgfSA9IG5vcm1hbGl6ZSQxKHRoaXMuc29ydGFibGUpO1xuICAgICAgICByZXR1cm4gc2hvd0luZGV4ZXNcbiAgICAgICAgICAgICYmIHRoaXMuc29ydFxuICAgICAgICAgICAgJiYgdGhpcy5zb3J0LmZpbHRlcigoeyBkaXIgfSkgPT4gaXNQcmVzZW50KGRpcikpLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICYmIHRoaXMuc29ydE9yZGVyKGNvbHVtbi5maWVsZCkgPiAwO1xuICAgIH1cbiAgICBzb3J0T3JkZXIoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydFxuICAgICAgICAgICAgLmZpbHRlcigoeyBkaXIgfSkgPT4gaXNQcmVzZW50KGRpcikpXG4gICAgICAgICAgICAuZmluZEluZGV4KHggPT4geC5maWVsZCA9PT0gZmllbGQpXG4gICAgICAgICAgICArIDE7XG4gICAgfVxuICAgIHNvcnRJY29uKGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlJCQxID0gdGhpcy5zb3J0RGVzY3JpcHRvcihmaWVsZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnay1pY29uJzogaXNQcmVzZW50KHN0YXRlJCQxLmRpciksXG4gICAgICAgICAgICAnay1pLXNvcnQtZGVzYy1zbSc6IHN0YXRlJCQxLmRpciA9PT0gXCJkZXNjXCIsXG4gICAgICAgICAgICAnay1pLXNvcnQtYXNjLXNtJzogc3RhdGUkJDEuZGlyID09PSBcImFzY1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNvcnRTdGF0ZShjb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU29ydGFibGUoY29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlJCQxID0gdGhpcy5zb3J0RGVzY3JpcHRvcihjb2x1bW4uZmllbGQpO1xuICAgICAgICBpZiAoc3RhdGUkJDEuZGlyID09PSAnYXNjJykge1xuICAgICAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSQkMS5kaXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgcmV0dXJuICdkZXNjZW5kaW5nJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzb3J0U3RhdHVzKGNvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMuc29ydGVkRmllbGRzW2NvbHVtbi5maWVsZF0gfHwgIXRoaXMuaXNTb3J0YWJsZShjb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1zZyA9ICdzb3J0ZWREZWZhdWx0JztcbiAgICAgICAgY29uc3Qgc3RhdGUkJDEgPSB0aGlzLnNvcnREZXNjcmlwdG9yKGNvbHVtbi5maWVsZCk7XG4gICAgICAgIGlmIChzdGF0ZSQkMS5kaXIgPT09ICdhc2MnKSB7XG4gICAgICAgICAgICBtc2cgPSAnc29ydGVkQXNjZW5kaW5nJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSQkMS5kaXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgbXNnID0gJ3NvcnRlZERlc2NlbmRpbmcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQobXNnKTtcbiAgICB9XG4gICAgdG9nZ2xlU29ydChjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd1Vuc29ydCwgbW9kZSwgaW5pdGlhbERpcmVjdGlvbiB9ID0gbm9ybWFsaXplJDEodGhpcy5zb3J0YWJsZSwgY29sdW1uLnNvcnRhYmxlKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudG9nZ2xlRGlyZWN0aW9uKGNvbHVtbi5maWVsZCwgYWxsb3dVbnNvcnQsIGluaXRpYWxEaXJlY3Rpb24pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHJldHVybiBbZGVzY3JpcHRvcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnNvcnQuZmlsdGVyKGRlc2MgPT4gZGVzYy5maWVsZCAhPT0gY29sdW1uLmZpZWxkKSwgZGVzY3JpcHRvcl07XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKG9ic2VydmUodGhpcy5kcm9wVGFyZ2V0cylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5hdHRhY2hUYXJnZXRzLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICB0aGlzLl9sZWFmQ29sdW1ucyA9IGNvbHVtbnNUb1JlbmRlcih0aGlzLmNvbHVtbnMgfHwgW10pLmZpbHRlcih4ID0+ICFpc0NvbHVtbkdyb3VwQ29tcG9uZW50KHgpKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzb3J0Q2hhbmdlID0gY2hhbmdlcy5zb3J0O1xuICAgICAgICBpZiAoc29ydENoYW5nZSAmJiAhc29ydENoYW5nZS5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgICAgICAgIHNvcnRDaGFuZ2UuY3VycmVudFZhbHVlLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRlZEZpZWxkc1tjaGFuZ2UuZmllbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGQodGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9wdXBTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwU2VydmljZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaXNGaXJzdE9uUm93KGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaXNUYWlsaW5nID0gKGMpID0+IGMgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbHVtbnNGb3JMZXZlbChjLmxldmVsKS5pbmRleE9mKGMpID4gMCB8fCBpc1RhaWxpbmcoYy5wYXJlbnQpKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwICYmIGlzVGFpbGluZyhjb2x1bW4ucGFyZW50KTtcbiAgICB9XG4gICAgbG9naWNhbENvbHVtbkluZGV4KGNvbHVtbikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbHVtbi5sZWFmSW5kZXg7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgc2hvd0ZpbHRlck1lbnUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2x1bW5NZW51ICYmIGhhc0ZpbHRlck1lbnUodGhpcy5maWx0ZXJhYmxlKTtcbiAgICB9XG4gICAgZ2V0IHNob3dGaWx0ZXJSb3coKSB7XG4gICAgICAgIHJldHVybiBoYXNGaWx0ZXJSb3codGhpcy5maWx0ZXJhYmxlKTtcbiAgICB9XG4gICAgc2hvd0NvbHVtbk1lbnUoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbk1lbnUgJiYgY29sdW1uLmNvbHVtbk1lbnUgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbHVtbk1lbnVUZW1wbGF0ZSB8fCBjb2x1bW4uY29sdW1uTWVudVRlbXBsYXRlcy5sZW5ndGggfHwgaGFzSXRlbXModGhpcy5jb2x1bW5NZW51LCBjb2x1bW4pKTtcbiAgICB9XG4gICAgaXNGaWx0ZXJhYmxlKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gIWlzTnVsbE9yRW1wdHlTdHJpbmcoY29sdW1uLmZpZWxkKSAmJiBjb2x1bW4uZmlsdGVyYWJsZSA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2FuRHJvcChkcmFnZ2FibGUsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9yZGVyYWJsZSAmJiBydWxlcyh7IGRyYWdnYWJsZSwgdGFyZ2V0IH0pO1xuICAgIH1cbiAgICBzaG91bGRBY3RpdmF0ZShjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVvcmRlcmFibGUgJiYgY29sdW1uLnJlb3JkZXJhYmxlO1xuICAgIH1cbiAgICBpc1NvcnRhYmxlKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gIWlzTnVsbE9yRW1wdHlTdHJpbmcoY29sdW1uLmZpZWxkKVxuICAgICAgICAgICAgJiYgaXNUcnV0aHkodGhpcy5zb3J0YWJsZSkgJiYgaXNUcnV0aHkoY29sdW1uLnNvcnRhYmxlKTtcbiAgICB9XG4gICAgdHJhY2tCeUluZGV4KGluZGV4LCBfaXRlbSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIHRvZ2dsZURpcmVjdGlvbihmaWVsZCwgYWxsb3dVbnNvcnQsIGluaXRpYWxEaXJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuc29ydERlc2NyaXB0b3IoZmllbGQpO1xuICAgICAgICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSBkaXJlY3Rpb25zKGluaXRpYWxEaXJlY3Rpb24pO1xuICAgICAgICBsZXQgZGlyID0gZmlyc3Q7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmRpciA9PT0gZmlyc3QpIHtcbiAgICAgICAgICAgIGRpciA9IHNlY29uZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yLmRpciA9PT0gc2Vjb25kICYmIGFsbG93VW5zb3J0KSB7XG4gICAgICAgICAgICBkaXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGlyLCBmaWVsZCB9O1xuICAgIH1cbiAgICBjb2x1bW5zRm9yTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucyA/IHRoaXMuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sZXZlbCA9PT0gbGV2ZWwpIDogW107XG4gICAgICAgIHJldHVybiBzb3J0Q29sdW1ucyhjb2x1bW5zVG9SZW5kZXIoY29sdW1ucykpO1xuICAgIH1cbiAgICBpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbikge1xuICAgICAgICByZXR1cm4gaXNDb2x1bW5Hcm91cENvbXBvbmVudChjb2x1bW4pO1xuICAgIH1cbiAgICBnZXQgY29sdW1uTGV2ZWxzKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KCh0aGlzLnRvdGFsQ29sdW1uTGV2ZWxzIHx8IDApICsgMSk7XG4gICAgfVxuICAgIHJlbmRlclNlbGVjdEFsbChjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5pc0NoZWNrYm94Q29sdW1uICYmIGNvbHVtbi5zaG93U2VsZWN0QWxsICYmICFjb2x1bW4uaGVhZGVyVGVtcGxhdGVSZWYgJiZcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5lbmFibGVNdWx0aXBsZTtcbiAgICB9XG4gICAgc2VsZWN0QWxsQ2xpY2soYXJncykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UudG9nZ2xlQWxsKGFyZ3MudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICBzb3J0RGVzY3JpcHRvcihmaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0LmZpbmQoaXRlbSA9PiBpdGVtLmZpZWxkID09PSBmaWVsZCkgfHwgeyBmaWVsZCB9O1xuICAgIH1cbiAgICBnZXQgbGVhZkNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmQ29sdW1ucztcbiAgICB9XG4gICAgYXR0YWNoVGFyZ2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICBjb25zdCBlbnRlclN0cmVhbSA9IG1lcmdlKC4uLnRoaXMuZHJvcFRhcmdldHMubWFwKHRhcmdldCA9PiB0YXJnZXQuZW50ZXIpKTtcbiAgICAgICAgY29uc3QgbGVhdmVTdHJlYW0gPSBtZXJnZSguLi50aGlzLmRyb3BUYXJnZXRzLm1hcCh0YXJnZXQgPT4gdGFyZ2V0LmxlYXZlKSk7XG4gICAgICAgIGNvbnN0IGRyb3BTdHJlYW0gPSBtZXJnZSguLi50aGlzLmRyb3BUYXJnZXRzLm1hcCh0YXJnZXQgPT4gdGFyZ2V0LmRyb3ApKTtcbiAgICAgICAgdGhpcy50YXJnZXRTdWJzY3JpcHRpb24uYWRkKGVudGVyU3RyZWFtLnBpcGUodGFwKCh7IHRhcmdldCwgZHJhZ2dhYmxlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExvY2tlZCA9IGlzVHJ1dGh5KHRhcmdldC5jb250ZXh0LmNvbHVtbi5pc0xvY2tlZCk7XG4gICAgICAgICAgICBjb25zdCBkcmFnZ2FibGVMb2NrZWQgPSBpc1RydXRoeShkcmFnZ2FibGUuY29udGV4dC5jb2x1bW4uaXNMb2NrZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9ja2VkQ29sdW1uc0NvdW50ID4gMCB8fCB0YXJnZXRMb2NrZWQgfHwgZHJhZ2dhYmxlTG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaW50LnRvZ2dsZUxvY2sodGFyZ2V0TG9ja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIGZpbHRlcigoeyBkcmFnZ2FibGUsIHRhcmdldCB9KSA9PiB0aGlzLmNhbkRyb3AoZHJhZ2dhYmxlLCB0YXJnZXQpKSwgc3dpdGNoTWFwKHRoaXMudHJhY2tNb3ZlLmJpbmQodGhpcywgbGVhdmVTdHJlYW0sIGRyb3BTdHJlYW0pKSwgbWFwKChlKSA9PiBtZXJnZU9iamVjdHMoZSwgeyBiZWZvcmU6IHRoaXMuY2FsY3VsYXRlQmVmb3JlKGUpLCBjaGFuZ2VDb250YWluZXI6IGUuY2hhbmdlQ29udGFpbmVyIH0pKSwgbWFwKHRoaXMubm9ybWFsaXplVGFyZ2V0LmJpbmQodGhpcykpLCB0YXAodGhpcy5lbnRlci5iaW5kKHRoaXMpKSwgc3dpdGNoTWFwKChhcmdzKSA9PiBkcm9wU3RyZWFtLnBpcGUobWFwKCgpID0+IGFyZ3MpLCB0YWtlVW50aWwobGVhdmVTdHJlYW0ucGlwZSh0YXAodGhpcy5sZWF2ZS5iaW5kKHRoaXMpKSkpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuZHJvcC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVRhcmdldChlKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LmNvbnRleHQuY29sdW1uLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaXNTcGFuQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSB0aGlzLmRyb3BUYXJnZXRzLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U3BhbiA9IGFyci5maW5kKHQgPT4gdC5jb250ZXh0LmNvbHVtbi5wYXJlbnQgPT09IHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGZpcnN0U3Bhbik7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3QgPSBlLmJlZm9yZSA/IDAgOiBwYXJlbnQuY2hpbGRDb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB0YXJnZXQgPSBhcnJbaW5kZXggKyBhZGp1c3RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoZSwgeyB0YXJnZXQgfSk7XG4gICAgfVxuICAgIHRyYWNrTW92ZShsZWF2ZVN0cmVhbSwgZHJvcFN0cmVhbSwgZSkge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBlLnRhcmdldC5jb250ZXh0LmNvbHVtbjtcbiAgICAgICAgY29uc3QgbGV2ZWxDb2x1bW5zID0gdGhpcy5jb2x1bW5zRm9yTGV2ZWwoY29sdW1uLmxldmVsKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsZXZlbENvbHVtbnMuaW5kZXhPZihjb2x1bW4pO1xuICAgICAgICBjb25zdCBpc0ZpcnN0ID0gKGNvbHVtbi5sb2NrZWQgPyBpbmRleCA9PT0gbGV2ZWxDb2x1bW5zLmxlbmd0aCAtIDEgOiBpbmRleCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSBlLmRyYWdnYWJsZS5jb250ZXh0LmNvbHVtbi5pc0xvY2tlZCAhPT0gY29sdW1uLmlzTG9ja2VkO1xuICAgICAgICBpZiAoY2hhbmdlZCAmJiBpc0ZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5kcmFnZ2FibGUuZHJhZ1xuICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbChsZWF2ZVN0cmVhbSksIHRha2VVbnRpbChkcm9wU3RyZWFtKSwgbWFwKCh7IG1vdXNlRXZlbnQgfSkgPT4gbWVyZ2VPYmplY3RzKHsgY2hhbmdlQ29udGFpbmVyOiB0cnVlIH0sIGUsIHsgbW91c2VFdmVudCB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZihtZXJnZU9iamVjdHMoeyBjaGFuZ2VDb250YWluZXI6IGNoYW5nZWQgfSwgZSkpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVCZWZvcmUoeyBkcmFnZ2FibGUsIHRhcmdldCwgbW91c2VFdmVudCwgY2hhbmdlQ29udGFpbmVyID0gZmFsc2UgfSkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0LmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IGJlZm9yZSA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbmdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlZnQgfSA9IG9mZnNldCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRhcmdldEVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gbGVmdCArIGhhbGZXaWR0aDtcbiAgICAgICAgICAgIGJlZm9yZSA9IG1pZGRsZSA+IG1vdXNlRXZlbnQucGFnZVg7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb24ucnRsKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gIWJlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9IGlzVGFyZ2V0QmVmb3JlKGRyYWdnYWJsZS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZWZvcmU7XG4gICAgfVxuICAgIGVudGVyKHsgdGFyZ2V0LCBiZWZvcmUgfSkge1xuICAgICAgICB0aGlzLmhpbnQuZW5hYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsaXphdGlvbi5ydGwpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICFiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWUucG9zaXRpb24ocG9zaXRpb24odGFyZ2V0LmVsZW1lbnQubmF0aXZlRWxlbWVudCwgYmVmb3JlKSk7XG4gICAgfVxuICAgIGxlYXZlKCkge1xuICAgICAgICB0aGlzLmhpbnQuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLmN1ZS5oaWRlKCk7XG4gICAgfVxuICAgIGRyb3AoeyBkcmFnZ2FibGUsIHRhcmdldCwgYmVmb3JlLCBjaGFuZ2VDb250YWluZXIgfSkge1xuICAgICAgICB0aGlzLnJlb3JkZXJTZXJ2aWNlLnJlb3JkZXIoe1xuICAgICAgICAgICAgYmVmb3JlLFxuICAgICAgICAgICAgY2hhbmdlQ29udGFpbmVyLFxuICAgICAgICAgICAgc291cmNlOiBkcmFnZ2FibGUuY29udGV4dC5jb2x1bW4sXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5jb250ZXh0LmNvbHVtblxuICAgICAgICB9KTtcbiAgICB9XG59XG5IZWFkZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0SGVhZGVyXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHRyICpuZ0Zvcj1cImxldCBpIG9mIGNvbHVtbkxldmVsczsgbGV0IGxldmVsSW5kZXggPSBpbmRleFwiXG4gICAgICAgICAgICBrZW5kb1RyZWVMaXN0TG9naWNhbFJvd1xuICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibGV2ZWxJbmRleFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJsb2NrZWRDb2x1bW5zQ291bnQgPiAwXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENlbGxzQ291bnRdPVwiY29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsc0NvdW50XT1cInVubG9ja2VkQ29sdW1uc0NvdW50XCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbHVtbiBbbmdGb3JPZl09XCJjb2x1bW5zRm9yTGV2ZWwobGV2ZWxJbmRleClcIiBbbmdGb3JUcmFja0J5XT1cInRyYWNrQnlJbmRleFwiIGxldC1jb2x1bW5JbmRleD1cImluZGV4XCIgbGV0LWxhc3Q9XCJsYXN0XCI+XG4gICAgICAgICAgICAgICAgPHRoICpuZ0lmPVwiIWlzQ29sdW1uR3JvdXBDb21wb25lbnQoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RMb2dpY2FsQ2VsbCBbbG9naWNhbFJvd0luZGV4XT1cImxldmVsSW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cImxvZ2ljYWxDb2x1bW5JbmRleChjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbFNwYW5dPVwiY29sdW1uLmNvbHNwYW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcm93U3Bhbl09XCJjb2x1bW4ucm93c3Bhbih0b3RhbENvbHVtbkxldmVscylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwiY29sdW1uaGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1zb3J0XT1cInNvcnRTdGF0ZShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGtleWRvd24pPVwib25IZWFkZXJLZXlkb3duKGNvbHVtbiwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJvcFRhcmdldFxuICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZUNvbHVtblxuICAgICAgICAgICAgICAgICAgICBbZW5hYmxlRHJhZ109XCJzaG91bGRBY3RpdmF0ZShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50OiBjb2x1bW4udGl0bGUgfHwgY29sdW1uLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENvbHVtbjogbGFzdCAmJiBjb2x1bW5JbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWhlYWRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy5rLWZpbHRlcmFibGVdPVwiKHNob3dGaWx0ZXJNZW51ICYmIGlzRmlsdGVyYWJsZShjb2x1bW4pKSB8fCBzaG93Q29sdW1uTWVudShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstZmlyc3RdPVwiaXNGaXJzdE9uUm93KGNvbHVtbiwgY29sdW1uSW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY29sdW1uLmhlYWRlckNsYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiY29sdW1uLmhlYWRlclN0eWxlXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucm93c3Bhbl09XCJjb2x1bW4ucm93c3Bhbih0b3RhbENvbHVtbkxldmVscylcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5jb2xzcGFuXT1cImNvbHVtbi5jb2xzcGFuXCI+XG4gICAgICAgICAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1maWx0ZXItbWVudVxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJzaG93RmlsdGVyTWVudSAmJiBpc0ZpbHRlcmFibGUoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51PlxuICAgICAgICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uLW1lbnUgKm5nSWY9XCJzaG93Q29sdW1uTWVudShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZXR0aW5nc109XCJjb2x1bW5NZW51XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5NZW51VGVtcGxhdGVdPVwiY29sdW1uTWVudVRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzb3J0XT1cInNvcnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW3NvcnRhYmxlXT1cInNvcnRhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1uLW1lbnU+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNTb3J0YWJsZShjb2x1bW4pXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGVDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVSZWY6IGNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbi5sZWFmSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZlwiPnt7Y29sdW1uLmRpc3BsYXlUaXRsZX19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzU29ydGFibGUoY29sdW1uKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgI2xpbmsgaHJlZj1cIiNcIiB0YWJpbmRleD1cIi0xXCIgY2xhc3M9XCJrLWxpbmtcIiAoY2xpY2spPVwic29ydENvbHVtbihjb2x1bW4sICRldmVudCwgbGluaylcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlQ29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogY29sdW1uLmhlYWRlclRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbi5sZWFmSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhY29sdW1uLmhlYWRlclRlbXBsYXRlUmVmXCI+e3tjb2x1bW4uZGlzcGxheVRpdGxlfX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFthdHRyLmFyaWEtbGFiZWxdPVwic29ydGFibGVMYWJlbFwiIFtuZ0NsYXNzXT1cInNvcnRJY29uKGNvbHVtbi5maWVsZClcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJzaG93U29ydE51bWJlcmluZyhjb2x1bW4pXCIgY2xhc3M9XCJrLXNvcnQtb3JkZXJcIj57e3NvcnRPcmRlcihjb2x1bW4uZmllbGQpfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiByb2xlPVwic3RhdHVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1zb3J0LXN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogLTEwMDAwcHg7XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbm5lckh0bWxdPVwic29ydFN0YXR1cyhjb2x1bW4pXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJyZW5kZXJTZWxlY3RBbGwoY29sdW1uKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiay1jaGVja2JveFwiIGtlbmRvVHJlZUxpc3RGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3RBbGxDbGljaygkZXZlbnQpXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGtlbmRvVHJlZUxpc3RDb2x1bW5IYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstY29sdW1uLXJlc2l6ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICA8dGggKm5nSWY9XCJpc0NvbHVtbkdyb3VwQ29tcG9uZW50KGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBrZW5kb1RyZWVMaXN0TG9naWNhbENlbGwgW2xvZ2ljYWxSb3dJbmRleF09XCJsZXZlbEluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxDb2xJbmRleF09XCJsb2dpY2FsQ29sdW1uSW5kZXgoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyb3dTcGFuXT1cImNvbHVtbi5yb3dzcGFuKHRvdGFsQ29sdW1uTGV2ZWxzKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2xTcGFuXT1cImNvbHVtbi5jb2xzcGFuXCJcbiAgICAgICAgICAgICAgICAgICAga2VuZG9Ecm9wVGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvRHJhZ2dhYmxlQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgIFtlbmFibGVEcmFnXT1cInNob3VsZEFjdGl2YXRlKGNvbHVtbilcIlxuICAgICAgICAgICAgICAgICAgICBbY29udGV4dF09XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29sdW1uR3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50OiBjb2x1bW4udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q29sdW1uOiBsYXN0ICYmIGNvbHVtbkluZGV4ID09PSAwXG4gICAgICAgICAgICAgICAgICAgIH1cIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstZmlyc3RdPVwiaXNGaXJzdE9uUm93KGNvbHVtbiwgY29sdW1uSW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmstZmlsdGVyYWJsZV09XCJzaG93Q29sdW1uTWVudShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY29sdW1uLmhlYWRlckNsYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiY29sdW1uLmhlYWRlclN0eWxlXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucm93c3Bhbl09XCJjb2x1bW4ucm93c3Bhbih0b3RhbENvbHVtbkxldmVscylcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5jb2xzcGFuXT1cImNvbHVtbi5jb2xzcGFuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uLW1lbnUgKm5nSWY9XCJzaG93Q29sdW1uTWVudShjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NldHRpbmdzXT1cImNvbHVtbk1lbnVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uTWVudVRlbXBsYXRlXT1cImNvbHVtbk1lbnVUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW4tbWVudT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZUNvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVJlZjogY29sdW1uLmhlYWRlclRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogbG9ja2VkQ29sdW1uc0NvdW50ICsgY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWNvbHVtbi5oZWFkZXJUZW1wbGF0ZVJlZlwiPnt7Y29sdW1uLmRpc3BsYXlUaXRsZX19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGtlbmRvVHJlZUxpc3RDb2x1bW5IYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZW5kb0RyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay1jb2x1bW4tcmVzaXplclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJyZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uc109XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvdHI+XG4gICAgICAgIDx0ciAqbmdJZj1cInNob3dGaWx0ZXJSb3dcIlxuICAgICAgICAgICAga2VuZG9UcmVlTGlzdEZpbHRlclJvd1xuICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImxlYWZDb2x1bW5zXCJcbiAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgW2xvY2tlZENvbHVtbnNDb3VudF09XCJsb2NrZWRDb2x1bW5zQ291bnRcIlxuICAgICAgICAgICAga2VuZG9UcmVlTGlzdExvZ2ljYWxSb3dcbiAgICAgICAgICAgICAgICBbbG9naWNhbFJvd0luZGV4XT1cInRvdGFsQ29sdW1uTGV2ZWxzICsgMVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxTbGF2ZVJvd109XCJsb2NrZWRDb2x1bW5zQ291bnQgPiAwXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbENlbGxzQ291bnRdPVwiY29sdW1ucy5sZW5ndGhcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVDZWxsc0NvdW50XT1cInVubG9ja2VkQ29sdW1uc0NvdW50XCJcbiAgICAgICAgPjwvdHI+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5IZWFkZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBTaW5nbGVQb3B1cFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IERyYWdIaW50U2VydmljZSB9LFxuICAgIHsgdHlwZTogRHJvcEN1ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENvbHVtblJlb3JkZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTb3J0U2VydmljZSB9LFxuICAgIHsgdHlwZTogU2VsZWN0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbkhlYWRlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0b3RhbENvbHVtbkxldmVsczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2Nyb2xsYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc29ydDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzb3J0YWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9ja2VkQ29sdW1uc0NvdW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZXNpemFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlb3JkZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW5NZW51OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW5NZW51VGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvdGFsQ29sdW1uc0NvdW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoZWFkZXJDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1ncmlkLWhlYWRlcicsXSB9XSxcbiAgICBkcm9wVGFyZ2V0czogW3sgdHlwZTogVmlld0NoaWxkcmVuLCBhcmdzOiBbRHJvcFRhcmdldERpcmVjdGl2ZSxdIH1dXG59O1xuXG4vLyBUT0RPXG4vLyB0c2xpbnQ6ZGlzYWJsZTpyeGpzLW5vLXVuc2FmZS10YWtldW50aWxcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmcm9tUGVyY2VudGFnZSA9ICh2YWx1ZSwgcGVyY2VudCkgPT4ge1xuICAgIGNvbnN0IHNpZ24gPSBwZXJjZW50IDwgMCA/IC0xIDogMTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKChNYXRoLmFicyhwZXJjZW50KSAvIDEwMCkgKiB2YWx1ZSkgKiBzaWduO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWUsIHdob2xlKSA9PiAodmFsdWUgLyB3aG9sZSkgKiAxMDA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGVhZGVyV2lkdGggPSAoaGFuZGxlKSA9PiBoYW5kbGUubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGFsbExlYWZDb2x1bW5zID0gY29sdW1ucyA9PiBleHBhbmRDb2x1bW5zKGNvbHVtbnMpXG4gICAgLmZpbHRlcihjID0+ICFjLmlzQ29sdW1uR3JvdXApO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHN0b3BQcm9wYWdhdGlvbiA9ICh7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50IH0pID0+IHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjcmVhdGVNb3ZlU3RyZWFtID0gKHNlcnZpY2UsIGRyYWdnYWJsZSkgPT4gbW91c2VEb3duID0+IGRyYWdnYWJsZS5rZW5kb0RyYWcucGlwZSh0YWtlVW50aWwoZHJhZ2dhYmxlLmtlbmRvUmVsZWFzZS5waXBlKHRhcCgoKSA9PiBzZXJ2aWNlLmVuZCgpKSkpLCBtYXAoKHsgcGFnZVggfSkgPT4gKHtcbiAgICBvcmlnaW5hbFg6IG1vdXNlRG93bi5wYWdlWCxcbiAgICBwYWdlWFxufSkpKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwcmV2ZW50T25EYmxDbGljayA9IHJlbGVhc2UgPT4gbW91c2VEb3duID0+IG9mKG1vdXNlRG93bikucGlwZShkZWxheSgxNTApLCB0YWtlVW50aWwocmVsZWFzZSkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzSW5TcGFuQ29sdW1uJDEgPSBjb2x1bW4gPT4gISEoY29sdW1uLnBhcmVudCAmJiBjb2x1bW4ucGFyZW50LmlzU3BhbkNvbHVtbik7XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb2x1bW4gaW5kZXguIElmIHRoZSBjb2x1bW4gaXMgc3RhdGVkIGluIGBTcGFuQ29sdW1uYCxcbiAqIHRoZSBpbmRleCBmb3IgYWxsIGNoaWxkIGNvbHVtbnMgZXF1YWxzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gKi9cbmNvbnN0IGluZGV4T2YgPSAodGFyZ2V0LCBsaXN0KSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgaWdub3JlID0gMDtcbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGxpc3RbaW5kZXhdO1xuICAgICAgICBjb25zdCBpc1BhcmVudFNwYW5Db2x1bW4gPSBpc0luU3BhbkNvbHVtbiQxKGN1cnJlbnQpO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlnbm9yZS0tIDw9IDApICYmIGlzUGFyZW50U3BhbkNvbHVtbikge1xuICAgICAgICAgICAgaWdub3JlID0gY3VycmVudC5wYXJlbnQuY2hpbGRDb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBza2lwICs9IGlnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXggLSBza2lwO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5IYW5kbGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSwgZWxlbWVudCwgc2VydmljZSwgem9uZSwgY2RyLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5yZXNpemFibGUgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgIH1cbiAgICBnZXQgbGVmdFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gaXNUcnV0aHkodGhpcy5ydGwpID8gMCA6IG51bGw7XG4gICAgfVxuICAgIGdldCByaWdodFN0eWxlKCkge1xuICAgICAgICByZXR1cm4gaXNUcnV0aHkodGhpcy5ydGwpID8gbnVsbCA6IDA7XG4gICAgfVxuICAgIGF1dG9GaXQoKSB7XG4gICAgICAgIGNvbnN0IGFsbExlYWZzID0gYWxsTGVhZkNvbHVtbnModGhpcy5jb2x1bW5zKTtcbiAgICAgICAgY29uc3QgY3VycmVudExlYWZzID0gbGVhZkNvbHVtbnMoW3RoaXMuY29sdW1uXSkuZmlsdGVyKGNvbHVtbiA9PiBpc1RydXRoeShjb2x1bW4ucmVzaXphYmxlKSk7XG4gICAgICAgIGNvbnN0IGNvbHVtbkluZm8gPSBjdXJyZW50TGVhZnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1BhcmVudFNwYW4gPSBpc0luU3BhbkNvbHVtbiQxKGNvbHVtbik7XG4gICAgICAgICAgICBjb25zdCBpc0xhc3RJblNwYW4gPSBpc1BhcmVudFNwYW4gPyBjb2x1bW4ucGFyZW50LmNoaWxkQ29sdW1ucy5sYXN0ID09PSBjb2x1bW4gOiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZihjb2x1bW4sIGFsbExlYWZzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgICAgIGhlYWRlckluZGV4OiB0aGlzLmNvbHVtbnNGb3JMZXZlbChjb2x1bW4ubGV2ZWwpLmluZGV4T2YoY29sdW1uKSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBpc0xhc3RJblNwYW4sXG4gICAgICAgICAgICAgICAgaXNQYXJlbnRTcGFuLFxuICAgICAgICAgICAgICAgIGxldmVsOiBjb2x1bW4ubGV2ZWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50TGVhZnMuZm9yRWFjaChjb2x1bW4gPT4gY29sdW1uLndpZHRoID0gMCk7XG4gICAgICAgIHRoaXMuc2VydmljZS5tZWFzdXJlQ29sdW1ucyhjb2x1bW5JbmZvKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzLnNlcnZpY2UuY2hhbmdlcy5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmNvbHVtbi5yZXNpemFibGUpLCBmaWx0ZXIoZSA9PiBpc1ByZXNlbnQoZS5jb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbiA9PT0gdGhpcy5jb2x1bW4pKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHNlcnZpY2UucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdzdGFydCcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmluaXRTdGF0ZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc2VydmljZS5waXBlKGZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3Jlc2l6ZUNvbHVtbicpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5zZXJ2aWNlLmNoYW5nZXMucGlwZShmaWx0ZXIoZSA9PiBlLnR5cGUgPT09ICdzdGFydCcpLCBmaWx0ZXIodGhpcy5zaG91bGRVcGRhdGUuYmluZCh0aGlzKSksIHRha2UoMSkgLy9vbiBmaXJzdCByZXNpemUgb25seVxuICAgICAgICApLnN1YnNjcmliZSh0aGlzLmluaXRDb2x1bW5XaWR0aC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuZHJhZ2dhYmxlLmtlbmRvUHJlc3MucGlwZSh0YXAoc3RvcFByb3BhZ2F0aW9uKSwgdGFwKCgpID0+IHRoaXMuc2VydmljZS5zdGFydCh0aGlzLmNvbHVtbikpLCBzd2l0Y2hNYXAocHJldmVudE9uRGJsQ2xpY2sodGhpcy5kcmFnZ2FibGUua2VuZG9SZWxlYXNlKSksIHN3aXRjaE1hcChjcmVhdGVNb3ZlU3RyZWFtKHRoaXMuc2VydmljZSwgdGhpcy5kcmFnZ2FibGUpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgcGFnZVgsIG9yaWdpbmFsWCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHBhZ2VYIC0gb3JpZ2luYWxYO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IHRvUGVyY2VudGFnZShkZWx0YSwgdGhpcy5jb2x1bW4ucmVzaXplU3RhcnRXaWR0aCB8fCB0aGlzLmNvbHVtbi53aWR0aCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UucmVzaXplQ29sdW1ucyhwZXJjZW50KTtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzZXJ2aWNlLnBpcGUoZmlsdGVyKGUgPT4gZS50eXBlID09PSAnYXV0b0ZpdENvbXBsZXRlJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuc2l6ZVRvRml0LmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzZXJ2aWNlLnBpcGUoZmlsdGVyKGUgPT4gZS50eXBlID09PSAndHJpZ2dlckF1dG9GaXQnKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5hdXRvRml0LmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4gdGhpcy5ydGwgPSBydGwpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICFhbGxMZWFmQ29sdW1ucyh0aGlzLmNvbHVtbnMpXG4gICAgICAgICAgICAubWFwKGNvbHVtbiA9PiBjb2x1bW4ud2lkdGgpXG4gICAgICAgICAgICAuc29tZShpc0JsYW5rKTtcbiAgICB9XG4gICAgaW5pdENvbHVtbldpZHRoKCkge1xuICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IGhlYWRlcldpZHRoKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIGluaXRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jb2x1bW4ucmVzaXplU3RhcnRXaWR0aCA9IGhlYWRlcldpZHRoKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuc2VydmljZS5yZXNpemVkQ29sdW1uKHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBvbGRXaWR0aDogdGhpcy5jb2x1bW4ucmVzaXplU3RhcnRXaWR0aFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzaXplKHsgZGVsdGFQZXJjZW50IH0pIHtcbiAgICAgICAgbGV0IGRlbHRhID0gZnJvbVBlcmNlbnRhZ2UodGhpcy5jb2x1bW4ucmVzaXplU3RhcnRXaWR0aCwgZGVsdGFQZXJjZW50KTtcbiAgICAgICAgaWYgKGlzVHJ1dGh5KHRoaXMucnRsKSkge1xuICAgICAgICAgICAgZGVsdGEgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCh0aGlzLmNvbHVtbi5yZXNpemVTdGFydFdpZHRoICsgZGVsdGEsIHRoaXMuY29sdW1uLm1pblJlc2l6YWJsZVdpZHRoKTtcbiAgICAgICAgY29uc3QgdGFibGVEZWx0YSA9IG5ld1dpZHRoID4gdGhpcy5jb2x1bW4ubWluUmVzaXphYmxlV2lkdGggP1xuICAgICAgICAgICAgZGVsdGEgOiB0aGlzLmNvbHVtbi5taW5SZXNpemFibGVXaWR0aCAtIHRoaXMuY29sdW1uLnJlc2l6ZVN0YXJ0V2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlV2lkdGgodGhpcy5jb2x1bW4sIG5ld1dpZHRoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnJlc2l6ZVRhYmxlKHRoaXMuY29sdW1uLCB0YWJsZURlbHRhKTtcbiAgICB9XG4gICAgc2l6ZVRvRml0KHsgY29sdW1ucywgd2lkdGhzIH0pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjb2x1bW5zLmluZGV4T2YodGhpcy5jb2x1bW4pO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KC4uLndpZHRocy5tYXAodyA9PiB3W2luZGV4XSkpICsgMTsgLy9hZGQgMXB4IGZvciBJRVxuICAgICAgICBjb25zdCB0YWJsZURlbHRhID0gd2lkdGggLSB0aGlzLmNvbHVtbi5yZXNpemVTdGFydFdpZHRoO1xuICAgICAgICB0aGlzLnVwZGF0ZVdpZHRoKHRoaXMuY29sdW1uLCB3aWR0aCk7XG4gICAgICAgIHRoaXMuc2VydmljZS5yZXNpemVUYWJsZSh0aGlzLmNvbHVtbiwgdGFibGVEZWx0YSk7XG4gICAgfVxuICAgIHVwZGF0ZVdpZHRoKGNvbHVtbiwgd2lkdGgpIHtcbiAgICAgICAgY29sdW1uLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpOyAvL2ZvcmNlIENEIGN5Y2xlXG4gICAgfVxuICAgIGNvbHVtbnNGb3JMZXZlbChsZXZlbCkge1xuICAgICAgICByZXR1cm4gY29sdW1uc1RvUmVuZGVyKHRoaXMuY29sdW1ucyA/IHRoaXMuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sZXZlbCA9PT0gbGV2ZWwpIDogW10pO1xuICAgIH1cbn1cbkNvbHVtbkhhbmRsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RDb2x1bW5IYW5kbGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db2x1bW5IYW5kbGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBEcmFnZ2FibGVEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEhvc3QgfV0gfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IENvbHVtblJlc2l6aW5nU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuQ29sdW1uSGFuZGxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmlzaWJsZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUuZGlzcGxheScsXSB9XSxcbiAgICBsZWZ0U3R5bGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLmxlZnQnLF0gfV0sXG4gICAgcmlnaHRTdHlsZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUucmlnaHQnLF0gfV0sXG4gICAgYXV0b0ZpdDogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2RibGNsaWNrJyxdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVyTWVudUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgcG9wdXBTZXJ2aWNlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlID0gZmlsdGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJMYWJlbCA9IHRoaXMubG9jYWxpemF0aW9uLmdldCgnZmlsdGVyJyk7XG4gICAgfVxuICAgIGdldCBoYXNGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyc0J5RmllbGQodGhpcy5maWx0ZXIsICh0aGlzLmNvbHVtbiB8fCB7fSkuZmllbGQpLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHRvZ2dsZShhbmNob3IsIHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKGFuY2hvciwgdGVtcGxhdGUsIHRoaXMucG9wdXBSZWYpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZS5kZXN0cm95KCk7XG4gICAgfVxufVxuRmlsdGVyTWVudUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtZmlsdGVyLW1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxhICNhbmNob3JcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnay1ncmlkLWZpbHRlcic6dHJ1ZSwgJ2stc3RhdGUtYWN0aXZlJzogaGFzRmlsdGVyc31cIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZShhbmNob3IsIHRlbXBsYXRlKVwiXG4gICAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJmaWx0ZXJMYWJlbFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24gay1pLWZpbHRlclwiPjwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgICAgICA8bmctdGVtcGxhdGUgI3RlbXBsYXRlPlxuICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51LWNvbnRhaW5lclxuICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgKGNsb3NlKT1cImNsb3NlKClcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZmlsdGVyLW1lbnUtY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRmlsdGVyTWVudUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEZpbHRlclNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNpbmdsZVBvcHVwU2VydmljZSB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuRmlsdGVyTWVudUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb2x1bW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbmNvbnN0IGlzTm9WYWx1ZU9wZXJhdG9yID0gb3BlcmF0b3IgPT4gKG9wZXJhdG9yID09PSBcImlzbnVsbFwiXG4gICAgfHwgb3BlcmF0b3IgPT09IFwiaXNub3RudWxsXCJcbiAgICB8fCBvcGVyYXRvciA9PT0gXCJpc2VtcHR5XCJcbiAgICB8fCBvcGVyYXRvciA9PT0gXCJpc25vdGVtcHR5XCIpO1xuY29uc3QgdmFsaWRGaWx0ZXJzID0gKHsgdmFsdWUsIG9wZXJhdG9yIH0pID0+ICFpc051bGxPckVtcHR5U3RyaW5nKHZhbHVlKSB8fCBpc05vVmFsdWVPcGVyYXRvcihvcGVyYXRvcik7XG5jb25zdCB0cmltRmlsdGVycyA9IGZpbHRlciQkMSA9PiB7XG4gICAgZmlsdGVyJCQxLmZpbHRlcnMgPSBmaWx0ZXIkJDEuZmlsdGVycy5maWx0ZXIodmFsaWRGaWx0ZXJzKTtcbiAgICByZXR1cm4gZmlsdGVyJCQxO1xufTtcbmNvbnN0IGZpbmRQYXJlbnQgPSAoZmlsdGVycywgZmllbGQsIHBhcmVudCkgPT4ge1xuICAgIHJldHVybiBmaWx0ZXJzLnJlZHVjZSgoYWNjLCBmaWx0ZXIkJDEpID0+IHtcbiAgICAgICAgaWYgKGFjYykge1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyJCQxLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUGFyZW50KGZpbHRlciQkMS5maWx0ZXJzLCBmaWVsZCwgZmlsdGVyJCQxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXIkJDEuZmllbGQgPT09IGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdW5kZWZpbmVkKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTphbGlnblxufTtcbmNvbnN0IHBhcmVudExvZ2ljT2ZEZWZhdWx0ID0gKGZpbHRlciQkMSwgZmllbGQsIGRlZiA9IFwiYW5kXCIpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBmaW5kUGFyZW50KCgoZmlsdGVyJCQxIHx8IHt9KS5maWx0ZXJzIHx8IFtdKSwgZmllbGQpO1xuICAgIHJldHVybiBpc1ByZXNlbnQocGFyZW50KSA/IHBhcmVudC5sb2dpYyA6IGRlZjtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50U2VydmljZSwgY2hpbGRTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIGNkKSB7XG4gICAgICAgIHRoaXMucGFyZW50U2VydmljZSA9IHBhcmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hpbGRTZXJ2aWNlID0gY2hpbGRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3Rpb25zQ2xhc3MgPSAnay1hY3Rpb24tYnV0dG9ucyBrLWJ1dHRvbi1ncm91cCc7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dCA9IHt9O1xuICAgIH1cbiAgICBnZXQgZmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCByb290IGZpbHRlci5cbiAgICAgKiBAdHlwZSB7Q29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IGNsb25lRmlsdGVycyh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBjaGlsZEZpbHRlcigpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5fY2hpbGRGaWx0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZEZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzQnlGaWVsZCh0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZCksXG4gICAgICAgICAgICAgICAgbG9naWM6IHBhcmVudExvZ2ljT2ZEZWZhdWx0KHRoaXMuZmlsdGVyLCAodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRGaWx0ZXI7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuY2hpbGRTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKGZpbHRlciQkMSA9PiB0aGlzLl9jaGlsZEZpbHRlciA9IGZpbHRlciQkMSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZCh0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hpbGRGaWx0ZXIuZmlsdGVycy5zb21lKHZhbGlkRmlsdGVycyk7XG4gICAgfVxuICAgIGdldCB0ZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVDb250ZXh0LmZpbHRlciA9IHRoaXMuY2hpbGRGaWx0ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQ29udGV4dC5maWx0ZXJTZXJ2aWNlID0gdGhpcy5jaGlsZFNlcnZpY2U7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdHJpbmctbGl0ZXJhbFxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHRbXCIkaW1wbGljaXRcIl0gPSB0aGlzLmNoaWxkRmlsdGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVDb250ZXh0O1xuICAgIH1cbiAgICBnZXQgaGFzVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb2x1bW4pICYmIGlzUHJlc2VudCh0aGlzLmNvbHVtbi5maWx0ZXJNZW51VGVtcGxhdGVSZWYpO1xuICAgIH1cbiAgICBzdWJtaXQoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciQkMSA9IHRyaW1GaWx0ZXJzKHRoaXMuY2hpbGRGaWx0ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyJCQxLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5maWx0ZXIgfHwge1xuICAgICAgICAgICAgICAgIGZpbHRlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGxvZ2ljOiBcImFuZFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVtb3ZlRmlsdGVyKHJvb3QsIHRoaXMuY29sdW1uLmZpZWxkKTtcbiAgICAgICAgICAgIHJvb3QuZmlsdGVycy5wdXNoKGZpbHRlciQkMSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFNlcnZpY2UuZmlsdGVyKHJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5maWx0ZXIgfHwge1xuICAgICAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgICAgICBsb2dpYzogXCJhbmRcIlxuICAgICAgICB9O1xuICAgICAgICByZW1vdmVGaWx0ZXIocm9vdCwgdGhpcy5jb2x1bW4uZmllbGQpO1xuICAgICAgICB0aGlzLnBhcmVudFNlcnZpY2UuZmlsdGVyKHJvb3QpO1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgICB9XG4gICAgZ2V0IGNsZWFyVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlckNsZWFyQnV0dG9uXCIpO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChcImZpbHRlckZpbHRlckJ1dHRvblwiKTtcbiAgICB9XG59XG5GaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbRmlsdGVyU2VydmljZV0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1maWx0ZXItbWVudS1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxmb3JtIChzdWJtaXQpPVwic3VibWl0KClcIiAocmVzZXQpPVwicmVzZXQoKVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZmlsdGVyLW1lbnUgay1ncm91cCBrLXJlc2V0IGstc3RhdGUtYm9yZGVyLXVwXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1maWx0ZXItbWVudS1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJoYXNUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvRmlsdGVyTWVudUhvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJjaGlsZFNlcnZpY2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cImNoaWxkRmlsdGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cInRydWVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY29sdW1uLmZpbHRlck1lbnVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uLmZpbHRlck1lbnVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInRlbXBsYXRlQ29udGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBbbmdDbGFzc109XCJhY3Rpb25zQ2xhc3NcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwicmVzZXRcIiBjbGFzcz1cImstYnV0dG9uXCI+e3tjbGVhclRleHR9fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImstYnV0dG9uIGstcHJpbWFyeVwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPnt7ZmlsdGVyVGV4dH19PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9mb3JtPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEZpbHRlclNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNraXBTZWxmIH1dIH0sXG4gICAgeyB0eXBlOiBGaWx0ZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuRmlsdGVyTWVudUNvbnRhaW5lckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhY3Rpb25zQ2xhc3M6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRmlsdGVyTWVudUlucHV0V3JhcHBlckNvbXBvbmVudCBleHRlbmRzIEZpbHRlcklucHV0V3JhcHBlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhvc3RDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9wZXJhdG9yQ2hhbmdlKGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE9wZXJhdG9yID0gZGF0YUl0ZW07XG4gICAgfVxuICAgIGZpbHRlckNoYW5nZShmaWx0ZXIkJDEpIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcihmaWx0ZXIkJDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgZm9yIHRoZSBhc3NvY2lhdGVkIGNvbHVtbiBmaWVsZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7RmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRGaWx0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBmb3IgdGhlIGFzc29jaWF0ZWQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtGaWx0ZXJEZXNjcmlwdG9yfVxuICAgICAqL1xuICAgIHNldCBjdXJyZW50RmlsdGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGaWx0ZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgdXBkYXRlRmlsdGVyKGZpbHRlciQkMSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudEZpbHRlciwgZmlsdGVyJCQxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgIH1cbiAgICBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZpbHRlckNoYW5nZSh0aGlzLnVwZGF0ZUZpbHRlcih7XG4gICAgICAgICAgICBmaWVsZDogdGhpcy5jb2x1bW4uZmllbGQsXG4gICAgICAgICAgICBvcGVyYXRvcjogdGhpcy5jdXJyZW50T3BlcmF0b3IsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbkZpbHRlck1lbnVJbnB1dFdyYXBwZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51LWlucHV0LXdyYXBwZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgIFtkYXRhXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwib3BlcmF0b3JDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiY3VycmVudE9wZXJhdG9yXCJcbiAgICAgICAgICAgIFt2YWx1ZVByaW1pdGl2ZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWVGaWVsZD1cInZhbHVlXCI+XG4gICAgICAgIDwva2VuZG8tZHJvcGRvd25saXN0PlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJNZW51SW5wdXRXcmFwcGVyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW107XG5GaWx0ZXJNZW51SW5wdXRXcmFwcGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZpbHRlclNlcnZpY2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGN1cnJlbnRGaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3RyaW5nRmlsdGVyTWVudUlucHV0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgICB9XG59XG5TdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LXN0cmluZy1maWx0ZXItbWVudS1pbnB1dCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51LWlucHV0LXdyYXBwZXJcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtkZWZhdWx0T3BlcmF0b3JdPVwib3BlcmF0b3JcIlxuICAgICAgICAgICAgW2N1cnJlbnRGaWx0ZXJdPVwiY3VycmVudEZpbHRlclwiXG4gICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImstdGV4dGJveFwiIGtlbmRvRmlsdGVySW5wdXQgW2ZpbHRlckRlbGF5XT1cIjBcIiBbbmdNb2RlbF09XCJjdXJyZW50RmlsdGVyPy52YWx1ZVwiIC8+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZmlsdGVyLW1lbnUtaW5wdXQtd3JhcHBlcj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5TdHJpbmdGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb3BlcmF0b3JzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb3BlcmF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGN1cnJlbnRGaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlclNlcnZpY2U6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdHJpbmctZmlsdGVyIG1lbnUgY29tcG9uZW50LlxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBidWlsdGluZmlsdGVydGVtcGxhdGVfdHJlZWxpc3QgJX0jdG9jLWNvbmZpZ3VyYXRpb24tY29tcG9uZW50cy1mb3ItZmlsdGVyLXRlbXBsYXRlcykpLlxuICovXG5jbGFzcyBTdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50IGV4dGVuZHMgU3RyaW5nRmlsdGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgc3VwZXIobnVsbCwgbG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2dpY09wZXJhdG9ycyA9IGxvZ2ljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IG1lbnUgZmlsdGVyLlxuICAgICAgICAgKiBAdHlwZSB7Q29tcG9zaXRlRmlsdGVyRGVzY3JpcHRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyID0geyBmaWx0ZXJzOiBbXSwgbG9naWM6IFwiYW5kXCIgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGlucHV0cyBvZiBzZWNvbmQgY3JpdGVyaWEgd2lsbCBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4dHJhID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZmlyc3RGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBzZXRGaWx0ZXIoMCwgdGhpcy5maWx0ZXIsICh0aGlzLmNvbHVtbiB8fCB7fSkuZmllbGQsIHRoaXMub3BlcmF0b3IpO1xuICAgIH1cbiAgICBnZXQgc2Vjb25kRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKDEsIHRoaXMuZmlsdGVyLCAodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkLCB0aGlzLm9wZXJhdG9yKTtcbiAgICB9XG4gICAgbG9naWNDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIubG9naWMgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9jYWxpemF0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmxvZ2ljT3BlcmF0b3JzID0gbG9naWNPcGVyYXRvcnModGhpcy5sb2NhbGl6YXRpb24pO1xuICAgICAgICBzdXBlci5sb2NhbGl6YXRpb25DaGFuZ2UoKTtcbiAgICB9XG59XG5TdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1zdHJpbmctZmlsdGVyLW1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1zdHJpbmctZmlsdGVyLW1lbnUtaW5wdXRcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cImZpcnN0RmlsdGVyXCJcbiAgICAgICAgICAgIFtvcGVyYXRvcnNdPVwib3BlcmF0b3JzXCJcbiAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIj5cbiAgICAgICAgPC9rZW5kby10cmVlbGlzdC1zdHJpbmctZmlsdGVyLW1lbnUtaW5wdXQ+XG4gICAgICAgIDxrZW5kby1kcm9wZG93bmxpc3RcbiAgICAgICAgICAgICpuZ0lmPVwiZXh0cmFcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWZpbHRlci1hbmRcIlxuICAgICAgICAgICAgW2RhdGFdPVwibG9naWNPcGVyYXRvcnNcIlxuICAgICAgICAgICAgW3ZhbHVlUHJpbWl0aXZlXT1cInRydWVcIiAodmFsdWVDaGFuZ2UpPVwibG9naWNDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiZmlsdGVyPy5sb2dpY1wiXG4gICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiPlxuICAgICAgICA8L2tlbmRvLWRyb3Bkb3dubGlzdD5cbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LXN0cmluZy1maWx0ZXItbWVudS1pbnB1dFxuICAgICAgICAgICAgKm5nSWY9XCJleHRyYVwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbY3VycmVudEZpbHRlcl09XCJzZWNvbmRGaWx0ZXJcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiPlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LXN0cmluZy1maWx0ZXItbWVudS1pbnB1dD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5TdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWZpbHRlcmNlbGwnLF0gfV0sXG4gICAgY29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGV4dHJhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJTZXJ2aWNlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbnVtZXJpYy1maWx0ZXIgbWVudSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICBgYGBodG1sLW5vLXJ1blxuICogICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiVW5pdFByaWNlXCIgdGl0bGU9XCJVbml0IFByaWNlXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdEZpbHRlck1lbnVUZW1wbGF0ZSBsZXQtZmlsdGVyIGxldC1jb2x1bW49XCJjb2x1bW5cIiBsZXQtZmlsdGVyU2VydmljZT1cImZpbHRlclNlcnZpY2VcIj5cbiAqICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1udW1lcmljLWZpbHRlci1tZW51XG4gKiAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICogICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAqICAgICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAqICAgICAgICAgICAgICA+XG4gKiAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LW51bWVyaWMtZmlsdGVyLW1lbnU+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAqICAgYGBgXG4gKi9cbmNsYXNzIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50IGV4dGVuZHMgTnVtZXJpY0ZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMubG9naWNPcGVyYXRvcnMgPSBsb2dpY09wZXJhdG9ycyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBtZW51IGZpbHRlci5cbiAgICAgICAgICogQHR5cGUge0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9IHsgZmlsdGVyczogW10sIGxvZ2ljOiBcImFuZFwiIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dHMgb2Ygc2Vjb25kIGNyaXRlcmlhIHdpbGwgZGlzcGxheWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRyYSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKDAsIHRoaXMuZmlsdGVyLCAodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkLCB0aGlzLm9wZXJhdG9yKTtcbiAgICB9XG4gICAgZ2V0IHNlY29uZEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpbHRlcigxLCB0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZCwgdGhpcy5vcGVyYXRvcik7XG4gICAgfVxuICAgIGxvZ2ljQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyLmxvZ2ljID0gdmFsdWU7XG4gICAgfVxuICAgIGxvY2FsaXphdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5sb2dpY09wZXJhdG9ycyA9IGxvZ2ljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgc3VwZXIubG9jYWxpemF0aW9uQ2hhbmdlKCk7XG4gICAgfVxufVxuTnVtZXJpY0ZpbHRlck1lbnVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LW51bWVyaWMtZmlsdGVyLW1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1udW1lcmljLWZpbHRlci1tZW51LWlucHV0XG4gICAgICAgICAgICBbY3VycmVudEZpbHRlcl09XCJmaXJzdEZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgIFtkZWNpbWFsc109XCJkZWNpbWFsc1wiXG4gICAgICAgICAgICBbc3Bpbm5lcnNdPVwic3Bpbm5lcnNcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW3N0ZXBdPVwic3RlcFwiXG4gICAgICAgICAgICA+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtbnVtZXJpYy1maWx0ZXItbWVudS1pbnB1dD5cbiAgICAgICAgPGtlbmRvLWRyb3Bkb3dubGlzdFxuICAgICAgICAgICAgKm5nSWY9XCJleHRyYVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZmlsdGVyLWFuZFwiXG4gICAgICAgICAgICBbZGF0YV09XCJsb2dpY09wZXJhdG9yc1wiXG4gICAgICAgICAgICBbdmFsdWVQcmltaXRpdmVdPVwidHJ1ZVwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwibG9naWNDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiZmlsdGVyPy5sb2dpY1wiXG4gICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiPlxuICAgICAgICA8L2tlbmRvLWRyb3Bkb3dubGlzdD5cbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LW51bWVyaWMtZmlsdGVyLW1lbnUtaW5wdXRcbiAgICAgICAgICAgICpuZ0lmPVwiZXh0cmFcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2N1cnJlbnRGaWx0ZXJdPVwic2Vjb25kRmlsdGVyXCJcbiAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgW2RlY2ltYWxzXT1cImRlY2ltYWxzXCJcbiAgICAgICAgICAgIFtzcGlubmVyc109XCJzcGlubmVyc1wiXG4gICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICBbc3RlcF09XCJzdGVwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgPC9rZW5kby10cmVlbGlzdC1udW1lcmljLWZpbHRlci1tZW51LWlucHV0PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTnVtZXJpY0ZpbHRlck1lbnVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5OdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1maWx0ZXJjZWxsJyxdIH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHRyYTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyU2VydmljZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOdW1lcmljRmlsdGVyTWVudUlucHV0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgdmFsdWUgd2hpY2ggaXMgdXNlZCB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBjb21wb25lbnQgdmFsdWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1lcmljfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSAqKlVwKiogYW5kICoqRG93bioqIHNwaW4gYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lcnMgPSB0cnVlO1xuICAgIH1cbn1cbk51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LW51bWVyaWMtZmlsdGVyLW1lbnUtaW5wdXQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1maWx0ZXItbWVudS1pbnB1dC13cmFwcGVyXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZGVmYXVsdE9wZXJhdG9yXT1cIm9wZXJhdG9yXCJcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cImN1cnJlbnRGaWx0ZXJcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8a2VuZG8tbnVtZXJpY3RleHRib3hcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW2ZpbHRlckRlbGF5XT1cIjBcIlxuICAgICAgICAgICAgICAgIFthdXRvQ29ycmVjdF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVwiY3VycmVudEZpbHRlcj8udmFsdWVcIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgICAgICBbZGVjaW1hbHNdPVwiZGVjaW1hbHNcIlxuICAgICAgICAgICAgICAgIFtzcGlubmVyc109XCJzcGlubmVyc1wiXG4gICAgICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICAgICAgICBbc3RlcF09XCJzdGVwXCI+XG4gICAgICAgICAgICA8L2tlbmRvLW51bWVyaWN0ZXh0Ym94PlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51LWlucHV0LXdyYXBwZXI+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBvcGVyYXRvcnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcGVyYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3VycmVudEZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyU2VydmljZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RlcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNwaW5uZXJzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkZWNpbWFsczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGF0ZS1maWx0ZXIgbWVudSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICBgYGBodG1sLW5vLXJ1blxuICogICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1uIGZpZWxkPVwiT3JkZXJEYXRlXCIgdGl0bGU9XCJPcmRlciBEYXRlXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdEZpbHRlck1lbnVUZW1wbGF0ZSBsZXQtZmlsdGVyIGxldC1jb2x1bW49XCJjb2x1bW5cIiBsZXQtZmlsdGVyU2VydmljZT1cImZpbHRlclNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWRhdGUtZmlsdGVyLW1lbnVcbiAqICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAqICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAqICAgICAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICogICAgICAgICAgICAgICAgPlxuICogICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWRhdGUtZmlsdGVyLW1lbnU+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAqICAgYGBgXG4gKi9cbmNsYXNzIERhdGVGaWx0ZXJNZW51Q29tcG9uZW50IGV4dGVuZHMgRGF0ZUZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIHRoaXMubG9naWNPcGVyYXRvcnMgPSBsb2dpY09wZXJhdG9ycyh0aGlzLmxvY2FsaXphdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBtZW51IGZpbHRlci5cbiAgICAgICAgICogQHR5cGUge0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9IHsgZmlsdGVyczogW10sIGxvZ2ljOiBcImFuZFwiIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dHMgb2Ygc2Vjb25kIGNyaXRlcmlhIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRyYSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKDAsIHRoaXMuZmlsdGVyLCAodGhpcy5jb2x1bW4gfHwge30pLmZpZWxkLCB0aGlzLm9wZXJhdG9yKTtcbiAgICB9XG4gICAgZ2V0IHNlY29uZEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpbHRlcigxLCB0aGlzLmZpbHRlciwgKHRoaXMuY29sdW1uIHx8IHt9KS5maWVsZCwgdGhpcy5vcGVyYXRvcik7XG4gICAgfVxuICAgIGxvZ2ljQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyLmxvZ2ljID0gdmFsdWU7XG4gICAgfVxuICAgIGxvY2FsaXphdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5sb2dpY09wZXJhdG9ycyA9IGxvZ2ljT3BlcmF0b3JzKHRoaXMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgc3VwZXIubG9jYWxpemF0aW9uQ2hhbmdlKCk7XG4gICAgfVxufVxuRGF0ZUZpbHRlck1lbnVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWRhdGUtZmlsdGVyLW1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1kYXRlLWZpbHRlci1tZW51LWlucHV0XG4gICAgICAgICAgICBbY3VycmVudEZpbHRlcl09XCJmaXJzdEZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZmlsdGVyU2VydmljZV09XCJmaWx0ZXJTZXJ2aWNlXCJcbiAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICAgIFthY3RpdmVWaWV3XT1cImFjdGl2ZVZpZXdcIlxuICAgICAgICAgICAgW2JvdHRvbVZpZXddPVwiYm90dG9tVmlld1wiXG4gICAgICAgICAgICBbdG9wVmlld109XCJ0b3BWaWV3XCJcbiAgICAgICAgICAgIFtmb3JtYXRdPVwiZm9ybWF0XCJcbiAgICAgICAgICAgIFtmb3JtYXRQbGFjZWhvbGRlcl09XCJmb3JtYXRQbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICA+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZGF0ZS1maWx0ZXItbWVudS1pbnB1dD5cbiAgICAgICAgPGtlbmRvLWRyb3Bkb3dubGlzdFxuICAgICAgICAgICAgKm5nSWY9XCJleHRyYVwiXG4gICAgICAgICAgICBjbGFzcz1cImstZmlsdGVyLWFuZFwiXG4gICAgICAgICAgICBbZGF0YV09XCJsb2dpY09wZXJhdG9yc1wiXG4gICAgICAgICAgICBbdmFsdWVQcmltaXRpdmVdPVwidHJ1ZVwiXG4gICAgICAgICAgICAodmFsdWVDaGFuZ2UpPVwibG9naWNDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiZmlsdGVyPy5sb2dpY1wiXG4gICAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlRmllbGQ9XCJ2YWx1ZVwiPlxuICAgICAgICA8L2tlbmRvLWRyb3Bkb3dubGlzdD5cbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWRhdGUtZmlsdGVyLW1lbnUtaW5wdXRcbiAgICAgICAgICAgICpuZ0lmPVwiZXh0cmFcIlxuICAgICAgICAgICAgW29wZXJhdG9yc109XCJvcGVyYXRvcnNcIlxuICAgICAgICAgICAgW2N1cnJlbnRGaWx0ZXJdPVwic2Vjb25kRmlsdGVyXCJcbiAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICBbYm90dG9tVmlld109XCJib3R0b21WaWV3XCJcbiAgICAgICAgICAgIFt0b3BWaWV3XT1cInRvcFZpZXdcIlxuICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgW2Zvcm1hdFBsYWNlaG9sZGVyXT1cImZvcm1hdFBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICBbd2Vla051bWJlcl09XCJ3ZWVrTnVtYmVyXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgPC9rZW5kby10cmVlbGlzdC1kYXRlLWZpbHRlci1tZW51LWlucHV0PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRGF0ZUZpbHRlck1lbnVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5EYXRlRmlsdGVyTWVudUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBob3N0Q2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1maWx0ZXJjZWxsJyxdIH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHRyYTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyU2VydmljZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIEJvb2xlYW4tZmlsdGVyIG1lbnUgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgYGBgaHRtbC1uby1ydW5cbiAqICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbiBmaWVsZD1cIkRpc2NvbnRpbnVlZFwiIHRpdGxlPVwiRGlzY29udGludWVkXCI+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdEZpbHRlck1lbnVUZW1wbGF0ZSBsZXQtZmlsdGVyIGxldC1jb2x1bW49XCJjb2x1bW5cIiBsZXQtZmlsdGVyU2VydmljZT1cImZpbHRlclNlcnZpY2VcIj5cbiAqICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWJvb2xlYW4tZmlsdGVyLW1lbnVcbiAqICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAqICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAqICAgICAgICAgICAgICAgIFtmaWx0ZXJTZXJ2aWNlXT1cImZpbHRlclNlcnZpY2VcIlxuICogICAgICAgICAgICAgICAgPlxuICogICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWJvb2xlYW4tZmlsdGVyLW1lbnU+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbj5cbiAqICAgYGBgXG4gKi9cbmNsYXNzIEJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50IGV4dGVuZHMgQm9vbGVhbkZpbHRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIGxvY2FsaXphdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBtZW51IGZpbHRlci5cbiAgICAgICAgICogQHR5cGUge0NvbXBvc2l0ZUZpbHRlckRlc2NyaXB0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlciA9IHsgZmlsdGVyczogW10sIGxvZ2ljOiBcImFuZFwiIH07XG4gICAgICAgIHRoaXMuaWRQcmVmaXggPSBndWlkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaG9zdENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJhZGlvSWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWRQcmVmaXh9XyR7dmFsdWV9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIodGhpcy51cGRhdGVGaWx0ZXIoe1xuICAgICAgICAgICAgZmllbGQ6IHRoaXMuY29sdW1uLmZpZWxkLFxuICAgICAgICAgICAgb3BlcmF0b3I6IFwiZXFcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKHJhZGlvVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyc0J5RmllbGQodGhpcy5jb2x1bW4uZmllbGQpLnNvbWUoKHsgdmFsdWUgfSkgPT4gdmFsdWUgPT09IHJhZGlvVmFsdWUpO1xuICAgIH1cbn1cbkJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1ib29sZWFuLWZpbHRlci1tZW51JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dWwgY2xhc3M9XCJrLXJhZGlvLWxpc3Qgay1yZXNldFwiPlxuICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cImlkUHJlZml4XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLXJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwiaXNTZWxlY3RlZChpdGVtLnZhbHVlKVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmlkXT1cInJhZGlvSWQoaXRlbS52YWx1ZSlcIlxuICAgICAgICAgICAgICAgICAgICAoY2hhbmdlKT1cIm9uQ2hhbmdlKGl0ZW0udmFsdWUpXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImstcmFkaW8tbGFiZWxcIiBbYXR0ci5mb3JdPVwicmFkaW9JZChpdGVtLnZhbHVlKVwiPnt7aXRlbS50ZXh0fX08L2xhYmVsPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuQm9vbGVhbkZpbHRlck1lbnVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaG9zdENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZmlsdGVyY2VsbCcsXSB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlclNlcnZpY2U6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiA+IExpc3QgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzIGFzIGBlbnRyeUNvbXBvbmVudHNgIGluIHRoZSBUcmVlTGlzdE1vZHVsZS5cbiAqL1xuY29uc3QgZmlsdGVyTWVudUNvbXBvbmVudEZhY3RvcnkgPSAodHlwZSkgPT4gKHtcbiAgICBcImJvb2xlYW5cIjogQm9vbGVhbkZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgXCJkYXRlXCI6IERhdGVGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIFwibnVtZXJpY1wiOiBOdW1lcmljRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBcInRleHRcIjogU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudFxufVt0eXBlXSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWx0ZXJNZW51SG9zdERpcmVjdGl2ZSBleHRlbmRzIEZpbHRlckhvc3REaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHJlc29sdmVyKSB7XG4gICAgICAgIHN1cGVyKGhvc3QsIHJlc29sdmVyKTtcbiAgICB9XG4gICAgY29tcG9uZW50VHlwZSgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbHVtbikgJiYgIWlzTnVsbE9yRW1wdHlTdHJpbmcodGhpcy5jb2x1bW4uZmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlck1lbnVDb21wb25lbnRGYWN0b3J5KHRoaXMuY29sdW1uLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQ7XG4gICAgfVxuICAgIGluaXRDb21wb25lbnQoY3R4KSB7XG4gICAgICAgIHN1cGVyLmluaXRDb21wb25lbnQoY3R4KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuZmlsdGVyU2VydmljZSA9IHRoaXMuZmlsdGVyU2VydmljZTtcbiAgICB9XG59XG5GaWx0ZXJNZW51SG9zdERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRmlsdGVyTWVudUhvc3RdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5GaWx0ZXJNZW51SG9zdERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYgfSxcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9XG5dO1xuRmlsdGVyTWVudUhvc3REaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmlsdGVyU2VydmljZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMub3BlcmF0b3JzID0gW107XG4gICAgfVxuICAgIG9wZW4ocGlja2VyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5wb3B1cFNlcnZpY2Uub25DbG9zZVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHBpY2tlci5pc0FjdGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkRhdGVGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWRhdGUtZmlsdGVyLW1lbnUtaW5wdXQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1maWx0ZXItbWVudS1pbnB1dC13cmFwcGVyXG4gICAgICAgICAgICBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgICBbb3BlcmF0b3JzXT1cIm9wZXJhdG9yc1wiXG4gICAgICAgICAgICBbZGVmYXVsdE9wZXJhdG9yXT1cIm9wZXJhdG9yXCJcbiAgICAgICAgICAgIFtjdXJyZW50RmlsdGVyXT1cImN1cnJlbnRGaWx0ZXJcIlxuICAgICAgICAgICAgW2ZpbHRlclNlcnZpY2VdPVwiZmlsdGVyU2VydmljZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8a2VuZG8tZGF0ZXBpY2tlclxuICAgICAgICAgICAgICAgICNwaWNrZXJcbiAgICAgICAgICAgICAgICBrZW5kb0ZpbHRlcklucHV0XG4gICAgICAgICAgICAgICAgW2ZpbHRlckRlbGF5XT1cIjBcIlxuICAgICAgICAgICAgICAgIChvcGVuKT1cIm9wZW4ocGlja2VyKVwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cImN1cnJlbnRGaWx0ZXI/LnZhbHVlXCJcbiAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRQbGFjZWhvbGRlcl09XCJmb3JtYXRQbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgICAgICAgW2FjdGl2ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgW2JvdHRvbVZpZXddPVwiYm90dG9tVmlld1wiXG4gICAgICAgICAgICAgICAgW3RvcFZpZXddPVwidG9wVmlld1wiXG4gICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJdPVwid2Vla051bWJlclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9rZW5kby1kYXRlcGlja2VyPlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51LWlucHV0LXdyYXBwZXI+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogU2luZ2xlUG9wdXBTZXJ2aWNlIH1cbl07XG5EYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG9wZXJhdG9yczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9wZXJhdG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjdXJyZW50RmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXJTZXJ2aWNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZvcm1hdFBsYWNlaG9sZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFjdGl2ZVZpZXc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJvdHRvbVZpZXc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvcFZpZXc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdlZWtOdW1iZXI6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBJTlRFUk5BTF9DT01QT05FTlRTJDIgPSBbXG4gICAgRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBGaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LFxuICAgIEZpbHRlck1lbnVJbnB1dFdyYXBwZXJDb21wb25lbnQsXG4gICAgU3RyaW5nRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LFxuICAgIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgRmlsdGVyTWVudVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIE51bWVyaWNGaWx0ZXJNZW51SW5wdXRDb21wb25lbnQsXG4gICAgRGF0ZUZpbHRlck1lbnVJbnB1dENvbXBvbmVudCxcbiAgICBEYXRlRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICBGaWx0ZXJNZW51SG9zdERpcmVjdGl2ZSxcbiAgICBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudFxuXTtcbmNvbnN0IEVOVFJZX0NPTVBPTkVOVFMkMSA9IFtcbiAgICBTdHJpbmdGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIERhdGVGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgIEJvb2xlYW5GaWx0ZXJNZW51Q29tcG9uZW50XG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZpbHRlck1lbnVNb2R1bGUge1xuICAgIHN0YXRpYyBleHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgU3RyaW5nRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICAgICAgICAgIEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIE51bWVyaWNGaWx0ZXJNZW51Q29tcG9uZW50LFxuICAgICAgICAgICAgRGF0ZUZpbHRlck1lbnVDb21wb25lbnQsXG4gICAgICAgICAgICBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudCxcbiAgICAgICAgICAgIFNoYXJlZEZpbHRlck1vZHVsZS5leHBvcnRzKClcbiAgICAgICAgXTtcbiAgICB9XG59XG5GaWx0ZXJNZW51TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtJTlRFUk5BTF9DT01QT05FTlRTJDJdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogRU5UUllfQ09NUE9ORU5UUyQxLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJTlRFUk5BTF9DT01QT05FTlRTJDIsIFNoYXJlZEZpbHRlck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1NoYXJlZEZpbHRlck1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLy8gVE9ET1xuLy8gdHNsaW50OmRpc2FibGU6cnhqcy1uby11bnNhZmUtdGFrZXVudGlsXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcHJldmVudE9uRGJsQ2xpY2skMSA9IHJlbGVhc2UgPT4gbW91c2VEb3duID0+IG9mKG1vdXNlRG93bikucGlwZShkZWxheSgxNTApLCB0YWtlVW50aWwocmVsZWFzZSkpO1xuY29uc3QgaGFzQ2xhc3MgPSBjbGFzc05hbWUgPT4gZWwgPT4gbmV3IFJlZ0V4cChgKF58ICkke2NsYXNzTmFtZX0oIHwkKWApLnRlc3QoZWwuY2xhc3NOYW1lKTtcbmNvbnN0IGlzRGVsZXRlQnV0dG9uID0gb3IoaGFzQ2xhc3MoXCJrLWktZ3JvdXAtZGVsZXRlXCIpLCBoYXNDbGFzcyhcImstYnV0dG9uLWljb25cIikpO1xuY29uc3QgaXNTb3J0SWNvbiA9IG9yKGhhc0NsYXNzKFwiay1pLXNvcnQtYXNjLXNtXCIpLCBoYXNDbGFzcyhcImstaS1zb3J0LWRlc2Mtc21cIikpO1xuY29uc3Qgc2tpcEJ1dHRvbnMgPSBhbmQobm90KGlzRGVsZXRlQnV0dG9uKSwgbm90KGlzU29ydEljb24pLCBub3QoaXNGb2N1c2FibGVXaXRoVGFiS2V5KSwgbm90KG1hdGNoZXNOb2RlTmFtZShcImxhYmVsXCIpKSk7XG5jb25zdCBlbGVtZW50VW5kZXJDdXJzb3IgPSAoeyBjbGllbnRYLCBjbGllbnRZIH0pID0+IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG5jb25zdCBoaWRlVGhlblNob3cgPSAoZWxlbWVudCwgY29udCkgPT4ge1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBjb25zdCByZXN1bHQgPSBjb250KCk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEcmFnZ2FibGVDb2x1bW5EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSwgZWxlbWVudCwgem9uZSwgc2VydmljZSwgaGludCwgY3VlLCBuYXYsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLmhpbnQgPSBoaW50O1xuICAgICAgICB0aGlzLmN1ZSA9IGN1ZTtcbiAgICAgICAgdGhpcy5uYXYgPSBuYXY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgICAgIHRoaXMuZHJhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBzZXQgZW5hYmxlRHJhZyhlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlVG91Y2hBY3Rpb24oKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuZHJhZ2dhYmxlLmtlbmRvUHJlc3MucGlwZShmaWx0ZXIoXyA9PiB0aGlzLmVuYWJsZWQpLCBmaWx0ZXIoKHsgb3JpZ2luYWxFdmVudDogeyB0YXJnZXQgfSB9KSA9PiB0YXJnZXQgPT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50IHx8IHNraXBCdXR0b25zKHRhcmdldCkpLCB0YXAoKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICBpZiAoIWUuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmF2Lm5hdmlnYXRlVG8ob3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICB9KSwgc3dpdGNoTWFwKHByZXZlbnRPbkRibENsaWNrJDEodGhpcy5kcmFnZ2FibGUua2VuZG9SZWxlYXNlKSksIHRhcChkb3duID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGludC5jcmVhdGUoZG93biwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMuY29udGV4dC5oaW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VlLmNyZWF0ZSgpO1xuICAgICAgICB9KSwgc3dpdGNoTWFwKGRvd24gPT4gdGhpcy5kcmFnZ2FibGUua2VuZG9EcmFnLnBpcGUodGFwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB0YXAodGhpcy5oaW50LmF0dGFjaCgpKSwgdGFwKHRoaXMuY3VlLmF0dGFjaCgpKSwgdGFrZVVudGlsKHRoaXMuZHJhZ2dhYmxlLmtlbmRvUmVsZWFzZSksIG1hcChtb3ZlID0+ICh7IG1vdmUsIGRvd24gfSkpKSksIHRhcCh0aGlzLnBlcmZvcm1EcmFnLmJpbmQodGhpcykpLCBzd2l0Y2hNYXBUbyh0aGlzLmRyYWdnYWJsZS5rZW5kb1JlbGVhc2UpKS5zdWJzY3JpYmUodGhpcy5kcm9wLmJpbmQodGhpcykpKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcm9wKHVwRXZlbnQpIHtcbiAgICAgICAgdGhpcy5oaW50LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmN1ZS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm5vdGlmeURyb3AodGhpcywgdXBFdmVudCk7XG4gICAgfVxuICAgIHBlcmZvcm1EcmFnKHsgbW92ZSB9KSB7XG4gICAgICAgIHRoaXMuaGludC5tb3ZlKG1vdmUpO1xuICAgICAgICBjb25zdCBjdXJzb3JFbGVtZW50ID0gdGhpcy5lbGVtZW50VW5kZXJDdXJzb3IobW92ZSk7XG4gICAgICAgIGlmIChjdXJzb3JFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2Uubm90aWZ5RHJhZyh0aGlzLCBjdXJzb3JFbGVtZW50LCBtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWcuZW1pdCh7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRoaXMsXG4gICAgICAgICAgICBtb3VzZUV2ZW50OiBtb3ZlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbGVtZW50VW5kZXJDdXJzb3IobW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLmhpbnQuaGlkZSgpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZWxlbWVudFVuZGVyQ3Vyc29yKG1vdXNlRXZlbnQpO1xuICAgICAgICBpZiAodGFyZ2V0ICYmIC9rLWdyb3VwaW5nLWRyb3BjbHVlLy50ZXN0KHRhcmdldC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBoaWRlVGhlblNob3codGFyZ2V0LCBlbGVtZW50VW5kZXJDdXJzb3IuYmluZCh0aGlzLCBtb3VzZUV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaW50LnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgdXBkYXRlVG91Y2hBY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3RvdWNoLWFjdGlvbicsIHRoaXMuZW5hYmxlZCA/ICdub25lJyA6ICcnKTtcbiAgICB9XG59XG5EcmFnZ2FibGVDb2x1bW5EaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYWdnYWJsZUNvbHVtbl0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRyYWdnYWJsZUNvbHVtbkRpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERyYWdnYWJsZURpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3sgdHlwZTogSG9zdCB9XSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBEcmFnQW5kRHJvcFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IERyYWdIaW50U2VydmljZSB9LFxuICAgIHsgdHlwZTogRHJvcEN1ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5hdmlnYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfVxuXTtcbkRyYWdnYWJsZUNvbHVtbkRpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb250ZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBlbmFibGVEcmFnOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkcmFnOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaG9zdENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQtZHJhZ2dhYmxlLWhlYWRlcicsXSB9XVxufTtcblxuY29uc3QgZXhwb3J0ZWQgPSBbXG4gICAgRHJhZ2dhYmxlQ29sdW1uRGlyZWN0aXZlLFxuICAgIERyb3BUYXJnZXREaXJlY3RpdmVcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRHJhZ0FuZERyb3BNb2R1bGUge1xufVxuRHJhZ0FuZERyb3BNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2V4cG9ydGVkXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbZXhwb3J0ZWRdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5MaXN0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuZ1pvbmUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVzZXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYXBwbHkgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29sdW1uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmF1dG9TeW5jID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbGxvd0hpZGVBbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3Rpb25zQ2xhc3MgPSAnay1hY3Rpb24tYnV0dG9ucyc7XG4gICAgICAgIHRoaXMudW5sb2NrZWRDb3VudCA9IDA7XG4gICAgfVxuICAgIGdldCBjbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXQgY29sdW1ucyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb2x1bW5zID0gdmFsdWUuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uaW5jbHVkZUluQ2hvb3NlciAhPT0gZmFsc2UpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5TdGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgY29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XG4gICAgfVxuICAgIGlzRGlzYWJsZWQoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuYWxsb3dIaWRlQWxsIHx8IHRoaXMuaGFzRmlsdGVyZWQgfHwgY29sdW1uLmhpZGRlbiB8fCB0aGlzLmNvbHVtbnMuZmluZChjdXJyZW50ID0+IGN1cnJlbnQgIT09IGNvbHVtbiAmJiAhY3VycmVudC5oaWRkZW4pKSB8fFxuICAgICAgICAgICAgKHRoaXMuaGFzVmlzaWJsZUxvY2tlZCAmJiAhdGhpcy5oYXNVbmxvY2tlZEZpbHRlcmVkICYmIHRoaXMudW5sb2NrZWRDb3VudCA9PT0gMSAmJiAhY29sdW1uLmxvY2tlZCAmJiAhY29sdW1uLmhpZGRlbik7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucyA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzc2VzKGUudGFyZ2V0LCAnay1jaGVja2JveCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9TeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmNvbHVtbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuID0gIWUudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQm9vbGVhbihjb2x1bW4uaGlkZGVuKSAhPT0gaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLmhpZGRlbiA9IGhpZGRlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5DaGFuZ2UuZW1pdChbY29sdW1uXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpc2FibGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kb21TdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hDaGVja0JveCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9ICF0aGlzLmNvbHVtbnNbaW5kZXhdLmhpZGRlbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzYWJsZWQoKTtcbiAgICAgICAgdGhpcy5yZXNldC5lbWl0KCk7XG4gICAgfVxuICAgIGFwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2hDaGVja0JveCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuY29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBoaWRkZW4gPSAhZWxlbWVudC5jaGVja2VkO1xuICAgICAgICAgICAgaWYgKEJvb2xlYW4oY29sdW1uLmhpZGRlbikgIT09IGhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5oaWRkZW4gPSBoaWRkZW47XG4gICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc2FibGVkKCk7XG4gICAgICAgIHRoaXMuYXBwbHkuZW1pdChjaGFuZ2VkKTtcbiAgICB9XG4gICAgZm9yRWFjaENoZWNrQm94KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdrLWNoZWNrYm94Jyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoZWNrYm94ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjaGVja2JveGVzW2lkeF0sIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRGlzYWJsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SGlkZUFsbCAmJiAhdGhpcy5oYXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja2VkSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2hlY2tCb3goKGNoZWNrYm94LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkSXRlbXMucHVzaCh7IGNoZWNrYm94LCBpbmRleCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrYm94LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dIaWRlQWxsICYmIGNoZWNrZWRJdGVtcy5sZW5ndGggPT09IDEgJiYgIXRoaXMuaGFzRmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGNoZWNrZWRJdGVtc1swXS5jaGVja2JveC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNMb2NrZWQgJiYgIXRoaXMuaGFzVW5sb2NrZWRGaWx0ZXJlZCkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWRVbmxvY2tlZCA9IGNoZWNrZWRJdGVtcy5maWx0ZXIoaXRlbSA9PiAhY29sdW1uc1tpdGVtLmluZGV4XS5sb2NrZWQpO1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRVbmxvY2tlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkVW5sb2NrZWRbMF0uY2hlY2tib3guZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtblN0YXRlKCkge1xuICAgICAgICB0aGlzLmhhc0xvY2tlZCA9IHRoaXMuYWxsQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sb2NrZWQgJiYgKCFjb2x1bW4uaGlkZGVuIHx8IGNvbHVtbi5pbmNsdWRlSW5DaG9vc2VyICE9PSBmYWxzZSkpLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuaGFzVmlzaWJsZUxvY2tlZCA9IHRoaXMuYWxsQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5sb2NrZWQgJiYgIWNvbHVtbi5oaWRkZW4pLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMudW5sb2NrZWRDb3VudCA9IHRoaXMuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4ubG9ja2VkICYmICFjb2x1bW4uaGlkZGVuKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkQ29sdW1ucyA9IHRoaXMuYWxsQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5pbmNsdWRlSW5DaG9vc2VyID09PSBmYWxzZSAmJiAhY29sdW1uLmhpZGRlbik7XG4gICAgICAgIGlmIChmaWx0ZXJlZENvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZpbHRlcmVkID0gZmlsdGVyZWRDb2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB0aGlzLmhhc1VubG9ja2VkRmlsdGVyZWQgPSBmaWx0ZXJlZENvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiAhY29sdW1uLmxvY2tlZCkubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFzVW5sb2NrZWRGaWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuQ29sdW1uTGlzdENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtY29sdW1ubGlzdCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImstY29sdW1uLWxpc3RcIj5cbiAgICAgICAgICAgIDxsYWJlbCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnM7IGxldCBpbmRleCA9IGluZGV4O1wiIGNsYXNzPSdrLWNvbHVtbi1saXN0LWl0ZW0nPlxuICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImstY2hlY2tib3hcIiB0eXBlPVwiY2hlY2tib3hcIiBbYXR0ci5kYXRhLWluZGV4XT1cImluZGV4XCIgW2NoZWNrZWRdPVwiIWNvbHVtbi5oaWRkZW5cIiBbZGlzYWJsZWRdPVwiaXNEaXNhYmxlZChjb2x1bW4pXCIgLz48c3BhbiBjbGFzcz1cImstY2hlY2tib3gtbGFiZWxcIj57eyBjb2x1bW4uZGlzcGxheVRpdGxlIH19PC9zcGFuPlxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVwiYWN0aW9uc0NsYXNzXCIgKm5nSWY9XCIhYXV0b1N5bmNcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiay1idXR0b25cIiAoY2xpY2spPVwiY2FuY2VsQ2hhbmdlcygpXCI+e3sgcmVzZXRUZXh0IH19PC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImstYnV0dG9uIGstcHJpbWFyeVwiIChjbGljayk9XCJhcHBseUNoYW5nZXMoKVwiPnt7IGFwcGx5VGV4dCB9fTwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbkxpc3RDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuQ29sdW1uTGlzdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjbGFzc05hbWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbXCJjbGFzcy5rLWNvbHVtbi1saXN0LXdyYXBwZXJcIixdIH1dLFxuICAgIHJlc2V0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgYXBwbHk6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2x1bW5DaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2x1bW5zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhdXRvU3luYzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWxsb3dIaWRlQWxsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhcHBseVRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlc2V0VGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aW9uc0NsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb21wb25lbnQgZm9yIHNlbGVjdGluZyBjb2x1bW5zIGluIHRoZSBUcmVlTGlzdC4gVG8gZW5hYmxlIHRoZSB1c2VyIHRvIHNob3cgb3IgaGlkZSBjb2x1bW5zLFxuICogYWRkIHRoZSBjb21wb25lbnQgaW5zaWRlIGEgW2BUb29sYmFyVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF90b29sYmFydGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiB7JSBtZXRhIGhlaWdodDo1MDAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvY2hvb3Nlci10b29sYmFyL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2VtcGxveWVlcy50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBDb2x1bW5DaG9vc2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNvbHVtbkluZm9TZXJ2aWNlLCBwb3B1cFNlcnZpY2UsIG5nWm9uZSwgcmVuZGVyZXIsIGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlID0gY29sdW1uSW5mb1NlcnZpY2U7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNoYW5nZXMgaW4gdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbHVtbiB3aWxsIGJlIGltbWVkaWF0ZWx5IGFwcGxpZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9TeW5jID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgYWxsIGNvbHVtbnMgY2FuIGJlIGhpZGRlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dIaWRlQWxsID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmxlYWZOYW1lZENvbHVtbnM7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b2dnbGUoYW5jaG9yLCB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMubG9jYWxpemF0aW9uLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25Nb2RlOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGFuY2hvckFsaWduOiB7IHZlcnRpY2FsOiAnYm90dG9tJywgaG9yaXpvbnRhbDogZGlyZWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgcG9wdXBBbGlnbjogeyB2ZXJ0aWNhbDogJ3RvcCcsIGhvcml6b250YWw6IGRpcmVjdGlvbiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50LCAnZGlyJywgdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3J0bCcgOiAnbHRyJyk7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLmNsb3NlQ2xpY2sgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihcImRvY3VtZW50XCIsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3Nlc3QodGFyZ2V0LCBub2RlID0+IG5vZGUgPT09IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50IHx8IG5vZGUgPT09IGFuY2hvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25BcHBseShjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgaWYgKGNoYW5nZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZS5jaGFuZ2VWaXNpYmlsaXR5KGNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNoYW5nZShjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UuY2hhbmdlVmlzaWJpbGl0eShjaGFuZ2VkKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFjaENsb3NlKCk7XG4gICAgfVxuICAgIGRldGFjaENsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZUNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDbGljayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5Db2x1bW5DaG9vc2VyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1jb2x1bW4tY2hvb3NlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiAjYW5jaG9yXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGUoYW5jaG9yLCB0ZW1wbGF0ZSlcIlxuICAgICAgICAgICAgY2xhc3M9XCJrLWJ1dHRvbiBrLWJhcmUgay1idXR0b24taWNvblwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdjb2x1bW5zJylcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1jb2x1bW5zXCI+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdrLWNvbHVtbi1jaG9vc2VyLXRpdGxlJz57eyBsb2NhbGl6YXRpb24uZ2V0KCdjb2x1bW5zJykgfX08L3NwYW4+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1ubGlzdFxuICAgICAgICAgICAgICAgIFtjb2x1bW5zXT1cImNvbHVtbnNcIlxuICAgICAgICAgICAgICAgIFthcHBseVRleHRdPVwibG9jYWxpemF0aW9uLmdldCgnY29sdW1uc0FwcGx5JylcIlxuICAgICAgICAgICAgICAgIFtyZXNldFRleHRdPVwibG9jYWxpemF0aW9uLmdldCgnY29sdW1uc1Jlc2V0JylcIlxuICAgICAgICAgICAgICAgIFthdXRvU3luY109XCJhdXRvU3luY1wiXG4gICAgICAgICAgICAgICAgW2FsbG93SGlkZUFsbF09XCJhbGxvd0hpZGVBbGxcIlxuICAgICAgICAgICAgICAgIChhcHBseSk9XCJvbkFwcGx5KCRldmVudClcIlxuICAgICAgICAgICAgICAgIChjb2x1bW5DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW5saXN0PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sdW1uQ2hvb3NlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENvbHVtbkluZm9TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBQb3B1cFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuQ29sdW1uQ2hvb3NlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBhdXRvU3luYzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWxsb3dIaWRlQWxsOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzZXJ2aWNlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZVxuICogW2BDb2x1bW5NZW51VGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiB7JSBtZXRhIGhlaWdodDo1MDAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvdGVtcGxhdGUtaXRlbS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9lbXBsb3llZXMudHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgQ29sdW1uTWVudVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZU1lbnUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29sdW1uIG1lbnUuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VNZW51LmVtaXQoKTtcbiAgICB9XG59XG5Db2x1bW5NZW51U2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbHVtbk1lbnVJdGVtQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiAhdGhpcy5zZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2aWNlIGlucHV0IG9mIHRoZSBwcmVkZWZpbmVkIGNvbHVtbiBtZW51IGNvbXBvbmVudHMgaXMgbWFuZGF0b3J5LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmNsb3NlKCk7XG4gICAgfVxufVxuQ29sdW1uTWVudUl0ZW1CYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNlcnZpY2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1jb2x1bW5tZW51LWl0ZW0td3JhcHBlcicsXSB9XVxufTtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbXBvbmVudCBmb3Igc2VsZWN0aW5nIGNvbHVtbnMgaW4gdGhlIFRyZWVMaXN0IHRoYXQgY2FuIGJlIHBsYWNlZFxuICogaW5zaWRlIGEgW2BDb2x1bW5NZW51VGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiA+IFlvdSBoYXZlIHRvIHNldCB0aGUgW0NvbHVtbk1lbnVTZXJ2aWNlXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb2x1bW5tZW51c2VydmljZSAlfSkgdGhhdCBpcyBwYXNzZWQgYnlcbiAqID4gdGhlIHRlbXBsYXRlIHRvIHRoZSBzZXJ2aWNlIGlucHV0IG9mIHRoZSBga2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1jaG9vc2VyYCBjb21wb25lbnQuXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NTAwICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L3RlbXBsYXRlLWNob29zZXIvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvbWFpbi50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZW1wbG95ZWVzLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIENvbHVtbk1lbnVDaG9vc2VyQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uTWVudUl0ZW1CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGl6YXRpb24sIGNvbHVtbkluZm9TZXJ2aWNlLCBjaGFuZ2VEZXRlY3Rvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZSA9IGNvbHVtbkluZm9TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGV4cGFuZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGNvbGxhcHNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNvbnRlbnQgaXMgZXhwYW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGlvbnNDbGFzcyA9ICdrLWNvbHVtbm1lbnUtYWN0aW9ucyc7XG4gICAgfVxuICAgIGdldCBjb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5JbmZvU2VydmljZS5sZWFmTmFtZWRDb2x1bW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25BcHBseShjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgaWYgKGNoYW5nZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZS5jaGFuZ2VWaXNpYmlsaXR5KGNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtY2hvb3NlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbSBbdGV4dF09XCJsb2NhbGl6YXRpb24uZ2V0KCdjb2x1bW5zJylcIlxuICAgICAgICAgICAgaWNvbj1cImNvbHVtbnNcIiBbZXhwYW5kZWRdPVwiZXhwYW5kZWRcIiAoY29sbGFwc2UpPVwiY29sbGFwc2UuZW1pdCgpXCIgKGV4cGFuZCk9XCJleHBhbmQuZW1pdCgpXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdENvbHVtbk1lbnVJdGVtQ29udGVudFRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5saXN0XG4gICAgICAgICAgICAgICAgICAgIFthcHBseVRleHRdPVwibG9jYWxpemF0aW9uLmdldCgnY29sdW1uc0FwcGx5JylcIlxuICAgICAgICAgICAgICAgICAgICBbcmVzZXRUZXh0XT1cImxvY2FsaXphdGlvbi5nZXQoJ2NvbHVtbnNSZXNldCcpXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbnNdPVwiY29sdW1uc1wiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvU3luY109XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFthbGxvd0hpZGVBbGxdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbYWN0aW9uc0NsYXNzXT1cImFjdGlvbnNDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgIChhcHBseSk9XCJvbkFwcGx5KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbmxpc3Q+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbT5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbk1lbnVDaG9vc2VyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29sdW1uSW5mb1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5Db2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBleHBhbmQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb2xsYXBzZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGV4cGFuZGVkOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbXBvbmVudCBmb3IgZWRpdGluZyBjb2x1bW4gZmlsdGVycyBpbiB0aGUgVHJlZUxpc3QgdGhhdCBjYW4gYmUgcGxhY2VkXG4gKiBpbnNpZGUgYSBbYENvbHVtbk1lbnVUZW1wbGF0ZWBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NvbHVtbm1lbnV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICpcbiAqID4gWW91IGhhdmUgdG8gc2V0IHRoZSBbQ29sdW1uTWVudVNlcnZpY2VdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NvbHVtbm1lbnVzZXJ2aWNlICV9KSB0aGF0IGlzIHBhc3NlZCBieVxuICogPiB0aGUgdGVtcGxhdGUgdG8gdGhlIHNlcnZpY2UgaW5wdXQgb2YgdGhlIGBrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWZpbHRlcmAgY29tcG9uZW50LlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjUwMCAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS90ZW1wbGF0ZS1maWx0ZXIvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L2FwcC5tb2R1bGUudHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvbWFpbi50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZW1wbG95ZWVzLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmNsYXNzIENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW5NZW51SXRlbUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGNvbnRlbnQgaXMgZXhwYW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGNvbnRlbnQgaXMgY29sbGFwc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsYXBzZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgY29udGVudCBpcyBleHBhbmRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aW9uc0NsYXNzID0gJ2stY29sdW1ubWVudS1hY3Rpb25zJztcbiAgICB9XG59XG5Db2x1bW5NZW51RmlsdGVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWZpbHRlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbSBbdGV4dF09XCJsb2NhbGl6YXRpb24uZ2V0KCdmaWx0ZXInKVwiIGljb249XCJmaWx0ZXJcIlxuICAgICAgICAgICAgW2V4cGFuZGVkXT1cImV4cGFuZGVkXCIgKGNvbGxhcHNlKT1cImNvbGxhcHNlLmVtaXQoKVwiIChleHBhbmQpPVwiZXhwYW5kLmVtaXQoKVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWZpbHRlci1tZW51LWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJzZXJ2aWNlLmNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cInNlcnZpY2UuZmlsdGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthY3Rpb25zQ2xhc3NdPVwiYWN0aW9uc0NsYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbG9zZSk9XCJjbG9zZSgpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtZmlsdGVyLW1lbnUtY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1pdGVtPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sdW1uTWVudUZpbHRlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfVxuXTtcbkNvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZXhwYW5kOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY29sbGFwc2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb250ZW50IHRlbXBsYXRlIG9mIHRoZVxuICogW2BrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWl0ZW1gXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb2x1bW5tZW51aXRlbWNvbXBvbmVudCAlfSkgY29tcG9uZW50LlxuICogUHJvdmlkZXMgYW4gb3B0aW9uIGZvciBzcGVjaWZ5aW5nIHRoZSBjb250ZW50IG9mIGEgY29sdW1uIGl0ZW0uXG4gKiBUbyBkZWZpbmUgdGhlIGNvbnRlbnQgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZVxuICogYGtlbmRvVHJlZUxpc3RDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZWAgZGlyZWN0aXZlIGluc2lkZSBhIGA8a2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1pdGVtPmAuXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NTAwICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L3RlbXBsYXRlLWl0ZW0tY29udGVudC9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9lbXBsb3llZXMudHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Db2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbk1lbnVJdGVtQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpdGVtIHRoYXQgY2FuIGJlIHBsYWNlZCBpbnNpZGUgYVxuICogW2BDb2x1bW5NZW51VGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb2x1bW5tZW51dGVtcGxhdGVkaXJlY3RpdmUgJX0pIGRpcmVjdGl2ZS5cbiAqXG4gKiB7JSBtZXRhIGhlaWdodDo1MDAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvdGVtcGxhdGUtaXRlbS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9lbXBsb3llZXMudHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaXRlbSBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGV4cGFuZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjb250ZW50IGlzIGNvbGxhcHNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY29udGVudFN0YXRlID0gJ2NvbGxhcHNlZCc7XG4gICAgfVxuICAgIGdldCBpY29uQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBgay1pLSR7dGhpcy5pY29ufWA7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2xpY2soZSkge1xuICAgICAgICB0aGlzLml0ZW1DbGljay5lbWl0KGUpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRlbnRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50U3RhdGUgPSB0aGlzLmV4cGFuZGVkID8gJ2V4cGFuZGVkJyA6ICdjb2xsYXBzZWQnO1xuICAgIH1cbn1cbkNvbHVtbk1lbnVJdGVtQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdzdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IGRpc3BsYXk6ICdub25lJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnZXhwYW5kZWQnLCBzdHlsZSh7IGRpc3BsYXk6ICdibG9jaycgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignY29sbGFwc2VkID0+IGV4cGFuZGVkJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzEwMG1zIGVhc2UtaW4nLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJyonXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkID0+IGNvbGxhcHNlZCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJyonXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMTAwbXMgZWFzZS1pbicsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMHB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1pdGVtJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1jb2x1bW5tZW51LWl0ZW1cIiAoY2xpY2spPVwib25DbGljaygkZXZlbnQpXCIgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwic2VsZWN0ZWRcIiBbY2xhc3Muay1zdGF0ZS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuICAgICAgICAgICA8c3BhbiAqbmdJZj1cImljb25cIiBjbGFzcz1cImstaWNvblwiIFtuZ0NsYXNzXT1cImljb25DbGFzc1wiPlxuICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgIHt7IHRleHQgfX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJjb250ZW50VGVtcGxhdGVcIiBbQHN0YXRlXT1cImNvbnRlbnRTdGF0ZVwiIHN0eWxlPVwib3ZlcmZsb3c6aGlkZGVuO1wiIGNsYXNzPVwiay1jb2x1bW5tZW51LWl0ZW0tY29udGVudFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJjb250ZW50VGVtcGxhdGUudGVtcGxhdGVSZWZcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2PlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkNvbHVtbk1lbnVJdGVtQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGl0ZW1DbGljazogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGV4cGFuZDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbGxhcHNlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaWNvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0ZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29udGVudFRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dXG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbHVtbi1tZW51IGl0ZW0gZm9yIHNvcnRpbmcgVHJlZUxpc3QgY29sdW1ucyB0aGF0IGNhbiBiZSBwbGFjZWQgaW5zaWRlIGFcbiAqIFtgQ29sdW1uTWVudVRlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29sdW1ubWVudXRlbXBsYXRlZGlyZWN0aXZlICV9KSBkaXJlY3RpdmUuXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gc29ydCB0aGUgY29sdW1uLlxuICpcbiAqID4gWW91IGhhdmUgdG8gc2V0IHRoZSBbQ29sdW1uTWVudVNlcnZpY2VdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NvbHVtbm1lbnVzZXJ2aWNlICV9KSB0aGF0IGlzIHBhc3NlZCBieVxuICogPiB0aGUgdGVtcGxhdGUgdG8gdGhlIHNlcnZpY2UgaW5wdXQgb2YgdGhlIGBrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LXNvcnRgIGNvbXBvbmVudC5cbiAqXG4gKiB7JSBtZXRhIGhlaWdodDo1MDAgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvdGVtcGxhdGUtc29ydC9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgY29sdW1uLW1lbnUvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9tYWluLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9lbXBsb3llZXMudHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgQ29sdW1uTWVudVNvcnRDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW5NZW51SXRlbUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgc29ydFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc29ydFNlcnZpY2UgPSBzb3J0U2VydmljZTtcbiAgICB9XG4gICAgZ2V0IHNvcnRlZEFzYygpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgKCFkZXNjcmlwdG9yLmRpciB8fCBkZXNjcmlwdG9yLmRpciA9PT0gJ2FzYycpO1xuICAgIH1cbiAgICBnZXQgc29ydGVkRGVzYygpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5kaXIgPT09ICdkZXNjJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZVNvcnQoZGlyKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5zZXJ2aWNlLmNvbHVtbi5maWVsZDtcbiAgICAgICAgY29uc3QgeyBtb2RlLCBhbGxvd1Vuc29ydCB9ID0gbm9ybWFsaXplJDEodGhpcy5zZXJ2aWNlLnNvcnRhYmxlKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICAgICAgY29uc3Qgc29ydCA9IG1vZGUgPT09ICdtdWx0aXBsZScgPyB0aGlzLnNlcnZpY2Uuc29ydC5maWx0ZXIocyA9PiBzLmZpZWxkICE9PSBmaWVsZCkgOiBbXTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5kaXIgPT09IGRpcikge1xuICAgICAgICAgICAgaWYgKCFhbGxvd1Vuc29ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvcnQucHVzaCh7IGZpZWxkLCBkaXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3J0U2VydmljZS5zb3J0KHNvcnQpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdG9yKCkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KHRoaXMuc2VydmljZS5zb3J0IHx8IFtdKS5maW5kKHMgPT4gcy5maWVsZCA9PT0gdGhpcy5zZXJ2aWNlLmNvbHVtbi5maWVsZCk7XG4gICAgfVxufVxuQ29sdW1uTWVudVNvcnRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtc29ydCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbSBbdGV4dF09XCJsb2NhbGl6YXRpb24uZ2V0KCdzb3J0QXNjZW5kaW5nJylcIlxuICAgICAgICAgICAgaWNvbj1cInNvcnQtYXNjLXNtXCIgKGl0ZW1DbGljayk9XCJ0b2dnbGVTb3J0KCdhc2MnKVwiIFtzZWxlY3RlZF09XCJzb3J0ZWRBc2NcIj5cbiAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWl0ZW0+XG4gICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWl0ZW0gW3RleHRdPVwibG9jYWxpemF0aW9uLmdldCgnc29ydERlc2NlbmRpbmcnKVwiXG4gICAgICAgICAgICBpY29uPVwic29ydC1kZXNjLXNtXCIgKGl0ZW1DbGljayk9XCJ0b2dnbGVTb3J0KCdkZXNjJylcIiBbc2VsZWN0ZWRdPVwic29ydGVkRGVzY1wiPlxuICAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbT5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbk1lbnVTb3J0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogU29ydFNlcnZpY2UgfVxuXTtcblxuY29uc3QgUE9QVVBfQ0xBU1MgPSAnay1ncmlkLWNvbHVtbm1lbnUtcG9wdXAnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbY29sdW1uIG1lbnVdKHslIHNsdWcgY29sdW1ubWVudV90cmVlbGlzdCAlfSkgY29tcG9uZW50LlxuICovXG5jbGFzcyBDb2x1bW5NZW51Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvbiwgc2VydmljZSkge1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YW5kYWxvbmUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNldHRpbmdzIGZvciB0aGUgQ29sdW1uIE1lbnUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWRGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWRDb2x1bW5zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24gPSBzZXJ2aWNlLmNsb3NlTWVudS5zdWJzY3JpYmUodGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc0ZpbHRlciAmJiBmaWx0ZXJzQnlGaWVsZCh0aGlzLmZpbHRlciwgdGhpcy5jb2x1bW4uZmllbGQpLmxlbmd0aCA+IDApIHx8XG4gICAgICAgICAgICAoIXRoaXMuc29ydGFibGUgJiYgdGhpcy5oYXNTb3J0ICYmIHRoaXMuc29ydC5maW5kKGRlc2NyaXB0b3IgPT4gZGVzY3JpcHRvci5maWVsZCA9PT0gdGhpcy5jb2x1bW4uZmllbGQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoYXNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBoYXNGaWx0ZXIodGhpcy5zZXR0aW5ncywgdGhpcy5jb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhhc1NvcnQoKSB7XG4gICAgICAgIHJldHVybiBoYXNTb3J0KHRoaXMuc2V0dGluZ3MsIHRoaXMuY29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoYXNDb2x1bW5DaG9vc2VyKCkge1xuICAgICAgICByZXR1cm4gaGFzQ29sdW1uQ2hvb3Nlcih0aGlzLnNldHRpbmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoYXNMb2NrKCkge1xuICAgICAgICByZXR1cm4gaGFzTG9jayh0aGlzLnNldHRpbmdzLCB0aGlzLmNvbHVtbik7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHRoaXMuc2VydmljZS5zb3J0ID0gdGhpcy5zb3J0O1xuICAgICAgICB0aGlzLnNlcnZpY2UuZmlsdGVyID0gdGhpcy5maWx0ZXI7XG4gICAgICAgIHRoaXMuc2VydmljZS5zb3J0YWJsZSA9IHRoaXMuc29ydGFibGU7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRvZ2dsZShlLCBhbmNob3IsIHRlbXBsYXRlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZEZpbHRlciA9ICF0aGlzLmhhc0NvbHVtbkNob29zZXI7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDb2x1bW5zID0gIXRoaXMuaGFzRmlsdGVyO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3BlbihhbmNob3IsIHRlbXBsYXRlLCB0aGlzLnBvcHVwUmVmLCBQT1BVUF9DTEFTUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ29sdW1uc0V4cGFuZCgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZENvbHVtbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmV4cGFuZGVkRmlsdGVyID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkZpbHRlckV4cGFuZCgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZEZpbHRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDb2x1bW5zID0gZmFsc2U7XG4gICAgfVxufVxuQ29sdW1uTWVudUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NvbHVtbk1lbnVTZXJ2aWNlXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWNvbHVtbi1tZW51JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YSAjYW5jaG9yXG4gICAgICAgICAgICBjbGFzcz1cImstZ3JpZC1jb2x1bW4tbWVudSBrLWdyaWQtZmlsdGVyXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2stc3RhdGUtYWN0aXZlJzogaXNBY3RpdmUgfVwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlKCRldmVudCwgYW5jaG9yLCB0ZW1wbGF0ZSlcIlxuICAgICAgICAgICAgaHJlZj1cIiNcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJsb2NhbGl6YXRpb24uZ2V0KCdjb2x1bW5NZW51JylcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1tb3JlLXZlcnRpY2FsXCI+PC9zcGFuPlxuICAgICAgICA8L2E+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjdGVtcGxhdGU+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5jb2x1bW5NZW51VGVtcGxhdGVSZWYgfHwgY29sdW1uTWVudVRlbXBsYXRlIHx8IGRlZmF1bHRUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7IHNlcnZpY2U6IHNlcnZpY2UsIGNvbHVtbjogY29sdW1uIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LXNvcnQgKm5nSWY9XCJoYXNTb3J0XCIgW3NlcnZpY2VdPVwic2VydmljZVwiPlxuICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LXNvcnQ+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1sb2NrICpuZ0lmPVwiaGFzTG9ja1wiIFtzZXJ2aWNlXT1cInNlcnZpY2VcIj5cbiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1sb2NrPlxuICAgICAgICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtY2hvb3NlciAqbmdJZj1cImhhc0NvbHVtbkNob29zZXJcIiBbc2VydmljZV09XCJzZXJ2aWNlXCJcbiAgICAgICAgICAgICAgICBbZXhwYW5kZWRdPVwiZXhwYW5kZWRDb2x1bW5zXCIgKGV4cGFuZCk9XCJvbkNvbHVtbnNFeHBhbmQoKVwiPlxuICAgICAgICAgICAgPC9rZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWNob29zZXI+XG4gICAgICAgICAgICA8a2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1maWx0ZXIgKm5nSWY9XCJoYXNGaWx0ZXJcIiBbc2VydmljZV09XCJzZXJ2aWNlXCJcbiAgICAgICAgICAgICAgICBbZXhwYW5kZWRdPVwiZXhwYW5kZWRGaWx0ZXJcIiAoZXhwYW5kKT1cIm9uRmlsdGVyRXhwYW5kKClcIj5cbiAgICAgICAgICAgIDwva2VuZG8tdHJlZWxpc3QtY29sdW1ubWVudS1maWx0ZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Db2x1bW5NZW51Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogU2luZ2xlUG9wdXBTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDb2x1bW5NZW51U2VydmljZSB9XG5dO1xuQ29sdW1uTWVudUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBzdGFuZGFsb25lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQtY29sdW1uLW1lbnUtc3RhbmRhbG9uZScsXSB9LCB7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2V0dGluZ3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNvcnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc29ydGFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbk1lbnVUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29sdW1uLW1lbnUgaXRlbSB0aGF0IGNhbiBiZSBwbGFjZWQgaW5zaWRlIGFcbiAqIFtgQ29sdW1uTWVudVRlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29sdW1ubWVudXRlbXBsYXRlZGlyZWN0aXZlICV9KSBkaXJlY3RpdmUuXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gbG9jayBvciB1bmxvY2sgdGhlIGNvbHVtbnMuXG4gKlxuICogPiBZb3UgaGF2ZSB0byBzZXQgdGhlIFtDb2x1bW5NZW51U2VydmljZV0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29sdW1ubWVudXNlcnZpY2UgJX0pIHRoYXQgaXMgcGFzc2VkIGJ5XG4gKiA+IHRoZSB0ZW1wbGF0ZSB0byB0aGUgc2VydmljZSBpbnB1dCBvZiB0aGUgYGtlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtbG9ja2AgY29tcG9uZW50LlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjUwMCAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS90ZW1wbGF0ZS1sb2NrL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBjb2x1bW4tbWVudS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIGNvbHVtbi1tZW51L21haW4udHMgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL2VtcGxveWVlcy50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBDb2x1bW5NZW51TG9ja0NvbXBvbmVudCBleHRlbmRzIENvbHVtbk1lbnVJdGVtQmFzZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uLCBjb2x1bW5JbmZvU2VydmljZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UgPSBjb2x1bW5JbmZvU2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldCh0aGlzLmxvY2tlZCA/ICd1bmxvY2snIDogJ2xvY2snKTtcbiAgICB9XG4gICAgZ2V0IGljb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tlZCA/ICd1bmxvY2snIDogJ2xvY2snO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5sb2NrZWQgJiYgdGhpcy5jb2x1bW5JbmZvU2VydmljZS51bmxvY2tlZFJvb3RDb3VudCA8IDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0b2dnbGVDb2x1bW4oKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlSGllcmFyY2h5KCF0aGlzLmxvY2tlZCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgdG9nZ2xlSGllcmFyY2h5KGxvY2tlZCkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMuc2VydmljZS5jb2x1bW47XG4gICAgICAgIHdoaWxlIChyb290LnBhcmVudCkge1xuICAgICAgICAgICAgcm9vdCA9IHJvb3QucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBbcm9vdF07XG4gICAgICAgIGNvbnN0IGFsbENoYW5nZWQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb2x1bW4ubG9ja2VkID0gbG9ja2VkO1xuICAgICAgICAgICAgYWxsQ2hhbmdlZC5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKC4uLmNvbHVtbi5jaGlsZHJlbkFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLmNoYW5nZUxvY2tlZChhbGxDaGFuZ2VkKTtcbiAgICB9XG4gICAgZ2V0IGxvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5jb2x1bW4ubG9ja2VkO1xuICAgIH1cbn1cbkNvbHVtbk1lbnVMb2NrQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1jb2x1bW5tZW51LWxvY2snLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgPGtlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbSBbdGV4dF09XCJ0ZXh0XCIgW2ljb25dPVwiaWNvblwiIChpdGVtQ2xpY2spPVwidG9nZ2xlQ29sdW1uKClcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICA8L2tlbmRvLXRyZWVsaXN0LWNvbHVtbm1lbnUtaXRlbT5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbk1lbnVMb2NrQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29sdW1uSW5mb1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5cbmNvbnN0IENPTVBPTkVOVFMkMSA9IFtcbiAgICBDb2x1bW5MaXN0Q29tcG9uZW50LFxuICAgIENvbHVtbkNob29zZXJDb21wb25lbnQsXG4gICAgQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQsXG4gICAgQ29sdW1uTWVudUZpbHRlckNvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51SXRlbUNvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDb2x1bW5NZW51U29ydENvbXBvbmVudCxcbiAgICBDb2x1bW5NZW51Q29tcG9uZW50LFxuICAgIENvbHVtbk1lbnVMb2NrQ29tcG9uZW50LFxuICAgIENvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2x1bW5NZW51TW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIENvbHVtbkNob29zZXJDb21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51RmlsdGVyQ29tcG9uZW50LFxuICAgICAgICAgICAgQ29sdW1uTWVudUl0ZW1Db21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51SXRlbUNvbnRlbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENvbHVtbk1lbnVTb3J0Q29tcG9uZW50LFxuICAgICAgICAgICAgQ29sdW1uTWVudUxvY2tDb21wb25lbnQsXG4gICAgICAgICAgICBDb2x1bW5NZW51Q2hvb3NlckNvbXBvbmVudCxcbiAgICAgICAgICAgIENvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIENvbHVtbk1lbnVDb21wb25lbnRcbiAgICAgICAgXTtcbiAgICB9XG59XG5Db2x1bW5NZW51TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRTJDFdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZpbHRlck1lbnVNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRTJDFdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQxID0gW1xuICAgIEhlYWRlckNvbXBvbmVudCxcbiAgICBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDb2x1bW5IYW5kbGVEaXJlY3RpdmVcbl07XG5jb25zdCBpbXBvcnRlZE1vZHVsZXMkMiA9IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgUm93RmlsdGVyTW9kdWxlLFxuICAgIEZpbHRlck1lbnVNb2R1bGUsXG4gICAgU2hhcmVkTW9kdWxlLFxuICAgIERyYWdBbmREcm9wTW9kdWxlLFxuICAgIENvbHVtbk1lbnVNb2R1bGVcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSGVhZGVyTW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlXG4gICAgICAgIF07XG4gICAgfVxufVxuSGVhZGVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtleHBvcnRlZE1vZHVsZXMkMV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW2V4cG9ydGVkTW9kdWxlcyQxXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbLi4uaW1wb3J0ZWRNb2R1bGVzJDJdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29tbWFuZCBjb2x1bW5zIG9mIHRoZSBUcmVlTGlzdC4gWW91IGhhdmUgdG8gZGVmaW5lIHRoZSBjb250ZW50IG9mIHRoZVxuICogY29sdW1uIGluc2lkZSBhbiBgPG5nLXRlbXBsYXRlPmAgdGFnLiBUaGUgdGVtcGxhdGUgY29udGV4dCBpcyBzZXQgdG8gdGhlIGN1cnJlbnRcbiAqIGRhdGEgaXRlbS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzIG9uIHVzaW5nIHRoZSBwYXNzZWQgZmllbGRzXG4gKiBhbmQgdGhlIGNvbW1hbmQgZGlyZWN0aXZlcywgcmVmZXIgdG8gdGhlIGFydGljbGUgb25cbiAqIFtlZGl0aW5nIHRoZSBUcmVlTGlzdCBpbiBBbmd1bGFyIFJlYWN0aXZlIEZvcm1zXSh7JSBzbHVnIGVkaXRpbmdfcmVhY3RpdmVfZm9ybXNfdHJlZWxpc3QgJX0pLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBmaWVsZHMgYXJlIHBhc3NlZDpcbiAqIC0gYGNvbHVtbkluZGV4YCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gaW5kZXguXG4gKiAtIGByb3dJbmRleGAmbWRhc2g7VGhlIGN1cnJlbnQgZGF0YSByb3cgaW5kZXguIElmIGluc2lkZSBhIG5ldyBpdGVtIHJvdywgYHJvd0luZGV4YGlzIGAtMWAuXG4gKiAtIGBkYXRhSXRlbWAmbWRhc2g7VGhlIGN1cnJlbnQgZGF0YSBpdGVtLlxuICogLSBgY29sdW1uYCZtZGFzaDtUaGUgY3VycmVudCBjb2x1bW4gaW5zdGFuY2UuXG4gKiAtIGBpc05ld2AmbWRhc2g7VGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG4gKlxuICogVXN1YWxseSwgdGhlIHRlbXBsYXRlIGNvbnRhaW5zIENSVUQgY29tbWFuZCBkaXJlY3RpdmVzIHN1Y2ggYXM6XG4gKiAtIFtgRWRpdENvbW1hbmREaXJlY3RpdmVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9lZGl0Y29tbWFuZGRpcmVjdGl2ZSAlfSlcbiAqIC0gW2BSZW1vdmVDb21tYW5kRGlyZWN0aXZlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfcmVtb3ZlY29tbWFuZGRpcmVjdGl2ZSAlfSlcbiAqIC0gW2BDYW5jZWxDb21tYW5kRGlyZWN0aXZlYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY2FuY2VsY29tbWFuZGRpcmVjdGl2ZSAlfSlcbiAqIC0gW2BTYXZlQ29tbWFuZERpcmVjdGl2ZWBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X3NhdmVjb21tYW5kZGlyZWN0aXZlICV9KVxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjU5MCAlfVxuICogeyUgZW1iZWRfZmlsZSBlZGl0aW5nL2VkaXRpbmctZGlyZWN0aXZlcy9yZWFjdGl2ZS1lZGl0aW5nL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZW1wbG95ZWVzLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIGVkaXRpbmcvZWRpdGluZy1kaXJlY3RpdmVzL3JlYWN0aXZlLWVkaXRpbmcvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvbWFpbi50cyAlfVxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBDb21tYW5kQ29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9wdGlvbkNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvcHRpb25DaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuaXNDb21tYW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZSA/IHRoaXMudGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuQ29tbWFuZENvbHVtbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDb2x1bW5CYXNlJDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDb21tYW5kQ29sdW1uQ29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWNvbW1hbmQtY29sdW1uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29tbWFuZENvbHVtbkNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbHVtbkJhc2UkMSwgZGVjb3JhdG9yczogW3sgdHlwZTogU2tpcFNlbGYgfSwgeyB0eXBlOiBIb3N0IH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICB7IHR5cGU6IE9wdGlvbkNoYW5nZXNTZXJ2aWNlIH1cbl07XG5Db21tYW5kQ29sdW1uQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXSB9XVxufTtcblxuY29uc3QgY29sdW1uQ2VsbEluZGV4ID0gKGNlbGwsIGNlbGxzKSA9PiB7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY2VsbHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoY2VsbHNbaWR4XSA9PT0gY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVGFibGVCb2R5Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VOb3RpZmljYXRpb24sIGVkaXRTZXJ2aWNlLCBsb2NhbGl6YXRpb24sIG5nWm9uZSwgcmVuZGVyZXIsIGVsZW1lbnQsIGRvbUV2ZW50cywgY29sdW1uSW5mb1NlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlLCBleHBhbmRTdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTm90aWZpY2F0aW9uID0gY2hhbmdlTm90aWZpY2F0aW9uO1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlID0gZWRpdFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmRvbUV2ZW50cyA9IGRvbUV2ZW50cztcbiAgICAgICAgdGhpcy5jb2x1bW5JbmZvU2VydmljZSA9IGNvbHVtbkluZm9TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlID0gbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuZXhwYW5kU3RhdGUgPSBleHBhbmRTdGF0ZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICB0aGlzLm5vUmVjb3Jkc1RleHQgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ25vUmVjb3JkcycpO1xuICAgICAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9ja2VkQ29sdW1uc0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy50b3RhbENvbHVtbnNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudHJhY2tCeSA9IGRlZmF1bHRUcmFja0J5O1xuICAgICAgICB0aGlzLnJvd0NsYXNzID0gKCkgPT4gbnVsbDtcbiAgICAgICAgdGhpcy5jZWxsS2V5ZG93blN1YnNjcmlwdGlvbiA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2UuY2VsbEtleWRvd24uc3Vic2NyaWJlKChhcmdzKSA9PiB0aGlzLmNlbGxLZXlkb3duSGFuZGxlcihhcmdzKSk7XG4gICAgICAgIHRoaXMudHJhY2tCeVdyYXBwZXIgPSB0aGlzLnRyYWNrQnlXcmFwcGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhY2tCeUNvbHVtbnMgPSB0aGlzLnRyYWNrQnlDb2x1bW5zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlZ2lzdGVyVGFibGUodGhpcyk7XG4gICAgfVxuICAgIGdldCBuZXdEYXRhSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdFNlcnZpY2UubmV3RGF0YUl0ZW07XG4gICAgfVxuICAgIC8vIE51bWJlciBvZiB1bmxvY2tlZCBjb2x1bW5zIGluIHRoZSBuZXh0IHRhYmxlLCBpZiBhbnlcbiAgICBnZXQgdW5sb2NrZWRDb2x1bW5zQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29sdW1uc0NvdW50IC0gdGhpcy5sb2NrZWRDb2x1bW5zQ291bnQgLSAodGhpcy5hbGxDb2x1bW5zIHx8IHRoaXMuY29sdW1ucykubGVuZ3RoO1xuICAgIH1cbiAgICBpc09kZChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmluZGV4ICUgMiAhPT0gMDtcbiAgICB9XG4gICAgdHJhY2tCeVdyYXBwZXIoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBpdGVtLmlzRWRpdGluZyA9IHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0ZWQoaXRlbS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFja0J5KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gICAgdHJhY2tCeUNvbHVtbnMoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlydHVhbENvbHVtbnMgPyBpbmRleCA6IGl0ZW07XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGlzQ2hhbmdlZChcImNvbHVtbnNcIiwgY2hhbmdlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU5vdGlmaWNhdGlvbi5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSb3dMb2dpY2FsSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkluZm9TZXJ2aWNlLnRvdGFsTGV2ZWxzICsgMTtcbiAgICB9XG4gICAgbG9naWNhbENvbEluZGV4KGNvbHVtbikge1xuICAgICAgICBpZiAoIWlzUHJlc2VudChjb2x1bW4ubGVhZkluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW4ubGVhZkluZGV4O1xuICAgIH1cbiAgICBhcmlhRXhwYW5kZWQoaXRlbSwgY29sdW1uKSB7XG4gICAgICAgIGlmICghY29sdW1uLmV4cGFuZGFibGUgfHwgIWl0ZW0uaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVtLmV4cGFuZGVkKTtcbiAgICB9XG4gICAgYXJpYVNlbGVjdGVkKGl0ZW0sIGNvbHVtbiwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0uc2VsZWN0ZWQgfHwgdGhpcy5pc0NlbGxTZWxlY3RlZChpdGVtLmRhdGEsIGNvbHVtbiwgY29sdW1uSW5kZXgpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xpY2tIYW5kbGVyID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlZG93blN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbW91c2Vkb3duJywgY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrU3Vic2NyaXB0aW9uID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdjbGljaycsIGNsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0bWVudVN1YnNjcmlwdGlvbiA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnY29udGV4dG1lbnUnLCBjbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5jbGlja1N1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd25TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBjbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRtZW51U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9yaWdpbmFsTm9SZWNvcmRUZXh0ID0gdGhpcy5sb2NhbGl6YXRpb24uZ2V0KCdub1JlY29yZHMnKTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9SZWNvcmRzVGV4dCA9PT0gb3JpZ2luYWxOb1JlY29yZFRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vUmVjb3Jkc1RleHQgPSB0aGlzLmxvY2FsaXphdGlvbi5nZXQoJ25vUmVjb3JkcycpO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTm9SZWNvcmRUZXh0ID0gdGhpcy5ub1JlY29yZHNUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICB0aGlzLmhlYWRlck9mZnNldCA9IHRoaXMuY29sdW1uSW5mb1NlcnZpY2UudG90YWxMZXZlbHMgKyAoaGFzRmlsdGVyUm93KHRoaXMuZmlsdGVyYWJsZSkgPyAxIDogMCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbGlja1N1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2VsbEtleWRvd25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24udW5yZWdpc3RlclRhYmxlKHRoaXMpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja1RpbWVvdXQpO1xuICAgIH1cbiAgICBpc0VkaXRpbmdDZWxsKGl0ZW0sIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVtLmVkaXRDb250ZXh0ICYmIHRoaXMuZWRpdFNlcnZpY2UuaXNFZGl0aW5nQ29sdW1uKGNvbHVtbikpO1xuICAgIH1cbiAgICBpc0VkaXRpbmdSb3coaXRlbSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVtLmVkaXRDb250ZXh0KSB8fCBpdGVtLmlzTmV3O1xuICAgIH1cbiAgICBnZXQgY29sdW1uc0NvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSW5mb1NlcnZpY2UuY29sdW1uc0NvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IGhhc0Zvb3RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc0NvbnRhaW5lci5oYXNGb290ZXI7XG4gICAgfVxuICAgIGdldCBjb2x1bW5zU3BhbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnNTcGFuKHRoaXMuY29sdW1ucyk7XG4gICAgfVxuICAgIGdldCBhbGxDb2x1bW5zU3BhbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnNTcGFuKHRoaXMuYWxsQ29sdW1ucyB8fCB0aGlzLmNvbHVtbnMpO1xuICAgIH1cbiAgICBnZXQgY29sU3BhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1NwYW47XG4gICAgfVxuICAgIGdldCBmb290ZXJDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xvY2tlZCA/IHRoaXMuY29sdW1uc0NvbnRhaW5lci5sb2NrZWRDb2x1bW5zVG9SZW5kZXIgOiB0aGlzLmNvbHVtbnNDb250YWluZXIubm9uTG9ja2VkQ29sdW1uc1RvUmVuZGVyO1xuICAgIH1cbiAgICBsb2dpY2FsUm93SW5kZXgocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDEgKyByb3dJbmRleCArIHRoaXMuaGVhZGVyT2Zmc2V0O1xuICAgIH1cbiAgICBpc0NlbGxTZWxlY3RlZChkYXRhSXRlbSwgY29sdW1uLCBjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uaXNDZWxsU2VsZWN0ZWQoZGF0YUl0ZW0sIGNvbHVtbiwgY29sdW1uSW5kZXgpO1xuICAgIH1cbiAgICB0YXJnZXRBcmdzKHRhcmdldCwgc2tpcEZvY3VzYWJsZSkge1xuICAgICAgICBjb25zdCB7IGNlbGwsIHJvdyB9ID0gdGhpcy50YXJnZXRFbGVtZW50cyh0YXJnZXQpO1xuICAgICAgICBpZiAoY2VsbCAmJiAoIXNraXBGb2N1c2FibGUgfHwgdGFyZ2V0ID09PSBjZWxsIHx8ICFpc0ZvY3VzYWJsZVdpdGhUYWJLZXkodGFyZ2V0LCBmYWxzZSkpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbHVtbkNlbGxJbmRleChjZWxsLCByb3cuY2VsbHMpO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zLnRvQXJyYXkoKVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHRoaXMubG9ja2VkQ29sdW1uc0NvdW50ICsgaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGl0ZW06IHRoaXMucm93SXRlbShyb3cpLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGlja0hhbmRsZXIoZXZlbnRBcmcpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRBcmcudGFyZ2V0O1xuICAgICAgICBjb25zdCB7IGNlbGwsIHJvdyB9ID0gdGhpcy50YXJnZXRFbGVtZW50cyh0YXJnZXQpO1xuICAgICAgICBpZiAoY2VsbCAmJiAhaGFzQ2xhc3NlcyhjZWxsLCBOT05fREFUQV9DRUxMX0NMQVNTRVMpICYmXG4gICAgICAgICAgICAhaGFzQ2xhc3Nlcyhyb3csIE5PTl9EQVRBX1JPV19DTEFTU0VTKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwYW5kQ2xpY2soZXZlbnRBcmcsIHJvdykgfHwgdGhpcy5jaGVja2JveENsaWNrKGNlbGwsIHJvdywgZXZlbnRBcmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5wcmV2ZW50Q2VsbENsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBmb2N1c2FibGUgPSB0YXJnZXQgIT09IGNlbGwgJiYgaXNGb2N1c2FibGVXaXRoVGFiS2V5KHRhcmdldCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFmb2N1c2FibGUgJiYgIW1hdGNoZXNOb2RlTmFtZSgnbGFiZWwnKSh0YXJnZXQpICYmICFoYXNDbGFzc2VzKHRhcmdldCwgSUdOT1JFX1RBUkdFVF9DTEFTU1NFUykgJiZcbiAgICAgICAgICAgICAgICAhY2xvc2VzdEluU2NvcGUodGFyZ2V0LCBtYXRjaGVzQ2xhc3NlcyhJR05PUkVfQ09OVEFJTkVSX0NMQVNTRVMpLCBjZWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmNlbGxDbGlja0FyZ3MoY2VsbCwgcm93LCBldmVudEFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QXJnLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmNlbGxNb3VzZWRvd24uZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmlzRWRpdGVkQ29sdW1uIHx8ICF0aGlzLmVkaXRTZXJ2aWNlLmNsb3NlQ2VsbChldmVudEFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEFyZy50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0Q2VsbENsaWNrKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0Q2VsbENsaWNrKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRDZWxsQ2xpY2soYXJncykge1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5jZWxsQ2xpY2suZW1pdChhcmdzKTtcbiAgICB9XG4gICAgY2VsbEtleWRvd25IYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3Mua2V5Q29kZSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICAgICAgdGhpcy5jbGlja0hhbmRsZXIoYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VsbENsaWNrQXJncyhjZWxsLCByb3csIGV2ZW50QXJnKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29sdW1uQ2VsbEluZGV4KGNlbGwsIHJvdy5jZWxscyk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuY29sdW1ucy50b0FycmF5KClbaW5kZXhdO1xuICAgICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHRoaXMubG9ja2VkQ29sdW1uc0NvdW50ICsgaW5kZXg7XG4gICAgICAgIGNvbnN0IHZpZXdJdGVtID0gdGhpcy5yb3dJdGVtKHJvdyk7XG4gICAgICAgIGlmICh2aWV3SXRlbS50eXBlICE9PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gZXZlbnRBcmcudHlwZSA9PT0gJ2tleWRvd24nID8gJ2NsaWNrJyA6IGV2ZW50QXJnLnR5cGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIHZpZXdJdGVtOiB2aWV3SXRlbSxcbiAgICAgICAgICAgIGRhdGFJdGVtOiB2aWV3SXRlbS5kYXRhLFxuICAgICAgICAgICAgaW5kZXg6IHZpZXdJdGVtLmluZGV4LFxuICAgICAgICAgICAgaXNFZGl0ZWRDb2x1bW46ICh2aWV3SXRlbS5lZGl0Q29udGV4dCAmJiB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGluZ0NvbHVtbihjb2x1bW4pKSxcbiAgICAgICAgICAgIGlzRWRpdGVkOiB2aWV3SXRlbS5pc05ldyB8fCAodmlld0l0ZW0uZWRpdENvbnRleHQgJiYgdGhpcy5lZGl0U2VydmljZS5pc0VkaXRlZENvbHVtbihjb2x1bW4pKSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50QXJnLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXRFbGVtZW50cyh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBsZXQgY2VsbCwgcm93LCBib2R5LCB0cmVlbGlzdEVsZW1lbnQ7XG4gICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjZWxsID0gY2xvc2VzdChjdXJyZW50VGFyZ2V0LCBtYXRjaGVzTm9kZU5hbWUoJ3RkJykpO1xuICAgICAgICAgICAgcm93ID0gY2xvc2VzdChjZWxsLCBtYXRjaGVzTm9kZU5hbWUoJ3RyJykpO1xuICAgICAgICAgICAgYm9keSA9IGNsb3Nlc3Qocm93LCBtYXRjaGVzTm9kZU5hbWUoJ3Rib2R5JykpO1xuICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IGJvZHk7XG4gICAgICAgICAgICB0cmVlbGlzdEVsZW1lbnQgPSBjbG9zZXN0SW5TY29wZShjdXJyZW50VGFyZ2V0LCBtYXRjaGVzQ2xhc3Nlcygnay10cmVlbGlzdCBrLWdyaWQnKSwgZWxlbWVudCk7XG4gICAgICAgIH0gd2hpbGUgKGJvZHkgJiYgYm9keSAhPT0gZWxlbWVudCAmJiAhdHJlZWxpc3RFbGVtZW50KTtcbiAgICAgICAgaWYgKGNlbGwgJiYgYm9keSA9PT0gZWxlbWVudCAmJiAhdHJlZWxpc3RFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgICAgICAgcm93XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZXhwYW5kQ2xpY2soZXZlbnRBcmcsIHJvdykge1xuICAgICAgICBpZiAoZXZlbnRBcmcudHlwZSA9PT0gJ2NsaWNrJyAmJiBoYXNDbGFzc2VzKGV2ZW50QXJnLnRhcmdldCwgJ2staS1leHBhbmQgay1pLWNvbGxhcHNlJykpIHtcbiAgICAgICAgICAgIGV2ZW50QXJnLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3SXRlbSA9IHRoaXMucm93SXRlbShyb3cpO1xuICAgICAgICAgICAgaWYgKHZpZXdJdGVtLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU3RhdGUudG9nZ2xlU3RhdGUodmlld0l0ZW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tib3hDbGljayhjZWxsLCByb3csIGV2ZW50QXJnKSB7XG4gICAgICAgIGlmIChldmVudEFyZy50eXBlID09PSAnY2xpY2snICYmIGhhc0NsYXNzZXMoY2VsbCwgJ2stY2hlY2tib3gtY2VsbCcpICYmXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbmFibGVkICYmIHRoaXMuc2VsZWN0aW9uLnJvd1NlbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuY2VsbENsaWNrQXJncyhjZWxsLCByb3csIGV2ZW50QXJnKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNoZWNrYm94Q2xpY2soYXJncyk7XG4gICAgICAgICAgICBpZiAoZXZlbnRBcmcudGFyZ2V0LmNoZWNrZWQgIT09IHRoaXMuc2VsZWN0aW9uLmlzUm93U2VsZWN0ZWQoYXJncy5kYXRhSXRlbSkpIHtcbiAgICAgICAgICAgICAgICBldmVudEFyZy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcm93SXRlbShyb3cpIHtcbiAgICAgICAgbGV0IHZpZXdJbmRleCA9IHJvdy5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJlZWxpc3Qtdmlldy1pbmRleCcpO1xuICAgICAgICB2aWV3SW5kZXggPSB2aWV3SW5kZXggPyBwYXJzZUludCh2aWV3SW5kZXgsIDEwKSA6IC0xO1xuICAgICAgICBjb25zdCB2aWV3SXRlbSA9IHRoaXMudmlldy5hdCh2aWV3SW5kZXgpO1xuICAgICAgICByZXR1cm4gdmlld0l0ZW07XG4gICAgfVxufVxuVGFibGVCb2R5Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdFRhYmxlQm9keV0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHRyICpuZ0lmPVwiIXZpZXcgfHwgdmlldy5kYXRhPy5sZW5ndGggPT09IDAgfHwgdmlldy5kYXRhID09IG51bGxcIiBjbGFzcz1cImstZ3JpZC1ub3JlY29yZHNcIj5cbiAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiY29sU3BhblwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIm5vUmVjb3Jkc1RlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vUmVjb3Jkc1RlbXBsYXRlLnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhbm9SZWNvcmRzVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICAgICAge3tub1JlY29yZHNUZXh0fX1cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3RkPlxuICAgIDwvdHI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiB2aWV3Py5kYXRhO2xldCByb3dJbmRleCA9IGluZGV4O3RyYWNrQnk6IHRyYWNrQnlXcmFwcGVyO1wiPlxuICAgICAgICA8dHIgKm5nSWY9XCJpdGVtLnR5cGUgPT09ICdkYXRhJ1wiXG4gICAgICAgICAgICBrZW5kb1RyZWVMaXN0TG9naWNhbFJvd1xuICAgICAgICAgICAgICAgIFtkYXRhUm93SW5kZXhdPVwiaXRlbS5pbmRleFwiXG4gICAgICAgICAgICAgICAgW2RhdGFJdGVtXT1cIml0ZW0uZGF0YVwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxSb3dJbmRleF09XCJsb2dpY2FsUm93SW5kZXgoaXRlbS5yb3dJbmRleClcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVSb3ddPVwibG9ja2VkQ29sdW1uc0NvdW50ID4gMFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxDZWxsc0NvdW50XT1cImNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbFNsYXZlQ2VsbHNDb3VudF09XCJ1bmxvY2tlZENvbHVtbnNDb3VudFwiXG4gICAgICAgICAgICAgICAgW2lzTmV3XT1cIml0ZW0uaXNOZXdcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwicm93Q2xhc3MoeyBkYXRhSXRlbTogaXRlbS5kYXRhLCBpbmRleDogaXRlbS5pbmRleCB9KVwiXG4gICAgICAgICAgICBbY2xhc3Muay1hbHRdPVwiaXNPZGQoaXRlbSlcIlxuICAgICAgICAgICAgW2NsYXNzLmstZ3JpZC1lZGl0LXJvd109XCJpc0VkaXRpbmdSb3coaXRlbSlcIlxuICAgICAgICAgICAgW2NsYXNzLmstZ3JpZC1hZGQtcm93XT1cIml0ZW0uaXNOZXdcIlxuICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXRyZWVsaXN0LXZpZXctaW5kZXhdPVwicm93SW5kZXhcIj5cblxuICAgICAgICAgICAgPHRkIGtlbmRvVHJlZUxpc3RDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5JbmRleF09XCJsb2NrZWRDb2x1bW5zQ291bnQgKyBjb2x1bW5JbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZpZXdJdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YUl0ZW1dPVwiaXRlbS5kYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgW2xldmVsXT1cIml0ZW0ubGV2ZWxcIlxuICAgICAgICAgICAgICAgICAgICBbaGFzQ2hpbGRyZW5dPVwiaXRlbS5oYXNDaGlsZHJlblwiXG4gICAgICAgICAgICAgICAgICAgIFtpc0V4cGFuZGVkXT1cIml0ZW0uZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICBbbG9hZGluZ109XCJpdGVtLmxvYWRpbmdcIlxuICAgICAgICAgICAgICAgICAgICBbaXNOZXddPVwiaXRlbS5pc05ld1wiXG4gICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2V4cGFuZEljb25zXT1cImV4cGFuZEljb25zXCJcbiAgICAgICAgICAgICAgICBrZW5kb1RyZWVMaXN0TG9naWNhbENlbGxcbiAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxSb3dJbmRleF09XCJsb2dpY2FsUm93SW5kZXgoaXRlbS5yb3dJbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbbG9naWNhbENvbEluZGV4XT1cImxvZ2ljYWxDb2xJbmRleChjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFSb3dJbmRleF09XCJpdGVtLmluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICBbY29sSW5kZXhdPVwiY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICBbY29sU3Bhbl09XCJjb2x1bW4uY29sc3BhblwiXG4gICAgICAgICAgICAgICAgICAgIFtleHBhbmRhYmxlXT1cImNvbHVtbi5leHBhbmRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cImdyaWRjZWxsXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJhcmlhRXhwYW5kZWQoaXRlbSwgY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiYXJpYVNlbGVjdGVkKGl0ZW0sIGNvbHVtbiwgbG9ja2VkQ29sdW1uc0NvdW50ICsgY29sdW1uSW5kZXgpXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjb2x1bW4uY3NzQ2xhc3NcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5rLWdyaWQtZWRpdC1jZWxsXT1cImlzRWRpdGluZ0NlbGwoaXRlbSwgY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmstc3RhdGUtc2VsZWN0ZWRdPVwiaXNDZWxsU2VsZWN0ZWQoaXRlbS5kYXRhLCBjb2x1bW4sIGxvY2tlZENvbHVtbnNDb3VudCArIGNvbHVtbkluZGV4KVwiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwiY29sdW1uLnN0eWxlXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5jb2xzcGFuXT1cImNvbHVtbi5jb2xzcGFuXCJcbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbHVtbnM7IGxldCBjb2x1bW5JbmRleCA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5Q29sdW1ucztcIj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgICAgIDx0ciAqbmdJZj1cIml0ZW0udHlwZSA9PT0gJ2Zvb3RlcicgJiYgaGFzRm9vdGVyXCJcbiAgICAgICAgICAgIGNsYXNzPVwiay1mb290ZXJcIlxuICAgICAgICAgICAgW2F0dHIuZGF0YS10cmVlbGlzdC12aWV3LWluZGV4XT1cInJvd0luZGV4XCJcbiAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RMb2dpY2FsUm93XG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxSb3dJbmRleF09XCJsb2dpY2FsUm93SW5kZXgoaXRlbS5yb3dJbmRleClcIlxuICAgICAgICAgICAgICAgIFtsb2dpY2FsU2xhdmVSb3ddPVwibG9ja2VkQ29sdW1uc0NvdW50ID4gMFwiXG4gICAgICAgICAgICAgICAgW2xvZ2ljYWxDZWxsc0NvdW50XT1cImNvbHVtbnMubGVuZ3RoXCJcbiAgICAgICAgICAgICAgICBbbG9naWNhbFNsYXZlQ2VsbHNDb3VudF09XCJ1bmxvY2tlZENvbHVtbnNDb3VudFwiPlxuXG4gICAgICAgICAgICA8dGQga2VuZG9UcmVlTGlzdExvZ2ljYWxDZWxsXG4gICAgICAgICAgICAgICAgICAgIFtsb2dpY2FsUm93SW5kZXhdPVwibG9naWNhbFJvd0luZGV4KGl0ZW0ucm93SW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2xvZ2ljYWxDb2xJbmRleF09XCJsb2dpY2FsQ29sSW5kZXgoY29sdW1uKVwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgW2NvbEluZGV4XT1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJjb2x1bW4uZm9vdGVyQ2xhc3NcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5mb290ZXJTdHlsZVwiXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBmb290ZXJDb2x1bW5zOyBsZXQgY29sdW1uSW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUNvbHVtbnM7XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImNvbHVtbi5leHBhbmRhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1ub25lXCIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbS5sZXZlbCB8IGxldmVsSXRlbXNcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4uZm9vdGVyVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW0uaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogY29sdW1uLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzOiBpdGVtLmFnZ3JlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGl0ZW0uYWdncmVnYXRlc1xuICAgICAgICAgICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UYWJsZUJvZHlDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFZGl0U2VydmljZSB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IERvbUV2ZW50c1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENvbHVtbkluZm9TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYXZpZ2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogRXhwYW5kU3RhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTZWxlY3Rpb25TZXJ2aWNlIH1cbl07XG5UYWJsZUJvZHlDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWxsQ29sdW1uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbm9SZWNvcmRzVGVtcGxhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpZXc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNraXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG5vUmVjb3Jkc1RleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzTG9ja2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2NrZWRDb2x1bW5zQ291bnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvdGFsQ29sdW1uc0NvdW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXJ0dWFsQ29sdW1uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXhwYW5kSWNvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRyYWNrQnk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJvd0NsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRTZXJ2aWNlLCBmb2N1c0dyb3VwKSB7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICAgICAgdGhpcy5mb2N1c0dyb3VwID0gZm9jdXNHcm91cDtcbiAgICAgICAgdGhpcy5pc05ldyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgICAgdGhpcy5jZWxsQ29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUNvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLnRlbXBsYXRlQ29udGV4dC5jZWxsQ29udGV4dCA9IHRoaXMuY2VsbENvbnRleHQ7XG4gICAgICAgIHRoaXMuY2VsbENvbnRleHQuZm9jdXNHcm91cCA9IGZvY3VzR3JvdXA7XG4gICAgfVxuICAgIGdldCBjb21tYW5kQ2VsbENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uaXNDb21tYW5kO1xuICAgIH1cbiAgICBnZXQgY2hlY2tib3hDZWxsQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5pc0NoZWNrYm94Q29sdW1uO1xuICAgIH1cbiAgICBnZXQgdGV4dE5vV3JhcENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uZXhwYW5kYWJsZTtcbiAgICB9XG4gICAgc2V0IHZpZXdJdGVtKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdJdGVtID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2VsbENvbnRleHQudmlld0l0ZW0gPSB0aGlzLnZpZXdJdGVtO1xuICAgIH1cbiAgICBnZXQgdmlld0l0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3SXRlbTtcbiAgICB9XG4gICAgZ2V0IGZvcm1Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0l0ZW0uaXNOZXcgPyB0aGlzLmVkaXRTZXJ2aWNlLm5ld0l0ZW1Hcm91cCA6XG4gICAgICAgICAgICB0aGlzLnZpZXdJdGVtLmVkaXRDb250ZXh0ID8gdGhpcy52aWV3SXRlbS5lZGl0Q29udGV4dC5ncm91cCA6IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0VkaXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMudmlld0l0ZW0uaXNOZXcgJiYgaXNDb2x1bW5FZGl0YWJsZSh0aGlzLmNvbHVtbiwgdGhpcy5lZGl0U2VydmljZS5uZXdJdGVtR3JvdXApKSB8fFxuICAgICAgICAgICAgKGlzQ29sdW1uRWRpdGFibGUodGhpcy5jb2x1bW4sIHRoaXMuZm9ybUdyb3VwKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudmlld0l0ZW0uZWRpdENvbnRleHQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmlzRWRpdGVkQ29sdW1uKHRoaXMuY29sdW1uKSkpO1xuICAgIH1cbiAgICBnZXQgdGVtcGxhdGVDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVDb250ZXh0O1xuICAgIH1cbiAgICBnZXQgZWRpdFRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dC4kaW1wbGljaXQgPSB0aGlzLmZvcm1Hcm91cDtcbiAgICAgICAgdGhpcy5fZWRpdFRlbXBsYXRlQ29udGV4dC5jZWxsQ29udGV4dCA9IHRoaXMuY2VsbENvbnRleHQ7XG4gICAgICAgIHRoaXMuX2VkaXRUZW1wbGF0ZUNvbnRleHQuY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHRoaXMuX2VkaXRUZW1wbGF0ZUNvbnRleHQuZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtO1xuICAgICAgICB0aGlzLl9lZGl0VGVtcGxhdGVDb250ZXh0LmZvcm1Hcm91cCA9IHRoaXMuZm9ybUdyb3VwO1xuICAgICAgICB0aGlzLl9lZGl0VGVtcGxhdGVDb250ZXh0LmlzTmV3ID0gdGhpcy5pc05ldztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRUZW1wbGF0ZUNvbnRleHQ7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIGlmIChpc0NvbHVtbkNvbXBvbmVudCh0aGlzLmNvbHVtbikgJiYgIWlzTnVsbE9yRW1wdHlTdHJpbmcodGhpcy5jb2x1bW4uZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RGb3JtYXQodGhpcy5jb2x1bW4uZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaXNCb3VuZENvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uLmZpZWxkICYmICF0aGlzLmNvbHVtbi50ZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgZ2V0IGlzU3BhbkNvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIGlzU3BhbkNvbHVtbih0aGlzLmNvbHVtbikgJiYgIXRoaXMuY29sdW1uLnRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICBnZXQgY2hpbGRDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gY29sdW1uc1RvUmVuZGVyKFt0aGlzLmNvbHVtbl0pO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi50ZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZW1wbGF0ZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl90ZW1wbGF0ZUNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQuJGltcGxpY2l0ID0gdGhpcy5kYXRhSXRlbTtcbiAgICAgICAgY29udGV4dC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgY29udGV4dC5jb2x1bW5JbmRleCA9IHRoaXMuY29sdW1uSW5kZXg7XG4gICAgICAgIGNvbnRleHQuZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtO1xuICAgICAgICBjb250ZXh0Lmhhc0NoaWxkcmVuID0gdGhpcy5oYXNDaGlsZHJlbjtcbiAgICAgICAgY29udGV4dC5pc0V4cGFuZGVkID0gdGhpcy5pc0V4cGFuZGVkO1xuICAgICAgICBjb250ZXh0LmlzTmV3ID0gdGhpcy5pc05ldztcbiAgICAgICAgY29udGV4dC5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgIGNvbnRleHQubG9hZGluZyA9IHRoaXMubG9hZGluZztcbiAgICAgICAgY29udGV4dC5yb3dJbmRleCA9IHRoaXMudmlld0l0ZW0ucm93SW5kZXg7XG4gICAgfVxufVxuQ2VsbENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RDZWxsXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwiaXNFZGl0ZWRcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cImZhbHNlXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImNvbHVtbi5leHBhbmRhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uIGstaS1ub25lXCIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgbGV2ZWwgfCBsZXZlbEl0ZW1zIDogaGFzQ2hpbGRyZW4gJiYgZXhwYW5kSWNvbnNcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiay1pY29uXCIgKm5nSWY9XCJoYXNDaGlsZHJlbiAmJiBleHBhbmRJY29uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdrLWktY29sbGFwc2UnOiBpc0V4cGFuZGVkICYmICFsb2FkaW5nLCAnay1pLWV4cGFuZCc6ICFpc0V4cGFuZGVkICYmICFsb2FkaW5nLCAnay1pLWxvYWRpbmcnOiBsb2FkaW5nIH1cIj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwidGVtcGxhdGVDb250ZXh0XCI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImlzU3BhbkNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBjaGlsZENvbHVtbiBvZiBjaGlsZENvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGRhdGFJdGVtIHwgdmFsdWVPZjogY2hpbGRDb2x1bW4uZmllbGQ6IGNoaWxkQ29sdW1uLmZvcm1hdH19XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpc0JvdW5kQ29sdW1uXCI+e3sgZGF0YUl0ZW0gfCB2YWx1ZU9mOiBjb2x1bW4uZmllbGQ6IGNvbHVtbi5mb3JtYXR9fTwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJjb2x1bW4uaXNDaGVja2JveENvbHVtbiAmJiAhaXNOZXdcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGtlbmRvVHJlZUxpc3RGb2N1c2FibGUgY2xhc3M9XCJrLWNoZWNrYm94XCIgW2NoZWNrZWRdPVwic2VsZWN0ZWRcIiAvPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cInRydWVcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY29sdW1uLmVkaXRUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5lZGl0VGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiZWRpdFRlbXBsYXRlQ29udGV4dFwiPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cImNvbHVtbi5lZGl0b3JcIiAqbmdJZj1cIiFjb2x1bW4uZWRpdFRlbXBsYXRlUmVmXCI+XG4gICAgICAgICAgICAgICAgICAgIDxrZW5kby1udW1lcmljdGV4dGJveFxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nU3dpdGNoQ2FzZT1cIidudW1lcmljJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZm9ybWF0XT1cImZvcm1hdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUdyb3VwLmdldChjb2x1bW4uZmllbGQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgPjwva2VuZG8tbnVtZXJpY3RleHRib3g+XG5cbiAgICAgICAgICAgICAgICAgICAgPGtlbmRvLWRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ1N3aXRjaENhc2U9XCInZGF0ZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1hdF09XCJmb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2Zvcm1Db250cm9sXT1cImZvcm1Hcm91cC5nZXQoY29sdW1uLmZpZWxkKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBrZW5kb1RyZWVMaXN0Rm9jdXNhYmxlXG4gICAgICAgICAgICAgICAgICAgID48L2tlbmRvLWRhdGVwaWNrZXI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdTd2l0Y2hDYXNlPVwiJ2Jvb2xlYW4nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUdyb3VwLmdldChjb2x1bW4uZmllbGQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlbmRvVHJlZUxpc3RGb2N1c2FibGVcbiAgICAgICAgICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ1N3aXRjaERlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiay10ZXh0Ym94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtmb3JtQ29udHJvbF09XCJmb3JtR3JvdXAuZ2V0KGNvbHVtbi5maWVsZClcIlxuICAgICAgICAgICAgICAgICAgICAgICAga2VuZG9UcmVlTGlzdEZvY3VzYWJsZVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVkaXRTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBGb2N1c0dyb3VwIH1cbl07XG5DZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbW1hbmRDZWxsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstY29tbWFuZC1jZWxsJyxdIH1dLFxuICAgIGNoZWNrYm94Q2VsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWNoZWNrYm94LWNlbGwnLF0gfV0sXG4gICAgdGV4dE5vV3JhcENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLXRleHQtbm93cmFwJyxdIH1dLFxuICAgIGNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sdW1uSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzTmV3OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsZXZlbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGFzQ2hpbGRyZW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzRXhwYW5kZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxvYWRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGV4cGFuZEljb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0YUl0ZW06IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpZXdJdGVtOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEJhc2VDb21tYW5kRGlyZWN0aXZlIGV4dGVuZHMgQnV0dG9uIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0U2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIHJlbmRlcmVyLCBudWxsLCBsb2NhbGl6YXRpb24sIG5nWm9uZSk7XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBlZGl0U2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsQ29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFZGl0ZWQgIT09IHRoaXMucmVhZFZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNFZGl0ZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuY2VsbENvbnRleHQgJiYgdGhpcy5lZGl0U2VydmljZS5pc0VkaXRlZCh0aGlzLmRhdGFJdGVtKSAmJiAhdGhpcy5lZGl0U2VydmljZS5pc0VkaXRpbmdDZWxsKCkpO1xuICAgIH1cbiAgICBnZXQgZGF0YUl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsQ29udGV4dC52aWV3SXRlbS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub25DbGljaygpO1xuICAgIH1cbn1cbkJhc2VDb21tYW5kRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEJhc2VDb21tYW5kXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQmFzZUNvbW1hbmREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFZGl0U2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcbkJhc2VDb21tYW5kRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZpc2libGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLmRpc3BsYXknLF0gfV0sXG4gICAgY2xpY2tIYW5kbGVyOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYGVkaXRgIGNvbW1hbmQgb2YgdGhlIFRyZWVMaXN0LiBZb3UgY2FuIGFwcGx5IHRoaXMgZGlyZWN0aXZlIHRvIGFueSBgYnV0dG9uYFxuICogZWxlbWVudCBpbnNpZGUgYSBbYENvbW1hbmRDb2x1bW5Db21wb25lbnRgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb21tYW5kY29sdW1uY29tcG9uZW50ICV9KS5cbiAqIFdoZW4gYW4gYXNzb2NpYXRlZCBidXR0b24gd2l0aCB0aGUgZGlyZWN0aXZlIGlzIGNsaWNrZWQsIHRoZVxuICogW2BlZGl0YF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfdHJlZWxpc3Rjb21wb25lbnQgJX0jdG9jLWVkaXQpIGV2ZW50XG4gKiBpcyB0cmlnZ2VyZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RyZWVsaXN0ICV9KSkuXG4gKlxuICogPiAqIFdoZW4gdGhlIHJvdyBpcyBpbiB0aGUgZWRpdCBtb2RlLCB0aGUgYnV0dG9uIHdpdGggYGtlbmRvVHJlZUxpc3RFZGl0Q29tbWFuZGAgaXMgYXV0b21hdGljYWxseSBoaWRkZW4uXG4gKiA+ICogVGhlIGRpcmVjdGl2ZSB0YWtlcyBhcyBpbnB1dCB0aGUgYGNlbGxDb250ZXh0YCBmcm9tIHRoZSBjZWxsIHRlbXBsYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0PlxuICogICA8a2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWNlbGxDb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgIDxidXR0b24gW2tlbmRvVHJlZUxpc3RFZGl0Q29tbWFuZF09XCJjZWxsQ29udGV4dFwiIGNsYXNzPVwiay1wcmltYXJ5XCI+RWRpdDwvYnV0dG9uPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwva2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4+XG4gKiA8L2tlbmRvLXRyZWVsaXN0PlxuICogYGBgXG4gKlxuICovXG5jbGFzcyBFZGl0Q29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJhc2VDb21tYW5kRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0U2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVkaXRTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpO1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZFZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5iZWdpbkVkaXQodGhpcy5kYXRhSXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5FZGl0Q29tbWFuZERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RFZGl0Q29tbWFuZF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkVkaXRDb21tYW5kRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWRpdFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5FZGl0Q29tbWFuZERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjZWxsQ29udGV4dDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9UcmVlTGlzdEVkaXRDb21tYW5kJyxdIH1dLFxuICAgIGNvbW1hbmRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1ncmlkLWVkaXQtY29tbWFuZCcsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgY2FuY2VsYCBjb21tYW5kIG9mIHRoZSBUcmVlTGlzdC4gWW91IGNhbiBhcHBseSB0aGlzIGRpcmVjdGl2ZSB0byBhbnkgYGJ1dHRvbmBcbiAqIGVsZW1lbnQgaW5zaWRlIGEgW2BDb21tYW5kQ29sdW1uQ29tcG9uZW50YF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29tbWFuZGNvbHVtbmNvbXBvbmVudCAlfSkuXG4gKiBXaGVuIGFuIGFzc29jaWF0ZWQgYnV0dG9uIHdpdGggdGhlIGRpcmVjdGl2ZSBpcyBjbGlja2VkLCB0aGVcbiAqIFtgY2FuY2VsYF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfdHJlZWxpc3Rjb21wb25lbnQgJX0jdG9jLWNhbmNlbCkgZXZlbnRcbiAqIGlzIHRyaWdnZXJlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdHJlZWxpc3QgJX0pKS5cbiAqXG4gKiA+ICogV2hlbiB0aGUgcm93IGlzIG5vdCBpbiB0aGUgZWRpdCBtb2RlLCB0aGUgYnV0dG9uIHdpdGggdGhlIGBrZW5kb1RyZWVMaXN0Q2FuY2VsQ29tbWFuZGAgaXMgYXV0b21hdGljYWxseSBoaWRkZW4uXG4gKiA+ICogVGhlIGRpcmVjdGl2ZSB0YWtlcyBhcyBpbnB1dCB0aGUgYGNlbGxDb250ZXh0YCBmcm9tIHRoZSBjZWxsIHRlbXBsYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0PlxuICogICA8a2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWNlbGxDb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgIDxidXR0b24gW2tlbmRvVHJlZUxpc3RDYW5jZWxDb21tYW5kXT1cImNlbGxDb250ZXh0XCI+Q2FuY2VsIGNoYW5nZXM8L2J1dHRvbj5cbiAqICAgICA8L25nLXRlbXBsYXRlPlxuICogICA8L2tlbmRvLXRyZWVsaXN0LWNvbW1hbmQtY29sdW1uPlxuICogPC9rZW5kby10cmVlbGlzdD5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gY29udHJvbCB0aGUgY29udGVudCBvZiB0aGUgYnV0dG9uIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgcm93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0PlxuICogICA8a2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWNlbGxDb250ZXh0PVwiY2VsbENvbnRleHRcIiBsZXQtaXNOZXc9XCJpc05ld1wiPlxuICogICAgICAgPGJ1dHRvbiBba2VuZG9UcmVlTGlzdENhbmNlbENvbW1hbmRdPVwiY2VsbENvbnRleHRcIj57e2lzTmV3ID8gJ0Rpc2NhcmQnIDogJ0NhbmNlbCBjaGFuZ2VzJ319PC9idXR0b24+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9rZW5kby10cmVlbGlzdC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJhc2VDb21tYW5kRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0U2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVkaXRTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpO1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZFZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdJdGVtID0gdGhpcy5jZWxsQ29udGV4dC52aWV3SXRlbTtcbiAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuZW5kRWRpdCh2aWV3SXRlbS5kYXRhLCB2aWV3SXRlbS5pc05ldyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5DYW5jZWxDb21tYW5kRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdENhbmNlbENvbW1hbmRdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DYW5jZWxDb21tYW5kRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWRpdFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5DYW5jZWxDb21tYW5kRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNlbGxDb250ZXh0OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb1RyZWVMaXN0Q2FuY2VsQ29tbWFuZCcsXSB9XSxcbiAgICBjb21tYW5kQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZ3JpZC1jYW5jZWwtY29tbWFuZCcsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgc2F2ZWAgY29tbWFuZCBvZiB0aGUgVHJlZUxpc3QuIFlvdSBjYW4gYXBwbHkgdGhpcyBkaXJlY3RpdmUgdG8gYW55IGBidXR0b25gXG4gKiBlbGVtZW50IGluc2lkZSBhIFtgQ29tbWFuZENvbHVtbkNvbXBvbmVudGBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NvbW1hbmRjb2x1bW5jb21wb25lbnQgJX0pLlxuICogV2hlbiBhbiBhc3NvY2lhdGVkIGJ1dHRvbiB3aXRoIHRoZSBkaXJlY3RpdmUgaXMgY2xpY2tlZCwgdGhlXG4gKiBbYHNhdmVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF90cmVlbGlzdGNvbXBvbmVudCAlfSN0b2Mtc2F2ZSkgZXZlbnRcbiAqIGlzIHRyaWdnZXJlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfdHJlZWxpc3QgJX0pKS5cbiAqXG4gKiA+ICogV2hlbiB0aGUgcm93IGlzIG5vdCBpbiB0aGUgZWRpdCBtb2RlLCB0aGUgYnV0dG9uIHdpdGggYGtlbmRvVHJlZUxpc3RTYXZlQ29tbWFuZGAgaXMgYXV0b21hdGljYWxseSBoaWRkZW4uXG4gKiA+ICogVGhlIGRpcmVjdGl2ZSB0YWtlcyBhcyBpbnB1dCB0aGUgYGNlbGxDb250ZXh0YCBmcm9tIHRoZSBjZWxsIHRlbXBsYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0PlxuICogICA8a2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWNlbGxDb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgIDxidXR0b24gW2tlbmRvVHJlZUxpc3RTYXZlQ29tbWFuZF09XCJjZWxsQ29udGV4dFwiPlNhdmUgY2hhbmdlczwvYnV0dG9uPlxuICogICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwva2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4+XG4gKiA8L2tlbmRvLXRyZWVsaXN0PlxuICogYGBgXG4gKlxuICogWW91IGNhbiBjb250cm9sIHRoZSBjb250ZW50IG9mIHRoZSBidXR0b24gYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSByb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tdHJlZWxpc3Q+XG4gKiAgIDxrZW5kby10cmVlbGlzdC1jb21tYW5kLWNvbHVtbiB0aXRsZT1cImNvbW1hbmRcIj5cbiAqICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdENlbGxUZW1wbGF0ZSBsZXQtY2VsbENvbnRleHQ9XCJjZWxsQ29udGV4dFwiIGxldC1pc05ldz1cImlzTmV3XCI+XG4gKiAgICAgICA8YnV0dG9uIFtrZW5kb1RyZWVMaXN0U2F2ZUNvbW1hbmRdPVwiY2VsbENvbnRleHRcIj57e2lzTmV3ID8gJ0FkZCcgOiAnVXBkYXRlJ319PC9idXR0b24+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9rZW5kby10cmVlbGlzdC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gKiBgYGBcbiAqL1xuY2xhc3MgU2F2ZUNvbW1hbmREaXJlY3RpdmUgZXh0ZW5kcyBCYXNlQ29tbWFuZERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWRpdFNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCBsb2NhbGl6YXRpb24sIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihlZGl0U2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKTtcbiAgICAgICAgdGhpcy5jb21tYW5kQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWRWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLnNhdmUodGhpcy5kYXRhSXRlbSwgdGhpcy5jZWxsQ29udGV4dC52aWV3SXRlbS5pc05ldyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5TYXZlQ29tbWFuZERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RTYXZlQ29tbWFuZF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNhdmVDb21tYW5kRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWRpdFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5TYXZlQ29tbWFuZERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjZWxsQ29udGV4dDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9UcmVlTGlzdFNhdmVDb21tYW5kJyxdIH1dLFxuICAgIGNvbW1hbmRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1ncmlkLXNhdmUtY29tbWFuZCcsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgcmVtb3ZlYCBjb21tYW5kIG9mIHRoZSBUcmVlTGlzdC4gWW91IGNhbiBhcHBseSB0aGlzIGRpcmVjdGl2ZSB0byBhbnkgYGJ1dHRvbmAgZWxlbWVudFxuICogaW5zaWRlIGEgW2BDb21tYW5kQ29sdW1uQ29tcG9uZW50YF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29tbWFuZGNvbHVtbmNvbXBvbmVudCAlfSkuXG4gKiBXaGVuIGFuIGFzc29jaWF0ZWQgYnV0dG9uIHdpdGggdGhlIGRpcmVjdGl2ZSBpcyBjbGlja2VkLCB0aGVcbiAqIFtgcmVtb3ZlYCBldmVudF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfdHJlZWxpc3Rjb21wb25lbnQgJX0jdG9jLXJlbW92ZSlcbiAqIGlzIHRyaWdnZXJlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfcmVhY3RpdmVfZm9ybXNfdHJlZWxpc3QgJX0pKS5cbiAqXG4gKiA+ICogV2hlbiB0aGUgcm93IGlzIGluIHRoZSBlZGl0IG1vZGUsIHRoZSBidXR0b24gd2l0aCB0aGUgYGtlbmRvVHJlZUxpc3RSZW1vdmVDb21tYW5kYCBpcyBhdXRvbWF0aWNhbGx5IGhpZGRlbi5cbiAqID4gKiBUaGUgZGlyZWN0aXZlIHRha2VzIGFzIGlucHV0IHRoZSBgY2VsbENvbnRleHRgIGZyb20gdGhlIGNlbGwgdGVtcGxhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tdHJlZWxpc3Q+XG4gKiAgIDxrZW5kby10cmVlbGlzdC1jb21tYW5kLWNvbHVtbiB0aXRsZT1cImNvbW1hbmRcIj5cbiAqICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdENlbGxUZW1wbGF0ZSBsZXQtY2VsbENvbnRleHQ9XCJjZWxsQ29udGV4dFwiPlxuICogICAgICAgPGJ1dHRvbiBba2VuZG9UcmVlTGlzdFJlbW92ZUNvbW1hbmRdPVwiY2VsbENvbnRleHRcIj5SZW1vdmUgcm93PC9idXR0b24+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9rZW5kby10cmVlbGlzdC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gKiBgYGBcbiAqL1xuY2xhc3MgUmVtb3ZlQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJhc2VDb21tYW5kRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0U2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVkaXRTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpO1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZFZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5yZW1vdmUodGhpcy5kYXRhSXRlbSwgKHRoaXMuY2VsbENvbnRleHQudmlld0l0ZW0ucGFyZW50IHx8IHt9KS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblJlbW92ZUNvbW1hbmREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0UmVtb3ZlQ29tbWFuZF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblJlbW92ZUNvbW1hbmREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFZGl0U2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblJlbW92ZUNvbW1hbmREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2VsbENvbnRleHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvVHJlZUxpc3RSZW1vdmVDb21tYW5kJyxdIH1dLFxuICAgIGNvbW1hbmRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1ncmlkLXJlbW92ZS1jb21tYW5kJyxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNvbW1hbmQgZm9yIGFkZGluZyBhIG5ldyBpdGVtIHRvIHRoZSBUcmVlTGlzdC4gWW91IGNhbiBhcHBseSB0aGlzIGRpcmVjdGl2ZSB0byBhbnlcbiAqIGBidXR0b25gIGVsZW1lbnQgaW5zaWRlIGEgW2BUb29sYmFyVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb21tYW5kY29sdW1uY29tcG9uZW50ICV9KSBvclxuICogaW5zaWRlIGEgW2BDb21tYW5kQ29sdW1uQ29tcG9uZW50YF0oeyUgc2x1ZyBhcGlfdHJlZWxpc3RfY29tbWFuZGNvbHVtbmNvbXBvbmVudCAlfSkuXG4gKlxuICogV2hlbiBhbiBhc3NvY2lhdGVkIGJ1dHRvbiB3aXRoIHRoZSBkaXJlY3RpdmUgaXMgY2xpY2tlZCwgdGhlXG4gKiBbYGFkZGBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X3RyZWVsaXN0Y29tcG9uZW50ICV9I3RvYy1hZGQpIGV2ZW50IGlzIHRyaWdnZXJlZFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX3RyZWVsaXN0ICV9KSkuXG4gKlxuICogPiBXaGVuIHRoZSByb3cgaXMgaW4gdGhlIGVkaXQgbW9kZSwgdGhlIGJ1dHRvbiB3aXRoIGBrZW5kb1RyZWVMaXN0QWRkQ29tbWFuZGAgaXMgYXV0b21hdGljYWxseSBoaWRkZW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tdHJlZWxpc3Q+XG4gKiAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdFRvb2xiYXJUZW1wbGF0ZT5cbiAqICAgICAgIDxidXR0b24ga2VuZG9UcmVlTGlzdEFkZENvbW1hbmQ+QWRkIG5ldzwvYnV0dG9uPlxuICogICAgPC9uZy10ZW1wbGF0ZT5cbiAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIGFkZGVkIHRvIHRoZSBjb21tYW5kIGNvbHVtbiwgdGhlIGRpcmVjdGl2ZSB0YWtlcyBhcyBpbnB1dCB0aGUgYGNlbGxDb250ZXh0YCBmcm9tIHRoZSBjZWxsIHRlbXBsYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0PlxuICogICA8a2VuZG8tdHJlZWxpc3QtY29tbWFuZC1jb2x1bW4gdGl0bGU9XCJjb21tYW5kXCI+XG4gKiAgICAgPG5nLXRlbXBsYXRlIGtlbmRvVHJlZUxpc3RDZWxsVGVtcGxhdGUgbGV0LWNlbGxDb250ZXh0PVwiY2VsbENvbnRleHRcIj5cbiAqICAgICAgIDxidXR0b24gW2tlbmRvVHJlZUxpc3RBZGRDb21tYW5kXT1cImNlbGxDb250ZXh0XCIgY2xhc3M9XCJrLXByaW1hcnlcIj5FZGl0PC9idXR0b24+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9rZW5kby10cmVlbGlzdC1jb21tYW5kLWNvbHVtbj5cbiAqIDwva2VuZG8tdHJlZWxpc3Q+XG4gKiBgYGBcbiAqL1xuY2xhc3MgQWRkQ29tbWFuZERpcmVjdGl2ZSBleHRlbmRzIEJhc2VDb21tYW5kRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0U2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVkaXRTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpO1xuICAgICAgICB0aGlzLmNvbW1hbmRDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZFZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmJlZ2luQWRkKHRoaXMuZGF0YUl0ZW0pO1xuICAgIH1cbn1cbkFkZENvbW1hbmREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0QWRkQ29tbWFuZF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkFkZENvbW1hbmREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFZGl0U2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcbkFkZENvbW1hbmREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2VsbENvbnRleHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvVHJlZUxpc3RBZGRDb21tYW5kJyxdIH1dLFxuICAgIGNvbW1hbmRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1ncmlkLWFkZC1jb21tYW5kJyxdIH1dXG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpwaXBlLW5hbWluZyAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExldmVsSXRlbXNQaXBlIHtcbiAgICB0cmFuc2Zvcm0obGV2ZWwsIGhhc0NoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGxldmVsICsgMSAtIChoYXNDaGlsZHJlbiA/IDEgOiAwKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY291bnQ7IGlkeCsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuTGV2ZWxJdGVtc1BpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IFBpcGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2xldmVsSXRlbXMnLFxuICAgICAgICAgICAgICAgIHB1cmU6IHRydWVcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuY29uc3QgZXhwb3J0ZWQkMSA9IFtcbiAgICBDb21tYW5kQ29sdW1uQ29tcG9uZW50LFxuICAgIENlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBFZGl0VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgVGFibGVCb2R5Q29tcG9uZW50LFxuICAgIE5vUmVjb3Jkc1RlbXBsYXRlRGlyZWN0aXZlLFxuICAgIENlbGxDb21wb25lbnQsXG4gICAgQmFzZUNvbW1hbmREaXJlY3RpdmUsXG4gICAgRWRpdENvbW1hbmREaXJlY3RpdmUsXG4gICAgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSxcbiAgICBTYXZlQ29tbWFuZERpcmVjdGl2ZSxcbiAgICBSZW1vdmVDb21tYW5kRGlyZWN0aXZlLFxuICAgIEFkZENvbW1hbmREaXJlY3RpdmUsXG4gICAgTGV2ZWxJdGVtc1BpcGUsXG4gICAgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmVcbl07XG5jb25zdCBpbXBvcnRlZE1vZHVsZXMkMyA9IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBTaGFyZWRNb2R1bGUsXG4gICAgTnVtZXJpY1RleHRCb3hNb2R1bGUsXG4gICAgRGF0ZVBpY2tlck1vZHVsZVxuXTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBCb2R5TW9kdWxlIHtcbiAgICBzdGF0aWMgZXhwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIENvbW1hbmRDb2x1bW5Db21wb25lbnQsXG4gICAgICAgICAgICBDZWxsVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIEVkaXRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIEVkaXRDb21tYW5kRGlyZWN0aXZlLFxuICAgICAgICAgICAgQ2FuY2VsQ29tbWFuZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIFNhdmVDb21tYW5kRGlyZWN0aXZlLFxuICAgICAgICAgICAgUmVtb3ZlQ29tbWFuZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIEFkZENvbW1hbmREaXJlY3RpdmUsXG4gICAgICAgICAgICBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZVxuICAgICAgICBdO1xuICAgIH1cbn1cbkJvZHlNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW2V4cG9ydGVkJDFdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZCQxXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbLi4uaW1wb3J0ZWRNb2R1bGVzJDNdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUb29sYmFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlbGlzdCkge1xuICAgICAgICB0aGlzLnRyZWVsaXN0ID0gdHJlZWxpc3Q7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgIH1cbiAgICBnZXQgY2xhc3NOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuICdrLWhlYWRlciBrLWdyaWQtdG9vbGJhcic7XG4gICAgfVxuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQucG9zaXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRvb2xiYXJUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZWxpc3QudG9vbGJhclRlbXBsYXRlID8gdGhpcy50cmVlbGlzdC50b29sYmFyVGVtcGxhdGUudGVtcGxhdGVSZWYgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuVG9vbGJhckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tdHJlZWxpc3QtdG9vbGJhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqbmdJZj1cInRvb2xiYXJUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0b29sYmFyVGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cImNvbnRleHRcIlxuICAgICAgICAgICAgPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVG9vbGJhckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRyZWVMaXN0Q29tcG9uZW50IH1cbl07XG5Ub29sYmFyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNsYXNzTmFtZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEVkaXRpbmdEaXJlY3RpdmVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlbGlzdCkge1xuICAgICAgICB0aGlzLnRyZWVsaXN0ID0gdHJlZWxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0IHNlcnZpY2UgdGhhdCB3aWxsIGhhbmRsZSB0aGUgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBzZXQgZWRpdFNlcnZpY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy51c2VyRWRpdFNlcnZpY2UgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGVkaXRTZXJ2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VyRWRpdFNlcnZpY2UgfHwgdGhpcy5kZWZhdWx0RWRpdFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gZGV0ZXJtaW5lIHRoZSB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqIGZvciBuZXcgaXRlbXMuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgYGl0ZW1gIGFuZCBpdHMgYHBhcmVudGAgYXMgcGFyYW1ldGVyc1xuICAgICAqIGFuZCBtdXN0IHJldHVybiBhbiBJRC5cbiAgICAgKi9cbiAgICBzZXQgbmV3SXRlbUlkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgbmV3SXRlbUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZENhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMudHJlZWxpc3QuYWRkLnN1YnNjcmliZSh0aGlzLmFkZEhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVlbGlzdC5yZW1vdmUuc3Vic2NyaWJlKHRoaXMucmVtb3ZlSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVlbGlzdC5jYW5jZWwuc3Vic2NyaWJlKHRoaXMuY2FuY2VsSGFuZGxlci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVlbGlzdC5zYXZlLnN1YnNjcmliZSh0aGlzLnNhdmVIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChtZXJnZSh0aGlzLnRyZWVsaXN0LmRhdGFTdGF0ZUNoYW5nZSwgdGhpcy50cmVlbGlzdC5wYWdlQ2hhbmdlKS5zdWJzY3JpYmUodGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRFZGl0U2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZWxpc3QubG9jYWxFZGl0U2VydmljZTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcih7IHBhcmVudCB9KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmlzTmV3ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmVlbGlzdC5leHBhbmQocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyZWVsaXN0LmFkZFJvdyh0aGlzLmNyZWF0ZU1vZGVsKHsgaXNOZXc6IHRydWUgfSksIHBhcmVudCk7XG4gICAgfVxuICAgIHNhdmVIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2F2ZU1vZGVsKGFyZ3MpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGFyZ3MuaXNOZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmNyZWF0ZShpdGVtLCBhcmdzLnBhcmVudCwgdGhpcy5pZENhbGxiYWNrID8gdGhpcy5pZENhbGxiYWNrKGl0ZW0sIGFyZ3MucGFyZW50KSA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS51cGRhdGUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmVlbGlzdC5jbG9zZVJvdyhhcmdzLmRhdGFJdGVtLCBhcmdzLmlzTmV3KTtcbiAgICB9XG4gICAgY2FuY2VsSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoYXJncyk7XG4gICAgfVxuICAgIHJlbW92ZUhhbmRsZXIoeyBkYXRhSXRlbSwgcGFyZW50IH0pIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlSXRlbSA9IChzaG91bGRSZW1vdmUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLnJlbW92ZShkYXRhSXRlbSwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlQ29uZmlybWF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlbW92ZUNvbmZpcm1hdGlvbihkYXRhSXRlbSwgcGFyZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVtb3ZlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKHJlbW92ZUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlSXRlbSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZUVkaXRvcihhcmdzID0geyBkYXRhSXRlbTogdGhpcy5kYXRhSXRlbSwgaXNOZXc6IHRoaXMuaXNOZXcgfSkge1xuICAgICAgICB0aGlzLnRyZWVsaXN0LmNsb3NlUm93KGFyZ3MuZGF0YUl0ZW0sIGFyZ3MuaXNOZXcpO1xuICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgfVxuICAgIGNsZWFuKCkge1xuICAgICAgICB0aGlzLmlzTmV3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICAgIG9uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICB9XG59XG5FZGl0aW5nRGlyZWN0aXZlQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBlZGl0U2VydmljZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbmV3SXRlbUlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByZW1vdmVDb25maXJtYXRpb246IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUm93RWRpdGluZ0RpcmVjdGl2ZUJhc2UgZXh0ZW5kcyBFZGl0aW5nRGlyZWN0aXZlQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIC5hZGQodGhpcy50cmVlbGlzdC5lZGl0LnN1YnNjcmliZSh0aGlzLmVkaXRIYW5kbGVyLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICAgICAgc3VwZXIuYWRkSGFuZGxlcihhcmdzKTtcbiAgICB9XG4gICAgZWRpdEhhbmRsZXIoYXJncykge1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKCk7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBhcmdzLmRhdGFJdGVtO1xuICAgICAgICB0aGlzLnRyZWVsaXN0LmVkaXRSb3coYXJncy5kYXRhSXRlbSwgdGhpcy5jcmVhdGVNb2RlbChhcmdzKSk7XG4gICAgfVxuICAgIHNhdmVIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIuc2F2ZUhhbmRsZXIoYXJncyk7XG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggZW5jYXBzdWxhdGVzIHRoZSBlZGl0aW5nIG9wZXJhdGlvbnMgb2YgdGhlIFRyZWVMaXN0IHdoZW4gdXNpbmdcbiAqIHRoZSBUZW1wbGF0ZS1Ecml2ZW4gQW5ndWxhciBGb3JtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfZGlyZWN0aXZlc190cmVlbGlzdCAlfSN0b2MtdGhlLXRlbXBsYXRlLWRpcmVjdGl2ZSkpLlxuICovXG5jbGFzcyBUZW1wbGF0ZUVkaXRpbmdEaXJlY3RpdmUgZXh0ZW5kcyBSb3dFZGl0aW5nRGlyZWN0aXZlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHJlZWxpc3QpIHtcbiAgICAgICAgc3VwZXIodHJlZWxpc3QpO1xuICAgICAgICB0aGlzLnRyZWVsaXN0ID0gdHJlZWxpc3Q7XG4gICAgfVxuICAgIGVkaXRIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIuZWRpdEhhbmRsZXIoYXJncyk7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBhcmdzLmRhdGFJdGVtO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuYXNzaWduVmFsdWVzKHRoaXMub3JpZ2luYWxWYWx1ZXMsIHRoaXMuZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBjbG9zZUVkaXRvcihhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmFzc2lnblZhbHVlcyh0aGlzLmRhdGFJdGVtLCB0aGlzLm9yaWdpbmFsVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5jbG9zZUVkaXRvcihhcmdzKTtcbiAgICB9XG4gICAgY3JlYXRlTW9kZWwoYXJncykge1xuICAgICAgICBpZiAoYXJncy5pc05ldykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTmV3SXRlbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhdmVNb2RlbChhcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmRhdGFJdGVtO1xuICAgIH1cbn1cblRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9UcmVlTGlzdFRlbXBsYXRlRWRpdGluZycsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdFRlbXBsYXRlRWRpdGluZ10nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRyZWVMaXN0Q29tcG9uZW50IH1cbl07XG5UZW1wbGF0ZUVkaXRpbmdEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY3JlYXRlTmV3SXRlbTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9UcmVlTGlzdFRlbXBsYXRlRWRpdGluZycsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1hcmtBbGxBc1RvdWNoZWQgPSAoY29udHJvbCkgPT4ge1xuICAgIGNvbnRyb2wubWFya0FzVG91Y2hlZCgpO1xuICAgIGlmIChjb250cm9sLmhhc093blByb3BlcnR5KCdjb250cm9scycpKSB7XG4gICAgICAgIGxldCBjb250cm9scyA9IGNvbnRyb2wuY29udHJvbHM7XG4gICAgICAgIGZvciAobGV0IGlubmVyIGluIGNvbnRyb2xzKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbHMuaGFzT3duUHJvcGVydHkoaW5uZXIpKSB7XG4gICAgICAgICAgICAgICAgbWFya0FsbEFzVG91Y2hlZChjb250cm9sc1tpbm5lcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpbnNlcnROZXdJdGVtID0gKG5ld0l0ZW0sIG9yaWdpbmFsRGF0YSwgdHJlZWxpc3QsIHBhcmVudCkgPT4ge1xuICAgIGxldCBpbnNlcnRBdCA9IDA7XG4gICAgaWYgKCFwYXJlbnQgJiYgdHJlZWxpc3Quc2tpcCkge1xuICAgICAgICBsZXQgZmlyc3RJdGVtID0gdHJlZWxpc3Qudmlldy5maW5kKGl0ZW0gPT4gaXRlbS50eXBlID09PSAnZGF0YScgJiYgIWl0ZW0uaXNOZXcpO1xuICAgICAgICBsZXQgZmlyc3RSb290SXRlbSA9IGZpcnN0SXRlbTtcbiAgICAgICAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGZpcnN0SXRlbS5sZXZlbCA+IDApIHtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdEl0ZW0ubGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RJdGVtID0gZmlyc3RJdGVtLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0Um9vdEl0ZW0gPSBmaXJzdEl0ZW07XG4gICAgICAgICAgICBmaXJzdE9mZnNldCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IG9yaWdpbmFsRGF0YS5pbmRleE9mKGZpcnN0Um9vdEl0ZW0uZGF0YSk7XG4gICAgICAgIGlmIChmaXJzdEluZGV4ID4gMCkge1xuICAgICAgICAgICAgaW5zZXJ0QXQgPSBmaXJzdEluZGV4ICsgZmlyc3RPZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3JpZ2luYWxEYXRhLnNwbGljZShpbnNlcnRBdCwgMCwgbmV3SXRlbSk7XG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgZWRpdGluZyBvcGVyYXRpb25zIG9mIHRoZSBUcmVlTGlzdCB3aGVuIHVzaW5nIHRoZVxuICogUmVhY3RpdmUgRm9ybXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlZGl0aW5nX2RpcmVjdGl2ZXNfdHJlZWxpc3QgJX0jdG9jLXRoZS1yZWFjdGl2ZS1kaXJlY3RpdmUpKS5cbiAqL1xuY2xhc3MgUmVhY3RpdmVFZGl0aW5nRGlyZWN0aXZlIGV4dGVuZHMgUm93RWRpdGluZ0RpcmVjdGl2ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyZWVsaXN0KSB7XG4gICAgICAgIHN1cGVyKHRyZWVsaXN0KTtcbiAgICAgICAgdGhpcy50cmVlbGlzdCA9IHRyZWVsaXN0O1xuICAgIH1cbiAgICBjcmVhdGVNb2RlbChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZvcm1Hcm91cChhcmdzKTtcbiAgICB9XG4gICAgc2F2ZU1vZGVsKHsgZGF0YUl0ZW0sIGZvcm1Hcm91cCwgaXNOZXcgfSkge1xuICAgICAgICBpZiAoIWZvcm1Hcm91cC5kaXJ0eSAmJiAhaXNOZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybUdyb3VwLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLmFzc2lnblZhbHVlcyhkYXRhSXRlbSwgZm9ybUdyb3VwLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrQWxsQXNUb3VjaGVkKGZvcm1Hcm91cCk7XG4gICAgfVxufVxuUmVhY3RpdmVFZGl0aW5nRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RyZWVMaXN0UmVhY3RpdmVFZGl0aW5nJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0UmVhY3RpdmVFZGl0aW5nXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUmVhY3RpdmVFZGl0aW5nRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVHJlZUxpc3RDb21wb25lbnQgfVxuXTtcblJlYWN0aXZlRWRpdGluZ0RpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjcmVhdGVGb3JtR3JvdXA6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2tlbmRvVHJlZUxpc3RSZWFjdGl2ZUVkaXRpbmcnLF0gfV1cbn07XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggZW5jYXBzdWxhdGVzIHRoZSBlZGl0aW5nIG9wZXJhdGlvbnMgb2YgdGhlIFRyZWVMaXN0IHdoZW4gdXNpbmcgdGhlIGluLWNlbGxcbiAqIGVkaXRpbmcgd2l0aCBSZWFjdGl2ZSBGb3JtcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGVkaXRpbmdfZGlyZWN0aXZlc190cmVlbGlzdCAlfSN0b2MtdGhlLWluY2VsbC1kaXJlY3RpdmUpKS5cbiAqL1xuY2xhc3MgSW5DZWxsRWRpdGluZ0RpcmVjdGl2ZSBleHRlbmRzIEVkaXRpbmdEaXJlY3RpdmVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlbGlzdCkge1xuICAgICAgICBzdXBlcih0cmVlbGlzdCk7XG4gICAgICAgIHRoaXMudHJlZWxpc3QgPSB0cmVlbGlzdDtcbiAgICB9XG4gICAgLy8gTmVlZCBtaXhpblxuICAgIGNyZWF0ZU1vZGVsKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRm9ybUdyb3VwKGFyZ3MpO1xuICAgIH1cbiAgICBzYXZlTW9kZWwoeyBkYXRhSXRlbSwgZm9ybUdyb3VwLCBpc05ldyB9KSB7XG4gICAgICAgIGlmICghZm9ybUdyb3VwLmRpcnR5ICYmICFpc05ldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtR3JvdXAudmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFNlcnZpY2UuYXNzaWduVmFsdWVzKGRhdGFJdGVtLCBmb3JtR3JvdXAudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtBbGxBc1RvdWNoZWQoZm9ybUdyb3VwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZWxpc3QuY2VsbENsaWNrLnN1YnNjcmliZSh0aGlzLmNlbGxDbGlja0hhbmRsZXIuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZWxpc3QuY2VsbENsb3NlLnN1YnNjcmliZSh0aGlzLmNlbGxDbG9zZUhhbmRsZXIuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlSGFuZGxlcihhcmdzKTtcbiAgICAgICAgdGhpcy50cmVlbGlzdC5jYW5jZWxDZWxsKCk7XG4gICAgfVxuICAgIGNlbGxDbGlja0hhbmRsZXIoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MuaXNFZGl0ZWQgJiYgYXJncy50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVsaXN0LmVkaXRDZWxsKGFyZ3MuZGF0YUl0ZW0sIGFyZ3MuY29sdW1uSW5kZXgsIHRoaXMuY3JlYXRlRm9ybUdyb3VwKGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjZWxsQ2xvc2VIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBmb3JtR3JvdXAsIGRhdGFJdGVtIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIWZvcm1Hcm91cC52YWxpZCkge1xuICAgICAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcm1Hcm91cC5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZS5hc3NpZ25WYWx1ZXMoZGF0YUl0ZW0sIGZvcm1Hcm91cC52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlLnVwZGF0ZShkYXRhSXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5JbkNlbGxFZGl0aW5nRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RyZWVMaXN0SW5DZWxsRWRpdGluZycsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEluQ2VsbEVkaXRpbmddJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5JbkNlbGxFZGl0aW5nRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVHJlZUxpc3RDb21wb25lbnQgfVxuXTtcbkluQ2VsbEVkaXRpbmdEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY3JlYXRlRm9ybUdyb3VwOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb1RyZWVMaXN0SW5DZWxsRWRpdGluZycsXSB9XVxufTtcblxuY2xhc3MgQmFzZUJpbmRpbmdEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRyZWVsaXN0KSB7XG4gICAgICAgIHRoaXMudHJlZWxpc3QgPSB0cmVlbGlzdDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMudHJlZWxpc3QuZmV0Y2hDaGlsZHJlbiA9IHRoaXMuZmV0Y2hDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyZWVsaXN0Lmhhc0NoaWxkcmVuID0gdGhpcy5oYXNDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBkZXNjcmlwdG9ycyBieSB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIHNvcnRlZC5cbiAgICAgKi9cbiAgICBzZXQgc29ydCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyZWVsaXN0LnNvcnQgPSB0aGlzLnN0YXRlLnNvcnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZGVzY3JpcHRvciBieSB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlbGlzdC5maWx0ZXIgPSB0aGlzLnN0YXRlLmZpbHRlciA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBkZXNjcmlwdG9yIGJ5IHdoaWNoIHRoZSBkYXRhIHdpbGwgYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgc2V0IGFnZ3JlZ2F0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hZ2dyZWdhdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFwcGx5U3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy50cmVlbGlzdC5kYXRhU3RhdGVDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlYmluZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChhbnlDaGFuZ2VkKFsnc29ydCcsICdmaWx0ZXInLCAnYWdncmVnYXRlJ10sIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlYmluZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblN0YXRlQ2hhbmdlKHN0YXRlJCQxKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZShzdGF0ZSQkMSk7XG4gICAgICAgIHRoaXMucmViaW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWJpbmQoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy50cmVlbGlzdC5kYXRhID0gdGhpcy5mZXRjaENoaWxkcmVuKCk7XG4gICAgfVxuICAgIGFwcGx5U3RhdGUoeyBzb3J0LCBmaWx0ZXI6IGZpbHRlciQkMSB9KSB7XG4gICAgICAgIHRoaXMuc29ydCA9IHNvcnQ7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyJCQxO1xuICAgIH1cbiAgICBmZXRjaENoaWxkcmVuKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKGl0ZW0pO1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLmZpbHRlckl0ZW1zKGNoaWxkcmVuKTtcbiAgICAgICAgbGV0IGFnZ3JlZ2F0ZXM7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnNvcnQpIHtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IHByb2Nlc3MoaXRlbXMsIHsgc29ydDogdGhpcy5zdGF0ZS5zb3J0IH0pLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRlcyA9IHRoaXMuY2FsY3VsYXRlQWdncmVnYXRlcyhpdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZGF0YTogaXRlbXMsXG4gICAgICAgICAgICBhZ2dyZWdhdGVzOiBhZ2dyZWdhdGVzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGFzQ2hpbGRyZW4oaXRlbSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuZmV0Y2hDaGlsZHJlbihpdGVtKS5kYXRhO1xuICAgICAgICByZXR1cm4gaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZmlsdGVySXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmlsdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIkJDEgPSB7XG4gICAgICAgICAgICAgICAgbG9naWM6ICdvcicsXG4gICAgICAgICAgICAgICAgZmlsdGVyczogW3RoaXMuc3RhdGUuZmlsdGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZmV0Y2hDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihjaGlsZHJlbi5kYXRhICYmIGNoaWxkcmVuLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcHJvY2VzcyhpdGVtcywge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyJCQxXG4gICAgICAgICAgICB9KS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgY2FsY3VsYXRlQWdncmVnYXRlcyhpdGVtcykge1xuICAgICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICAgIGNvbnN0IHRvQWRkID0gaXRlbXMuc2xpY2UoMCk7XG4gICAgICAgIHdoaWxlICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0b0FkZC5zaGlmdCgpO1xuICAgICAgICAgICAgbGlzdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2hpbGRyZW4oY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICB0b0FkZC5wdXNoLmFwcGx5KHRvQWRkLCB0aGlzLmZldGNoQ2hpbGRyZW4oY3VycmVudCkuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuIGFjY3VtdWxhdGUgZnJvbSBjaGlsZHJlbiBhZ2dyZWdhdGVzIGV4Y2VwdCBmb3IgYXZlcmFnZVxuICAgICAgICAvLyBmb3IgYXZlcmFnZSB3ZSBuZWVkIHRoZSBjaGlsZHJlbiBjb3VudCB0aGF0IGhhdmUgbnVtZXJpYyB2YWx1ZVxuICAgICAgICAvLyBtYXliZSBtb3ZlIHRoZSBhZ2dyZWdhdGVzIGltcGxlbWVudGF0aW9uIGhlcmUgPz8/XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGVCeShsaXN0LCB0aGlzLl9hZ2dyZWdhdGUpO1xuICAgIH1cbn1cbkJhc2VCaW5kaW5nRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNvcnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWdncmVnYXRlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEhpZXJhcmNoeUVkaXRTZXJ2aWNlIGV4dGVuZHMgTG9jYWxFZGl0U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ0RpcmVjdGl2ZSwgbG9jYWxEYXRhQ2hhbmdlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJpbmRpbmdEaXJlY3RpdmUgPSBiaW5kaW5nRGlyZWN0aXZlO1xuICAgICAgICB0aGlzLmxvY2FsRGF0YUNoYW5nZXMgPSBsb2NhbERhdGFDaGFuZ2VzO1xuICAgIH1cbiAgICBjcmVhdGUoaXRlbSwgcGFyZW50LCBfaWQpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbkdldHRlciwgY2hpbGRyZW5TZXR0ZXIsIG9yaWdpbmFsRGF0YSwgdHJlZWxpc3QgfSA9IHRoaXMuYmluZGluZ0RpcmVjdGl2ZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbkdldHRlcihwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4udW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuU2V0dGVyKHBhcmVudCwgW2l0ZW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydE5ld0l0ZW0oaXRlbSwgb3JpZ2luYWxEYXRhLCB0cmVlbGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kaW5nRGlyZWN0aXZlLnJlYmluZCgpO1xuICAgIH1cbiAgICB1cGRhdGUoX2l0ZW0pIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nRGlyZWN0aXZlLnJlYmluZCgpO1xuICAgIH1cbiAgICByZW1vdmUoaXRlbSwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGlkR2V0dGVyID0gdGhpcy5iaW5kaW5nRGlyZWN0aXZlLnRyZWVsaXN0LmlkR2V0dGVyOyAvLyByZWZhY3RvciBwcm92aWRlIGlkR2V0dGVyIHZpYSBjb250ZXh0IHNlcnZpY2VcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbkdldHRlciwgb3JpZ2luYWxEYXRhIH0gPSB0aGlzLmJpbmRpbmdEaXJlY3RpdmU7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50ID8gY2hpbGRyZW5HZXR0ZXIocGFyZW50KSA6IG9yaWdpbmFsRGF0YTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBpZEdldHRlcihpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2hpbGRyZW4uZmluZEluZGV4KGkgPT4gaWRHZXR0ZXIoaSkgPT09IGlkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdEaXJlY3RpdmUucmViaW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlSZW1vdmUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5UmVtb3ZlKGl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxEYXRhQ2hhbmdlcyAmJiBoYXNPYnNlcnZlcnModGhpcy5sb2NhbERhdGFDaGFuZ2VzLmNoYW5nZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkdldHRlciA9IHRoaXMuYmluZGluZ0RpcmVjdGl2ZS5jaGlsZHJlbkdldHRlcjtcbiAgICAgICAgICAgIGNvbnN0IHRvTm90aWZ5ID0gW2l0ZW1dO1xuICAgICAgICAgICAgd2hpbGUgKHRvTm90aWZ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0b05vdGlmeS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxEYXRhQ2hhbmdlcy5jaGFuZ2VzLmVtaXQoeyBhY3Rpb246ICdyZW1vdmUnLCBpdGVtOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW5HZXR0ZXIoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0b05vdGlmeS5wdXNoLmFwcGx5KHRvTm90aWZ5LCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGJpbmRzIHRoZSBUcmVlTGlzdCB0byBhIHRyZWUgb2Ygb2JqZWN0cy5cbiAqXG4gKiBUaGUgZGlyZWN0aXZlIGVuY2Fwc3VsYXRlcyB0aGUgaW4tbWVtb3J5IGhhbmRsaW5nIG9mIGRhdGEgb3BlcmF0aW9ucyBzdWNoIGFzXG4gKiBbc29ydGluZ10oeyUgc2x1ZyBzb3J0aW5nX3RyZWVsaXN0ICV9KSwgW2FnZ3JlZ2F0aW9uXSh7JSBzbHVnIHRyZWVsaXN0X3dpdGhfYWdncmVnYXRlcyAlfSlcbiAqIGFuZCBbZmlsdGVyaW5nXSh7JSBzbHVnIGZpbHRlcmluZ190cmVlbGlzdCAlfSkgKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlc10oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVlbGlzdCAlfSkpLlxuICovXG5jbGFzcyBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlIGV4dGVuZHMgQmFzZUJpbmRpbmdEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRyZWVsaXN0LCBsb2NhbERhdGFDaGFuZ2VzKSB7XG4gICAgICAgIHN1cGVyKHRyZWVsaXN0KTtcbiAgICAgICAgdGhpcy50cmVlbGlzdCA9IHRyZWVsaXN0O1xuICAgICAgICB0aGlzLmNoaWxkcmVuR2V0dGVyID0gZ2V0dGVyKCdpdGVtcycpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuU2V0dGVyID0gc2V0dGVyKCdpdGVtcycpO1xuICAgICAgICB0cmVlbGlzdC5sb2NhbEVkaXRTZXJ2aWNlID0gbmV3IEhpZXJhcmNoeUVkaXRTZXJ2aWNlKHRoaXMsIGxvY2FsRGF0YUNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHdoaWNoIGhvbGRzIHRoZSBjaGlsZCBkYXRhIGl0ZW1zIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIHNldCBjaGlsZHJlbkZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5HZXR0ZXIgPSBnZXR0ZXIodmFsdWUpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuU2V0dGVyID0gc2V0dGVyKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGRhdGEgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHBvcHVsYXRlIHRoZSBUcmVlTGlzdC5cbiAgICAgKi9cbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA/IHRoaXMuY2hpbGRyZW5HZXR0ZXIoaXRlbSkgfHwgW10gOiB0aGlzLm9yaWdpbmFsRGF0YTtcbiAgICB9XG4gICAgaXRlbUtleShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbn1cbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvVHJlZUxpc3RIaWVyYXJjaHlCaW5kaW5nJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0SGllcmFyY2h5QmluZGluZ10nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlTGlzdENvbXBvbmVudCB9LFxuICAgIHsgdHlwZTogTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgfVxuXTtcbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2hpbGRyZW5GaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0YTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcImtlbmRvVHJlZUxpc3RIaWVyYXJjaHlCaW5kaW5nXCIsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZsYXRFZGl0U2VydmljZSBleHRlbmRzIExvY2FsRWRpdFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJpbmRpbmdEaXJlY3RpdmUsIGxvY2FsRGF0YUNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iaW5kaW5nRGlyZWN0aXZlID0gYmluZGluZ0RpcmVjdGl2ZTtcbiAgICAgICAgdGhpcy5sb2NhbERhdGFDaGFuZ2VzID0gbG9jYWxEYXRhQ2hhbmdlcztcbiAgICB9XG4gICAgY3JlYXRlKGl0ZW0sIHBhcmVudCwgaWQpIHtcbiAgICAgICAgY29uc3QgeyBpZEdldHRlciwgaWRTZXR0ZXIsIHBhcmVudElkU2V0dGVyLCBvcmlnaW5hbERhdGEsIHRyZWVsaXN0IH0gPSB0aGlzLmJpbmRpbmdEaXJlY3RpdmU7XG4gICAgICAgIGlkU2V0dGVyKGl0ZW0sIGlzUHJlc2VudChpZCkgPyBpZCA6IGd1aWQoKSk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudElkU2V0dGVyKGl0ZW0sIGlkR2V0dGVyKHBhcmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydE5ld0l0ZW0oaXRlbSwgb3JpZ2luYWxEYXRhLCB0cmVlbGlzdCwgcGFyZW50KTtcbiAgICAgICAgdGhpcy5iaW5kaW5nRGlyZWN0aXZlLnJlYmluZCgpO1xuICAgIH1cbiAgICB1cGRhdGUoX2l0ZW0pIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nRGlyZWN0aXZlLnJlYmluZCgpO1xuICAgIH1cbiAgICByZW1vdmUoaXRlbSwgX3BhcmVudCkge1xuICAgICAgICBjb25zdCB7IGlkR2V0dGVyLCBwYXJlbnRJZEdldHRlciwgb3JpZ2luYWxEYXRhIH0gPSB0aGlzLmJpbmRpbmdEaXJlY3RpdmU7XG4gICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gW2l0ZW1dO1xuICAgICAgICB3aGlsZSAodG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdG9SZW1vdmUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gaWRHZXR0ZXIoY3VycmVudCk7XG4gICAgICAgICAgICBsZXQgaXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gb3JpZ2luYWxEYXRhW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEgJiYgaWRHZXR0ZXIoZGF0YUl0ZW0pID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBpZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZEdldHRlcihkYXRhSXRlbSkgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2goZGF0YUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGF0YS5zcGxpY2UoaXRlbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVJlbW92ZShjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpbmRpbmdEaXJlY3RpdmUucmViaW5kKCk7XG4gICAgfVxuICAgIG5vdGlmeVJlbW92ZShpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsRGF0YUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxEYXRhQ2hhbmdlcy5jaGFuZ2VzLmVtaXQoeyBhY3Rpb246ICdyZW1vdmUnLCBpdGVtIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBST09UX0lEID0gbnVsbDtcbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggYmluZHMgdGhlIFRyZWVMaXN0IHRvIGFuIGFycmF5IG9mIG9iamVjdHMgYnkgdXNpbmdcbiAqIGFuIElEIGFuZCBwYXJlbnRJRCBmaWVsZCB0byBkZWZpbmUgdGhlIGhpZXJhcmNoeS5cbiAqXG4gKiBUaGUgZGlyZWN0aXZlIGVuY2Fwc3VsYXRlcyB0aGUgaW4tbWVtb3J5IGhhbmRsaW5nIG9mIGRhdGEgb3BlcmF0aW9ucyBzdWNoIGFzXG4gKiBbc29ydGluZ10oeyUgc2x1ZyBzb3J0aW5nX3RyZWVsaXN0ICV9KSwgW2FnZ3JlZ2F0aW9uXSh7JSBzbHVnIHRyZWVsaXN0X3dpdGhfYWdncmVnYXRlcyAlfSlcbiAqIGFuZCBbZmlsdGVyaW5nXSh7JSBzbHVnIGZpbHRlcmluZ190cmVlbGlzdCAlfSkgKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlc10oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVlbGlzdCAlfSkpLlxuICovXG5jbGFzcyBGbGF0QmluZGluZ0RpcmVjdGl2ZSBleHRlbmRzIEJhc2VCaW5kaW5nRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlbGlzdCwgbG9jYWxEYXRhQ2hhbmdlcykge1xuICAgICAgICBzdXBlcih0cmVlbGlzdCk7XG4gICAgICAgIHRoaXMudHJlZWxpc3QgPSB0cmVlbGlzdDtcbiAgICAgICAgdGhpcy5pZEdldHRlciA9IGdldHRlcignaWQnKTtcbiAgICAgICAgdGhpcy5pZFNldHRlciA9IHNldHRlcignaWQnKTtcbiAgICAgICAgdGhpcy5wYXJlbnRJZEdldHRlciA9IGdldHRlcigncGFyZW50SWQnKTtcbiAgICAgICAgdGhpcy5wYXJlbnRJZFNldHRlciA9IHNldHRlcigncGFyZW50SWQnKTtcbiAgICAgICAgdHJlZWxpc3QubG9jYWxFZGl0U2VydmljZSA9IG5ldyBGbGF0RWRpdFNlcnZpY2UodGhpcywgbG9jYWxEYXRhQ2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgaWRlbnRpZmllciBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgICovXG4gICAgc2V0IHBhcmVudElkRmllbGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRJZEdldHRlciA9IGdldHRlcih2YWx1ZSk7XG4gICAgICAgIHRoaXMucGFyZW50SWRTZXR0ZXIgPSBzZXR0ZXIodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2hpY2ggY29udGFpbnMgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIHNldCBpZEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaWRHZXR0ZXIgPSBnZXR0ZXIodmFsdWUpO1xuICAgICAgICB0aGlzLmlkU2V0dGVyID0gc2V0dGVyKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGRhdGEgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHBvcHVsYXRlIHRoZSBUcmVlTGlzdC5cbiAgICAgKi9cbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oaXRlbSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuaXRlbUtleShpdGVtKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBpZCA9PT0gUk9PVF9JRCA/XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YS5maWx0ZXIobyA9PiAhaXNQcmVzZW50KHRoaXMucGFyZW50SWRHZXR0ZXIobykpKSA6XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YS5maWx0ZXIobyA9PiB0aGlzLnBhcmVudElkR2V0dGVyKG8pID09PSBpZCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaXRlbUtleShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtID8gdGhpcy5pZEdldHRlcihpdGVtKSA6IFJPT1RfSUQ7XG4gICAgfVxufVxuRmxhdEJpbmRpbmdEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvVHJlZUxpc3RGbGF0QmluZGluZycsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdEZsYXRCaW5kaW5nXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRmxhdEJpbmRpbmdEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlTGlzdENvbXBvbmVudCB9LFxuICAgIHsgdHlwZTogTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UgfVxuXTtcbkZsYXRCaW5kaW5nRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHBhcmVudElkRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlkRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbXCJrZW5kb1RyZWVMaXN0RmxhdEJpbmRpbmdcIixdIH1dXG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGNvbnRyb2xzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgaXRlbXNcbiAqL1xuY2xhc3MgRXhwYW5kYWJsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZWxpc3QpIHtcbiAgICAgICAgdGhpcy50cmVlbGlzdCA9IHRyZWVsaXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZXhwYW5kZWRLZXlzIGFyZSBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZEtleXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGl0ZW1zIHNob3VsZCBiZSBpbml0aWFsbHkgZXhwYW5kZWQuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxseUV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudHJlZWxpc3QuaXNFeHBhbmRlZCA9IHRoaXMuaXNFeHBhbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlID0gdGhpcy50b2dnbGVTdGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLnRyZWVsaXN0LmV4cGFuZFN0YXRlQ2hhbmdlLnN1YnNjcmliZSh0aGlzLnRvZ2dsZVN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZXhwYW5kZWQgaXRlbSBrZXlzLlxuICAgICAqL1xuICAgIHNldCBleHBhbmRlZEtleXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9leHBhbmRlZEtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuZGVkS2V5cyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy50cmVlbGlzdC51cGRhdGVWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGV4cGFuZGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdGF0ZS5rZXlzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBpdGVtIGtleSB0aGF0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSBleHBhbmRlZEtleXMgY29sbGVjdGlvbi5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgVHJlZUxpc3QgaWRGaWVsZC5cbiAgICAgKi9cbiAgICBzZXQgZXhwYW5kQnkoa2V5KSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbmRCeSA9IGdldHRlcihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXhwYW5kQnkgPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGtleUdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZEJ5IHx8IHRoaXMudHJlZWxpc3QuaWRHZXR0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlHZXR0ZXIoaXRlbSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhhcyhrZXkpID8gIXRoaXMuaW5pdGlhbGx5RXhwYW5kZWQgOiB0aGlzLmluaXRpYWxseUV4cGFuZGVkO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmV4cGFuZGVkS2V5cykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTZXQodGhpcy5fZXhwYW5kZWRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2VzLmluaXRpYWxseUV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0b2dnbGVTdGF0ZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5R2V0dGVyKGFyZ3MuZGF0YUl0ZW0pO1xuICAgICAgICBpZiAoQm9vbGVhbih0aGlzLmluaXRpYWxseUV4cGFuZGVkKSAhPT0gYXJncy5leHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZEtleXMpO1xuICAgIH1cbn1cbkV4cGFuZGFibGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvVHJlZUxpc3RFeHBhbmRhYmxlJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0RXhwYW5kYWJsZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkV4cGFuZGFibGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlTGlzdENvbXBvbmVudCB9XG5dO1xuRXhwYW5kYWJsZURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBleHBhbmRlZEtleXNDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBleHBhbmRlZEtleXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluaXRpYWxseUV4cGFuZGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHBhbmRCeTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSb3dTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMua2V5cy5jbGVhcigpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMuaGFzKGtleSk7XG4gICAgfVxuICAgIGFkZChrZXkpIHtcbiAgICAgICAgdGhpcy5rZXlzLmFkZChrZXkpO1xuICAgIH1cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIHRoaXMua2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMua2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGl0ZW1LZXk6IGtleSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZyb21BcnJheShhcnIpIHtcbiAgICAgICAgdGhpcy5rZXlzLmNsZWFyKCk7XG4gICAgICAgIGFyci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGQoaXRlbS5pdGVtS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENlbGxTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMua2V5cy5jbGVhcigpO1xuICAgIH1cbiAgICBoYXMoa2V5LCBjb2x1bW5LZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5oYXMoa2V5KSAmJiB0aGlzLmtleXMuZ2V0KGtleSkuaGFzKGNvbHVtbktleSk7XG4gICAgfVxuICAgIGFkZChrZXksIGNvbHVtbktleSkge1xuICAgICAgICBpZiAoIXRoaXMua2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNldChrZXksIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sdW1uU2V0ID0gdGhpcy5rZXlzLmdldChrZXkpO1xuICAgICAgICBjb2x1bW5TZXQuYWRkKGNvbHVtbktleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXksIGNvbHVtbktleSkge1xuICAgICAgICBpZiAodGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5TZXQgPSB0aGlzLmtleXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBjb2x1bW5TZXQuZGVsZXRlKGNvbHVtbktleSk7XG4gICAgICAgICAgICBpZiAoIWNvbHVtblNldC5zaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKGl0ZW1LZXksIGNvbHVtbktleSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBpdGVtS2V5LCBjb2x1bW5LZXkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmcm9tQXJyYXkoc3RhdGUkJDEpIHtcbiAgICAgICAgdGhpcy5rZXlzLmNsZWFyKCk7XG4gICAgICAgIHN0YXRlJCQxLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZChpdGVtLml0ZW1LZXksIGl0ZW0uY29sdW1uS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtS2V5cyhjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2V5cy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdLZXlzID0gW107XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGNvbHVtbktleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMuaGFzKGNvbHVtbktleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3S2V5cy5wdXNoKGNoYW5nZXMuZ2V0KGNvbHVtbktleSkpO1xuICAgICAgICAgICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0tleXMucHVzaChjb2x1bW5LZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNldChrZXksIG5ldyBTZXQobmV3S2V5cykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZXM7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5rZXlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGNvbHVtbktleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGtleSwgY29sdW1uS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY3JlYXRlU3RhdGUgPSAoc2V0dGluZ3MpID0+IHNldHRpbmdzLm1vZGUgPT09ICdjZWxsJyA/IG5ldyBDZWxsU2VsZWN0aW9uU3RhdGUoKSA6IG5ldyBSb3dTZWxlY3Rpb25TdGF0ZSgpO1xuXG5jb25zdCBkZWZhdWx0Q29sdW1uS2V5R2V0dGVyID0gKF9jb2x1bW4sIGNvbHVtbkluZGV4KSA9PiBjb2x1bW5JbmRleDtcbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggY29udHJvbHMgdGhlIHNlbGVjdGlvbiBzdGF0ZVxuICovXG5jbGFzcyBTZWxlY3RhYmxlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlbGlzdCkge1xuICAgICAgICB0aGlzLnRyZWVsaXN0ID0gdHJlZWxpc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3RlZCBpdGVtcyBhcmUgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBSb3dTZWxlY3Rpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLmNlbGxTZWxlY3RlZCA9IHRoaXMuY2VsbFNlbGVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucm93U2VsZWN0ZWQgPSB0aGlzLnJvd1NlbGVjdGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5JbmRpY2VzID0gdGhpcy51cGRhdGVDb2x1bW5JbmRpY2VzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJlZWxpc3Quc2VsZWN0YWJsZSA9IHRoaXMuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0YWJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgeyAvLyBhZGQgbWV0aG9kIHRvIG5vcm1hbGl6ZSB0aGlzXG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNyZWF0ZVN0YXRlKHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmVuYWJsZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVsaXN0LmlzU2VsZWN0ZWQgPSB0aGlzLl9zZXR0aW5ncy5tb2RlID09PSAnY2VsbCcgPyB0aGlzLmNlbGxTZWxlY3RlZCA6IHRoaXMucm93U2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZVNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmVlbGlzdC5pc1NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHNlbGVjdGVkIGl0ZW1zLlxuICAgICAqL1xuICAgIHNldCBzZWxlY3RlZEl0ZW1zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdGhpcy5sYXN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZyb21BcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVsaXN0LnVwZGF0ZVZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgbmFtZSBvciBhIGZ1bmN0aW9uIHRoYXQgc3BlY2lmeSB0aGUgZGF0YUl0ZW1zIGtleS5cbiAgICAgKi9cbiAgICBzZXQgaXRlbUtleSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlHZXR0ZXIgPSBnZXR0ZXIoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlHZXR0ZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgbmFtZSBvciBhIGZ1bmN0aW9uIHRoYXQgc3BlY2lmeSB0aGUgY29sdW1ucyBrZXkuXG4gICAgICovXG4gICAgc2V0IGNvbHVtbktleSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5LZXlHZXR0ZXIgPSBnZXR0ZXIoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbktleUdldHRlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBrZXlHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlHZXR0ZXIgfHwgdGhpcy50cmVlbGlzdC5pZEdldHRlcjtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbktleUdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbktleUdldHRlciB8fCBkZWZhdWx0Q29sdW1uS2V5R2V0dGVyO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2VsbFNlbGVjdGVkKGRhdGFJdGVtLCBjb2x1bW4sIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhhcyh0aGlzLmtleUdldHRlcihkYXRhSXRlbSksIHRoaXMuY29sdW1uS2V5R2V0dGVyKGNvbHVtbiwgY29sdW1uSW5kZXgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJvd1NlbGVjdGVkKGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhhcyh0aGlzLmtleUdldHRlcihkYXRhSXRlbSkpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DaGFuZ2UoeyBhY3Rpb24sIGl0ZW1zIH0pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3NlbGVjdCcgfHwgYWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYWRkKHRoaXMua2V5R2V0dGVyKGl0ZW0uZGF0YUl0ZW0pLCB0aGlzLmNvbHVtbktleUdldHRlcihpdGVtLmNvbHVtbiwgaXRlbS5jb2x1bW5JbmRleCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVtb3ZlKHRoaXMua2V5R2V0dGVyKGl0ZW0uZGF0YUl0ZW0pLCB0aGlzLmNvbHVtbktleUdldHRlcihpdGVtLmNvbHVtbiwgaXRlbS5jb2x1bW5JbmRleCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0U2VsZWN0ZWRJdGVtc0NoYW5nZSgpO1xuICAgIH1cbiAgICBlbWl0U2VsZWN0ZWRJdGVtc0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gdGhpcy5zdGF0ZS50b0FycmF5KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtc0NoYW5nZS5lbWl0KHRoaXMubGFzdENoYW5nZSk7XG4gICAgfVxuICAgIHN1YnNjcmliZVNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLnRyZWVsaXN0LnNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUodGhpcy5zZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubW9kZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZWxpc3QuY29sdW1uT3JkZXJDaGFuZ2Uuc3Vic2NyaWJlKHRoaXMudXBkYXRlQ29sdW1uSW5kaWNlcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnRyZWVsaXN0LmNvbHVtbkxvY2tlZENoYW5nZS5zdWJzY3JpYmUodGhpcy51cGRhdGVDb2x1bW5JbmRpY2VzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmVTZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDb2x1bW5JbmRpY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbHVtbktleUdldHRlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRpY2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmxlYWZDb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRpY2VzLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlbGlzdC5jb2x1bW5zQ29udGFpbmVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gdGhpcy5sZWFmQ29sdW1ucztcbiAgICAgICAgICAgIGN1cnJlbnRJbmRpY2VzLmZvckVhY2goKGNvbHVtbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uICE9PSBsZWFmQ29sdW1uc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5zZXQoaW5kZXgsIGxlYWZDb2x1bW5zLmluZGV4T2YoY29sdW1uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5zaXplICYmIHRoaXMuc3RhdGUudXBkYXRlQ29sdW1LZXlzKGNoYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0U2VsZWN0ZWRJdGVtc0NoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBsZWFmQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZWxpc3QubG9ja2VkTGVhZkNvbHVtbnMudG9BcnJheSgpLmNvbmNhdCh0aGlzLnRyZWVsaXN0Lm5vbkxvY2tlZExlYWZDb2x1bW5zLnRvQXJyYXkoKSk7XG4gICAgfVxufVxuU2VsZWN0YWJsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9UcmVlTGlzdFNlbGVjdGFibGUnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RTZWxlY3RhYmxlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuU2VsZWN0YWJsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRyZWVMaXN0Q29tcG9uZW50IH1cbl07XG5TZWxlY3RhYmxlRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNlbGVjdGFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkSXRlbXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkSXRlbXNDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBpdGVtS2V5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb2x1bW5LZXk6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBjcmVhdGVFbGVtZW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IG1hcnF1ZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG1hcnF1ZWUuY2xhc3NOYW1lID0gXCJrLW1hcnF1ZWVcIjtcbiAgICBjb25zdCBtYXJxdWVlQ29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG1hcnF1ZWVDb2xvci5jbGFzc05hbWUgPSBcImstbWFycXVlZS1jb2xvclwiO1xuICAgIG1hcnF1ZWUuYXBwZW5kQ2hpbGQobWFycXVlZUNvbG9yKTtcbiAgICByZXR1cm4gbWFycXVlZTtcbn07XG5jb25zdCBlbGVtZW50VW5kZXJDdXJzb3IkMSA9ICh7IGNsaWVudFgsIGNsaWVudFkgfSkgPT4gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBNYXJxdWVlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUsIHNlbGVjdGlvbiwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuY2VsbFNlbGVjdGVkID0gdGhpcy5jZWxsU2VsZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3RlZCA9IHRoaXMucm93U2VsZWN0ZWQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHVzZXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5lbmFibGVNYXJxdWVlID8gJ25vbmUnIDogbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlc2NcbiAgICAgICAgLy8gdHJpZ2dlciBjYW5jZWxcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gdGhpcy5kcmFnZ2FibGUua2VuZG9QcmVzcy5zdWJzY3JpYmUodGhpcy5zdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmRyYWdnYWJsZS5rZW5kb0RyYWcuc3Vic2NyaWJlKHRoaXMubW92ZU1hcnF1ZWUuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuZHJhZ2dhYmxlLmtlbmRvUmVsZWFzZS5zdWJzY3JpYmUodGhpcy5lbmRTZWxlY3Rpb24uYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICB9XG4gICAgY2VsbFNlbGVjdGVkKGRhdGFJdGVtLCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaGFzKGRhdGFJdGVtLCBjb2x1bW4pO1xuICAgIH1cbiAgICByb3dTZWxlY3RlZChkYXRhSXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXMoZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBzdGFydChhcmdzKSB7XG4gICAgICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy50YXJnZXRBcmdzKGFyZ3MsIHRydWUpO1xuICAgICAgICBpZiAoIXByZXNzVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzc1RhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXNzQXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIG1vdmVNYXJxdWVlKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlc3NUYXJnZXQgJiYgIXRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdE1hcnF1ZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXJxdWVlRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubWFycXVlZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBwcmVzcyA9IHRoaXMucHJlc3NBcmdzO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IE1hdGgubWluKGFyZ3MucGFnZVgsIHByZXNzLnBhZ2VYKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IE1hdGgubWluKGFyZ3MucGFnZVksIHByZXNzLnBhZ2VZKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5hYnMoYXJncy5wYWdlWCAtIHByZXNzLnBhZ2VYKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKGFyZ3MucGFnZVkgLSBwcmVzcy5wYWdlWSk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHRoaXMudGFyZ2V0QXJncyhhcmdzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmICghdGhpcy5jdXJyZW50VGFyZ2V0IHx8IHRoaXMuY3VycmVudFRhcmdldC5pdGVtLmRhdGEgIT09IGN1cnJlbnRUYXJnZXQuaXRlbS5kYXRhIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc2VsZWN0aW9uLnNldHRpbmdzLm1vZGUgPT09ICdjZWxsJyAmJiB0aGlzLmN1cnJlbnRUYXJnZXQuY29sdW1uICE9PSBjdXJyZW50VGFyZ2V0LmNvbHVtbikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmZyb21BcnJheSh0aGlzLnNlbGVjdGlvbi5yYW5nZUl0ZW1zKHRoaXMucHJlc3NUYXJnZXQsIGN1cnJlbnRUYXJnZXQpLm1hcChpdGVtID0+ICh7IGl0ZW1LZXk6IGl0ZW0uZGF0YUl0ZW0sIGNvbHVtbktleTogaXRlbS5jb2x1bW4gfSkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi51cGRhdGVTZWxlY3RlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5kU2VsZWN0aW9uKGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLnByZXNzQXJncy5wYWdlWCAhPT0gYXJncy5wYWdlWCB8fCB0aGlzLnByZXNzQXJncy5wYWdlWSAhPT0gYXJncy5wYWdlWSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy5wcmVzc1RhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VUYXJnZXQgPSB0aGlzLnRhcmdldEFyZ3MoYXJncyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgICAgICAvLyBpZiBvbmUgaXMgbWlzc2luZyBzZWxlY3QgZmlyc3QgLyBsYXN0IHZpZXdJdGVtIGRlcGVuZGluZyBvbiB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIHNlbGVjdCBjb2x1bW4gYmFzZWQgb24gY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGlmIChwcmVzc1RhcmdldCAmJiByZWxlYXNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0UmFuZ2UocHJlc3NUYXJnZXQsIHJlbGVhc2VUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWFycXVlZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5tYXJxdWVlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLm1hcnF1ZWVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnNldHRpbmdzLm1vZGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmlzQ2VsbFNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25TZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmlzUm93U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvblNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc3NUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXNzQXJncyA9IG51bGw7XG4gICAgfVxuICAgIHRhcmdldEFyZ3MoYXJncywgc2tpcEZvY3VzYWJsZSkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYXJncy5vcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMubWFycXVlZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubWFycXVlZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRhcmdldCA9IGVsZW1lbnRVbmRlckN1cnNvciQxKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5tYXJxdWVlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24udGFyZ2V0QXJncyh0YXJnZXQsIHNraXBGb2N1c2FibGUpO1xuICAgIH1cbiAgICBpbml0TWFycXVlZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNyZWF0ZVN0YXRlKHRoaXMuc2VsZWN0aW9uLnNldHRpbmdzKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnNldHRpbmdzLm1vZGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uLmlzQ2VsbFNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uaXNDZWxsU2VsZWN0ZWQgPSB0aGlzLmNlbGxTZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbi5pc1Jvd1NlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uaXNSb3dTZWxlY3RlZCA9IHRoaXMucm93U2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGNvbnN0IGRyYWcgPSB0aGlzLnNlbGVjdGlvbi5zZXR0aW5ncy5kcmFnO1xuICAgICAgICBpZiAoIShkcmFnICYmIGRyYWcuc25hcCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFycXVlZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubWFycXVlZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuTWFycXVlZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RTZWxlY3Rpb25NYXJxdWVlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWFycXVlZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERyYWdnYWJsZURpcmVjdGl2ZSB9LFxuICAgIHsgdHlwZTogU2VsZWN0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbk1hcnF1ZWVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdXNlclNlbGVjdGlvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUudXNlci1zZWxlY3QnLF0gfV1cbn07XG5cbmNvbnN0IGV4cG9ydGVkTW9kdWxlcyQyID0gW1xuICAgIFRyZWVMaXN0Q29tcG9uZW50LFxuICAgIFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBUb29sYmFyQ29tcG9uZW50LFxuICAgIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIFRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBSZWFjdGl2ZUVkaXRpbmdEaXJlY3RpdmUsXG4gICAgSW5DZWxsRWRpdGluZ0RpcmVjdGl2ZSxcbiAgICBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLFxuICAgIEZsYXRCaW5kaW5nRGlyZWN0aXZlLFxuICAgIEV4cGFuZGFibGVEaXJlY3RpdmUsXG4gICAgU2VsZWN0YWJsZURpcmVjdGl2ZSxcbiAgICAuLi5TaGFyZWRNb2R1bGUuZXhwb3J0cygpLFxuICAgIC4uLkJvZHlNb2R1bGUuZXhwb3J0cygpLFxuICAgIC4uLkhlYWRlck1vZHVsZS5leHBvcnRzKCksXG4gICAgLi4uUGFnZXJNb2R1bGUuZXhwb3J0cygpLFxuICAgIC4uLlJvd0ZpbHRlck1vZHVsZS5leHBvcnRzKCksXG4gICAgLi4uRmlsdGVyTWVudU1vZHVsZS5leHBvcnRzKCksXG4gICAgLi4uQ29sdW1uTWVudU1vZHVsZS5leHBvcnRzKClcbl07XG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgVHJlZUxpc3RDb21wb25lbnQsXG4gICAgTGlzdENvbXBvbmVudCxcbiAgICBUb29sYmFyQ29tcG9uZW50LFxuICAgIExvY2FsaXplZE1lc3NhZ2VzRGlyZWN0aXZlLFxuICAgIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LFxuICAgIFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBUZW1wbGF0ZUVkaXRpbmdEaXJlY3RpdmUsXG4gICAgUmVhY3RpdmVFZGl0aW5nRGlyZWN0aXZlLFxuICAgIEluQ2VsbEVkaXRpbmdEaXJlY3RpdmUsXG4gICAgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSxcbiAgICBGbGF0QmluZGluZ0RpcmVjdGl2ZSxcbiAgICBFeHBhbmRhYmxlRGlyZWN0aXZlLFxuICAgIFNlbGVjdGFibGVEaXJlY3RpdmUsXG4gICAgTWFycXVlZURpcmVjdGl2ZVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFRyZWVMaXN0IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBUcmVlTGlzdCBtb2R1bGVcbiAqIGltcG9ydCB7IFRyZWVMaXN0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZWxpc3QnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBUcmVlTGlzdE1vZHVsZV0sIC8vIGltcG9ydCBUcmVlTGlzdCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIFRyZWVMaXN0TW9kdWxlIHtcbn1cblRyZWVMaXN0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtkZWNsYXJhdGlvbnNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkMl0sXG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQm9keU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgSGVhZGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQYWdlck1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgUm93RmlsdGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBGaWx0ZXJNZW51TW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBSZXNpemVTZW5zb3JNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIENvbHVtbk1lbnVNb2R1bGVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmNsYXNzIFBERk1hcmdpbkNvbXBvbmVudCQxIGV4dGVuZHMgUERGTWFyZ2luQ29tcG9uZW50IHtcbn1cblBERk1hcmdpbkNvbXBvbmVudCQxLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1wZGYtbWFyZ2luJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBQREYgcGFnZSB0ZW1wbGF0ZSBvZiB0aGUgVHJlZUxpc3QgdGhhdCBoZWxwcyB0byBjdXN0b21pemUgdGhlIFBERiBwYWdlcy4gVG8gZGVmaW5lIGEgcGFnZSB0ZW1wbGF0ZSxcbiAqIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyB3aXRoIHRoZSBga2VuZG9UcmVlTGlzdFBERlRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGA8a2VuZG8tdHJlZWxpc3QtcGRmPmAuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNvbnRleHQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gKiAtIGBwYWdlTnVtYmVyYCZtZGFzaDtEZWZpbmVzIFBERiBwYWdlIG51bWJlci5cbiAqIC0gYHRvdGFsUGFnZXNgJm1kYXNoO0RlZmluZXMgdGhlIHRvdGFsIG51bWJlciBvZiBQREYgcGFnZXMuXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6NTUwICV9XG4gKiB7JSBlbWJlZF9maWxlIHBkZi1leHBvcnQvcGFnZS10ZW1wbGF0ZS1pbmxpbmUvYXBwLmNvbXBvbmVudC50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIHBkZi1leHBvcnQvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzaGFyZWQvZmlsZXN5c3RlbS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBwZGYtZXhwb3J0L21haW4udHMgJX1cbiAqIHslIGVuZG1ldGEgJX1cbiAqL1xuY2xhc3MgUERGVGVtcGxhdGVEaXJlY3RpdmUkMSBleHRlbmRzIFBERlRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICBzdXBlcih0ZW1wbGF0ZVJlZik7XG4gICAgfVxufVxuUERGVGVtcGxhdGVEaXJlY3RpdmUkMS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZUxpc3RQREZUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBERlRlbXBsYXRlRGlyZWN0aXZlJDEuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEhFQURFUl9DTEFTUyA9ICdrLWdyaWQtaGVhZGVyJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBGT09URVJfQ0xBU1MgPSAnay1ncmlkLWZvb3Rlcic7XG5jb25zdCBHUklEX0xJU1QgPSAnS0VORE8tVFJFRUxJU1QtTElTVCc7XG5jb25zdCBUQUJMRSA9ICdUQUJMRSc7XG5jb25zdCBtYXRjaGVzTGlzdCA9IG1hdGNoZXNOb2RlTmFtZShHUklEX0xJU1QpO1xuY29uc3QgbWF0Y2hlc1RhYmxlID0gbWF0Y2hlc05vZGVOYW1lKFRBQkxFKTtcbmNvbnN0IHN1ZmZpeCA9IChsb2NrZWQpID0+IGxvY2tlZCA/ICdsb2NrZWQnIDogJ3dyYXAnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFRyZWVMaXN0UXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5saXN0ID0gZmluZEVsZW1lbnQoZWxlbWVudCwgbWF0Y2hlc0xpc3QpO1xuICAgIH1cbiAgICBjb250ZW50KGxvY2tlZCkge1xuICAgICAgICByZXR1cm4gZmluZEVsZW1lbnQodGhpcy5saXN0LCBtYXRjaGVzQ2xhc3Nlcyhgay1ncmlkLWNvbnRlbnQke2xvY2tlZCA/ICctbG9ja2VkJyA6ICcnfWApKTtcbiAgICB9XG4gICAgaGVhZGVyKGxvY2tlZCkge1xuICAgICAgICB0aGlzLmhlYWRlcldyYXAgPSB0aGlzLmhlYWRlcldyYXAgfHwgZmluZEVsZW1lbnQodGhpcy5lbGVtZW50LCBtYXRjaGVzQ2xhc3NlcyhIRUFERVJfQ0xBU1MpKTtcbiAgICAgICAgcmV0dXJuIGZpbmRFbGVtZW50KHRoaXMuaGVhZGVyV3JhcCwgbWF0Y2hlc0NsYXNzZXMoYCR7SEVBREVSX0NMQVNTfS0ke3N1ZmZpeChsb2NrZWQpfWApKTtcbiAgICB9XG4gICAgZm9vdGVyKGxvY2tlZCkge1xuICAgICAgICB0aGlzLmZvb3RlcldyYXAgPSB0aGlzLmZvb3RlcldyYXAgfHwgZmluZEVsZW1lbnQodGhpcy5lbGVtZW50LCBtYXRjaGVzQ2xhc3NlcyhGT09URVJfQ0xBU1MpKTtcbiAgICAgICAgcmV0dXJuIGZpbmRFbGVtZW50KHRoaXMuZm9vdGVyV3JhcCwgbWF0Y2hlc0NsYXNzZXMoYCR7Rk9PVEVSX0NMQVNTfS0ke3N1ZmZpeChsb2NrZWQpfWApKTtcbiAgICB9XG4gICAgdGFibGUoKSB7XG4gICAgICAgIHJldHVybiBmaW5kRWxlbWVudCh0aGlzLmVsZW1lbnQsIG1hdGNoZXNUYWJsZSk7XG4gICAgfVxufVxuXG5jb25zdCBGSVJTVF9DTEFTUyA9ICdrLWZpcnN0JztcbmNvbnN0IElOUFVUUyA9IFsnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJywgJ29wdGlvbiddO1xuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGNsb25lTm9kZSA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgY2xvbmUgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgaWYgKG5vZGUuX2tlbmRvRXhwb3J0VmlzdWFsKSB7XG4gICAgICAgIGNsb25lLl9rZW5kb0V4cG9ydFZpc3VhbCA9IG5vZGUuX2tlbmRvRXhwb3J0VmlzdWFsO1xuICAgIH1cbiAgICBpZiAoSU5QVVRTLmluZGV4T2YoU3RyaW5nKG5vZGUubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgY2xvbmUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgIGNsb25lLnJlbW92ZUF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgIGNsb25lLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgY2xvbmUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcbiAgICAgICAgY2xvbmUuc2VsZWN0ZWQgPSBub2RlLnNlbGVjdGVkO1xuICAgIH1cbiAgICBsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCkpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuY29uc3QgYXBwZW5kTm9kZXMgPSAoZWxlbWVudCwgbm9kZXMpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNsb25lTm9kZShub2Rlc1tpZHhdKSk7XG4gICAgfVxufTtcbmNvbnN0IHdyYXBUYWJsZSA9ICh0YWJsZSkgPT4ge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3cmFwcGVyLmNsYXNzTmFtZSA9ICdrLXdpZGdldCBrLWdyaWQnO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGFibGUpO1xuICAgIHJldHVybiB3cmFwcGVyO1xufTtcbmNvbnN0IGNyZWF0ZVRhYmxlRWxlbWVudCA9IChzb3VyY2VzKSA9PiB7XG4gICAgY29uc3Qgc291cmNlQ291bnQgPSBzb3VyY2VzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50ID0gY2xvbmVOb2RlKHNvdXJjZXNbMF0pO1xuICAgIGNvbnN0IHJvd3NDb3VudCA9IGVsZW1lbnQucm93cy5sZW5ndGg7XG4gICAgaWYgKHNvdXJjZUNvdW50ID4gMSkge1xuICAgICAgICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCByb3dzQ291bnQ7IHJvd0lkeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2VJZHggPSAxOyBzb3VyY2VJZHggPCBzb3VyY2VDb3VudDsgc291cmNlSWR4KyspIHtcbiAgICAgICAgICAgICAgICBhcHBlbmROb2RlcyhlbGVtZW50LnJvd3Nbcm93SWR4XSwgc291cmNlc1tzb3VyY2VJZHhdLnJvd3Nbcm93SWR4XS5jZWxscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuY29uc3Qgc2V0Rmlyc3RDZWxsQ2xhc3MgPSAoaGVhZGVyLCBoZWFkZXJzKSA9PiB7XG4gICAgaWYgKGhlYWRlcnMubGVuZ3RoID4gMSAmJiBoZWFkZXIucm93cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDE7IGlkeCA8IGhlYWRlci5yb3dzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbEluZGV4ID0gaGVhZGVyc1swXS5yb3dzW2lkeF0uY2VsbHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGhlYWRlci5yb3dzW2lkeF0uY2VsbHNbZmlyc3RDZWxsSW5kZXhdO1xuICAgICAgICAgICAgaWYgKFN0cmluZyhjZWxsLmNsYXNzTmFtZSkuaW5kZXhPZihGSVJTVF9DTEFTUykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5jbGFzc05hbWUgKz0gYCAke0ZJUlNUX0NMQVNTfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgY3JlYXRlVGFibGUgPSAoY29sR3JvdXBzLCBoZWFkZXJzLCBib2RpZXMsIGZvb3RlcnMpID0+IHtcbiAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgY29uc3QgY29sR3JvdXAgPSBjb2xHcm91cHNbMF0uY2xvbmVOb2RlKHRydWUpO1xuICAgIGZvciAobGV0IGlkeCA9IDE7IGlkeCA8IGNvbEdyb3Vwcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGFwcGVuZE5vZGVzKGNvbEdyb3VwLCBjb2xHcm91cHNbaWR4XS5xdWVyeVNlbGVjdG9yQWxsKCdjb2wnKSk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGNyZWF0ZVRhYmxlRWxlbWVudChoZWFkZXJzKTtcbiAgICBjb25zdCBib2R5ID0gY3JlYXRlVGFibGVFbGVtZW50KGJvZGllcyk7XG4gICAgaGVhZGVyLmNsYXNzTmFtZSA9IEhFQURFUl9DTEFTUztcbiAgICBzZXRGaXJzdENlbGxDbGFzcyhoZWFkZXIsIGhlYWRlcnMpO1xuICAgIHRhYmxlLmFwcGVuZENoaWxkKGNvbEdyb3VwKTtcbiAgICB0YWJsZS5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgIHRhYmxlLmFwcGVuZENoaWxkKGJvZHkpO1xuICAgIGlmIChmb290ZXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmb290ZXIgPSBjcmVhdGVUYWJsZUVsZW1lbnQoZm9vdGVycyk7XG4gICAgICAgIGZvb3Rlci5jbGFzc05hbWUgPSBGT09URVJfQ0xBU1M7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKGZvb3Rlcik7XG4gICAgfVxuICAgIHJldHVybiB3cmFwVGFibGUodGFibGUpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHBvcnRFbGVtZW50ID0gKHdyYXBwZXIpID0+IHtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBUcmVlTGlzdFF1ZXJ5KHdyYXBwZXIpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBxdWVyeS5jb250ZW50KCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgICBjb25zdCBjb2xHcm91cHMgPSBbY29udGVudC5xdWVyeVNlbGVjdG9yKCdjb2xncm91cCcpXTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IFtxdWVyeS5oZWFkZXIoKS5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpXTtcbiAgICAgICAgY29uc3QgYm9kaWVzID0gW2NvbnRlbnQucXVlcnlTZWxlY3RvcigndGJvZHknKV07XG4gICAgICAgIGNvbnN0IGZvb3RlciA9IHF1ZXJ5LmZvb3RlcigpO1xuICAgICAgICBjb25zdCBmb290ZXJzID0gW107XG4gICAgICAgIGlmIChmb290ZXIpIHtcbiAgICAgICAgICAgIGZvb3RlcnMucHVzaChmb290ZXIucXVlcnlTZWxlY3RvcigndGZvb3QnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9ja2VkQ29udGVudCA9IHF1ZXJ5LmNvbnRlbnQodHJ1ZSk7XG4gICAgICAgIGlmIChsb2NrZWRDb250ZW50KSB7XG4gICAgICAgICAgICBjb2xHcm91cHMudW5zaGlmdChsb2NrZWRDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJykpO1xuICAgICAgICAgICAgaGVhZGVycy51bnNoaWZ0KHF1ZXJ5LmhlYWRlcih0cnVlKS5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpKTtcbiAgICAgICAgICAgIGJvZGllcy51bnNoaWZ0KGxvY2tlZENvbnRlbnQucXVlcnlTZWxlY3RvcigndGJvZHknKSk7XG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgZm9vdGVycy51bnNoaWZ0KHF1ZXJ5LmZvb3Rlcih0cnVlKS5xdWVyeVNlbGVjdG9yKCd0Zm9vdCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBjcmVhdGVUYWJsZShjb2xHcm91cHMsIGhlYWRlcnMsIGJvZGllcywgZm9vdGVycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB3cmFwVGFibGUocXVlcnkudGFibGUoKS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY3JlYXRlRWxlbWVudCQxID0gKHRhZ05hbWUsIGNsYXNzTmFtZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IGNyZWF0ZURpdiA9IChjbGFzc05hbWUpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCQxKCdkaXYnLCBjbGFzc05hbWUpO1xufTtcbi8qKlxuICogQ29uZmlndXJlcyB0aGUgc2V0dGluZ3MgZm9yIHRoZSBleHBvcnQgb2YgVHJlZUxpc3QgaW4gUERGIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGRmZXhwb3J0X3RyZWVsaXN0ICV9KSkuXG4gKi9cbmNsYXNzIFBERkNvbXBvbmVudCBleHRlbmRzIFBERkV4cG9ydENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocGRmU2VydmljZSwgc3VzcGVuZFNlcnZpY2UsIG5nWm9uZSwgZWxlbWVudCkge1xuICAgICAgICBzdXBlcihlbGVtZW50KTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlID0gcGRmU2VydmljZTtcbiAgICAgICAgdGhpcy5zdXNwZW5kU2VydmljZSA9IHN1c3BlbmRTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnNhdmVTdWJzY3JpcHRpb24gPSBwZGZTZXJ2aWNlLnNhdmVQREYuc3Vic2NyaWJlKHRoaXMuc2F2ZVBERi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5kcmF3U3Vic2NyaXB0aW9uID0gcGRmU2VydmljZS5kcmF3UERGLnN1YnNjcmliZSh0aGlzLmRyYXdQREYuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZHJhdyA9IHRoaXMuZHJhdy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zYXZlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZHJhd1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIHNhdmVQREYoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlUERGKGNvbXBvbmVudCwgdGhpcy5kcmF3KTtcbiAgICB9XG4gICAgZHJhd1BERih7IGNvbXBvbmVudCwgcHJvbWlzZSB9KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlUERGKGNvbXBvbmVudCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVFeHBvcnRHcm91cChwcm9taXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVBERihjb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VTaXplID0gY29tcG9uZW50LnBhZ2VTaXplO1xuICAgICAgICBjb25zdCB0b3RhbCA9IGNvbXBvbmVudC52aWV3LnRvdGFsVmlzaWJsZTtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuY29sdW1ucy50b0FycmF5KCk7XG4gICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbENvbHVtbnMgPSBjb21wb25lbnQuY29sdW1ucy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuc3VzcGVuZFNlcnZpY2Uuc2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlLmV4cG9ydGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5pdFByb2dyZXNzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQWxsUGFnZXMgPSB0aGlzLmFsbFBhZ2VzICYmIHBhZ2VTaXplIDwgdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlckFsbFBhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnNraXAgPSBjb21wb25lbnQuc2tpcDtcbiAgICAgICAgICAgIHRoaXMucGFnZVNpemUgPSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlUGFnZSgwLCB0b3RhbCwgY2FsbGJhY2ssIGNvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbHVtbnMubGVuZ3RoIHx8IGNvbXBvbmVudC52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VDb2x1bW5zKGNvbHVtbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFByb2dyZXNzKCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyRWxlbWVudCA9IHRoaXMuY29tcG9uZW50LndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzID0gY3JlYXRlRGl2KCdrLWxvYWRpbmctcGRmLW1hc2snKTtcbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGNsb25lTm9kZSh3cmFwcGVyRWxlbWVudCk7XG4gICAgICAgIHByb2dyZXNzLmFwcGVuZENoaWxkKG92ZXJsYXkpO1xuICAgICAgICBwcm9ncmVzcy5hcHBlbmRDaGlsZChjcmVhdGVEaXYoJ2stbG9hZGluZy1jb2xvcicpKTtcbiAgICAgICAgcHJvZ3Jlc3MuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCQxKCdzcGFuJywgJ2staS1sb2FkaW5nIGstaWNvbicpKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhlaWdodCA9IHdyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE92ZXJmbG93ID0gd3JhcHBlckVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHdyYXBwZXJFbGVtZW50Lm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICAgICAgdGhpcy5hcHBseVNjcm9sbChvdmVybGF5KTtcbiAgICB9XG4gICAgYXBwbHlTY3JvbGwob3ZlcmxheSkge1xuICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBUcmVlTGlzdFF1ZXJ5KHRoaXMuY29tcG9uZW50LndyYXBwZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBxdWVyeS5jb250ZW50KCk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5UXVlcnkgPSBuZXcgVHJlZUxpc3RRdWVyeShvdmVybGF5KTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlDb250ZW50ID0gb3ZlcmxheVF1ZXJ5LmNvbnRlbnQoKTtcbiAgICAgICAgICAgIG92ZXJsYXlDb250ZW50LnNjcm9sbFRvcCA9IGNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgb3ZlcmxheUNvbnRlbnQuc2Nyb2xsTGVmdCA9IGNvbnRlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIG92ZXJsYXlRdWVyeS5oZWFkZXIoKS5zY3JvbGxMZWZ0ID0gcXVlcnkuaGVhZGVyKCkuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGZvb3RlciA9IHF1ZXJ5LmZvb3RlcigpO1xuICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlRdWVyeS5mb290ZXIoKS5zY3JvbGxMZWZ0ID0gZm9vdGVyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NrZWRDb250ZW50ID0gcXVlcnkuY29udGVudCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChsb2NrZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheUxvY2tlZENvbnRlbnQgPSBvdmVybGF5UXVlcnkuY29udGVudCh0cnVlKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5TG9ja2VkQ29udGVudC5zY3JvbGxUb3AgPSBsb2NrZWRDb250ZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBvdmVybGF5TG9ja2VkQ29udGVudC5zY3JvbGxMZWZ0ID0gbG9ja2VkQ29udGVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRXhwb3J0RWxlbWVudCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zYXZlKGVsZW1lbnQsIHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlRXhwb3J0R3JvdXAocHJvbWlzZSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUV4cG9ydEVsZW1lbnQoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0RWxlbWVudChlbGVtZW50KS50aGVuKGdyb3VwID0+IHByb21pc2UucmVzb2x2ZShncm91cCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlRXhwb3J0RWxlbWVudChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciA9IGNyZWF0ZURpdignay1ncmlkLXBkZi1leHBvcnQtZWxlbWVudCcpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGV4cG9ydEVsZW1lbnQodGhpcy5jb21wb25lbnQud3JhcHBlci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhd09wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzdXBlci5kcmF3T3B0aW9ucygpO1xuICAgICAgICBvcHRpb25zLl9kZXN0cnVjdGl2ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBzdXBlci5jbGVhbnVwKCk7XG4gICAgICAgIHRoaXMucGRmU2VydmljZS5leHBvcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbENvbHVtbnMgPSB0aGlzLm9yaWdpbmFsQ29sdW1ucztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsQ29sdW1ucztcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlckFsbFBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VQYWdlKHRoaXMuc2tpcCwgdGhpcy5wYWdlU2l6ZSwgdGhpcy5yZXNldCwgb3JpZ2luYWxDb2x1bW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbmFsQ29sdW1ucyB8fCB0aGlzLmNvbXBvbmVudC52aXJ0dWFsQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlQ29sdW1ucyhvcmlnaW5hbENvbHVtbnMsIHRoaXMucmVzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFpbmVyKCk7XG4gICAgfVxuICAgIHJlbW92ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VQYWdlKHNraXAsIF90YWtlLCBjYWxsYmFjaywgY29sdW1ucykge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25QYWdlQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKGNvbHVtbnMgJiYgY29sdW1ucy5sZW5ndGgpIHx8IHRoaXMuY29tcG9uZW50LnZpcnR1YWxDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlQ29sdW1ucyhjb2x1bW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3RhYmxlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQubm90aWZ5UGFnZUNoYW5nZSgncGRmJywgeyBza2lwOiBza2lwLCB0YWtlOiBfdGFrZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC52aWV3LmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC52aWRhLmRhdGFMb2FkZWQucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUob25QYWdlQ2hhbmdlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvblBhZ2VDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGFuZ2VDb2x1bW5zKGNvbHVtbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uU3RhYmxlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY29sdW1ucy5yZXNldChjb2x1bW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN1c3BlbmRTZXJ2aWNlLnNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlckFsbFBhZ2VzID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyRWxlbWVudCA9IHRoaXMuY29tcG9uZW50LndyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5wcm9ncmVzcyk7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMub3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gdGhpcy5vcmlnaW5hbE92ZXJmbG93O1xuICAgICAgICBkZWxldGUgdGhpcy5wcm9ncmVzcztcbiAgICAgICAgZGVsZXRlIHRoaXMuY29tcG9uZW50O1xuICAgIH1cbiAgICBvblN0YWJsZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKS5waXBlKHRha2UoMSkpLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgfVxufVxuUERGQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVlbGlzdC1wZGYnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5QREZDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBQREZTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTdXNwZW5kU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG5QREZDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgYWxsUGFnZXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0NvbHVtbkJhc2UkMSxdIH1dLFxuICAgIG1hcmdpbkNvbXBvbmVudDogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbUERGTWFyZ2luQ29tcG9uZW50JDEsXSB9XSxcbiAgICBwYWdlVGVtcGxhdGVEaXJlY3RpdmU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW1BERlRlbXBsYXRlRGlyZWN0aXZlJDEsXSB9XVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBgZXhwb3J0LXRvLVBERmAgY29tbWFuZCBvZiB0aGUgVHJlZUxpc3QuXG4gKiBZb3UgY2FuIGFwcGx5IHRoaXMgZGlyZWN0aXZlIHRvIGFueSBgYnV0dG9uYCBlbGVtZW50IGluc2lkZSBhXG4gKiBbYFRvb2xiYXJUZW1wbGF0ZWBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X2NvbW1hbmRjb2x1bW5jb21wb25lbnQgJX0pLlxuICogV2hlbiB0aGUgdXNlciBjbGlja3MgYSBidXR0b24gdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGRpcmVjdGl2ZSwgdGhlXG4gKiBbYHBkZkV4cG9ydGBdKHslIHNsdWcgYXBpX3RyZWVsaXN0X3RyZWVsaXN0Y29tcG9uZW50ICV9I3RvYy1wZGZleHBvcnQpIGV2ZW50XG4gKiBmaXJlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBkZmV4cG9ydF90cmVlbGlzdCAlfSkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXRyZWVsaXN0PlxuICogICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlTGlzdFRvb2xiYXJUZW1wbGF0ZT5cbiAqICAgICAgICAgIDxidXR0b24ga2VuZG9UcmVlTGlzdFBERkNvbW1hbmQ+RXhwb3J0IHRvIFBERjwvYnV0dG9uPlxuICogICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8a2VuZG8tdHJlZWxpc3QtcGRmIGZpbGVOYW1lPVwiVHJlZUxpc3QucGRmXCI+XG4gKiAgICAgIDwva2VuZG8tdHJlZWxpc3QtcGRmPlxuICogPC9rZW5kby10cmVlbGlzdD5cbiAqIGBgYFxuICovXG5jbGFzcyBQREZDb21tYW5kRGlyZWN0aXZlIGV4dGVuZHMgQnV0dG9uIHtcbiAgICBjb25zdHJ1Y3RvcihwZGZTZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbG9jYWxpemF0aW9uLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgcmVuZGVyZXIsIG51bGwsIGxvY2FsaXphdGlvbiwgbmdab25lKTtcbiAgICAgICAgdGhpcy5wZGZTZXJ2aWNlID0gcGRmU2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnBkZlNlcnZpY2UuZXhwb3J0Q2xpY2suZW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBkZkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5QREZDb21tYW5kRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlTGlzdFBERkNvbW1hbmRdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5QREZDb21tYW5kRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUERGU2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcblBERkNvbW1hbmREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJywgWyckZXZlbnQnXSxdIH1dLFxuICAgIHBkZkNsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQtcGRmJyxdIH1dXG59O1xuXG5jb25zdCBleHBvcnRlZE1vZHVsZXMkMyA9IFtcbiAgICBQREZDb21wb25lbnQsXG4gICAgUERGTWFyZ2luQ29tcG9uZW50JDEsXG4gICAgUERGQ29tbWFuZERpcmVjdGl2ZSxcbiAgICBQREZUZW1wbGF0ZURpcmVjdGl2ZSQxXG5dO1xuY29uc3QgZGVjbGFyYXRpb25zJDEgPSBbXG4gICAgUERGQ29tcG9uZW50LFxuICAgIFBERk1hcmdpbkNvbXBvbmVudCQxLFxuICAgIFBERkNvbW1hbmREaXJlY3RpdmUsXG4gICAgUERGVGVtcGxhdGVEaXJlY3RpdmUkMVxuXTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFRyZWVMaXN0IFBERiBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqIC8vIEltcG9ydCB0aGUgVHJlZUxpc3QgYW5kIFBERiBtb2R1bGVzXG4gKiBpbXBvcnQgeyBUcmVlTGlzdE1vZHVsZSwgUERGTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZWxpc3QnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBUcmVlTGlzdE1vZHVsZSwgUERGTW9kdWxlXSwgLy8gaW1wb3J0IFRyZWVMaXN0IGFuZCBQREYgbW9kdWxlc1xuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgUERGTW9kdWxlIHtcbn1cblBERk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zJDFdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtleHBvcnRlZE1vZHVsZXMkM11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgZXhjZWxFeHBvcnRgIGV2ZW50LlxuICovXG5jbGFzcyBFeGNlbEV4cG9ydEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgY29uc3RydWN0b3Iod29ya2Jvb2spIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53b3JrYm9vayA9IHdvcmtib29rO1xuICAgIH1cbn1cblxuY29uc3QgaGllcmFyY2h5RGF0YSA9ICh2aWV3KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHZpZXcuZGF0YTtcbiAgICBjb25zdCBsZXZlbHMgPSB7fTtcbiAgICBjb25zdCBhZ2dyZWdhdGVzID0ge307XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGlkeCA9IDAsIGRhdGFJbmRleCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtpZHhdO1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbS5kYXRhKTtcbiAgICAgICAgICAgIGxldmVsc1tkYXRhSW5kZXhdID0gaXRlbS5sZXZlbDtcbiAgICAgICAgICAgIGRlcHRoID0gTWF0aC5tYXgoZGVwdGgsIGl0ZW0ubGV2ZWwpO1xuICAgICAgICAgICAgZGF0YUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGVzW2l0ZW0ucGFyZW50SW5kZXhdID0gaXRlbS5hZ2dyZWdhdGVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1JZDogKF9pdGVtLCBpZHgpID0+IGlkeCxcbiAgICAgICAgaXRlbUxldmVsOiAoX2l0ZW0sIGlkeCkgPT4gbGV2ZWxzW2lkeF0sXG4gICAgICAgIGRlcHRoOiBkZXB0aCArIDEsXG4gICAgICAgIGFnZ3JlZ2F0ZXMsXG4gICAgICAgIGRhdGE6IGl0ZW1zXG4gICAgfTtcbn07XG5jb25zdCB0b0V4Y2VsQ29sdW1uID0gKGNvbHVtbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBjb2x1bW4udGl0bGUsXG4gICAgICAgIGZpZWxkOiBjb2x1bW4uZmllbGQsXG4gICAgICAgIGxvY2tlZDogQm9vbGVhbihjb2x1bW4ubG9ja2VkKSxcbiAgICAgICAgd2lkdGg6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgbGV2ZWw6IGNvbHVtbi5sZXZlbCxcbiAgICAgICAgaGlkZGVuOiAhY29sdW1uLmlzVmlzaWJsZSxcbiAgICAgICAgZm9vdGVyVGVtcGxhdGU6IGNvbHVtbi5mb290ZXJUZW1wbGF0ZVxuICAgIH07XG59O1xuY29uc3QgdG9FeGNlbENvbHVtbnMgPSAoY29sdW1ucykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHNvcnRDb2x1bW5zKGNvbHVtbnMpXG4gICAgICAgIC5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbi5pc1NwYW5Db2x1bW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRvRXhjZWxDb2x1bW5zKGNvbHVtbi5jaGlsZHJlbkFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGNlbENvbHVtbiA9IHRvRXhjZWxDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uaXNDb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgICAgIGV4Y2VsQ29sdW1uLmNoaWxkcmVuID0gW2V4Y2VsQ29sdW1uXS5jb25jYXQodG9FeGNlbENvbHVtbnMoY29sdW1uLmNoaWxkcmVuQXJyYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4Y2VsQ29sdW1uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgY29tcG9uZW50Q29sdW1ucyA9IChjb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gdG9FeGNlbENvbHVtbnMoY29tcG9uZW50LmNvbHVtbnMudG9BcnJheSgpKTtcbiAgICByZXR1cm4gb3JkZXJCeShjb2x1bW5zLCBbeyBmaWVsZDogJ2xvY2tlZCcsIGRpcjogJ2Rlc2MnIH1dKTtcbn07XG4vKipcbiAqIENvbmZpZ3VyZXMgdGhlIHNldHRpbmdzIGZvciB0aGUgZXhwb3J0IG9mIFRyZWVMaXN0IGluIEV4Y2VsIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXhjZWxleHBvcnRfdHJlZWxpc3QgJX0pKS5cbiAqL1xuY2xhc3MgRXhjZWxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGV4Y2VsU2VydmljZSwgbG9jYWxpemF0aW9uLCB6b25lKSB7XG4gICAgICAgIHRoaXMuZXhjZWxTZXJ2aWNlID0gZXhjZWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgZmlsZSBuYW1lIG9mIHRoZSBleHBvcnRlZCBFeGNlbCBmaWxlLlxuICAgICAgICAgKiBAZGVmYXVsdCBcIkV4cG9ydC54bHN4XCJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnRXhwb3J0Lnhsc3gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGlmIGV4cG9ydCBzaG91bGQgaW5jbHVkZSBhbGwgcGFnZXNcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxQYWdlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGV4cG9ydCBzaG91bGQgZXhwYW5kIGFsbCBpdGVtcyBvciBzaG91bGQgdXNlIHRoZSBjdXJyZW50IFRyZWVMaXN0IHN0YXRlLlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZEFsbCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgICAgIHRoaXMuc2F2ZVN1YnNjcmlwdGlvbiA9IGV4Y2VsU2VydmljZS5zYXZlVG9FeGNlbC5zdWJzY3JpYmUodGhpcy5zYXZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zYXZlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhdmUoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZmV0Y2hEYXRhID8gdGhpcy5mZXRjaERhdGEoY29tcG9uZW50KSA6IG51bGw7XG4gICAgICAgIHRoaXMuZXhjZWxTZXJ2aWNlLnRvZ2dsZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIGlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTdWJzY3JpcHRpb24gPSByZXN1bHQuZGF0YS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydERhdGEoY29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hDaGlsZHJlbjogcmVzdWx0LmZldGNoQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbjogcmVzdWx0Lmhhc0NoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGxvYWRpbmcgdG8gYmUgc2hvd25cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvcnREYXRhKGNvbXBvbmVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydERhdGEoY29tcG9uZW50LCByZXN1bHQpIHtcbiAgICAgICAgY29uc3Qgdmlld09wdGlvbnMgPSByZXN1bHQgPyB7XG4gICAgICAgICAgICBmaWVsZHM6IHJlc3VsdCxcbiAgICAgICAgICAgIGV4cGFuZFN0YXRlOiB0aGlzLmV4cGFuZEFsbCA/IEVYUEFOREVEX1NUQVRFIDogY29tcG9uZW50LmV4cGFuZFN0YXRlU2VydmljZVxuICAgICAgICB9IDogdGhpcy5jb21wb25lbnRWaWV3T3B0aW9ucyhjb21wb25lbnQpO1xuICAgICAgICBWaWV3Q29sbGVjdGlvbi5sb2FkVmlldyh2aWV3T3B0aW9ucykuc3Vic2NyaWJlKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaWVyYXJjaHkgPSBoaWVyYXJjaHlEYXRhKHZpZXcpO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHdvcmtib29rT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLmxlbmd0aCA/IHRoaXMuY29sdW1ucyA6IGNvbXBvbmVudENvbHVtbnMoY29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICBkYXRhOiBoaWVyYXJjaHkuZGF0YSxcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzOiBoaWVyYXJjaHkuYWdncmVnYXRlcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJhYmxlOiB0aGlzLmZpbHRlcmFibGUsXG4gICAgICAgICAgICAgICAgY3JlYXRvcjogdGhpcy5jcmVhdG9yLFxuICAgICAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZSxcbiAgICAgICAgICAgICAgICBydGw6IHRoaXMubG9jYWxpemF0aW9uLnJ0bCxcbiAgICAgICAgICAgICAgICBjb2xsYXBzaWJsZTogdGhpcy5jb2xsYXBzaWJsZSxcbiAgICAgICAgICAgICAgICBoaWVyYXJjaHk6IGhpZXJhcmNoeSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IHRoaXMucGFkZGluZ0NlbGxPcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgRXhjZWxFeHBvcnRFdmVudChvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnMoY29tcG9uZW50LmV4Y2VsRXhwb3J0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZXhjZWxFeHBvcnQuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhjZWxTZXJ2aWNlLnRvZ2dsZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlRmlsZShvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVGaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgdG9EYXRhVVJMKG9wdGlvbnMpLnRoZW4oKGRhdGFVUkwpID0+IHtcbiAgICAgICAgICAgIHNhdmVBcyhkYXRhVVJMLCB0aGlzLmZpbGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VQcm94eTogdGhpcy5mb3JjZVByb3h5LFxuICAgICAgICAgICAgICAgIHByb3h5VVJMOiB0aGlzLnByb3h5VVJMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFZpZXdPcHRpb25zKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRzOiBPYmplY3QuYXNzaWduKGNvbXBvbmVudC52aWV3RmllbGRBY2Nlc3NvcigpLCB7XG4gICAgICAgICAgICAgICAgcGFnZWFibGU6ICF0aGlzLmFsbFBhZ2VzLFxuICAgICAgICAgICAgICAgIHNraXA6IHRoaXMuYWxsUGFnZXMgPyAwIDogY29tcG9uZW50LnNraXBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXhwYW5kU3RhdGU6ICF0aGlzLmV4cGFuZEFsbCB8fCAoIXRoaXMuYWxsUGFnZXMgJiYgY29tcG9uZW50LnBhZ2VhYmxlKSA/IGNvbXBvbmVudC5leHBhbmRTdGF0ZVNlcnZpY2UgOiBFWFBBTkRFRF9TVEFURSxcbiAgICAgICAgICAgIGxvYWRlZDogbmV3IE1hcChjb21wb25lbnQudmlldy5sb2FkZWQpXG4gICAgICAgIH07XG4gICAgfVxufVxuRXhjZWxDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWVsaXN0LWV4Y2VsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRXhjZWxDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFeGNlbFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuRXhjZWxDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmlsZU5hbWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNyZWF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZvcmNlUHJveHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb3h5VVJMOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmZXRjaERhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbGxhcHNpYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbGxQYWdlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZXhwYW5kQWxsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0NvbHVtbkJhc2UsIHsgZGVzY2VuZGFudHM6IHRydWUgfSxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGBleHBvcnQtdG8tRXhjZWxgIGNvbW1hbmQgb2YgdGhlIFRyZWVMaXN0LiBZb3UgY2FuIGFwcGx5IHRoaXNcbiAqIGRpcmVjdGl2ZSB0byBhbnkgYGJ1dHRvbmAgZWxlbWVudCBpbnNpZGUgYVxuICogW2BUb29sYmFyVGVtcGxhdGVgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF9jb21tYW5kY29sdW1uY29tcG9uZW50ICV9KS5cbiAqIFdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgYnV0dG9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGlyZWN0aXZlLCB0aGVcbiAqIFtgZXhjZWxFeHBvcnRgXSh7JSBzbHVnIGFwaV90cmVlbGlzdF90cmVlbGlzdGNvbXBvbmVudCAlfSN0b2MtZXhjZWxleHBvcnQpIGV2ZW50XG4gKiBmaXJlcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV4Y2VsZXhwb3J0X3RyZWVsaXN0ICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tdHJlZWxpc3Q+XG4gKiAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb1RyZWVMaXN0VG9vbGJhclRlbXBsYXRlPlxuICogICAgICAgICAgPGJ1dHRvbiBrZW5kb1RyZWVMaXN0RXhjZWxDb21tYW5kPkV4cG9ydCB0byBQREY8L2J1dHRvbj5cbiAqICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPGtlbmRvLXRyZWVsaXN0LWV4Y2VsIGZpbGVOYW1lPVwiVHJlZUxpc3QueGxzeFwiPlxuICogICAgICA8L2tlbmRvLXRyZWVsaXN0LWV4Y2VsPlxuICogPC9rZW5kby10cmVlbGlzdD5cbiAqIGBgYFxuICovXG5jbGFzcyBFeGNlbENvbW1hbmREaXJlY3RpdmUgZXh0ZW5kcyBCdXR0b24ge1xuICAgIGNvbnN0cnVjdG9yKGV4Y2VsU2VydmljZSwgZWxlbWVudCwgcmVuZGVyZXIsIGxvY2FsaXphdGlvbiwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnQsIHJlbmRlcmVyLCBudWxsLCBsb2NhbGl6YXRpb24sIG5nWm9uZSk7XG4gICAgICAgIHRoaXMuZXhjZWxTZXJ2aWNlID0gZXhjZWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQ2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZXhjZWxTZXJ2aWNlLmV4cG9ydENsaWNrLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBleGNlbENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5FeGNlbENvbW1hbmREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb1RyZWVMaXN0RXhjZWxDb21tYW5kXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRXhjZWxDb21tYW5kRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRXhjZWxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IExvY2FsaXphdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuRXhjZWxDb21tYW5kRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsIFsnJGV2ZW50J10sXSB9XSxcbiAgICBleGNlbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWdyaWQtZXhjZWwnLF0gfV1cbn07XG5cbmNvbnN0IGRlY2xhcmF0aW9ucyQyID0gW0V4Y2VsQ29tcG9uZW50LCBFeGNlbENvbW1hbmREaXJlY3RpdmVdO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRXhjZWwgY29tcG9uZW50IG9mIHRoZSBUcmVlTGlzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBUcmVlTGlzdCBhbmQgRXhjZWwgbW9kdWxlc1xuICogaW1wb3J0IHsgVHJlZUxpc3RNb2R1bGUsIEV4Y2VsTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItdHJlZWxpc3QnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBUcmVlTGlzdE1vZHVsZSwgRXhjZWxNb2R1bGVdLCAvLyBpbXBvcnQgVHJlZUxpc3QgYW5kIEV4Y2VsIG1vZHVsZXNcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIEV4Y2VsTW9kdWxlIHtcbn1cbkV4Y2VsTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtkZWNsYXJhdGlvbnMkMl0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW2RlY2xhcmF0aW9ucyQyLCBFeGNlbEV4cG9ydE1vZHVsZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBCYXNlQmluZGluZ0RpcmVjdGl2ZSwgQ29sdW1uQ2hvb3NlckNvbXBvbmVudCwgQ29sdW1uTGlzdENvbXBvbmVudCwgQ29sdW1uTWVudUNob29zZXJDb21wb25lbnQsIENvbHVtbk1lbnVGaWx0ZXJDb21wb25lbnQsIENvbHVtbk1lbnVJdGVtQmFzZSwgQ29sdW1uTWVudUl0ZW1Db250ZW50VGVtcGxhdGVEaXJlY3RpdmUsIENvbHVtbk1lbnVJdGVtQ29tcG9uZW50LCBDb2x1bW5NZW51TG9ja0NvbXBvbmVudCwgQ29sdW1uTWVudVNvcnRDb21wb25lbnQsIENvbHVtbk1lbnVUZW1wbGF0ZURpcmVjdGl2ZSwgQ29sdW1uTWVudU1vZHVsZSwgQ29sdW1uTWVudVNlcnZpY2UsIENvbHVtbkhhbmRsZURpcmVjdGl2ZSwgQ29sdW1uUmVzaXppbmdTZXJ2aWNlLCBUYWJsZURpcmVjdGl2ZSwgQ29sdW1uSW5mb1NlcnZpY2UsIERvbUV2ZW50c1NlcnZpY2UsIElkU2VydmljZSwgT3B0aW9uQ2hhbmdlc1NlcnZpY2UsIFByZXZlbnRhYmxlRXZlbnQsIFNvcnRTZXJ2aWNlLCBDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLCBDb2x1bW5SZW9yZGVyU2VydmljZSwgRHJhZ0FuZERyb3BNb2R1bGUsIERyYWdBbmREcm9wU2VydmljZSwgRHJhZ0hpbnRTZXJ2aWNlLCBEcmFnZ2FibGVDb2x1bW5EaXJlY3RpdmUsIERyb3BDdWVTZXJ2aWNlLCBEcm9wVGFyZ2V0RGlyZWN0aXZlLCBFZGl0aW5nRGlyZWN0aXZlQmFzZSwgUm93RWRpdGluZ0RpcmVjdGl2ZUJhc2UsIEFkZENvbW1hbmREaXJlY3RpdmUsIEJhc2VDb21tYW5kRGlyZWN0aXZlLCBDYW5jZWxDb21tYW5kRGlyZWN0aXZlLCBFZGl0Q29tbWFuZERpcmVjdGl2ZSwgRWRpdFNlcnZpY2UgYXMgRWRpdFNlcnZpY2UkMSwgTG9jYWxEYXRhQ2hhbmdlc1NlcnZpY2UsIFJlbW92ZUNvbW1hbmREaXJlY3RpdmUsIFNhdmVDb21tYW5kRGlyZWN0aXZlLCBFeGNlbENvbW1hbmREaXJlY3RpdmUsIEV4cGFuZFN0YXRlU2VydmljZSwgQm9vbGVhbkZpbHRlckNvbXBvbmVudCwgQm9vbGVhbkZpbHRlckNlbGxDb21wb25lbnQsIEZpbHRlckNlbGxIb3N0RGlyZWN0aXZlLCBGaWx0ZXJDZWxsT3BlcmF0b3JzQ29tcG9uZW50LCBGaWx0ZXJDZWxsV3JhcHBlckNvbXBvbmVudCwgRGF0ZUZpbHRlckNvbXBvbmVudCwgRmlsdGVySG9zdERpcmVjdGl2ZSwgRmlsdGVySW5wdXRXcmFwcGVyQ29tcG9uZW50LCBGaWx0ZXJJbnB1dERpcmVjdGl2ZSwgRmlsdGVyUm93Q29tcG9uZW50LCBEYXRlRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LCBGaWx0ZXJNZW51Q29udGFpbmVyQ29tcG9uZW50LCBGaWx0ZXJNZW51SG9zdERpcmVjdGl2ZSwgRmlsdGVyTWVudUlucHV0V3JhcHBlckNvbXBvbmVudCwgRmlsdGVyTWVudUNvbXBvbmVudCwgTnVtZXJpY0ZpbHRlck1lbnVJbnB1dENvbXBvbmVudCwgU3RyaW5nRmlsdGVyTWVudUlucHV0Q29tcG9uZW50LCBOdW1lcmljRmlsdGVyQ29tcG9uZW50LCBGaWx0ZXJPcGVyYXRvckJhc2UsIFNoYXJlZEZpbHRlck1vZHVsZSwgU3RyaW5nRmlsdGVyQ29tcG9uZW50LCBCcm93c2VyU3VwcG9ydFNlcnZpY2UsIFJlc2l6ZVNlcnZpY2UsIFJlc3BvbnNpdmVTZXJ2aWNlLCBMb2NhbGl6ZWRNZXNzYWdlc0RpcmVjdGl2ZSwgTWVzc2FnZXMsIEZvY3VzR3JvdXAsIEZvY3VzUm9vdCwgTG9naWNhbENlbGxEaXJlY3RpdmUsIExvZ2ljYWxSb3dEaXJlY3RpdmUsIE5hdmlnYXRpb25TZXJ2aWNlLCBQYWdlckNvbnRleHRTZXJ2aWNlLCBQYWdlckVsZW1lbnRDb21wb25lbnQsIFBERkNvbW1hbmREaXJlY3RpdmUsIFBERlRlbXBsYXRlRGlyZWN0aXZlJDEgYXMgUERGVGVtcGxhdGVEaXJlY3RpdmUsIENlbGxDb21wb25lbnQsIEZpZWxkQWNjZXNzb3JQaXBlLCBMZXZlbEl0ZW1zUGlwZSwgREVGQVVMVF9TQ1JPTExFUl9GQUNUT1JZLCBTQ1JPTExFUl9GQUNUT1JZX1RPS0VOLCBTY3JvbGxSZXF1ZXN0U2VydmljZSwgU2Nyb2xsU3luY1NlcnZpY2UsIFNjcm9sbGVyU2VydmljZSwgTWFycXVlZURpcmVjdGl2ZSwgU2VsZWN0aW9uU2VydmljZSwgVHJlZUxpc3RNb2R1bGUsIFNoYXJlZE1vZHVsZSwgVHJlZUxpc3RDb21wb25lbnQsIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUsIEZsYXRCaW5kaW5nRGlyZWN0aXZlLCBDb2x1bW5CYXNlJDEgYXMgQ29sdW1uQmFzZSwgQ29sdW1uQ29tcG9uZW50LCBDaGVja2JveENvbHVtbkNvbXBvbmVudCwgQ29tbWFuZENvbHVtbkNvbXBvbmVudCwgU3BhbkNvbHVtbkNvbXBvbmVudCwgQ29sdW1uR3JvdXBDb21wb25lbnQsIFRvb2xiYXJDb21wb25lbnQsIFRvb2xiYXJUZW1wbGF0ZURpcmVjdGl2ZSwgQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIFBhZ2VyVGVtcGxhdGVEaXJlY3RpdmUsIFJlc2l6YWJsZUNvbnRhaW5lckRpcmVjdGl2ZSwgVGVtcGxhdGVDb250ZXh0RGlyZWN0aXZlLCBOb1JlY29yZHNUZW1wbGF0ZURpcmVjdGl2ZSwgRmlsdGVyU2VydmljZSwgRmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBGaWx0ZXJDZWxsQ29tcG9uZW50LCBTdHJpbmdGaWx0ZXJDZWxsQ29tcG9uZW50LCBEYXRlRmlsdGVyQ2VsbENvbXBvbmVudCwgQmFzZUZpbHRlckNlbGxDb21wb25lbnQsIEZpbHRlck1lbnVUZW1wbGF0ZURpcmVjdGl2ZSwgTnVtZXJpY0ZpbHRlck1lbnVDb21wb25lbnQsIFN0cmluZ0ZpbHRlck1lbnVDb21wb25lbnQsIERhdGVGaWx0ZXJNZW51Q29tcG9uZW50LCBCb29sZWFuRmlsdGVyTWVudUNvbXBvbmVudCwgQmVmb3JlRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgQmVmb3JlRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIEFmdGVyRXFGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgQWZ0ZXJGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgQ29udGFpbnNGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgRG9lc05vdENvbnRhaW5GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgRW5kc1dpdGhGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgRXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgSXNFbXB0eUZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBJc05vdEVtcHR5RmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIElzTm90TnVsbEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBJc051bGxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgTm90RXF1YWxGaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgU3RhcnRzV2l0aEZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBOdW1lcmljRmlsdGVyQ2VsbENvbXBvbmVudCwgQXV0b0NvbXBsZXRlRmlsdGVyQ2VsbENvbXBvbmVudCwgR3JlYXRlckZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBHcmVhdGVyT3JFcXVhbFRvRmlsdGVyT3BlcmF0b3JDb21wb25lbnQsIExlc3NPckVxdWFsVG9GaWx0ZXJPcGVyYXRvckNvbXBvbmVudCwgTGVzc0ZpbHRlck9wZXJhdG9yQ29tcG9uZW50LCBQYWdlclByZXZCdXR0b25zQ29tcG9uZW50LCBQYWdlck5leHRCdXR0b25zQ29tcG9uZW50LCBQYWdlck51bWVyaWNCdXR0b25zQ29tcG9uZW50LCBQYWdlcklucHV0Q29tcG9uZW50LCBQYWdlckluZm9Db21wb25lbnQsIFBhZ2VyUGFnZVNpemVzQ29tcG9uZW50LCBSb3dGaWx0ZXJNb2R1bGUsIEZpbHRlck1lbnVNb2R1bGUsIEJvZHlNb2R1bGUsIEhlYWRlck1vZHVsZSwgUGFnZXJNb2R1bGUsIFRlbXBsYXRlRWRpdGluZ0RpcmVjdGl2ZSwgUmVhY3RpdmVFZGl0aW5nRGlyZWN0aXZlLCBJbkNlbGxFZGl0aW5nRGlyZWN0aXZlLCBFZGl0VGVtcGxhdGVEaXJlY3RpdmUsIENvbEdyb3VwQ29tcG9uZW50LCBIZWFkZXJDb21wb25lbnQsIExpc3RDb21wb25lbnQsIFRhYmxlQm9keUNvbXBvbmVudCwgUGFnZXJDb21wb25lbnQsIEN1c3RvbU1lc3NhZ2VzQ29tcG9uZW50LCBMb2FkaW5nQ29tcG9uZW50LCBQREZNb2R1bGUsIFBERkNvbXBvbmVudCwgUERGTWFyZ2luQ29tcG9uZW50JDEgYXMgUERGTWFyZ2luQ29tcG9uZW50LCBQREZTZXJ2aWNlLCBFeGNlbE1vZHVsZSwgRXhjZWxDb21wb25lbnQsIEV4Y2VsU2VydmljZSwgU2VsZWN0YWJsZURpcmVjdGl2ZSwgU2VsZWN0aW9uQ2hhbmdlRXZlbnQsIENlbGxDbG9zZUV2ZW50LCBTdXNwZW5kU2VydmljZSwgU2tpcCwgQ29sdW1uUmVvcmRlckV2ZW50LCBGb2N1c2FibGVEaXJlY3RpdmUsIENvbHVtblZpc2liaWxpdHlDaGFuZ2VFdmVudCwgQ29sdW1uTWVudUNvbXBvbmVudCwgU2luZ2xlUG9wdXBTZXJ2aWNlLCBQb3B1cENsb3NlRXZlbnQsIEV4cGFuZEV2ZW50LCBFeHBhbmRhYmxlRGlyZWN0aXZlIH07XG4iXX0=