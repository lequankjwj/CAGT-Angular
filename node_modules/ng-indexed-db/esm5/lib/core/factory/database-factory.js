/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Observable, forkJoin, timer } from 'rxjs';
import { map, switchMap } from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
import { IndexedDatabase } from '../indexed-database';
var NgDatabaseFactory = /** @class */ (function () {
    function NgDatabaseFactory() {
        /**
         * Emits an event when all databases recive has been generated
         */
        this.connectionsReady = new BehaviorSubject(false);
        /**
         * Indexed database connection factory
         */
        this.factory = window.indexedDB;
    }
    /**
     * Sends the database metadata to create.
     * Once it has been completed, emits the
     * connectionsReady event
     * @param databases Databases metadata
     */
    /**
     * Sends the database metadata to create.
     * Once it has been completed, emits the
     * connectionsReady event
     * @param {?} databases Databases metadata
     * @return {?}
     */
    NgDatabaseFactory.prototype.createConnnections = /**
     * Sends the database metadata to create.
     * Once it has been completed, emits the
     * connectionsReady event
     * @param {?} databases Databases metadata
     * @return {?}
     */
    function (databases) {
        var _this = this;
        this.createDataBases(databases)
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return _this.connections = response; })), switchMap((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return timer(100); })))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.connectionsReady.next(true); }));
    };
    /**
     * Find a database connection by name. If there isn't
     * a database name takes the default database name
     * @param dbName Name of the database alias
     */
    /**
     * Find a database connection by name. If there isn't
     * a database name takes the default database name
     * @param {?=} dbName Name of the database alias
     * @return {?}
     */
    NgDatabaseFactory.prototype.getDatabase = /**
     * Find a database connection by name. If there isn't
     * a database name takes the default database name
     * @param {?=} dbName Name of the database alias
     * @return {?}
     */
    function (dbName) {
        return this.connections[dbName ? dbName : this.defaultConnectionName];
    };
    /**
     * Open a database connection
     * @param dbName name of the database
     * @param version version of the database
     */
    /**
     * Open a database connection
     * @param {?} dbName name of the database
     * @param {?=} version version of the database
     * @return {?}
     */
    NgDatabaseFactory.prototype.open = /**
     * Open a database connection
     * @param {?} dbName name of the database
     * @param {?=} version version of the database
     * @return {?}
     */
    function (dbName, version) {
        var _this = this;
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var upgraded = false;
            /** @type {?} */
            var DBOpenRequest = _this.factory.open(dbName, version);
            DBOpenRequest.onupgradeneeded = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                observer.next({
                    upgraded: true,
                    success: true,
                    result: DBOpenRequest.result
                });
                observer.complete();
                upgraded = true;
            });
            DBOpenRequest.onsuccess = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (!upgraded) {
                    observer.next({
                        upgraded: false,
                        success: true,
                        result: DBOpenRequest.result
                    });
                    observer.complete();
                }
            });
            DBOpenRequest.onerror = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                observer.error("Error to connect database " + dbName);
                observer.complete();
            });
            DBOpenRequest.onblocked = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                console.log('blocked');
            });
        }));
    };
    /**
     * Generates an Observable collection of database connections
     * @param Databases metadata
     */
    /**
     * Generates an Observable collection of database connections
     * @param {?} databases
     * @return {?}
     */
    NgDatabaseFactory.prototype.createDataBases = /**
     * Generates an Observable collection of database connections
     * @param {?} databases
     * @return {?}
     */
    function (databases) {
        var _this = this;
        /** @type {?} */
        var operators = [];
        /** @type {?} */
        var firstIteration = true;
        /** @type {?} */
        var createConnnection = (/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            if (firstIteration) {
                _this.defaultConnectionName = item.name;
                firstIteration = false;
            }
            operators.push(_this.createConnection(item.name, item.stores, 1));
        });
        databases.forEach(createConnnection);
        /** @type {?} */
        var mappingResponse = (/**
         * @param {?} response
         * @return {?}
         */
        function (response) {
            /** @type {?} */
            var data = {};
            response.forEach((/**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                data = tslib_1.__assign({}, data, item);
            }));
            return data;
        });
        return forkJoin(operators)
            .pipe(map(mappingResponse));
    };
    /**
     * Generates a sigle database conecction client
     */
    /**
     * Generates a sigle database conecction client
     * @private
     * @param {?} dbName
     * @param {?} tables
     * @param {?=} version
     * @return {?}
     */
    NgDatabaseFactory.prototype.createConnection = /**
     * Generates a sigle database conecction client
     * @private
     * @param {?} dbName
     * @param {?} tables
     * @param {?=} version
     * @return {?}
     */
    function (dbName, tables, version) {
        return this.open(dbName, version)
            .pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            var _a;
            return (_a = {}, _a[dbName] = new IndexedDatabase(data.result, data.upgraded, tables), _a);
        })));
    };
    NgDatabaseFactory.decorators = [
        { type: Injectable }
    ];
    return NgDatabaseFactory;
}());
export { NgDatabaseFactory };
if (false) {
    /**
     * Emits an event when all databases recive has been generated
     * @type {?}
     */
    NgDatabaseFactory.prototype.connectionsReady;
    /**
     * Indexed database connection factory
     * @type {?}
     * @private
     */
    NgDatabaseFactory.prototype.factory;
    /**
     * List of all connections handled by the service
     * @type {?}
     * @private
     */
    NgDatabaseFactory.prototype.connections;
    /**
     * Default connection name
     * @type {?}
     * @private
     */
    NgDatabaseFactory.prototype.defaultConnectionName;
}
/**
 * @record
 */
function OpenConnectionResponse() { }
if (false) {
    /** @type {?} */
    OpenConnectionResponse.prototype.success;
    /** @type {?} */
    OpenConnectionResponse.prototype.upgraded;
    /** @type {?} */
    OpenConnectionResponse.prototype.result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWJhc2UtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWluZGV4ZWQtZGIvIiwic291cmNlcyI6WyJsaWIvY29yZS9mYWN0b3J5L2RhdGFiYXNlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRCxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUtoRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdEQ7SUFBQTs7OztRQUlFLHFCQUFnQixHQUFHLElBQUksZUFBZSxDQUFNLEtBQUssQ0FBQyxDQUFDOzs7O1FBRzNDLFlBQU8sR0FBZSxNQUFNLENBQUMsU0FBUyxDQUFDO0lBaUhqRCxDQUFDO0lBekdDOzs7OztPQUtHOzs7Ozs7OztJQUNILDhDQUFrQjs7Ozs7OztJQUFsQixVQUFtQixTQUF1QjtRQUExQyxpQkFPQztRQU5DLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDO2FBQzlCLElBQUksQ0FDSCxHQUFHOzs7O1FBQUMsVUFBQSxRQUFRLElBQUksT0FBQSxLQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsRUFBM0IsQ0FBMkIsRUFBQyxFQUM1QyxTQUFTOzs7O1FBQUMsVUFBQSxRQUFRLElBQUksT0FBQSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQVYsQ0FBVSxFQUFDLENBQ2xDO2FBQ0EsU0FBUzs7O1FBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQWhDLENBQWdDLEVBQUMsQ0FBQztJQUNyRCxDQUFDO0lBQ0Q7Ozs7T0FJRzs7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LDRDQUFnQjs7Ozs7Ozs7SUFBeEIsVUFBeUIsTUFBYyxFQUFFLE1BQWlCLEVBQUUsT0FBZ0I7UUFDMUUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUM7YUFDOUIsSUFBSSxDQUNILEdBQUc7Ozs7UUFBQyxVQUFBLElBQUk7O1lBQUksT0FBQSxVQUFFLEdBQUMsTUFBTSxJQUFHLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsS0FBRTtRQUFyRSxDQUFxRSxFQUFDLENBQ25GLENBQUM7SUFDTixDQUFDOztnQkF2SEYsVUFBVTs7SUF3SFgsd0JBQUM7Q0FBQSxBQXhIRCxJQXdIQztTQXZIWSxpQkFBaUI7Ozs7OztJQUc1Qiw2Q0FBbUQ7Ozs7OztJQUduRCxvQ0FBK0M7Ozs7OztJQUcvQyx3Q0FBa0M7Ozs7OztJQUdsQyxrREFBc0M7Ozs7O0FBNkd4QyxxQ0FJQzs7O0lBSEMseUNBQWlCOztJQUNqQiwwQ0FBa0I7O0lBQ2xCLHdDQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZvcmtKb2luLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL2ludGVybmFsL0JlaGF2aW9yU3ViamVjdCc7XG5cbmltcG9ydCB7IE5nQ29ubmVjdGlvbiB9IGZyb20gJy4uL3R5cGVzL2NvbmVjY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBOZ0RhdGFCYXNlIH0gZnJvbSAnLi4vdHlwZXMvZGF0YWJhc2UudHlwZSc7XG5pbXBvcnQgeyBOZ1N0b3JlIH0gZnJvbSAnLi4vdHlwZXMvc3RvcmUudHlwZSc7XG5pbXBvcnQgeyBJbmRleGVkRGF0YWJhc2UgfSBmcm9tICcuLi9pbmRleGVkLWRhdGFiYXNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5nRGF0YWJhc2VGYWN0b3J5IHtcblxuICAvKiogRW1pdHMgYW4gZXZlbnQgd2hlbiBhbGwgZGF0YWJhc2VzIHJlY2l2ZSBoYXMgYmVlbiBnZW5lcmF0ZWQgKi9cbiAgY29ubmVjdGlvbnNSZWFkeSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihmYWxzZSk7XG5cbiAgLyoqIEluZGV4ZWQgZGF0YWJhc2UgY29ubmVjdGlvbiBmYWN0b3J5ICovXG4gIHByaXZhdGUgZmFjdG9yeTogSURCRmFjdG9yeSA9IHdpbmRvdy5pbmRleGVkREI7XG5cbiAgLyoqIExpc3Qgb2YgYWxsIGNvbm5lY3Rpb25zIGhhbmRsZWQgYnkgdGhlIHNlcnZpY2UgKi9cbiAgcHJpdmF0ZSBjb25uZWN0aW9uczogTmdDb25uZWN0aW9uO1xuXG4gIC8qKiBEZWZhdWx0IGNvbm5lY3Rpb24gbmFtZSAqL1xuICBwcml2YXRlIGRlZmF1bHRDb25uZWN0aW9uTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgZGF0YWJhc2UgbWV0YWRhdGEgdG8gY3JlYXRlLlxuICAgKiBPbmNlIGl0IGhhcyBiZWVuIGNvbXBsZXRlZCwgZW1pdHMgdGhlXG4gICAqIGNvbm5lY3Rpb25zUmVhZHkgZXZlbnRcbiAgICogQHBhcmFtIGRhdGFiYXNlcyBEYXRhYmFzZXMgbWV0YWRhdGFcbiAgICovXG4gIGNyZWF0ZUNvbm5uZWN0aW9ucyhkYXRhYmFzZXM6IE5nRGF0YUJhc2VbXSkge1xuICAgIHRoaXMuY3JlYXRlRGF0YUJhc2VzKGRhdGFiYXNlcylcbiAgICAucGlwZShcbiAgICAgIG1hcChyZXNwb25zZSA9PiB0aGlzLmNvbm5lY3Rpb25zID0gcmVzcG9uc2UpLFxuICAgICAgc3dpdGNoTWFwKHJlc3BvbnNlID0+IHRpbWVyKDEwMCkpLFxuICAgIClcbiAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29ubmVjdGlvbnNSZWFkeS5uZXh0KHRydWUpKTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhIGRhdGFiYXNlIGNvbm5lY3Rpb24gYnkgbmFtZS4gSWYgdGhlcmUgaXNuJ3RcbiAgICogYSBkYXRhYmFzZSBuYW1lIHRha2VzIHRoZSBkZWZhdWx0IGRhdGFiYXNlIG5hbWVcbiAgICogQHBhcmFtIGRiTmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZSBhbGlhc1xuICAgKi9cbiAgZ2V0RGF0YWJhc2UoZGJOYW1lPzogc3RyaW5nKTogSW5kZXhlZERhdGFiYXNlIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1tkYk5hbWUgPyBkYk5hbWUgOiB0aGlzLmRlZmF1bHRDb25uZWN0aW9uTmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gYSBkYXRhYmFzZSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSBkYk5hbWUgbmFtZSBvZiB0aGUgZGF0YWJhc2VcbiAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBvZiB0aGUgZGF0YWJhc2VcbiAgICovXG4gIG9wZW4oZGJOYW1lOiBzdHJpbmcsIHZlcnNpb24/OiBudW1iZXIpOiBPYnNlcnZhYmxlPE9wZW5Db25uZWN0aW9uUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgbGV0IHVwZ3JhZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBEQk9wZW5SZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0ID0gdGhpcy5mYWN0b3J5Lm9wZW4oZGJOYW1lLCB2ZXJzaW9uKTtcblxuICAgICAgREJPcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBldmVudCA9PiB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgIHVwZ3JhZGVkOiB0cnVlLFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgcmVzdWx0OiBEQk9wZW5SZXF1ZXN0LnJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgdXBncmFkZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgREJPcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBldmVudCA9PiB7XG4gICAgICAgIGlmICghdXBncmFkZWQpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgIHVwZ3JhZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICByZXN1bHQ6IERCT3BlblJlcXVlc3QucmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgREJPcGVuUmVxdWVzdC5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgICBvYnNlcnZlci5lcnJvcihgRXJyb3IgdG8gY29ubmVjdCBkYXRhYmFzZSAke2RiTmFtZX1gKTtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH07XG5cbiAgICAgIERCT3BlblJlcXVlc3Qub25ibG9ja2VkID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnYmxvY2tlZCcpO1xuICAgICAgfTtcblxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gT2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGRhdGFiYXNlIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSBEYXRhYmFzZXMgbWV0YWRhdGFcbiAgICovXG4gIGNyZWF0ZURhdGFCYXNlcyhkYXRhYmFzZXM6IE5nRGF0YUJhc2VbXSk6IE9ic2VydmFibGU8TmdDb25uZWN0aW9uPiB7XG4gICAgY29uc3Qgb3BlcmF0b3JzID0gW107XG4gICAgbGV0IGZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcbiAgICBjb25zdCBjcmVhdGVDb25ubmVjdGlvbiA9IChpdGVtOiBOZ0RhdGFCYXNlKSA9PiB7XG4gICAgICBpZiAoZmlyc3RJdGVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29ubmVjdGlvbk5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICAgIGZpcnN0SXRlcmF0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvcGVyYXRvcnMucHVzaCh0aGlzLmNyZWF0ZUNvbm5lY3Rpb24oaXRlbS5uYW1lLCBpdGVtLnN0b3JlcywgMSkpO1xuICAgIH07XG4gICAgZGF0YWJhc2VzLmZvckVhY2goY3JlYXRlQ29ubm5lY3Rpb24pO1xuXG4gICAgY29uc3QgbWFwcGluZ1Jlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgIHJlc3BvbnNlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAuLi5pdGVtXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gZm9ya0pvaW4ob3BlcmF0b3JzKVxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcChtYXBwaW5nUmVzcG9uc2UpXG4gICAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBzaWdsZSBkYXRhYmFzZSBjb25lY2N0aW9uIGNsaWVudFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVDb25uZWN0aW9uKGRiTmFtZTogc3RyaW5nLCB0YWJsZXM6IE5nU3RvcmVbXSwgdmVyc2lvbj86IG51bWJlcik6IE9ic2VydmFibGU8TmdDb25uZWN0aW9uPiB7XG4gICAgcmV0dXJuIHRoaXMub3BlbihkYk5hbWUsIHZlcnNpb24pXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKGRhdGEgPT4gKHtbZGJOYW1lXTogbmV3IEluZGV4ZWREYXRhYmFzZShkYXRhLnJlc3VsdCwgZGF0YS51cGdyYWRlZCwgdGFibGVzKX0pKVxuICAgICAgKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgT3BlbkNvbm5lY3Rpb25SZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIHVwZ3JhZGVkOiBib29sZWFuO1xuICByZXN1bHQ6IElEQkRhdGFiYXNlO1xufVxuIl19