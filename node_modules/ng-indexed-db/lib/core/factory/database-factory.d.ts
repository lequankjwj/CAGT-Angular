import { Observable } from 'rxjs';
import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
import { NgConnection } from '../types/conecction.type';
import { NgDataBase } from '../types/database.type';
import { IndexedDatabase } from '../indexed-database';
import * as ɵngcc0 from '@angular/core';
export declare class NgDatabaseFactory {
    /** Emits an event when all databases recive has been generated */
    connectionsReady: BehaviorSubject<any>;
    /** Indexed database connection factory */
    private factory;
    /** List of all connections handled by the service */
    private connections;
    /** Default connection name */
    private defaultConnectionName;
    /**
     * Sends the database metadata to create.
     * Once it has been completed, emits the
     * connectionsReady event
     * @param databases Databases metadata
     */
    createConnnections(databases: NgDataBase[]): void;
    /**
     * Find a database connection by name. If there isn't
     * a database name takes the default database name
     * @param dbName Name of the database alias
     */
    getDatabase(dbName?: string): IndexedDatabase;
    /**
     * Open a database connection
     * @param dbName name of the database
     * @param version version of the database
     */
    open(dbName: string, version?: number): Observable<OpenConnectionResponse>;
    /**
     * Generates an Observable collection of database connections
     * @param Databases metadata
     */
    createDataBases(databases: NgDataBase[]): Observable<NgConnection>;
    /**
     * Generates a sigle database conecction client
     */
    private createConnection;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgDatabaseFactory, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NgDatabaseFactory>;
}
interface OpenConnectionResponse {
    success: boolean;
    upgraded: boolean;
    result: IDBDatabase;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWJhc2UtZmFjdG9yeS5kLnRzIiwic291cmNlcyI6WyJkYXRhYmFzZS1mYWN0b3J5LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL2ludGVybmFsL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBOZ0Nvbm5lY3Rpb24gfSBmcm9tICcuLi90eXBlcy9jb25lY2N0aW9uLnR5cGUnO1xuaW1wb3J0IHsgTmdEYXRhQmFzZSB9IGZyb20gJy4uL3R5cGVzL2RhdGFiYXNlLnR5cGUnO1xuaW1wb3J0IHsgSW5kZXhlZERhdGFiYXNlIH0gZnJvbSAnLi4vaW5kZXhlZC1kYXRhYmFzZSc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ0RhdGFiYXNlRmFjdG9yeSB7XG4gICAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYWxsIGRhdGFiYXNlcyByZWNpdmUgaGFzIGJlZW4gZ2VuZXJhdGVkICovXG4gICAgY29ubmVjdGlvbnNSZWFkeTogQmVoYXZpb3JTdWJqZWN0PGFueT47XG4gICAgLyoqIEluZGV4ZWQgZGF0YWJhc2UgY29ubmVjdGlvbiBmYWN0b3J5ICovXG4gICAgcHJpdmF0ZSBmYWN0b3J5O1xuICAgIC8qKiBMaXN0IG9mIGFsbCBjb25uZWN0aW9ucyBoYW5kbGVkIGJ5IHRoZSBzZXJ2aWNlICovXG4gICAgcHJpdmF0ZSBjb25uZWN0aW9ucztcbiAgICAvKiogRGVmYXVsdCBjb25uZWN0aW9uIG5hbWUgKi9cbiAgICBwcml2YXRlIGRlZmF1bHRDb25uZWN0aW9uTmFtZTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgZGF0YWJhc2UgbWV0YWRhdGEgdG8gY3JlYXRlLlxuICAgICAqIE9uY2UgaXQgaGFzIGJlZW4gY29tcGxldGVkLCBlbWl0cyB0aGVcbiAgICAgKiBjb25uZWN0aW9uc1JlYWR5IGV2ZW50XG4gICAgICogQHBhcmFtIGRhdGFiYXNlcyBEYXRhYmFzZXMgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVDb25ubmVjdGlvbnMoZGF0YWJhc2VzOiBOZ0RhdGFCYXNlW10pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEZpbmQgYSBkYXRhYmFzZSBjb25uZWN0aW9uIGJ5IG5hbWUuIElmIHRoZXJlIGlzbid0XG4gICAgICogYSBkYXRhYmFzZSBuYW1lIHRha2VzIHRoZSBkZWZhdWx0IGRhdGFiYXNlIG5hbWVcbiAgICAgKiBAcGFyYW0gZGJOYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlIGFsaWFzXG4gICAgICovXG4gICAgZ2V0RGF0YWJhc2UoZGJOYW1lPzogc3RyaW5nKTogSW5kZXhlZERhdGFiYXNlO1xuICAgIC8qKlxuICAgICAqIE9wZW4gYSBkYXRhYmFzZSBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGRiTmFtZSBuYW1lIG9mIHRoZSBkYXRhYmFzZVxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gb2YgdGhlIGRhdGFiYXNlXG4gICAgICovXG4gICAgb3BlbihkYk5hbWU6IHN0cmluZywgdmVyc2lvbj86IG51bWJlcik6IE9ic2VydmFibGU8T3BlbkNvbm5lY3Rpb25SZXNwb25zZT47XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIE9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBkYXRhYmFzZSBjb25uZWN0aW9uc1xuICAgICAqIEBwYXJhbSBEYXRhYmFzZXMgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhQmFzZXMoZGF0YWJhc2VzOiBOZ0RhdGFCYXNlW10pOiBPYnNlcnZhYmxlPE5nQ29ubmVjdGlvbj47XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgc2lnbGUgZGF0YWJhc2UgY29uZWNjdGlvbiBjbGllbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZUNvbm5lY3Rpb247XG59XG5pbnRlcmZhY2UgT3BlbkNvbm5lY3Rpb25SZXNwb25zZSB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICB1cGdyYWRlZDogYm9vbGVhbjtcbiAgICByZXN1bHQ6IElEQkRhdGFiYXNlO1xufVxuZXhwb3J0IHt9O1xuIl19