/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { Observable, forkJoin, timer } from 'rxjs';
import { map, switchMap } from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
import { IndexedDatabase } from '../indexed-database';
export class NgDatabaseFactory {
    constructor() {
        /**
         * Emits an event when all databases recive has been generated
         */
        this.connectionsReady = new BehaviorSubject(false);
        /**
         * Indexed database connection factory
         */
        this.factory = window.indexedDB;
    }
    /**
     * Sends the database metadata to create.
     * Once it has been completed, emits the
     * connectionsReady event
     * @param {?} databases Databases metadata
     * @return {?}
     */
    createConnnections(databases) {
        this.createDataBases(databases)
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        response => this.connections = response)), switchMap((/**
         * @param {?} response
         * @return {?}
         */
        response => timer(100))))
            .subscribe((/**
         * @return {?}
         */
        () => this.connectionsReady.next(true)));
    }
    /**
     * Find a database connection by name. If there isn't
     * a database name takes the default database name
     * @param {?=} dbName Name of the database alias
     * @return {?}
     */
    getDatabase(dbName) {
        return this.connections[dbName ? dbName : this.defaultConnectionName];
    }
    /**
     * Open a database connection
     * @param {?} dbName name of the database
     * @param {?=} version version of the database
     * @return {?}
     */
    open(dbName, version) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            /** @type {?} */
            let upgraded = false;
            /** @type {?} */
            const DBOpenRequest = this.factory.open(dbName, version);
            DBOpenRequest.onupgradeneeded = (/**
             * @param {?} event
             * @return {?}
             */
            event => {
                observer.next({
                    upgraded: true,
                    success: true,
                    result: DBOpenRequest.result
                });
                observer.complete();
                upgraded = true;
            });
            DBOpenRequest.onsuccess = (/**
             * @param {?} event
             * @return {?}
             */
            event => {
                if (!upgraded) {
                    observer.next({
                        upgraded: false,
                        success: true,
                        result: DBOpenRequest.result
                    });
                    observer.complete();
                }
            });
            DBOpenRequest.onerror = (/**
             * @param {?} event
             * @return {?}
             */
            event => {
                observer.error(`Error to connect database ${dbName}`);
                observer.complete();
            });
            DBOpenRequest.onblocked = (/**
             * @param {?} event
             * @return {?}
             */
            event => {
                console.log('blocked');
            });
        }));
    }
    /**
     * Generates an Observable collection of database connections
     * @param {?} databases
     * @return {?}
     */
    createDataBases(databases) {
        /** @type {?} */
        const operators = [];
        /** @type {?} */
        let firstIteration = true;
        /** @type {?} */
        const createConnnection = (/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (firstIteration) {
                this.defaultConnectionName = item.name;
                firstIteration = false;
            }
            operators.push(this.createConnection(item.name, item.stores, 1));
        });
        databases.forEach(createConnnection);
        /** @type {?} */
        const mappingResponse = (/**
         * @param {?} response
         * @return {?}
         */
        response => {
            /** @type {?} */
            let data = {};
            response.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                data = Object.assign({}, data, item);
            }));
            return data;
        });
        return forkJoin(operators)
            .pipe(map(mappingResponse));
    }
    /**
     * Generates a sigle database conecction client
     * @private
     * @param {?} dbName
     * @param {?} tables
     * @param {?=} version
     * @return {?}
     */
    createConnection(dbName, tables, version) {
        return this.open(dbName, version)
            .pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        data => ({ [dbName]: new IndexedDatabase(data.result, data.upgraded, tables) }))));
    }
}
NgDatabaseFactory.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * Emits an event when all databases recive has been generated
     * @type {?}
     */
    NgDatabaseFactory.prototype.connectionsReady;
    /**
     * Indexed database connection factory
     * @type {?}
     * @private
     */
    NgDatabaseFactory.prototype.factory;
    /**
     * List of all connections handled by the service
     * @type {?}
     * @private
     */
    NgDatabaseFactory.prototype.connections;
    /**
     * Default connection name
     * @type {?}
     * @private
     */
    NgDatabaseFactory.prototype.defaultConnectionName;
}
/**
 * @record
 */
function OpenConnectionResponse() { }
if (false) {
    /** @type {?} */
    OpenConnectionResponse.prototype.success;
    /** @type {?} */
    OpenConnectionResponse.prototype.upgraded;
    /** @type {?} */
    OpenConnectionResponse.prototype.result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWJhc2UtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWluZGV4ZWQtZGIvIiwic291cmNlcyI6WyJsaWIvY29yZS9mYWN0b3J5L2RhdGFiYXNlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBS2hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUd0RCxNQUFNLE9BQU8saUJBQWlCO0lBRDlCOzs7O1FBSUUscUJBQWdCLEdBQUcsSUFBSSxlQUFlLENBQU0sS0FBSyxDQUFDLENBQUM7Ozs7UUFHM0MsWUFBTyxHQUFlLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFpSGpELENBQUM7Ozs7Ozs7O0lBbkdDLGtCQUFrQixDQUFDLFNBQXVCO1FBQ3hDLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDO2FBQzlCLElBQUksQ0FDSCxHQUFHOzs7O1FBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsRUFBQyxFQUM1QyxTQUFTOzs7O1FBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FDbEM7YUFDQSxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUM7SUFDckQsQ0FBQzs7Ozs7OztJQU1ELFdBQVcsQ0FBQyxNQUFlO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENB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QUFHOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQ25GLENBQUM7SUFDTixDQUFDOzs7WUF2SEYsVUFBVTs7Ozs7OztJQUlULDZDQUFtRDs7Ozs7O0lBR25ELG9DQUErQzs7Ozs7O0lBRy9DLHdDQUFrQzs7Ozs7O0lBR2xDLGtEQUFzQzs7Ozs7QUE2R3hDLHFDQUlDOzs7SUFIQyx5Q0FBaUI7O0lBQ2pCLDBDQUFrQjs7SUFDbEIsd0NBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZm9ya0pvaW4sIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvaW50ZXJuYWwvQmVoYXZpb3JTdWJqZWN0JztcblxuaW1wb3J0IHsgTmdDb25uZWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMvY29uZWNjdGlvbi50eXBlJztcbmltcG9ydCB7IE5nRGF0YUJhc2UgfSBmcm9tICcuLi90eXBlcy9kYXRhYmFzZS50eXBlJztcbmltcG9ydCB7IE5nU3RvcmUgfSBmcm9tICcuLi90eXBlcy9zdG9yZS50eXBlJztcbmltcG9ydCB7IEluZGV4ZWREYXRhYmFzZSB9IGZyb20gJy4uL2luZGV4ZWQtZGF0YWJhc2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmdEYXRhYmFzZUZhY3Rvcnkge1xuXG4gIC8qKiBFbWl0cyBhbiBldmVudCB3aGVuIGFsbCBkYXRhYmFzZXMgcmVjaXZlIGhhcyBiZWVuIGdlbmVyYXRlZCAqL1xuICBjb25uZWN0aW9uc1JlYWR5ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxhbnk+KGZhbHNlKTtcblxuICAvKiogSW5kZXhlZCBkYXRhYmFzZSBjb25uZWN0aW9uIGZhY3RvcnkgKi9cbiAgcHJpdmF0ZSBmYWN0b3J5OiBJREJGYWN0b3J5ID0gd2luZG93LmluZGV4ZWREQjtcblxuICAvKiogTGlzdCBvZiBhbGwgY29ubmVjdGlvbnMgaGFuZGxlZCBieSB0aGUgc2VydmljZSAqL1xuICBwcml2YXRlIGNvbm5lY3Rpb25zOiBOZ0Nvbm5lY3Rpb247XG5cbiAgLyoqIERlZmF1bHQgY29ubmVjdGlvbiBuYW1lICovXG4gIHByaXZhdGUgZGVmYXVsdENvbm5lY3Rpb25OYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBkYXRhYmFzZSBtZXRhZGF0YSB0byBjcmVhdGUuXG4gICAqIE9uY2UgaXQgaGFzIGJlZW4gY29tcGxldGVkLCBlbWl0cyB0aGVcbiAgICogY29ubmVjdGlvbnNSZWFkeSBldmVudFxuICAgKiBAcGFyYW0gZGF0YWJhc2VzIERhdGFiYXNlcyBtZXRhZGF0YVxuICAgKi9cbiAgY3JlYXRlQ29ubm5lY3Rpb25zKGRhdGFiYXNlczogTmdEYXRhQmFzZVtdKSB7XG4gICAgdGhpcy5jcmVhdGVEYXRhQmFzZXMoZGF0YWJhc2VzKVxuICAgIC5waXBlKFxuICAgICAgbWFwKHJlc3BvbnNlID0+IHRoaXMuY29ubmVjdGlvbnMgPSByZXNwb25zZSksXG4gICAgICBzd2l0Y2hNYXAocmVzcG9uc2UgPT4gdGltZXIoMTAwKSksXG4gICAgKVxuICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb25uZWN0aW9uc1JlYWR5Lm5leHQodHJ1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGEgZGF0YWJhc2UgY29ubmVjdGlvbiBieSBuYW1lLiBJZiB0aGVyZSBpc24ndFxuICAgKiBhIGRhdGFiYXNlIG5hbWUgdGFrZXMgdGhlIGRlZmF1bHQgZGF0YWJhc2UgbmFtZVxuICAgKiBAcGFyYW0gZGJOYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlIGFsaWFzXG4gICAqL1xuICBnZXREYXRhYmFzZShkYk5hbWU/OiBzdHJpbmcpOiBJbmRleGVkRGF0YWJhc2Uge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zW2RiTmFtZSA/IGRiTmFtZSA6IHRoaXMuZGVmYXVsdENvbm5lY3Rpb25OYW1lXTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBhIGRhdGFiYXNlIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIGRiTmFtZSBuYW1lIG9mIHRoZSBkYXRhYmFzZVxuICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIG9mIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgb3BlbihkYk5hbWU6IHN0cmluZywgdmVyc2lvbj86IG51bWJlcik6IE9ic2VydmFibGU8T3BlbkNvbm5lY3Rpb25SZXNwb25zZT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICBsZXQgdXBncmFkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IERCT3BlblJlcXVlc3Q6IElEQk9wZW5EQlJlcXVlc3QgPSB0aGlzLmZhY3Rvcnkub3BlbihkYk5hbWUsIHZlcnNpb24pO1xuXG4gICAgICBEQk9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGV2ZW50ID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgdXBncmFkZWQ6IHRydWUsXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICByZXN1bHQ6IERCT3BlblJlcXVlc3QucmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB1cGdyYWRlZCA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICBEQk9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKCF1cGdyYWRlZCkge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgdXBncmFkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3VsdDogREJPcGVuUmVxdWVzdC5yZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBEQk9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGBFcnJvciB0byBjb25uZWN0IGRhdGFiYXNlICR7ZGJOYW1lfWApO1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfTtcblxuICAgICAgREJPcGVuUmVxdWVzdC5vbmJsb2NrZWQgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdibG9ja2VkJyk7XG4gICAgICB9O1xuXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBPYnNlcnZhYmxlIGNvbGxlY3Rpb24gb2YgZGF0YWJhc2UgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIERhdGFiYXNlcyBtZXRhZGF0YVxuICAgKi9cbiAgY3JlYXRlRGF0YUJhc2VzKGRhdGFiYXNlczogTmdEYXRhQmFzZVtdKTogT2JzZXJ2YWJsZTxOZ0Nvbm5lY3Rpb24+IHtcbiAgICBjb25zdCBvcGVyYXRvcnMgPSBbXTtcbiAgICBsZXQgZmlyc3RJdGVyYXRpb24gPSB0cnVlO1xuICAgIGNvbnN0IGNyZWF0ZUNvbm5uZWN0aW9uID0gKGl0ZW06IE5nRGF0YUJhc2UpID0+IHtcbiAgICAgIGlmIChmaXJzdEl0ZXJhdGlvbikge1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25uZWN0aW9uTmFtZSA9IGl0ZW0ubmFtZTtcbiAgICAgICAgZmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9wZXJhdG9ycy5wdXNoKHRoaXMuY3JlYXRlQ29ubmVjdGlvbihpdGVtLm5hbWUsIGl0ZW0uc3RvcmVzLCAxKSk7XG4gICAgfTtcbiAgICBkYXRhYmFzZXMuZm9yRWFjaChjcmVhdGVDb25ubmVjdGlvbik7XG5cbiAgICBjb25zdCBtYXBwaW5nUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgcmVzcG9uc2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIC4uLml0ZW1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBmb3JrSm9pbihvcGVyYXRvcnMpXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKG1hcHBpbmdSZXNwb25zZSlcbiAgICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNpZ2xlIGRhdGFiYXNlIGNvbmVjY3Rpb24gY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUNvbm5lY3Rpb24oZGJOYW1lOiBzdHJpbmcsIHRhYmxlczogTmdTdG9yZVtdLCB2ZXJzaW9uPzogbnVtYmVyKTogT2JzZXJ2YWJsZTxOZ0Nvbm5lY3Rpb24+IHtcbiAgICByZXR1cm4gdGhpcy5vcGVuKGRiTmFtZSwgdmVyc2lvbilcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoZGF0YSA9PiAoe1tkYk5hbWVdOiBuZXcgSW5kZXhlZERhdGFiYXNlKGRhdGEucmVzdWx0LCBkYXRhLnVwZ3JhZGVkLCB0YWJsZXMpfSkpXG4gICAgICApO1xuICB9XG59XG5cbmludGVyZmFjZSBPcGVuQ29ubmVjdGlvblJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgdXBncmFkZWQ6IGJvb2xlYW47XG4gIHJlc3VsdDogSURCRGF0YWJhc2U7XG59XG4iXX0=