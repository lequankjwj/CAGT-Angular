{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@datorama/akita/lib/actions.ts","ng://@datorama/akita/lib/hasEntity.ts","ng://@datorama/akita/lib/addEntities.ts","ng://@datorama/akita/lib/isNil.ts","ng://@datorama/akita/lib/coerceArray.ts","ng://@datorama/akita/lib/entityActions.ts","ng://@datorama/akita/lib/root.ts","ng://@datorama/akita/lib/env.ts","ng://@datorama/akita/lib/isObject.ts","ng://@datorama/akita/lib/isArray.ts","ng://@datorama/akita/lib/getActiveEntities.ts","ng://@datorama/akita/lib/getInitialEntitiesState.ts","ng://@datorama/akita/lib/isDefined.ts","ng://@datorama/akita/lib/isEmpty.ts","ng://@datorama/akita/lib/isFunction.ts","ng://@datorama/akita/lib/isUndefined.ts","ng://@datorama/akita/lib/activeState.ts","ng://@datorama/akita/lib/removeEntities.ts","ng://@datorama/akita/lib/toEntitiesObject.ts","ng://@datorama/akita/lib/setEntities.ts","ng://@datorama/akita/lib/config.ts","ng://@datorama/akita/lib/deepFreeze.ts","ng://@datorama/akita/lib/dispatchers.ts","ng://@datorama/akita/lib/errors.ts","ng://@datorama/akita/lib/toBoolean.ts","ng://@datorama/akita/lib/isPlainObject.ts","ng://@datorama/akita/lib/stores.ts","ng://@datorama/akita/lib/transaction.ts","ng://@datorama/akita/lib/store.ts","ng://@datorama/akita/lib/updateEntities.ts","ng://@datorama/akita/lib/sort.ts","ng://@datorama/akita/lib/entityStore.ts","ng://@datorama/akita/lib/defaultIDKey.ts","ng://@datorama/akita/lib/arrayFind.ts","ng://@datorama/akita/lib/entitiesToArray.ts","ng://@datorama/akita/lib/entitiesToMap.ts","ng://@datorama/akita/lib/isString.ts","ng://@datorama/akita/lib/getEntity.ts","ng://@datorama/akita/lib/query.ts","ng://@datorama/akita/lib/compareKeys.ts","ng://@datorama/akita/lib/sortByOptions.ts","ng://@datorama/akita/lib/queryEntity.ts","ng://@datorama/akita/lib/mapSkipUndefined.ts","ng://@datorama/akita/lib/filterNil.ts","ng://@datorama/akita/lib/getValueByString.ts","ng://@datorama/akita/lib/setValueByString.ts","ng://@datorama/akita/lib/persistState.ts","ng://@datorama/akita/lib/snapshotManager.ts","ng://@datorama/akita/lib/plugins/plugin.ts","ng://@datorama/akita/lib/plugins/paginator/paginatorPlugin.ts","ng://@datorama/akita/lib/plugins/persistForm/persistNgFormPlugin.ts","ng://@datorama/akita/lib/capitalize.ts","ng://@datorama/akita/lib/devtools.ts","ng://@datorama/akita/lib/plugins/entityCollectionPlugin.ts","ng://@datorama/akita/lib/plugins/stateHistory/stateHistoryPlugin.ts","ng://@datorama/akita/lib/plugins/stateHistory/entityStateHistoryPlugin.ts","ng://@datorama/akita/lib/plugins/dirtyCheck/dirtyCheckPlugin.ts","ng://@datorama/akita/lib/plugins/dirtyCheck/entityDirtyCheckPlugin.ts","ng://@datorama/akita/lib/runStoreAction.ts","ng://@datorama/akita/lib/arrayUpdate.ts","ng://@datorama/akita/lib/arrayAdd.ts","ng://@datorama/akita/lib/arrayToggle.ts","ng://@datorama/akita/lib/entityService.ts","ng://@datorama/akita/lib/trackIdChanges.ts","ng://@datorama/akita/lib/queryConfig.ts","ng://@datorama/akita/lib/storeConfig.ts","ng://@datorama/akita/lib/arrayRemove.ts","ng://@datorama/akita/lib/not.ts","ng://@datorama/akita/lib/arrayUpsert.ts","ng://@datorama/akita/lib/cacheable.ts","ng://@datorama/akita/lib/combineQueries.ts","ng://@datorama/akita/lib/fp.ts","ng://@datorama/akita/lib/guid.ts","ng://@datorama/akita/lib/isNumber.ts","ng://@datorama/akita/lib/resetStores.ts","ng://@datorama/akita/lib/setLoading.ts","ng://@datorama/akita/lib/toEntitiesIds.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","e","ar","push","error","__spread","concat","currentAction","type","entityIds","skip","customActionActive","resetCustomAction","logAction","setAction","setSkipAction","action","propertyKey","descriptor","originalMethod","args","_i","hasEntity","entities","id","addEntities","_a","state","idKey","_b","options","preAddEntity","newEntities","newIds","hasNewEntities","entities_1","tslib_1.__values","entities_1_1","entity","current","entityId","prepend","unshift","newState","ids","isNil","v","coerceArray","isArray","EntityActions","isBrowser","window","isNotBrowser","hasLocalStorage","localStorage","isDev","__DEV__","isObject","getActiveEntities","idOrOptions","currentActive","result","wrap","currentIdIndex","indexOf","prev","isFirst","isLast","getInitialEntitiesState","loading","isDefined","val","isEmpty","arr","isFunction","isUndefined","undefined","hasActiveState","isMultiActiveState","active","resolveActiveEntity","getExitingActives","currentActivesIds","filtered","filter","removeEntities","removeAllEntities","_c","_d","includes","toEntitiesObject","acc","isEntityState","applyMiddleware","mapped","keys","setEntities","isNativePreAdd","resolve","map","isNaN","Number","CONFIG","resettable","ttl","producerFn","getAkitaConfig","deepFreeze","freeze","oIsFunction","hasOwnProp","getOwnPropertyNames","forEach","prop","isFrozen","$$deleteStore","Subject","$$addStore","ReplaySubject","$$updateStore","dispatchDeleted","storeName","dispatchAdded","dispatchUpdate","AkitaError","_super","message","tslib_1.__extends","Error","toBoolean","isPlainObject","name","__stores__","__queries__","$$stores","$$queries","transactionFinished","transactionInProcess","BehaviorSubject","transactionManager","activeTransactions","batchTransaction","startBatch","isTransactionInProcess","endBatch","complete","commit","asObservable","of","applyTransaction","thisArg","transaction","_this","Store","initialState","inTransaction","cache","onInit","setLoading","_value","_setState","tslib_1.__assign","setHasCache","hasCache","restartTTL","ttlConfig","getCacheTTL","clearTimeout","setTimeout","getValue","storeValue","setError","_select","project","store","pipe","snapshot","distinctUntilChanged","_cache","config","deepFreezeFn","_dispatchAction","_newState","subscribe","handleTransaction","dispatch","reset","isResettable","_initialState","console","warn","update","stateOrCallback","currentState","_producerFn","withHook","akitaPreUpdate","resolved","updateStoreConfig","newOptions","_","nextState","ngOnDestroy","destroy","hmrEnabled","className","watchTransaction","cacheConfig","updateEntities","idToUpdate","newStateOrFn","preUpdateEntity","onEntityIdChanges","updatedEntities","isUpdatingIdKey","ids_1","ids_1_1","oldEntity","isIdChanged","newEntity","merged","updatedIds","stateEntities","id_1","_e","getOwnPropertySymbols","propertyIsEnumerable","__rest","Order","EntityStore","entityActions","entityIdChanges","set","akitaPreAddEntity","activeId","hasInitialUIState","handleUICreation","Set","add","collection","data","Add","idsOrFnOrState","entityIdChanged","akitaPreUpdateEntity","oldId","newId","pending","Update","upsert","onCreate","toArray","predicate","isUpdate","baseClass","isClassBased","updateIds","newStateObj","withId","upsertMany","addedIds","withPreCheckHook","akitaPreCheckEntity","nextId","hasUIStore","replace","replaced","toArray_1","toArray_1_1","move","from","to","slice","splice","remove","idsOrFn","idPassed","handleUIRemove","Remove","updateActive","newStateOrCallback","setActive","_setActive","addActive","every","uniques","removeActive","some","currentId","toggleActive","filterExists","createUIStore","storeConfig","defaults","ui","EntityUIStore","nextEntity","uiEntities","isFunc","_akitaCreateEntityFn","createFn","tslib_1.__decorate","T","setInitialEntityState","find","idsOrPredicate","collection_1","collection_1_1","toSet","reduce","collection_2","collection_2_1","has","distinctUntilArrayItemChanged","prevCollection","currentCollection","hasChange","first","second","currentItem","prevItem","compareValues","order","ASC","a","varA","toUpperCase","varB","comparison","DESC","entitiesToArray","filterBy","limitTo","sortBy","sortByOrder","fn","_sortBy_1","sort","Math","min","entitiesToMap","hasLimit","count","length_1","finalLength","isString","getEntity","Query","__store__","select","mapFn","keysOrFuncs","prevState","currState","isFns","keyOrFunc","func","k","selectLoading","selectError","selectHasCache","getHasCache","sortByOptions","QueryEntity","selectAll","asObject","getAll","selectMany","callbackFn","index","array","selectEntity","idOrPredicate","findEntityByPredicate","selectActiveId","getActiveId","selectActive","getActive","switchMap","selectCount","getCount","selectLast","selectAt","selectFirst","selectEntityAction","actionOrActions","selectEntityAction$","actions","projectOrIds","hasActive","isIdProvided","createUIQuery","EntityUIQuery","filterNil","source","obj","split","join","part","setValue","lastIndex","skipStorageUpdate","_persistStateInit","setSkipStorageUpdate","getSkipStorageUpdate","observify","asyncOrValue","then","isObservable","SnapshotManager","getStoresSnapshot","stores","setStoresSnapshot","mergedOptions","lazy","normalizedStores","JSON","parse","size","take","snapshotManager","AkitaPlugin","query","resetFn","onReset","getQuery","getStore","isEntityBased","selectSource","property","withStoreName","getSource","updateStore","original","params","paginatorDefaults","pagesControls","range","startWith","cacheTimeout","clearStoreWithCache","PaginatorPlugin","initial","clearCache","currentPage","Map","pages","pagination","perPage","total","lastPage","isLoading$","delay","page","clearCacheSubscription","withControls","withRange","response","addPage","clearStore","clearPage","delete","unsubscribe","setPage","isPageActive","hasPage","nextPage","prevPage","setLastPage","setFirstPage","getPage","req","selectPage","refreshCurrentPage","getFrom","getTo","get","pageControls","len","ceil","generatePages","Paginator","PersistNgFormPlugin","factoryFnOrPath","debounceTime","formKey","emitEvent","arrControlFactory","builder","control","isRootKeys","isKeyBased","setForm","form","activate","initialValue","stateKey","formArray","controls","cleanArray","insert","patchValue","removeAt","resolveInitialValue","formValue","root","factory_1","path","formChanges","valueChanges","capitalize","charAt","subs","EntityCollectionPlugin","removeEntity","createEntity","plugin","getIds","resolvedIds","rebase","beforeAdd","instantiatePlugin","afterAdd","beforeRemove","_ids","selectIds","forEachId","cb","StateHistoryPlugin","_entityId","clear","history","past","present","future","skipUpdate","maxAge","comparator","_hasPast$","_hasFuture$","watchProperty","updateHasHistory","hasFutureSubject","hasFuture","hasPastSubject","hasPast","subscription","pairwise","shouldUpdate","undo","previous","redo","newFuture","jumpToPast","newPast","newPresent","jumpToFuture","jump","customUpdateFn","clearHistory","ignoreNext","EntityStateHistoryPlugin","dirtyCheckDefaultParams","head","stringify","getNestedPath","nestedObj","DirtyCheckPlugin","dirty","_reset","isDirty$","reset$","watchProp","currentValue","updateFn","setHead","_getHead","updateDirtiness","isDirty","hasHead","getHead","isPathDirty","currentPathValue","headPathValue","__akitaKey","combineLatest","isChange","compareTo","getWatchedValues","watched","EntityDirtyCheckPlugin","_someDirty","someDirty$","merge","auditTime","checkSomeDirty","someDirty","entitiesIds","entitiesIds_1","entitiesIds_1_1","StoreAction","EntityStoreAction","StoreActionMapping","EntityStoreActionMapping","AddEntities","SetEntities","UpdateEntities","RemoveEntities","UpsertEntities","UpsertManyEntities","storeClass","getStoreByName","getEntityStore","getEntityStoreByName","arrayUpdate","predicateOrIds","condition","item","arrayAdd","toArr","tslib_1.__spread","byKey","TrackIdChanges","subscriber","currId","selectEntityIdChanges$","change","tap","ngZoneOrOptions","__REDUX_DEVTOOLS_EXTENSION__","run","shallow","storesWhitelist","devTools","connect","appState","isAllowed","send","normalize","msg","logTrace","group","trace","groupEnd","sortAlphabetically","sortedAppState","payload","init","rootState_1","identifier","identifiers","filterFn","pred","newValue","compare","findIndex","oldValue","entityIsObject","request$","emitNext","EMPTY","observables","random","toString","parseFloat","enableInNonBrowser","storage","deserialize","serialize","include","persistOnDestroy","preStorageUpdate","preStoreUpdate","preStorageUpdateOperator","includeStores","selectStores","hasInclude","hasSelect","fns","selectFn","subscriptions","buffer","isLocalStorage","sessionStorage","hasSessionStorage","getItem","storageState","save","storeCache","setItem","_save","shift","Promise","setInitial","exclude","stores_1","stores_1_1","storeClassOrName","operation","bind","defer","finalize","lift"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { IDS } from './types';\n\nexport interface StoreSnapshotAction {\n  type: string | null;\n  entityIds: IDS[] | null;\n  skip: boolean;\n}\n\nexport const currentAction: StoreSnapshotAction = {\n  type: null,\n  entityIds: null,\n  skip: false,\n};\n\nlet customActionActive = false;\n\nexport function resetCustomAction() {\n  customActionActive = false;\n}\n\n// public API for custom actions. Custom action always wins\nexport function logAction(type: string, entityIds?) {\n  setAction(type, entityIds);\n  customActionActive = true;\n}\n\nexport function setAction(type: string, entityIds?) {\n  if (customActionActive === false) {\n    currentAction.type = type;\n    currentAction.entityIds = entityIds;\n  }\n}\n\nexport function setSkipAction(skip = true) {\n  currentAction.skip = skip;\n}\n\nexport function action(action: string, entityIds?) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n      logAction(action, entityIds);\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n","import { EntityState, ID } from './index';\n\n// @internal\nexport function hasEntity<E>(entities: EntityState<E>, id: ID) {\n  return entities.hasOwnProperty(id);\n}\n","import { EntityState, PreAddEntity } from './types';\nimport { hasEntity } from './hasEntity';\n\nexport type AddEntitiesParams<State, Entity> = {\n  state: State;\n  entities: Entity[];\n  idKey: string;\n  options: AddEntitiesOptions;\n  preAddEntity: PreAddEntity<Entity>;\n};\n\nexport type AddEntitiesOptions = { prepend?: boolean; loading?: boolean };\n\n// @internal\nexport function addEntities<S extends EntityState<E>, E>({ state, entities, idKey, options = {}, preAddEntity }: AddEntitiesParams<S, E>) {\n  let newEntities = {};\n  let newIds = [];\n  let hasNewEntities = false;\n\n  for (const entity of entities) {\n    if (hasEntity(state.entities, entity[idKey]) === false) {\n      // evaluate the middleware first to support dynamic ids\n      const current = preAddEntity(entity);\n      const entityId = current[idKey];\n      newEntities[entityId] = current;\n      if (options.prepend) newIds.unshift(entityId);\n      else newIds.push(entityId);\n\n      hasNewEntities = true;\n    }\n  }\n\n  return hasNewEntities\n    ? {\n        newState: {\n          ...state,\n          entities: {\n            ...state.entities,\n            ...newEntities\n          },\n          ids: options.prepend ? [...newIds, ...state.ids] : [...state.ids, ...newIds]\n        },\n        newIds\n      }\n    : null;\n}\n","// @internal\nexport function isNil(v) {\n  return v === null || v === undefined;\n}\n","import { isNil } from './isNil';\n\n// @internal\nexport function coerceArray<T>(value: T | T[]): T[] {\n  if (isNil(value)) {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\n","export enum EntityActions {\n  Set = 'Set',\n  Add = 'Add',\n  Update = 'Update',\n  Remove = 'Remove',\n}\n\nexport interface EntityAction<IDType> {\n  type: EntityActions;\n  ids: IDType[];\n}\n","export const isBrowser = typeof window !== 'undefined';\nexport const isNotBrowser = !isBrowser;\n// export const isNativeScript = typeof global !== 'undefined' && (<any>global).__runtimeVersion !== 'undefined'; TODO is this used?\nexport const hasLocalStorage = () => {\n  try {\n    return typeof localStorage !== 'undefined';\n  } catch {\n    return false;\n  }\n};\nexport const hasSessionStorage = () => {\n  try {\n    return typeof sessionStorage !== 'undefined';\n  } catch {\n    return false;\n  }\n};\n","import { isBrowser } from './root';\n\nexport let __DEV__ = true;\n\nexport function enableAkitaProdMode() {\n  __DEV__ = false;\n  if (isBrowser) {\n    delete (window as any).$$stores;\n    delete (window as any).$$queries;\n  }\n}\n\n// @internal\nexport function isDev() {\n  return __DEV__;\n}\n","// @internal\nexport function isObject(value: any) {\n  const type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n","// @internal\nexport function isArray<T>(value: any): value is T[] {\n  return Array.isArray(value);\n}\n","import { ID, IDS } from './types';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { isArray } from './isArray';\n\nexport type SetActiveOptions = { prev?: boolean; next?: boolean; wrap?: boolean };\n\n// @internal\nexport function getActiveEntities(idOrOptions: IDS | SetActiveOptions | null, ids: ID[], currentActive: IDS | null) {\n  let result;\n\n  if (isArray(idOrOptions)) {\n    result = idOrOptions;\n  } else {\n    if (isObject(idOrOptions)) {\n      if (isNil(currentActive)) return;\n      (idOrOptions as SetActiveOptions) = Object.assign({ wrap: true }, idOrOptions);\n      const currentIdIndex = ids.indexOf(currentActive as ID);\n      if ((idOrOptions as SetActiveOptions).prev) {\n        const isFirst = currentIdIndex === 0;\n        if (isFirst && !(idOrOptions as SetActiveOptions).wrap) return;\n        result = isFirst ? ids[ids.length - 1] : (ids[currentIdIndex - 1] as any);\n      } else if ((idOrOptions as SetActiveOptions).next) {\n        const isLast = ids.length === currentIdIndex + 1;\n        if (isLast && !(idOrOptions as SetActiveOptions).wrap) return;\n        result = isLast ? ids[0] : (ids[currentIdIndex + 1] as any);\n      }\n    } else {\n      if (idOrOptions === currentActive) return;\n      result = idOrOptions as ID;\n    }\n  }\n\n  return result;\n}\n","import { EntityState } from './index';\n\n// @internal\nexport const getInitialEntitiesState = () =>\n  ({\n    entities: {},\n    ids: [],\n    loading: true,\n    error: null\n  } as EntityState);\n","import { isNil } from './isNil';\n\n// @internal\nexport function isDefined(val: any) {\n  return isNil(val) === false;\n}\n","import { isArray } from './isArray';\n\n// @internal\nexport function isEmpty<T>(arr: T) {\n  if (isArray(arr)) {\n    return arr.length === 0;\n  }\n  return false;\n}\n","// @internal\nexport function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n","// @internal\nexport function isUndefined(value: any): value is undefined {\n  return value === undefined;\n}\n","import { ActiveState, EntityState, ID, IDS, MultiActiveState } from './types';\nimport { hasEntity } from './hasEntity';\nimport { isArray } from './isArray';\n\n// @internal\nexport function hasActiveState<E>(state: EntityState<E>): state is EntityState<E> & (ActiveState | MultiActiveState) {\n  return state.hasOwnProperty('active');\n}\n\n// @internal\nexport function isMultiActiveState(active: IDS): active is ID[] {\n  return isArray(active);\n}\n\n// @internal\nexport function resolveActiveEntity<E>({ active, ids, entities }: EntityState<E> & (ActiveState | MultiActiveState)) {\n  if (isMultiActiveState(active)) {\n    return getExitingActives(active, ids);\n  }\n\n  if (hasEntity(entities, active) === false) {\n    return null;\n  }\n\n  return active;\n}\n\n// @internal\nexport function getExitingActives(currentActivesIds: ID[], newIds: ID[]) {\n  const filtered = currentActivesIds.filter(id => newIds.indexOf(id) > -1);\n  /** Return the same reference if nothing has changed */\n  if (filtered.length === currentActivesIds.length) {\n    return currentActivesIds;\n  }\n\n  return filtered;\n}\n","import { EntityState, ID, StateWithActive } from './types';\nimport { isNil } from './isNil';\nimport { hasActiveState, isMultiActiveState, resolveActiveEntity } from './activeState';\n\nexport type RemoveEntitiesParams<State, Entity> = {\n  state: StateWithActive<State>;\n  ids: any[];\n};\n\n// @internal\nexport function removeEntities<S extends EntityState<E>, E>({ state, ids }: RemoveEntitiesParams<S, E>): S {\n  if (isNil(ids)) return removeAllEntities(state);\n  const entities = state.entities;\n  let newEntities = {};\n\n  for (const id of state.ids) {\n    if (ids.includes(id) === false) {\n      newEntities[id] = entities[id];\n    }\n  }\n\n  const newState = {\n    ...state,\n    entities: newEntities,\n    ids: state.ids.filter(current => ids.includes(current) === false)\n  };\n\n  if (hasActiveState(state)) {\n    newState.active = resolveActiveEntity(newState);\n  }\n\n  return newState;\n}\n\n// @internal\nexport function removeAllEntities<S>(state: StateWithActive<S>): S {\n  return {\n    ...state,\n    entities: {},\n    ids: [],\n    active: isMultiActiveState(state.active) ? [] : null\n  };\n}\n","import { PreAddEntity } from './types';\n\n// @internal\nexport function toEntitiesObject<E>(entities: E[], idKey: string, preAddEntity: PreAddEntity<E>) {\n  const acc = {\n    entities: {},\n    ids: []\n  };\n\n  for (const entity of entities) {\n    // evaluate the middleware first to support dynamic ids\n    const current = preAddEntity(entity);\n    acc.entities[current[idKey]] = current;\n    acc.ids.push(current[idKey]);\n  }\n\n  return acc;\n}\n","import { Entities, EntityState, HashMap, ID, PreAddEntity } from './types';\nimport { toEntitiesObject } from './toEntitiesObject';\nimport { isArray } from './isArray';\nimport { hasActiveState, resolveActiveEntity } from './activeState';\n\nexport type SetEntities<Entity> = Entity[] | Entities<Entity> | HashMap<Entity>;\n\nexport type SetEntitiesParams<State, Entity> = {\n  state: State;\n  entities: SetEntities<Entity>;\n  idKey: string;\n  preAddEntity: PreAddEntity<Entity>;\n  isNativePreAdd?: boolean;\n};\n\n// @internal\nexport function isEntityState<Entity>(state): state is Entities<Entity> {\n  return state.entities && state.ids;\n}\n\n// @internal\nfunction applyMiddleware<E>(entities: HashMap<E>, preAddEntity: PreAddEntity<E>) {\n  let mapped = {};\n  for (const id of Object.keys(entities)) {\n    mapped[id] = preAddEntity(entities[id]);\n  }\n\n  return mapped;\n}\n\n// @internal\nexport function setEntities<S extends EntityState<E>, E>({ state, entities, idKey, preAddEntity, isNativePreAdd }: SetEntitiesParams<S, E>): S {\n  let newEntities: HashMap<E>;\n  let newIds: ID[];\n\n  if (isArray(entities)) {\n    const resolve = toEntitiesObject(entities, idKey, preAddEntity);\n    newEntities = resolve.entities;\n    newIds = resolve.ids;\n  } else if (isEntityState(entities)) {\n    newEntities = isNativePreAdd ? entities.entities : applyMiddleware(entities.entities, preAddEntity);\n    newIds = entities.ids;\n  } else {\n    // it's an object\n    newEntities = isNativePreAdd ? entities : applyMiddleware(entities, preAddEntity);\n    newIds = Object.keys(newEntities).map(id => (isNaN(id as any) ? id : Number(id)));\n  }\n\n  const newState = {\n    ...state,\n    entities: newEntities,\n    ids: newIds,\n    loading: false\n  };\n\n  if (hasActiveState(state)) {\n    (newState as any).active = resolveActiveEntity(newState as any);\n  }\n\n  return newState;\n}\n","export interface AkitaConfig {\n  /**\n   * Whether to allowed the reset() stores functionality\n   */\n  resettable?: boolean;\n  ttl?: number;\n  producerFn?: (state: any, fn: any) => any;\n}\n\nlet CONFIG: AkitaConfig = {\n  resettable: false,\n  ttl: null,\n  producerFn: undefined\n};\n\nexport function akitaConfig(config: AkitaConfig) {\n  CONFIG = { ...CONFIG, ...config };\n}\n\n// @internal\nexport function getAkitaConfig() {\n  return CONFIG;\n}\n\nexport function getGlobalProducerFn() {\n  return CONFIG.producerFn;\n}\n","// @internal\nexport function deepFreeze(o) {\n  Object.freeze(o);\n\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      hasOwnProp.call(o, prop) &&\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n","import { ReplaySubject, Subject } from 'rxjs';\nimport { StoreSnapshotAction } from './actions';\n\n// @internal\nexport const $$deleteStore = new Subject<string>();\n// @internal\nexport const $$addStore = new ReplaySubject<string>(50, 5000);\n// @internal\nexport const $$updateStore = new Subject<{ storeName: string; action: StoreSnapshotAction }>();\n\n// @internal\nexport function dispatchDeleted(storeName: string) {\n  $$deleteStore.next(storeName);\n}\n\n// @internal\nexport function dispatchAdded(storeName: string) {\n  $$addStore.next(storeName);\n}\n\n// @internal\nexport function dispatchUpdate(storeName: string, action: StoreSnapshotAction) {\n  $$updateStore.next({ storeName, action });\n}\n","// @internal\nexport class AkitaError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n// @internal\nexport function assertStoreHasName(name: string, className: string) {\n  if (!name) {\n    console.error(`@StoreConfig({ name }) is missing in ${className}`);\n  }\n}\n","// @internal\nexport function toBoolean(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","import { toBoolean } from './toBoolean';\n\n// @internal\nexport function isPlainObject(value) {\n  return toBoolean(value) && value.constructor.name === 'Object';\n}\n","import { Query } from './query';\nimport { isBrowser } from './root';\nimport { Store } from './store';\n\n// @internal\nexport const __stores__: { [storeName: string]: Store<any> } = {};\n\n// @internal\nexport const __queries__: { [storeName: string]: Query<any> } = {};\n\nif (isBrowser) {\n  (window as any).$$stores = __stores__;\n  (window as any).$$queries = __queries__;\n}\n","import { BehaviorSubject, Observable, of, Subject } from 'rxjs';\nimport { logAction } from './actions';\nimport { tap } from 'rxjs/operators';\n\n// @internal\nconst transactionFinished = new Subject();\n\n// @internal\nconst transactionInProcess = new BehaviorSubject(false);\n\nexport type TransactionManager = {\n  activeTransactions: number;\n  batchTransaction: Subject<boolean> | null;\n};\n\n// @internal\nexport const transactionManager: TransactionManager = {\n  activeTransactions: 0,\n  batchTransaction: null\n};\n\n// @internal\nexport function startBatch() {\n  if (!isTransactionInProcess()) {\n    transactionManager.batchTransaction = new Subject();\n  }\n  transactionManager.activeTransactions++;\n  transactionInProcess.next(true);\n}\n\n// @internal\nexport function endBatch() {\n  if (--transactionManager.activeTransactions === 0) {\n    transactionManager.batchTransaction.next(true);\n    transactionManager.batchTransaction.complete();\n    transactionInProcess.next(false);\n    transactionFinished.next(true);\n  }\n}\n\n// @internal\nexport function isTransactionInProcess() {\n  return transactionManager.activeTransactions > 0;\n}\n\n// @internal\nexport function commit(): Observable<boolean> {\n  return transactionManager.batchTransaction ? transactionManager.batchTransaction.asObservable() : of(true);\n}\n\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *  The following code will update the store, BUT  emits only once\n *\n *  @example\n *  applyTransaction(() => {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  });\n *\n */\nexport function applyTransaction<T>(action: () => T, thisArg = undefined): T {\n  startBatch();\n  try {\n    return action.apply(thisArg);\n  } finally {\n    logAction('@Transaction');\n    endBatch();\n  }\n}\n\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *\n *  The following code will update the store, BUT  emits only once.\n *\n *  @example\n *  @transaction\n *  addTodos() {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  }\n *\n *\n */\nexport function transaction() {\n  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function(...args) {\n      return applyTransaction(() => {\n        return originalMethod.apply(this, args);\n      }, this);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n *\n * RxJS custom operator that wraps the callback inside transaction\n *\n * @example\n *\n * return http.get().pipe(\n *    withTransaction(response > {\n *      store.setActive(1);\n *      store.update();\n *      store.updateEntity(1, {});\n *    })\n * )\n *\n */\nexport function withTransaction<T>(next: (value: T) => void) {\n  return function(source: Observable<T>): Observable<T> {\n    return source.pipe(tap(value => applyTransaction(() => next(value))));\n  };\n}\n","import { BehaviorSubject, Observable } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { currentAction, resetCustomAction, setAction, StoreSnapshotAction } from './actions';\nimport { getAkitaConfig, getGlobalProducerFn } from './config';\nimport { deepFreeze } from './deepFreeze';\nimport { dispatchAdded, dispatchDeleted, dispatchUpdate } from './dispatchers';\nimport { __DEV__, isDev } from './env';\nimport { assertStoreHasName } from './errors';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isPlainObject } from './isPlainObject';\nimport { isBrowser } from './root';\nimport { configKey, StoreConfigOptions, UpdatableStoreConfigOptions } from './storeConfig';\nimport { __stores__ } from './stores';\nimport { commit, isTransactionInProcess } from './transaction';\nimport { StoreCache, UpdateStateCallback } from './types';\n\ninterface StoreSnapshot<S> {\n  state: S;\n  action?: StoreSnapshotAction;\n}\n\n/**\n *\n * Store for managing any type of data\n *\n * @example\n *\n * export interface SessionState {\n *   token: string;\n *   userDetails: UserDetails\n * }\n *\n * export function createInitialState(): SessionState {\n *  return {\n *    token: '',\n *    userDetails: null\n *  };\n * }\n *\n * @StoreConfig({ name: 'session' })\n * export class SessionStore extends Store<SessionState> {\n *   constructor() {\n *    super(createInitialState());\n *   }\n * }\n */\nexport class Store<S = any> {\n  private store: BehaviorSubject<Readonly<StoreSnapshot<S>>>;\n  private storeValue: S;\n  private inTransaction = false;\n  private _initialState: S;\n  protected cache: StoreCache = {\n    active: new BehaviorSubject<boolean>(false),\n    ttl: null,\n  };\n\n  constructor(initialState: Partial<S>, protected options: Partial<StoreConfigOptions> = {}) {\n    this.onInit(initialState as S);\n  }\n\n  /**\n   *  Set the loading state\n   *\n   *  @example\n   *\n   *  store.setLoading(true)\n   *\n   */\n  setLoading(loading = false) {\n    if (loading !== (this._value() as S & { loading: boolean }).loading) {\n      isDev() && setAction('Set Loading');\n      this._setState((state) => ({ ...state, loading } as S & { loading: boolean }));\n    }\n  }\n\n  /**\n   *\n   * Set whether the data is cached\n   *\n   * @example\n   *\n   * store.setHasCache(true)\n   * store.setHasCache(false)\n   * store.setHasCache(true, { restartTTL: true })\n   *\n   */\n  setHasCache(hasCache: boolean, options: { restartTTL: boolean } = { restartTTL: false }) {\n    if (hasCache !== this.cache.active.value) {\n      this.cache.active.next(hasCache);\n    }\n\n    if (options.restartTTL) {\n      const ttlConfig = this.getCacheTTL();\n      if (ttlConfig) {\n        if (this.cache.ttl !== null) {\n          clearTimeout(this.cache.ttl);\n        }\n        this.cache.ttl = <any>setTimeout(() => this.setHasCache(false), ttlConfig);\n      }\n    }\n  }\n\n  /**\n   *\n   * Sometimes we need to access the store value from a store\n   *\n   * @example middleware\n   *\n   */\n  getValue() {\n    return this.storeValue;\n  }\n\n  /**\n   *  Set the error state\n   *\n   *  @example\n   *\n   *  store.setError({text: 'unable to load data' })\n   *\n   */\n  setError<T>(error: T) {\n    if (error !== (this._value() as S & { error: any }).error) {\n      isDev() && setAction('Set Error');\n      this._setState((state) => ({ ...state, error } as S & { error: any }));\n    }\n  }\n\n  // @internal\n  _select<R>(project: (store: S) => R): Observable<R> {\n    return this.store.asObservable().pipe(\n      map((snapshot) => project(snapshot.state)),\n      distinctUntilChanged()\n    );\n  }\n\n  // @internal\n  _value(): S {\n    return this.storeValue;\n  }\n\n  // @internal\n  _cache(): BehaviorSubject<boolean> {\n    return this.cache.active;\n  }\n\n  // @internal\n  get config(): StoreConfigOptions {\n    return this.constructor[configKey] || {};\n  }\n\n  // @internal\n  get storeName() {\n    return (this.config as StoreConfigOptions & { storeName: string }).storeName || (this.options as StoreConfigOptions & { storeName: string }).storeName || this.options.name;\n  }\n\n  // @internal\n  get deepFreeze() {\n    return this.config.deepFreezeFn || this.options.deepFreezeFn || deepFreeze;\n  }\n\n  // @internal\n  get cacheConfig() {\n    return this.config.cache || this.options.cache;\n  }\n\n  get _producerFn() {\n    return this.config.producerFn || this.options.producerFn || getGlobalProducerFn();\n  }\n\n  // @internal\n  get resettable() {\n    return isDefined(this.config.resettable) ? this.config.resettable : this.options.resettable;\n  }\n\n  // @internal\n  _setState(newState: ((state: Readonly<S>) => S) | S, _dispatchAction = true) {\n    if (isFunction(newState)) {\n      const _newState = newState(this._value());\n      this.storeValue = __DEV__ ? this.deepFreeze(_newState) : _newState;\n    } else {\n      this.storeValue = newState;\n    }\n\n    if (!this.store) {\n      this.store = new BehaviorSubject({ state: this.storeValue });\n\n      if (isDev()) {\n        this.store.subscribe(({ action }) => {\n          if (action) {\n            dispatchUpdate(this.storeName, action);\n          }\n        });\n      }\n\n      return;\n    }\n\n    if (isTransactionInProcess()) {\n      this.handleTransaction();\n      return;\n    }\n\n    this.dispatch(this.storeValue, _dispatchAction);\n  }\n\n  /**\n   *\n   * Reset the current store back to the initial value\n   *\n   * @example\n   *\n   * store.reset()\n   *\n   */\n  reset() {\n    if (this.isResettable()) {\n      isDev() && setAction('Reset');\n      this._setState(() => Object.assign({}, this._initialState));\n      this.setHasCache(false);\n    } else {\n      isDev() && console.warn(`You need to enable the reset functionality`);\n    }\n  }\n\n  /**\n   *\n   * Update the store's value\n   *\n   * @example\n   *\n   * this.store.update(state => {\n   *   return {...}\n   * })\n   */\n  update(stateCallback: UpdateStateCallback<S>);\n  /**\n   *\n   * @example\n   *\n   *  this.store.update({ token: token })\n   */\n  update(state: Partial<S>);\n  update(stateOrCallback: Partial<S> | UpdateStateCallback<S>) {\n    isDev() && setAction('Update');\n\n    let newState;\n    const currentState = this._value();\n    if (isFunction(stateOrCallback)) {\n      newState = isFunction(this._producerFn) ? this._producerFn(currentState, stateOrCallback) : stateOrCallback(currentState);\n    } else {\n      newState = stateOrCallback;\n    }\n\n    const withHook = this.akitaPreUpdate(currentState, { ...currentState, ...newState } as S);\n    const resolved = isPlainObject(currentState) ? withHook : new (currentState as any).constructor(withHook);\n    this._setState(resolved);\n  }\n\n  updateStoreConfig(newOptions: UpdatableStoreConfigOptions) {\n    this.options = { ...this.options, ...newOptions };\n  }\n\n  // @internal\n  akitaPreUpdate(_: Readonly<S>, nextState: Readonly<S>): S {\n    return nextState;\n  }\n\n  ngOnDestroy() {\n    this.destroy();\n  }\n\n  /**\n   *\n   * Destroy the store\n   *\n   * @example\n   *\n   * store.destroy()\n   *\n   */\n  destroy() {\n    const hmrEnabled = isBrowser ? (window as any).hmrEnabled : false;\n    if (!hmrEnabled && this === __stores__[this.storeName]) {\n      delete __stores__[this.storeName];\n      dispatchDeleted(this.storeName);\n      this.setHasCache(false);\n      this.cache.active.complete();\n      this.store.complete();\n    }\n  }\n\n  private onInit(initialState: S) {\n    __stores__[this.storeName] = this;\n    this._setState(() => initialState);\n    dispatchAdded(this.storeName);\n    if (this.isResettable()) {\n      this._initialState = initialState;\n    }\n    isDev() && assertStoreHasName(this.storeName, this.constructor.name);\n  }\n\n  private dispatch(state: S, _dispatchAction = true) {\n    let action: StoreSnapshotAction | undefined = undefined;\n\n    if (_dispatchAction) {\n      action = currentAction;\n      resetCustomAction();\n    }\n\n    this.store.next({ state, action });\n  }\n\n  private watchTransaction() {\n    commit().subscribe(() => {\n      this.inTransaction = false;\n      this.dispatch(this._value());\n    });\n  }\n\n  private isResettable() {\n    if (this.resettable === false) {\n      return false;\n    }\n    return this.resettable || getAkitaConfig().resettable;\n  }\n\n  private handleTransaction() {\n    if (!this.inTransaction) {\n      this.watchTransaction();\n      this.inTransaction = true;\n    }\n  }\n\n  private getCacheTTL() {\n    return (this.cacheConfig && this.cacheConfig.ttl) || getAkitaConfig().ttl;\n  }\n}\n","import { Subject } from 'rxjs';\nimport { EntityState, ID, PreUpdateEntity, UpdateStateCallback } from './types';\nimport { isFunction } from './isFunction';\nimport { hasEntity } from './hasEntity';\nimport { isPlainObject } from './isPlainObject';\n\nexport type UpdateEntitiesParams<State, Entity> = {\n  state: State;\n  ids: any[];\n  idKey: string;\n  newStateOrFn: UpdateStateCallback<Entity> | Partial<Entity> | Partial<State>;\n  preUpdateEntity: PreUpdateEntity<Entity>;\n  producerFn;\n  onEntityIdChanges: (oldId: any, newId: any) => void;\n};\n\n// @internal\nexport function updateEntities<S extends EntityState<E>, E>({ state, ids, idKey, newStateOrFn, preUpdateEntity, producerFn, onEntityIdChanges }: UpdateEntitiesParams<S, E>) {\n  const updatedEntities = {};\n\n  let isUpdatingIdKey = false;\n  let idToUpdate: ID;\n\n  for (const id of ids) {\n    // if the entity doesn't exist don't do anything\n    if (hasEntity(state.entities, id) === false) {\n      continue;\n    }\n\n    const oldEntity = state.entities[id];\n    let newState;\n    if (isFunction(newStateOrFn)) {\n      newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);\n    } else {\n      newState = newStateOrFn;\n    }\n\n    const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];\n    let newEntity: E;\n    idToUpdate = id;\n\n    if (isIdChanged) {\n      isUpdatingIdKey = true;\n      idToUpdate = newState[idKey];\n    }\n\n    const merged = {\n      ...oldEntity,\n      ...newState,\n    };\n\n    if (isPlainObject(oldEntity)) {\n      newEntity = merged;\n    } else {\n      /**\n       * In case that new state is class of it's own, there's\n       * a possibility that it will be different than the old\n       * class.\n       * For example, Old state is an instance of animal class\n       * and new state is instance of person class.\n       * To avoid run over new person class with the old animal\n       * class we check if the new state is a class of it's own.\n       * If so, use it. Otherwise, use the old state class\n       */\n      if (isPlainObject(newState)) {\n        newEntity = new (oldEntity as any).constructor(merged);\n      } else {\n        newEntity = new (newState as any).constructor(merged);\n      }\n    }\n\n    updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);\n  }\n\n  let updatedIds = state.ids;\n  let stateEntities = state.entities;\n\n  if (isUpdatingIdKey) {\n    const [id] = ids;\n    const { [id]: deletedEntity, ...rest } = state.entities;\n    stateEntities = rest;\n    updatedIds = state.ids.map((current) => (current === id ? idToUpdate : current));\n    onEntityIdChanges(id, idToUpdate);\n  }\n\n  return {\n    ...state,\n    entities: {\n      ...stateEntities,\n      ...updatedEntities,\n    },\n    ids: updatedIds,\n  };\n}\n","export enum Order {\n  ASC = 'asc',\n  DESC = 'desc'\n}\n\n// @internal\nexport function compareValues(key, order: Order = Order.ASC) {\n  return function(a, b) {\n    if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {\n      return 0;\n    }\n\n    const varA = typeof a[key] === 'string' ? a[key].toUpperCase() : a[key];\n    const varB = typeof b[key] === 'string' ? b[key].toUpperCase() : b[key];\n\n    let comparison = 0;\n    if (varA > varB) {\n      comparison = 1;\n    } else if (varA < varB) {\n      comparison = -1;\n    }\n    return order == Order.DESC ? comparison * -1 : comparison;\n  };\n}\n","import { Subject } from 'rxjs';\nimport { logAction, setAction } from './actions';\nimport { addEntities, AddEntitiesOptions } from './addEntities';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { EntityAction, EntityActions } from './entityActions';\nimport { isDev } from './env';\nimport { getActiveEntities, SetActiveOptions } from './getActiveEntities';\nimport { getInitialEntitiesState } from './getInitialEntitiesState';\nimport { hasEntity } from './hasEntity';\nimport { isDefined } from './isDefined';\nimport { isEmpty } from './isEmpty';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isUndefined } from './isUndefined';\nimport { removeEntities } from './removeEntities';\nimport { SetEntities, setEntities } from './setEntities';\nimport { Store } from './store';\nimport { StoreConfigOptions } from './storeConfig';\nimport { transaction } from './transaction';\nimport {\n  Constructor,\n  CreateStateCallback,\n  EntityState,\n  EntityUICreateFn,\n  getEntityType,\n  getIDType,\n  IDS,\n  OrArray,\n  StateWithActive,\n  UpdateEntityPredicate,\n  UpdateStateCallback,\n  UpsertStateCallback,\n} from './types';\nimport { updateEntities } from './updateEntities';\n\n/**\n *\n * Store for managing a collection of entities\n *\n * @example\n *\n * export interface WidgetsState extends EntityState<Widget> { }\n *\n * @StoreConfig({ name: 'widgets' })\n *  export class WidgetsStore extends EntityStore<WidgetsState> {\n *   constructor() {\n *     super();\n *   }\n * }\n *\n *\n */\nexport class EntityStore<S extends EntityState = any, EntityType = getEntityType<S>, IDType = getIDType<S>> extends Store<S> {\n  ui: EntityUIStore<any, EntityType>;\n  private entityActions = new Subject<EntityAction<IDType>>();\n  private entityIdChanges = new Subject<{ newId: IDType; oldId: IDType; pending: boolean }>();\n\n  constructor(initialState: Partial<S> = {}, protected options: Partial<StoreConfigOptions> = {}) {\n    super({ ...getInitialEntitiesState(), ...initialState }, options);\n  }\n\n  // @internal\n  get selectEntityAction$() {\n    return this.entityActions.asObservable();\n  }\n\n  // @internal\n  get selectEntityIdChanges$() {\n    return this.entityIdChanges.asObservable();\n  }\n\n  // @internal\n  get idKey() {\n    return (this.config as StoreConfigOptions).idKey || this.options.idKey || DEFAULT_ID_KEY;\n  }\n\n  /**\n   *\n   * Replace current collection with provided collection\n   *\n   * @example\n   *\n   * this.store.set([Entity, Entity])\n   * this.store.set({ids: [], entities: {}})\n   * this.store.set({ 1: {}, 2: {}})\n   *\n   */\n  set(entities: SetEntities<EntityType>, options: { activeId?: IDType | null } = {}) {\n    if (isNil(entities)) return;\n\n    isDev() && setAction('Set Entity');\n\n    const isNativePreAdd = this.akitaPreAddEntity === EntityStore.prototype.akitaPreAddEntity;\n    this.setHasCache(true, { restartTTL: true });\n\n    this._setState((state) => {\n      const newState = setEntities({\n        state,\n        entities,\n        idKey: this.idKey,\n        preAddEntity: this.akitaPreAddEntity,\n        isNativePreAdd,\n      });\n\n      if (isUndefined(options.activeId) === false) {\n        (newState as any).active = options.activeId;\n      }\n\n      return newState;\n    });\n\n    if (this.hasInitialUIState()) {\n      this.handleUICreation();\n    }\n\n    this.entityActions.next({ type: EntityActions.Set, ids: this.ids });\n  }\n\n  /**\n   * Add entities\n   *\n   * @example\n   *\n   * this.store.add([Entity, Entity])\n   * this.store.add(Entity)\n   * this.store.add(Entity, { prepend: true })\n   *\n   * this.store.add(Entity, { loading: false })\n   */\n  add(entities: OrArray<EntityType>, options: AddEntitiesOptions = { loading: false }) {\n    const collection = coerceArray(entities);\n\n    if (isEmpty(collection)) return;\n\n    const data = addEntities({\n      state: this._value(),\n      preAddEntity: this.akitaPreAddEntity,\n      entities: collection,\n      idKey: this.idKey,\n      options,\n    });\n\n    if (data) {\n      isDev() && setAction('Add Entity');\n      data.newState.loading = options.loading;\n\n      this._setState(() => data.newState);\n\n      if (this.hasInitialUIState()) {\n        this.handleUICreation(true);\n      }\n\n      this.entityActions.next({ type: EntityActions.Add, ids: data.newIds });\n    }\n  }\n\n  /**\n   *\n   * Update entities\n   *\n   * @example\n   *\n   * store.update(1, entity => ...)\n   * store.update([1, 2, 3], entity => ...)\n   * store.update(null, entity => ...)\n   */\n  update(id: OrArray<IDType> | null, newStateFn: UpdateStateCallback<EntityType>);\n  /**\n   * store.update(1, { name: newName })\n   */\n  update(id: OrArray<IDType> | null, newState: Partial<EntityType>);\n  /**\n   * store.update(entity => entity.price > 3, entity => ({ name: newName }))\n   */\n  update(predicate: UpdateEntityPredicate<EntityType>, newStateFn: UpdateStateCallback<EntityType>);\n  /**\n   * store.update(entity => entity.price > 3, { name: newName })\n   */\n  update(predicate: UpdateEntityPredicate<EntityType>, newState: Partial<EntityType>);\n  /** Support non-entity updates */\n  update(newState: UpdateStateCallback<S>);\n  update(newState: Partial<S>);\n  update(\n    idsOrFnOrState: OrArray<IDType> | null | Partial<S> | UpdateStateCallback<S> | UpdateEntityPredicate<EntityType>,\n    newStateOrFn?: UpdateStateCallback<EntityType> | Partial<EntityType> | Partial<S>\n  ) {\n    if (isUndefined(newStateOrFn)) {\n      super.update(idsOrFnOrState as Partial<S>);\n      return;\n    }\n    let ids: IDType[] = [];\n\n    if (isFunction(idsOrFnOrState)) {\n      // We need to filter according the predicate function\n      ids = this.ids.filter((id) => (idsOrFnOrState as UpdateEntityPredicate<EntityType>)(this.entities[id]));\n    } else {\n      // If it's nil we want all of them\n      ids = isNil(idsOrFnOrState) ? this.ids : coerceArray(idsOrFnOrState as OrArray<IDType>);\n    }\n\n    if (isEmpty(ids)) return;\n\n    isDev() && setAction('Update Entity', ids);\n\n    let entityIdChanged:\n      | undefined\n      | {\n          newId: IDType;\n          oldId: IDType;\n        };\n\n    this._setState((state) =>\n      updateEntities({\n        idKey: this.idKey,\n        ids,\n        preUpdateEntity: this.akitaPreUpdateEntity,\n        state,\n        newStateOrFn,\n        producerFn: this._producerFn,\n        onEntityIdChanges: (oldId: IDType, newId: IDType) => {\n          entityIdChanged = { oldId, newId };\n          this.entityIdChanges.next({ ...entityIdChanged, pending: true });\n        },\n      })\n    );\n\n    if (entityIdChanged) {\n      this.entityIdChanges.next({ ...entityIdChanged, pending: false });\n    }\n\n    this.entityActions.next({ type: EntityActions.Update, ids });\n  }\n\n  /**\n   *\n   * Create or update.\n   *\n   * Warning: By omitting the initializing callback parameter onCreate(), the type safety of entities cannot be guaranteed.\n   *\n   * @example\n   *\n   * store.upsert(1, { active: true });\n   * store.upsert([2, 3], { active: true });\n   * store.upsert([2, 3], entity => ({ isOpen: !(entity?.isOpen ?? true) }))\n   *\n   */\n  upsert<NewEntityType extends Partial<EntityType>>(ids: OrArray<IDType>, newState: UpsertStateCallback<EntityType, NewEntityType> | NewEntityType, options?: { baseClass?: Constructor }): void;\n  /**\n   *\n   * Create or update\n   *\n   * @example\n   *\n   * store.upsert(1, { active: true }, (id, newState) => ({ id, ...newState, enabled: true }));\n   * store.upsert([2, 3], { active: true }, (id, newState) => ({ id, ...newState, enabled: true }));\n   * store.upsert([2, 3], entity => ({ isOpen: !(entity?.isOpen ?? true) }), (id, newState) => ({ id, ...newState, enabled: true }));\n   *\n   */\n  upsert<NewEntityType extends Partial<EntityType>>(\n    ids: OrArray<IDType>,\n    newState: UpsertStateCallback<EntityType, NewEntityType> | NewEntityType,\n    onCreate: CreateStateCallback<EntityType, NewEntityType, IDType>,\n    options?: { baseClass?: Constructor }\n  ): void;\n  @transaction()\n  upsert<NewEntityType extends Partial<EntityType>>(\n    ids: OrArray<IDType>,\n    newState: UpsertStateCallback<EntityType, NewEntityType> | NewEntityType,\n    onCreate?: CreateStateCallback<EntityType, NewEntityType, IDType> | { baseClass?: Constructor },\n    options: { baseClass?: Constructor } = {}\n  ) {\n    const toArray = coerceArray(ids);\n    const predicate = (isUpdate) => (id) => hasEntity(this.entities, id) === isUpdate;\n    const baseClass = isFunction(onCreate) ? options.baseClass : onCreate ? onCreate.baseClass : undefined;\n    const isClassBased = isFunction(baseClass);\n\n    const updateIds = toArray.filter(predicate(true));\n    const newEntities = toArray.filter(predicate(false)).map((id) => {\n      const newStateObj = typeof newState === 'function' ? newState({}) : newState;\n      const entity = isFunction(onCreate) ? onCreate(id, newStateObj) : newStateObj;\n      const withId = { ...entity, [this.idKey]: id };\n      if (isClassBased) {\n        return new baseClass(withId);\n      }\n      return withId;\n    });\n\n    // it can be any of the three types\n    this.update(updateIds, newState as UpdateStateCallback<EntityType, NewEntityType>);\n    this.add(newEntities);\n    isDev() && logAction('Upsert Entity');\n  }\n\n  /**\n   *\n   * Upsert entity collection (idKey must be present)\n   *\n   * @example\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }]);\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });\n   *\n   */\n  upsertMany(entities: EntityType[], options: { baseClass?: Constructor; loading?: boolean } = {}) {\n    const addedIds = [];\n    const updatedIds = [];\n    const updatedEntities = {};\n\n    // Update the state directly to optimize performance\n    for (const entity of entities) {\n      const withPreCheckHook = this.akitaPreCheckEntity(entity);\n      const id = withPreCheckHook[this.idKey];\n      if (hasEntity(this.entities, id)) {\n        const prev = this._value().entities[id];\n        const merged = { ...this._value().entities[id], ...withPreCheckHook };\n        const next = options.baseClass ? new options.baseClass(merged) : merged;\n        const withHook = this.akitaPreUpdateEntity(prev, next);\n        const nextId = withHook[this.idKey];\n        updatedEntities[nextId] = withHook;\n        updatedIds.push(nextId);\n      } else {\n        const newEntity = options.baseClass ? new options.baseClass(withPreCheckHook) : withPreCheckHook;\n        const withHook = this.akitaPreAddEntity(newEntity);\n        const nextId = withHook[this.idKey];\n        addedIds.push(nextId);\n        updatedEntities[nextId] = withHook;\n      }\n    }\n\n    isDev() && logAction('Upsert Many');\n\n    this._setState((state) => ({\n      ...state,\n      ids: addedIds.length ? [...state.ids, ...addedIds] : state.ids,\n      entities: {\n        ...state.entities,\n        ...updatedEntities,\n      },\n      loading: !!options.loading,\n    }));\n\n    updatedIds.length && this.entityActions.next({ type: EntityActions.Update, ids: updatedIds });\n    addedIds.length && this.entityActions.next({ type: EntityActions.Add, ids: addedIds });\n    if (addedIds.length && this.hasUIStore()) {\n      this.handleUICreation(true);\n    }\n  }\n\n  /**\n   *\n   * Replace one or more entities (except the id property)\n   *\n   *\n   * @example\n   *\n   * this.store.replace(5, newEntity)\n   * this.store.replace([1,2,3], newEntity)\n   */\n  replace(ids: IDS, newState: Partial<EntityType>) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    let replaced = {};\n    for (const id of toArray) {\n      newState[this.idKey] = id;\n      replaced[id] = newState;\n    }\n    isDev() && setAction('Replace Entity', ids);\n    this._setState((state) => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        ...replaced,\n      },\n    }));\n  }\n\n  /**\n   *\n   * Move entity inside the collection\n   *\n   *\n   * @example\n   *\n   * this.store.move(fromIndex, toIndex)\n   */\n  move(from: number, to: number) {\n    const ids = this.ids.slice();\n    ids.splice(to < 0 ? ids.length + to : to, 0, ids.splice(from, 1)[0]);\n\n    isDev() && setAction('Move Entity');\n    this._setState((state) => ({\n      ...state,\n      // Change the entities reference so that selectAll emit\n      entities: {\n        ...state.entities,\n      },\n      ids,\n    }));\n  }\n\n  /**\n   *\n   * Remove one or more entities\n   *\n   * @example\n   *\n   * this.store.remove(5)\n   * this.store.remove([1,2,3])\n   * this.store.remove()\n   */\n  remove(id?: OrArray<IDType>);\n  /**\n   * this.store.remove(entity => entity.id === 1)\n   */\n  remove(predicate: (entity: Readonly<EntityType>) => boolean);\n  remove(idsOrFn?: OrArray<IDType> | ((entity: Readonly<EntityType>) => boolean)) {\n    if (isEmpty(this.ids)) return;\n\n    const idPassed = isDefined(idsOrFn);\n\n    // null means remove all\n    let ids: IDType[] | null = [];\n\n    if (isFunction(idsOrFn)) {\n      ids = this.ids.filter((entityId) => idsOrFn(this.entities[entityId]));\n    } else {\n      ids = idPassed ? coerceArray(idsOrFn) : this.ids;\n    }\n\n    if (isEmpty(ids)) return;\n\n    isDev() && setAction('Remove Entity', ids);\n    this._setState((state: StateWithActive<S>) => removeEntities({ state, ids }));\n\n    if (!idPassed) {\n      this.setHasCache(false);\n    }\n\n    this.handleUIRemove(ids);\n    this.entityActions.next({ type: EntityActions.Remove, ids });\n  }\n\n  /**\n   *\n   * Update the active entity\n   *\n   * @example\n   *\n   * this.store.updateActive({ completed: true })\n   * this.store.updateActive(active => {\n   *   return {\n   *     config: {\n   *      ..active.config,\n   *      date\n   *     }\n   *   }\n   * })\n   */\n  updateActive(newStateOrCallback: UpdateStateCallback<EntityType> | Partial<EntityType>) {\n    const ids = coerceArray(this.active);\n    isDev() && setAction('Update Active', ids);\n    this.update(ids, newStateOrCallback as Partial<EntityType>);\n  }\n\n  /**\n   * Set the given entity as active\n   *\n   * @example\n   *\n   * store.setActive(1)\n   * store.setActive([1, 2, 3])\n   */\n  setActive(idOrOptions: S['active'] extends any[] ? S['active'] : SetActiveOptions | S['active']);\n  setActive(idOrOptions: IDType | SetActiveOptions | null) {\n    const active = getActiveEntities(idOrOptions, this.ids, this.active);\n\n    if (active === undefined) {\n      return;\n    }\n\n    isDev() && setAction('Set Active', active);\n    this._setActive(active);\n  }\n\n  /**\n   * Add active entities\n   *\n   * @example\n   *\n   * store.addActive(2);\n   * store.addActive([3, 4, 5]);\n   */\n  addActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const everyExist = toArray.every((id) => this.active.indexOf(id) > -1);\n    if (everyExist) return;\n\n    isDev() && setAction('Add Active', ids);\n    this._setState((state) => {\n      /** Protect against case that one of the items in the array exist */\n      const uniques = Array.from(new Set([...(state.active as IDType[]), ...toArray]));\n      return {\n        ...state,\n        active: uniques,\n      };\n    });\n  }\n\n  /**\n   * Remove active entities\n   *\n   * @example\n   *\n   * store.removeActive(2)\n   * store.removeActive([3, 4, 5])\n   */\n  removeActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const someExist = toArray.some((id) => this.active.indexOf(id) > -1);\n    if (!someExist) return;\n\n    isDev() && setAction('Remove Active', ids);\n    this._setState((state) => {\n      return {\n        ...state,\n        active: Array.isArray(state.active) ? state.active.filter((currentId) => toArray.indexOf(currentId) === -1) : null,\n      };\n    });\n  }\n\n  /**\n   * Toggle active entities\n   *\n   * @example\n   *\n   * store.toggle(2)\n   * store.toggle([3, 4, 5])\n   */\n  @transaction()\n  toggleActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    const filterExists = (remove) => (id) => this.active.includes(id) === remove;\n    const remove = toArray.filter(filterExists(true));\n    const add = toArray.filter(filterExists(false));\n    this.removeActive(remove);\n    this.addActive(add);\n    isDev() && logAction('Toggle Active');\n  }\n\n  /**\n   *\n   * Create sub UI store for managing Entity's UI state\n   *\n   * @example\n   *\n   * export type ProductUI = {\n   *   isLoading: boolean;\n   *   isOpen: boolean\n   * }\n   *\n   * interface ProductsUIState extends EntityState<ProductUI> {}\n   *\n   * export class ProductsStore EntityStore<ProductsState, Product> {\n   *   ui: EntityUIStore<ProductsUIState, ProductUI>;\n   *\n   *   constructor() {\n   *     super();\n   *     this.createUIStore();\n   *   }\n   *\n   * }\n   */\n  createUIStore(initialState = {}, storeConfig: Partial<StoreConfigOptions> = {}) {\n    const defaults: Partial<StoreConfigOptions> = { name: `UI/${this.storeName}`, idKey: this.idKey };\n    this.ui = new EntityUIStore(initialState, { ...defaults, ...storeConfig });\n    return this.ui;\n  }\n\n  // @internal\n  destroy() {\n    super.destroy();\n    if (this.ui instanceof EntityStore) {\n      this.ui.destroy();\n    }\n    this.entityActions.complete();\n  }\n\n  // @internal\n  akitaPreUpdateEntity(_: Readonly<EntityType>, nextEntity: any): EntityType {\n    return nextEntity as EntityType;\n  }\n\n  // @internal\n  akitaPreAddEntity(newEntity: any): EntityType {\n    return newEntity as EntityType;\n  }\n\n  // @internal\n  akitaPreCheckEntity(newEntity: Readonly<EntityType>): EntityType {\n    return newEntity;\n  }\n\n  private get ids() {\n    return this._value().ids;\n  }\n\n  private get entities() {\n    return this._value().entities;\n  }\n\n  private get active() {\n    return this._value().active;\n  }\n\n  private _setActive(ids: OrArray<IDType>) {\n    this._setState((state) => {\n      return {\n        ...state,\n        active: ids,\n      };\n    });\n  }\n\n  private handleUICreation(add = false) {\n    const ids = this.ids;\n    const isFunc = isFunction(this.ui._akitaCreateEntityFn);\n    let uiEntities;\n    const createFn = (id) => {\n      const current = this.entities[id];\n      const ui = isFunc ? this.ui._akitaCreateEntityFn(current) : this.ui._akitaCreateEntityFn;\n      return {\n        [this.idKey]: current[this.idKey],\n        ...ui,\n      };\n    };\n\n    if (add) {\n      uiEntities = this.ids.filter((id) => isUndefined(this.ui.entities[id])).map(createFn);\n    } else {\n      uiEntities = ids.map(createFn);\n    }\n\n    add ? this.ui.add(uiEntities) : this.ui.set(uiEntities);\n  }\n\n  private hasInitialUIState() {\n    return this.hasUIStore() && isUndefined(this.ui._akitaCreateEntityFn) === false;\n  }\n\n  private handleUIRemove(ids: IDType[]) {\n    if (this.hasUIStore()) {\n      this.ui.remove(ids);\n    }\n  }\n\n  private hasUIStore() {\n    return this.ui instanceof EntityUIStore;\n  }\n}\n\n// @internal\nexport class EntityUIStore<UIState, DEPRECATED = any> extends EntityStore<UIState> {\n  _akitaCreateEntityFn: EntityUICreateFn;\n\n  constructor(initialState = {}, storeConfig: Partial<StoreConfigOptions> = {}) {\n    super(initialState, storeConfig);\n  }\n\n  /**\n   *\n   * Set the initial UI entity state. This function will determine the entity's\n   * initial state when we call `set()` or `add()`.\n   *\n   * @example\n   *\n   * constructor() {\n   *   super();\n   *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));\n   *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });\n   * }\n   *\n   */\n  setInitialEntityState<EntityUI = any, Entity = any>(createFn: EntityUICreateFn<EntityUI, Entity>) {\n    this._akitaCreateEntityFn = createFn;\n  }\n}\n","export const DEFAULT_ID_KEY = 'id';\n","import { ID, IDS, ItemPredicate } from './types';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { isArray } from './isArray';\nimport { isFunction } from './isFunction';\nimport { isEmpty } from './isEmpty';\n\n// @internal\nexport function find<T>(collection: T[], idsOrPredicate: IDS | ItemPredicate, idKey: string) {\n  const result = [];\n  if (isFunction(idsOrPredicate)) {\n    for (const entity of collection) {\n      if (idsOrPredicate(entity) === true) {\n        result.push(entity);\n      }\n    }\n  } else {\n    const toSet = coerceArray(idsOrPredicate).reduce((acc, current) => acc.add(current), new Set());\n\n    for (const entity of collection) {\n      if (toSet.has(entity[idKey])) {\n        result.push(entity);\n      }\n    }\n  }\n\n  return result;\n}\n\n// @internal\nexport function distinctUntilArrayItemChanged<T>(): MonoTypeOperatorFunction<T[]> {\n  return distinctUntilChanged((prevCollection: T[], currentCollection: T[]) => {\n    if (prevCollection === currentCollection) {\n      return true;\n    }\n\n    if (isArray(prevCollection) === false || isArray(currentCollection) === false) {\n      return false;\n    }\n\n    if (isEmpty(prevCollection) && isEmpty(currentCollection)) {\n      return true;\n    }\n\n    // if item is new in the current collection but not exist in the prev collection\n    const hasNewItem = hasChange(currentCollection, prevCollection);\n\n    if (hasNewItem) {\n      return false;\n    }\n\n    const isOneOfItemReferenceChanged = hasChange(prevCollection, currentCollection);\n\n    // return false means there is a change and we want to call next()\n    return isOneOfItemReferenceChanged === false;\n  });\n}\n\n// @internal\nfunction hasChange<T>(first: T[], second: T[]) {\n  const hasChange = second.some(currentItem => {\n    const oldItem = first.find(prevItem => prevItem === currentItem);\n    return oldItem === undefined;\n  });\n\n  return hasChange;\n}\n\n/**\n * Find items in a collection\n *\n * @example\n *\n *  selectEntity(1, 'comments').pipe(\n *   arrayFind(comment => comment.text = 'text')\n * )\n */\nexport function arrayFind<T>(ids: ItemPredicate<T>, idKey?: never): (source: Observable<T[]>) => Observable<T[]>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind(3)\n * )\n */\nexport function arrayFind<T>(ids: ID, idKey?: string): (source: Observable<T[]>) => Observable<T>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind([1, 2, 3])\n * )\n */\nexport function arrayFind<T>(ids: ID[], idKey?: string): (source: Observable<T[]>) => Observable<T[]>;\nexport function arrayFind<T>(idsOrPredicate: ID[] | ID | ItemPredicate<T>, idKey?: string): (source: Observable<T[]>) => Observable<T[] | T> {\n  return function(source: Observable<T[]>) {\n    return source.pipe(\n      map((collection: T[] | undefined | null) => {\n        // which means the user deleted the root entity or set the collection to nil\n        if (isArray(collection) === false) {\n          return collection;\n        }\n        return find(collection, idsOrPredicate, idKey || DEFAULT_ID_KEY);\n      }),\n      distinctUntilArrayItemChanged(),\n      map(value => {\n        if (isArray(value) === false) {\n          return value;\n        }\n\n        if (isArray(idsOrPredicate) || isFunction(idsOrPredicate)) {\n          return value;\n        }\n\n        return value[0];\n      })\n    );\n  };\n}\n","import { EntityState, SelectOptions } from './types';\nimport { isFunction } from './isFunction';\nimport { compareValues } from './sort';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToArray<E, S extends EntityState>(state: S, options: SelectOptions<E>): E[] {\n  let arr = [];\n  const { ids, entities } = state;\n  const { filterBy, limitTo, sortBy, sortByOrder } = options;\n\n  for (let i = 0; i < ids.length; i++) {\n    const entity = entities[ids[i]];\n    if (!filterBy) {\n      arr.push(entity);\n      continue;\n    }\n\n    const toArray = coerceArray(filterBy);\n    const allPass = toArray.every(fn => fn(entity, i));\n    if (allPass) {\n      arr.push(entity);\n    }\n  }\n\n  if (sortBy) {\n    let _sortBy: any = isFunction(sortBy) ? sortBy : compareValues(sortBy, sortByOrder);\n    arr = arr.sort((a, b) => _sortBy(a, b, state));\n  }\n\n  const length = Math.min(limitTo || arr.length, arr.length);\n\n  return length === arr.length ? arr : arr.slice(0, length);\n}\n","import { EntityState } from './types';\nimport { isNil } from './isNil';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToMap<S extends EntityState<E>, E>(state: S, options) {\n  const map = {};\n  const { filterBy, limitTo } = options;\n  const { ids, entities } = state;\n\n  if (!filterBy && !limitTo) {\n    return entities;\n  }\n  const hasLimit = isNil(limitTo) === false;\n\n  if (filterBy && hasLimit) {\n    let count = 0;\n    for (let i = 0, length = ids.length; i < length; i++) {\n      if (count === limitTo) break;\n      const id = ids[i];\n      const entity = entities[id];\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n        count++;\n      }\n    }\n  } else {\n    const finalLength = Math.min(limitTo || ids.length, ids.length);\n\n    for (let i = 0; i < finalLength; i++) {\n      const id = ids[i];\n      const entity = entities[id];\n\n      if (!filterBy) {\n        map[id] = entity;\n        continue;\n      }\n\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n      }\n    }\n  }\n\n  return map;\n}\n","// @internal\nexport function isString(value: any): value is string {\n  return typeof value === 'string';\n}\n","import { isUndefined } from './isUndefined';\nimport { isString } from './isString';\nimport { ItemPredicate } from './types';\n\n// @internal\nexport function findEntityByPredicate<E>(predicate: ItemPredicate<E>, entities) {\n    for(const entityId of Object.keys(entities)) {\n      if(predicate(entities[entityId]) === true) {\n        return entityId;\n      }\n    }\n\n    return undefined;\n}\n\n// @internal\nexport function getEntity( id, project ) {\n  return function(entities) {\n    const entity = entities[id];\n\n    if(isUndefined(entity)) {\n      return undefined;\n    }\n\n    if(!project) {\n      return entity;\n    }\n\n    if(isString(project)) {\n      return entity[project];\n    }\n\n    return (project as Function)(entity);\n  };\n\n}\n","import { Store } from './store';\nimport { Observable } from 'rxjs';\nimport { queryConfigKey, QueryConfigOptions } from './queryConfig';\nimport { isString } from './isString';\nimport { isFunction } from './isFunction';\nimport { isDev } from './env';\nimport { __queries__ } from './stores';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { compareKeys } from './compareKeys';\nimport { ReturnTypes } from './types';\n\nexport class Query<S> {\n  // @internal\n  __store__: Store<S>;\n\n  constructor(protected store: Store<S>) {\n    this.__store__ = store;\n    if (isDev()) {\n      // @internal\n      __queries__[store.storeName] = this;\n    }\n  }\n\n  /**\n   * Select a slice from the store\n   *\n   * @example\n   *\n   * this.query.select()\n   * this.query.select(state => state.entities)\n   * this.query.select('token');\n   * this.query.select(['name', 'email'])\n   * this.query.select([state => state.name, state => state.age])\n   *\n   */\n  select<K extends keyof S>(key: K): Observable<S[K]>;\n  select<R>(project: (store: S) => R): Observable<R>;\n  select<K extends keyof S>(stateKeys: K[]): Observable<Pick<S, K>>;\n  select<R extends [(state: S) => any] | Array<(state: S) => any>>(selectorFns: R): Observable<ReturnTypes<R>>;\n  select(): Observable<S>;\n  select<R>(project?: ((store: S) => R) | keyof S | (keyof S)[] | ((state: S) => any)[]): Observable<R | S | any[]> {\n    let mapFn;\n    if (isFunction(project)) {\n      mapFn = project;\n    } else if (isString(project)) {\n      mapFn = state => state[project];\n    } else if (Array.isArray(project)) {\n      return this.store\n        ._select(state => state)\n        .pipe(\n          distinctUntilChanged(compareKeys(project)),\n          map(state => {\n            if (isFunction(project[0])) {\n              return (project as ((state: S) => any)[]).map(func => func(state));\n            }\n\n            return (project as (keyof S)[]).reduce((acc, k) => {\n              acc[k as any] = state[k];\n              return acc;\n            }, {});\n          })\n        ) as any;\n    } else {\n      mapFn = state => state;\n    }\n\n    return this.store._select(mapFn);\n  }\n\n  /**\n   * Select the loading state\n   *\n   * @example\n   *\n   * this.query.selectLoading().subscribe(isLoading => {})\n   */\n  selectLoading() {\n    return this.select(state => (state as S & { loading: boolean }).loading);\n  }\n\n  /**\n   * Select the error state\n   *\n   * @example\n   *\n   * this.query.selectError().subscribe(error => {})\n   */\n  selectError<ErrorType = any>(): Observable<ErrorType> {\n    return this.select(state => (state as S & { error: ErrorType }).error);\n  }\n\n  /**\n   * Get the store's value\n   *\n   * @example\n   *\n   * this.query.getValue()\n   *\n   */\n  getValue(): S {\n    return this.store._value();\n  }\n\n  /**\n   * Select the cache state\n   *\n   * @example\n   *\n   * this.query.selectHasCache().pipe(\n   *   switchMap(hasCache => {\n   *     return hasCache ? of() : http().pipe(res => store.set(res))\n   *   })\n   * )\n   */\n  selectHasCache(): Observable<boolean> {\n    return this.store._cache().asObservable();\n  }\n\n  /**\n   * Whether we've cached data\n   *\n   * @example\n   *\n   * this.query.getHasCache()\n   *\n   */\n  getHasCache(): boolean {\n    return this.store._cache().value;\n  }\n\n  // @internal\n  get config(): QueryConfigOptions {\n    return this.constructor[queryConfigKey];\n  }\n}\n","import { isFunction } from './isFunction';\n\nexport function compareKeys<T>(keysOrFuncs: any[]) {\n  return function <T>(prevState, currState) {\n    const isFns = isFunction(keysOrFuncs[0]);\n    // Return when they are NOT changed\n    return keysOrFuncs.some(keyOrFunc => {\n      if(isFns) {\n        return keyOrFunc(prevState) !== keyOrFunc(currState);\n      }\n      return prevState[keyOrFunc] !== currState[keyOrFunc];\n    }) === false;\n  };\n}\n","// @internal\nexport function sortByOptions(options, config) {\n  options.sortBy = options.sortBy || (config && config.sortBy);\n  options.sortByOrder = options.sortByOrder || (config && config.sortByOrder);\n}\n","import { Observable, of } from 'rxjs';\nimport { distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\nimport { distinctUntilArrayItemChanged } from './arrayFind';\nimport { coerceArray } from './coerceArray';\nimport { entitiesToArray } from './entitiesToArray';\nimport { entitiesToMap } from './entitiesToMap';\nimport { EntityAction, EntityActions } from './entityActions';\nimport { EntityStore } from './entityStore';\nimport { findEntityByPredicate, getEntity } from './getEntity';\nimport { isArray } from './isArray';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { mapSkipUndefined } from './mapSkipUndefined';\nimport { Query } from './query';\nimport { QueryConfigOptions } from './queryConfig';\nimport { SelectAllOptionsA, SelectAllOptionsB, SelectAllOptionsC, SelectAllOptionsD, SelectAllOptionsE } from './selectAllOverloads';\nimport { sortByOptions } from './sortByOptions';\nimport { toBoolean } from './toBoolean';\nimport { EntityState, getEntityType, getIDType, HashMap, ItemPredicate, OrArray, SelectOptions } from './types';\n\n/**\n *\n *  The Entity Query is similar to the general Query, with additional functionality tailored for EntityStores.\n *\n *  class WidgetsQuery extends QueryEntity<WidgetsState> {\n *     constructor(protected store: WidgetsStore) {\n *       super(store);\n *     }\n *  }\n *\n *\n *\n */\nexport class QueryEntity<S extends EntityState, EntityType = getEntityType<S>, IDType = getIDType<S>> extends Query<S> {\n  ui: EntityUIQuery<any, EntityType>;\n  protected store: EntityStore<S>;\n\n  // @internal\n  __store__;\n\n  constructor(store: EntityStore<S>, private options: QueryConfigOptions = {}) {\n    super(store);\n    this.__store__ = store;\n  }\n\n  /**\n   * Select the entire store's entity collection\n   *\n   * @example\n   *\n   * this.query.selectAll()\n   *\n   * this.query.selectAll({\n   *   limitTo: 5\n   *   filterBy: entity => entity.completed === true\n   * })\n   *\n   * this.query.selectAll({\n   *   asObject: true,\n   *   limitTo: 3\n   * })\n   *\n   *  this.query.selectAll({\n   *   sortBy: 'price',\n   *   sortByOrder: Order.DESC\n   * })\n   *\n   */\n  selectAll(options: SelectAllOptionsA<EntityType>): Observable<HashMap<EntityType>>;\n  selectAll(options: SelectAllOptionsB<EntityType>): Observable<EntityType[]>;\n  selectAll(options: SelectAllOptionsC<EntityType>): Observable<HashMap<EntityType>>;\n  selectAll(options: SelectAllOptionsD<EntityType>): Observable<EntityType[]>;\n  selectAll(options: SelectAllOptionsE<EntityType>): Observable<EntityType[]>;\n  selectAll(): Observable<EntityType[]>;\n  selectAll(\n    options: SelectOptions<EntityType> = {\n      asObject: false,\n    }\n  ): Observable<EntityType[] | HashMap<EntityType>> {\n    return this.select((state) => state.entities).pipe(map(() => this.getAll(options)));\n  }\n\n  /**\n   * Get the entire store's entity collection\n   *\n   * @example\n   *\n   * this.query.getAll()\n   *\n   * this.query.getAll({\n   *   limitTo: 5\n   *   filterBy: entity => entity.completed === true\n   * })\n   *\n   * this.query.getAll({\n   *   asObject: true,\n   *   limitTo: 3\n   * })\n   *\n   *  this.query.getAll({\n   *   sortBy: 'price',\n   *   sortByOrder: Order.DESC\n   * })\n   */\n  getAll(options: SelectAllOptionsA<EntityType>): HashMap<EntityType>;\n  getAll(options: SelectAllOptionsB<EntityType>): EntityType[];\n  getAll(options: SelectAllOptionsC<EntityType>): HashMap<EntityType>;\n  getAll(options: SelectAllOptionsD<EntityType>): EntityType[];\n  getAll(options: SelectAllOptionsE<EntityType>): EntityType[];\n  getAll(): EntityType[];\n  getAll(options: SelectOptions<EntityType> = { asObject: false, filterBy: undefined, limitTo: undefined }): EntityType[] | HashMap<EntityType> {\n    if (options.asObject) {\n      return entitiesToMap(this.getValue(), options);\n    }\n    sortByOptions(options, this.config || this.options);\n\n    return entitiesToArray(this.getValue(), options);\n  }\n\n  /**\n   * Select multiple entities from the store\n   *\n   * @example\n   *\n   * this.query.selectMany([1,2,3])\n   * this.query.selectMany([1,2], entity => entity.title)\n   */\n  selectMany<R>(ids: IDType[]): Observable<EntityType[]>;\n  selectMany<R>(ids: IDType[], project: (entity: EntityType) => R): Observable<R[]>;\n  selectMany<R>(ids: IDType[], project?: (entity: EntityType) => R): Observable<EntityType[] | R[]> {\n    if (!ids || !ids.length) return of([]);\n\n    return this.select((state) => state.entities).pipe(\n      map((entities) => mapSkipUndefined(ids, (id) => getEntity(id, project)(entities))),\n      distinctUntilArrayItemChanged()\n    );\n  }\n\n  /**\n   * Select an entity or a slice of an entity\n   *\n   * @example\n   *\n   * this.query.selectEntity(1)\n   * this.query.selectEntity(1, entity => entity.config.date)\n   * this.query.selectEntity(1, 'comments')\n   * this.query.selectEntity(e => e.title === 'title')\n   *\n   */\n  selectEntity<R>(id: IDType): Observable<EntityType | undefined>;\n  selectEntity<K extends keyof EntityType>(id: IDType, project?: K): Observable<EntityType[K] | undefined>;\n  selectEntity<R>(id: IDType, project: (entity?: EntityType) => R): Observable<R>;\n  selectEntity<R>(predicate: ItemPredicate<EntityType>): Observable<EntityType | undefined>;\n  selectEntity<R>(idOrPredicate: IDType | ItemPredicate<EntityType>, project?: ((entity: EntityType) => R) | keyof EntityType): Observable<R | EntityType | undefined> {\n    let id = idOrPredicate;\n\n    if (isFunction(idOrPredicate)) {\n      // For performance reason we expect the entity to be in the store\n      (id as any) = findEntityByPredicate(idOrPredicate, this.getValue().entities);\n    }\n\n    return this.select((state) => state.entities).pipe(map(getEntity(id, project)), distinctUntilChanged());\n  }\n\n  /**\n   * Get an entity by id\n   *\n   * @example\n   *\n   * this.query.getEntity(1);\n   */\n  getEntity(id: IDType): EntityType | undefined {\n    return this.getValue().entities[id as any];\n  }\n\n  /**\n   * Select the active entity's id\n   *\n   * @example\n   *\n   * this.query.selectActiveId()\n   */\n  selectActiveId(): Observable<S['active'] | undefined> {\n    return this.select((state) => (state as S & { active: S['active'] }).active);\n  }\n\n  /**\n   * Get the active id\n   *\n   * @example\n   *\n   * this.query.getActiveId()\n   */\n  getActiveId(): S['active'] | undefined {\n    return this.getValue().active;\n  }\n\n  /**\n   * Select the active entity\n   *\n   * @example\n   *\n   * this.query.selectActive()\n   * this.query.selectActive(entity => entity.title)\n   */\n  selectActive<R>(): S['active'] extends any[] ? Observable<EntityType[]> : Observable<EntityType | undefined>;\n  selectActive<R>(project?: (entity: EntityType) => R): S['active'] extends any[] ? Observable<R[]> : Observable<R | undefined>;\n  selectActive<R>(project?: (entity: EntityType) => R): Observable<R | EntityType> | Observable<EntityType[] | R[] | undefined> {\n    if (isArray(this.getActive())) {\n      return this.selectActiveId().pipe(switchMap((ids) => this.selectMany(ids, project)));\n    }\n    return this.selectActiveId().pipe(switchMap((ids) => this.selectEntity(ids, project)));\n  }\n\n  /**\n   * Get the active entity\n   *\n   * @example\n   *\n   * this.query.getActive()\n   */\n  getActive(): S['active'] extends any[] ? EntityType[] : EntityType | undefined;\n  getActive(): OrArray<EntityType> | undefined {\n    const activeId = this.getActiveId();\n    if (isArray(activeId)) {\n      return activeId.map((id) => this.getValue().entities[id as any]);\n    }\n    return toBoolean(activeId) ? this.getEntity(activeId) : undefined;\n  }\n\n  /**\n   * Select the store's entity collection length\n   *\n   * @example\n   *\n   * this.query.selectCount()\n   * this.query.selectCount(entity => entity.completed)\n   */\n  selectCount(predicate?: (entity: EntityType, index: number) => boolean): Observable<number> {\n    return this.select((state) => state.entities).pipe(map(() => this.getCount(predicate)));\n  }\n\n  /**\n   * Get the store's entity collection length\n   *\n   * @example\n   *\n   * this.query.getCount()\n   * this.query.getCount(entity => entity.completed)\n   */\n  getCount(predicate?: (entity: EntityType, index: number) => boolean): number {\n    if (isFunction(predicate)) {\n      return this.getAll().filter(predicate).length;\n    }\n    return this.getValue().ids.length;\n  }\n\n  /**\n   *\n   * Select the last entity from the store\n   *\n   * @example\n   *\n   * this.query.selectLast()\n   * this.query.selectLast(todo => todo.title)\n   */\n  selectLast<R>(): Observable<EntityType | undefined>;\n  selectLast<R>(project: (entity?: EntityType) => R): Observable<R>;\n  selectLast<R>(project?: (entity?: EntityType) => R): Observable<R | EntityType | undefined> {\n    return this.selectAt((ids) => ids[ids.length - 1], project);\n  }\n\n  /**\n   *\n   * Select the first entity from the store\n   *\n   * @example\n   *\n   * this.query.selectFirst()\n   * this.query.selectFirst(todo => todo.title)\n   */\n  selectFirst<R>(): Observable<EntityType | undefined>;\n  selectFirst<R>(project: (entity?: EntityType) => R): Observable<R>;\n  selectFirst<R>(project?: (entity?: EntityType) => R): Observable<R | EntityType | undefined> {\n    return this.selectAt((ids) => ids[0], project);\n  }\n\n  /**\n   *\n   * Listen for entity actions\n   *\n   *  @example\n   *  this.query.selectEntityAction(EntityActions.Add);\n   *  this.query.selectEntityAction(EntityActions.Update);\n   *  this.query.selectEntityAction(EntityActions.Remove);\n   *\n   *  this.query.selectEntityAction([EntityActions.Add, EntityActions.Update, EntityActions.Remove])\n   *\n   *  this.query.selectEntityAction();\n   */\n  selectEntityAction(action: EntityActions): Observable<IDType[]>;\n  selectEntityAction(actions: EntityActions[]): Observable<EntityAction<IDType>>;\n  selectEntityAction(): Observable<EntityAction<IDType>>;\n  selectEntityAction(actionOrActions?: EntityActions | EntityActions[]): Observable<IDType[] | EntityAction<IDType>> {\n    if (isNil(actionOrActions)) {\n      return this.store.selectEntityAction$;\n    }\n\n    const project = isArray(actionOrActions) ? (action: EntityAction<IDType>) => action : ({ ids }: EntityAction<IDType>) => ids;\n    const actions = coerceArray(actionOrActions);\n\n    return this.store.selectEntityAction$.pipe(\n      filter(({ type }: EntityAction<IDType>) => actions.includes(type)),\n      map((action) => project(action))\n    );\n  }\n\n  /**\n   * Returns whether entity exists\n   *\n   * @example\n   *\n   * this.query.hasEntity(2)\n   * this.query.hasEntity(entity => entity.completed)\n   * this.query.hasEntity([1, 2, 33])\n   *\n   */\n  hasEntity(id: IDType): boolean;\n  hasEntity(id: IDType[]): boolean;\n  hasEntity(project: (entity: EntityType) => boolean): boolean;\n  hasEntity(): boolean;\n  hasEntity(projectOrIds?: IDType | IDType[] | ((entity: EntityType) => boolean)): boolean {\n    if (isNil(projectOrIds)) {\n      return this.getValue().ids.length > 0;\n    }\n\n    if (isFunction(projectOrIds)) {\n      return this.getAll().some(projectOrIds);\n    }\n\n    if (isArray(projectOrIds)) {\n      return projectOrIds.every((id) => (id as any) in this.getValue().entities);\n    }\n\n    return (projectOrIds as any) in this.getValue().entities;\n  }\n\n  /**\n   * Returns whether entity store has an active entity\n   *\n   * @example\n   *\n   * this.query.hasActive()\n   * this.query.hasActive(3)\n   *\n   */\n  hasActive(id?: IDType): boolean {\n    const active = this.getValue().active;\n    const isIdProvided = isDefined(id);\n    if (Array.isArray(active)) {\n      if (isIdProvided) {\n        return active.includes(id);\n      }\n      return active.length > 0;\n    }\n    return isIdProvided ? active === id : isDefined(active);\n  }\n\n  /**\n   *\n   * Create sub UI query for querying Entity's UI state\n   *\n   * @example\n   *\n   *\n   * export class ProductsQuery extends QueryEntity<ProductsState> {\n   *   ui: EntityUIQuery<ProductsUIState>;\n   *\n   *   constructor(protected store: ProductsStore) {\n   *     super(store);\n   *     this.createUIQuery();\n   *   }\n   *\n   * }\n   */\n  createUIQuery() {\n    this.ui = new EntityUIQuery(this.__store__.ui);\n  }\n\n  private selectAt<R>(mapFn: (ids: IDType[]) => IDType, project?: (entity?: EntityType) => R) {\n    return this.select((state) => state.ids as any[]).pipe(\n      map(mapFn),\n      distinctUntilChanged(),\n      switchMap((id: IDType) => this.selectEntity(id, project))\n    );\n  }\n}\n\n// @internal\nexport class EntityUIQuery<UIState, DEPRECATED = any> extends QueryEntity<UIState> {\n  constructor(store) {\n    super(store);\n  }\n}\n","// @internal\nexport function mapSkipUndefined<T, V>(arr: T[], callbackFn: (value: T, index: number, array: T[]) => V) {\n  return arr.reduce((result, value, index, array) => {\n    const val = callbackFn(value, index, array);\n    if (val !== undefined) {\n      result.push(val);\n    }\n    return result;\n  }, []);\n}\n","import { Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { Diff } from './types';\n\n/**\n * @example\n *\n * query.selectEntity(2).pipe(filterNil)\n */\nexport const filterNil = <T>(source: Observable<T | undefined | null>) => source.pipe(filter((value): value is Diff<T, null | undefined> => value !== null && typeof value !== 'undefined'));\n","/**\n * @internal\n *\n * @example\n *\n * getValue(state, 'todos.ui')\n *\n */\nexport function getValue( obj: any, prop: string ) {\n  /** return the whole state  */\n  if( prop.split('.').length === 1 ) {\n    return obj;\n  }\n  const removeStoreName = prop\n    .split('.')\n    .slice(1)\n    .join('.');\n  return removeStoreName.split('.').reduce(( acc: any, part: string ) => acc && acc[part], obj);\n}\n","import { isObject } from './isObject';\n\n/**\n * @internal\n *\n * @example\n * setValue(state, 'todos.ui', { filter: {} })\n */\nexport function setValue(obj: any, prop: string, val: any) {\n  const split = prop.split('.');\n\n  if (split.length === 1) {\n    return { ...obj, ...val };\n  }\n\n  obj = { ...obj };\n\n  const lastIndex = split.length - 2;\n  const removeStoreName = prop.split('.').slice(1);\n\n  removeStoreName.reduce((acc, part, index) => {\n    if (index !== lastIndex) {\n      acc[part] = { ...acc[part] };\n      return acc && acc[part];\n    }\n\n    acc[part] = Array.isArray(acc[part]) || !isObject(acc[part]) ? val : { ...acc[part], ...val };\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n}\n","import { from, isObservable, of, OperatorFunction, ReplaySubject, Subscription } from 'rxjs';\nimport { filter, map, skip } from 'rxjs/operators';\nimport { setAction } from './actions';\nimport { $$addStore, $$deleteStore } from './dispatchers';\nimport { getValue } from './getValueByString';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { hasLocalStorage, hasSessionStorage, isNotBrowser } from './root';\nimport { setValue } from './setValueByString';\nimport { __stores__ } from './stores';\nimport { HashMap, MaybeAsync } from './types';\n\nlet skipStorageUpdate = false;\n\nconst _persistStateInit = new ReplaySubject(1);\n\nexport function selectPersistStateInit() {\n  return _persistStateInit.asObservable();\n}\n\nexport function setSkipStorageUpdate(skip: boolean) {\n  skipStorageUpdate = skip;\n}\n\nexport function getSkipStorageUpdate() {\n  return skipStorageUpdate;\n}\n\nexport interface PersistStateStorage {\n  getItem(key: string): MaybeAsync;\n\n  setItem(key: string, value: any): MaybeAsync;\n\n  clear(): void;\n}\n\nfunction isPromise(v: any) {\n  return v && isFunction(v.then);\n}\n\nfunction observify(asyncOrValue: any) {\n  if (isPromise(asyncOrValue) || isObservable(asyncOrValue)) {\n    return from(asyncOrValue);\n  }\n\n  return of(asyncOrValue);\n}\n\nexport type PersistStateSelectFn<T = any> = ((store: T) => Partial<T>) & { storeName: string };\n\nexport interface PersistStateParams {\n  /** The storage key */\n  key: string;\n  /** Whether to enable persistState in a non-browser environment */\n  enableInNonBrowser: boolean;\n  /** Storage strategy to use. This defaults to LocalStorage but you can pass SessionStorage or anything that implements the StorageEngine API. */\n  storage: PersistStateStorage;\n  /** Custom deserializer. Defaults to JSON.parse */\n  deserialize: Function;\n  /** Custom serializer, defaults to JSON.stringify */\n  serialize: Function;\n  /** By default the whole state is saved to storage, use this param to include only the stores you need. */\n  include: (string | ((storeName: string) => boolean))[];\n  /** By default the whole state is saved to storage, use this param to include only the data you need. */\n  select: PersistStateSelectFn[];\n\n  preStorageUpdate(storeName: string, state: any): any;\n\n  preStoreUpdate(storeName: string, state: any, initialState: any): any;\n\n  skipStorageUpdate: () => boolean;\n  preStorageUpdateOperator: () => OperatorFunction<any, any>;\n  /** Whether to persist a dynamic store upon destroy */\n  persistOnDestroy: boolean;\n}\n\nexport interface PersistState {\n  destroy(): void;\n  /**\n   * @deprecated Use clearStore instead.\n   */\n  clear(): void;\n  clearStore(storeName?: string): void;\n}\n\nexport function persistState(params?: Partial<PersistStateParams>): PersistState {\n  const defaults: PersistStateParams = {\n    key: 'AkitaStores',\n    enableInNonBrowser: false,\n    storage: !hasLocalStorage() ? params.storage : localStorage,\n    deserialize: JSON.parse,\n    serialize: JSON.stringify,\n    include: [],\n    select: [],\n    persistOnDestroy: false,\n    preStorageUpdate: function (storeName, state) {\n      return state;\n    },\n    preStoreUpdate: function (storeName, state) {\n      return state;\n    },\n    skipStorageUpdate: getSkipStorageUpdate,\n    preStorageUpdateOperator: () => (source) => source,\n  };\n\n  const { storage, enableInNonBrowser, deserialize, serialize, include, select, key, preStorageUpdate, persistOnDestroy, preStorageUpdateOperator, preStoreUpdate, skipStorageUpdate } = Object.assign(\n    {},\n    defaults,\n    params\n  );\n\n  if ((isNotBrowser && !enableInNonBrowser) || !storage) return;\n\n  const hasInclude = include.length > 0;\n  const hasSelect = select.length > 0;\n  let includeStores: { fns: Function[]; [key: string]: Function[] | string };\n  let selectStores: { [key: string]: PersistStateSelectFn };\n\n  if (hasInclude) {\n    includeStores = include.reduce(\n      (acc, path) => {\n        if (isFunction(path)) {\n          acc.fns.push(path);\n        } else {\n          const storeName = path.split('.')[0];\n          acc[storeName] = path;\n        }\n        return acc;\n      },\n      { fns: [] }\n    );\n  }\n\n  if (hasSelect) {\n    selectStores = select.reduce((acc, selectFn) => {\n      acc[selectFn.storeName] = selectFn;\n\n      return acc;\n    }, {});\n  }\n\n  let stores: HashMap<Subscription> = {};\n  let acc = {};\n  let subscriptions: Subscription[] = [];\n\n  const buffer = [];\n\n  function _save(v: any) {\n    observify(v).subscribe(() => {\n      const next = buffer.shift();\n      next && _save(next);\n    });\n  }\n\n  // when we use the local/session storage we perform the serialize, otherwise we let the passed storage implementation to do it\n  const isLocalStorage = (hasLocalStorage() && storage === localStorage) || (hasSessionStorage() && storage === sessionStorage);\n\n  observify(storage.getItem(key)).subscribe((value: any) => {\n    let storageState = isObject(value) ? value : deserialize(value || '{}');\n\n    function save(storeCache) {\n      storageState['$cache'] = { ...(storageState['$cache'] || {}), ...storeCache };\n      storageState = Object.assign({}, storageState, acc);\n\n      buffer.push(storage.setItem(key, isLocalStorage ? serialize(storageState) : storageState));\n      _save(buffer.shift());\n    }\n\n    function subscribe(storeName, path) {\n      stores[storeName] = __stores__[storeName]\n        ._select((state) => getValue(state, path))\n        .pipe(\n          skip(1),\n          map((store) => {\n            if (hasSelect && selectStores[storeName]) {\n              return selectStores[storeName](store);\n            }\n\n            return store;\n          }),\n          filter(() => skipStorageUpdate() === false),\n          preStorageUpdateOperator()\n        )\n        .subscribe((data) => {\n          acc[storeName] = preStorageUpdate(storeName, data);\n          Promise.resolve().then(() => save({ [storeName]: __stores__[storeName]._cache().getValue() }));\n        });\n    }\n\n    function setInitial(storeName, store, path) {\n      if (storeName in storageState) {\n        setAction('@PersistState');\n        store._setState((state) => {\n          return setValue(state, path, preStoreUpdate(storeName, storageState[storeName], state));\n        });\n        const hasCache = storageState['$cache'] ? storageState['$cache'][storeName] : false;\n        __stores__[storeName].setHasCache(hasCache, { restartTTL: true });\n      }\n    }\n\n    subscriptions.push(\n      $$deleteStore.subscribe((storeName) => {\n        if (stores[storeName]) {\n          if (persistOnDestroy === false) {\n            save({ [storeName]: false });\n          }\n          stores[storeName].unsubscribe();\n          delete stores[storeName];\n        }\n      })\n    );\n\n    subscriptions.push(\n      $$addStore.subscribe((storeName) => {\n        if (storeName === 'router') {\n          return;\n        }\n\n        const store = __stores__[storeName];\n        if (hasInclude) {\n          let path = includeStores[storeName];\n\n          if (!path) {\n            const passPredicate = includeStores.fns.some((fn) => fn(storeName));\n            if (passPredicate) {\n              path = storeName;\n            } else {\n              return;\n            }\n          }\n          setInitial(storeName, store, path);\n          subscribe(storeName, path);\n        } else {\n          setInitial(storeName, store, storeName);\n          subscribe(storeName, storeName);\n        }\n      })\n    );\n\n    _persistStateInit.next();\n  });\n\n  return {\n    destroy() {\n      subscriptions.forEach((s) => s.unsubscribe());\n      for (let i = 0, keys = Object.keys(stores); i < keys.length; i++) {\n        const storeName = keys[i];\n        stores[storeName].unsubscribe();\n      }\n      stores = {};\n    },\n    clear() {\n      storage.clear();\n    },\n    clearStore(storeName?: string) {\n      if (isNil(storeName)) {\n        const value = observify(storage.setItem(key, '{}'));\n        value.subscribe();\n        return;\n      }\n      const value = storage.getItem(key);\n      observify(value).subscribe((v) => {\n        const storageState = deserialize(v || '{}');\n\n        if (storageState[storeName]) {\n          delete storageState[storeName];\n          const value = observify(storage.setItem(key, serialize(storageState)));\n          value.subscribe();\n        }\n      });\n    },\n  };\n}\n","import { __stores__ } from './stores';\nimport { isString } from './isString';\nimport { setSkipStorageUpdate } from './persistState';\nimport { $$addStore } from './dispatchers';\nimport { filter, take } from 'rxjs/operators';\n\nexport class SnapshotManager {\n  /**\n   * Get a snapshot of the whole state or a specific stores\n   * Use it ONLY for things such as saving the state in the server\n   */\n  getStoresSnapshot(stores: string[] = []) {\n    let acc = {};\n    const hasInclude = stores.length > 0;\n    const keys = hasInclude ? stores : Object.keys(__stores__);\n    for (let i = 0; i < keys.length; i++) {\n      let storeName = keys[i];\n      if (storeName !== 'router') {\n        acc[storeName] = __stores__[storeName]._value();\n      }\n    }\n\n    return acc;\n  }\n\n  setStoresSnapshot(stores: { [storeName: string]: any } | string, options?: { skipStorageUpdate?: boolean; lazy?: boolean }) {\n    const mergedOptions = { ...{ skipStorageUpdate: false, lazy: false }, ...options };\n    mergedOptions.skipStorageUpdate && setSkipStorageUpdate(true);\n\n    let normalizedStores = stores;\n\n    if (isString(stores)) {\n      normalizedStores = JSON.parse(normalizedStores as string);\n    }\n\n    const size = Object.keys(normalizedStores).length;\n\n    if (mergedOptions.lazy) {\n      $$addStore\n        .pipe(\n          filter(name => normalizedStores.hasOwnProperty(name)),\n          take(size)\n        )\n        .subscribe(name => __stores__[name]._setState(() => normalizedStores[name]));\n    } else {\n      for (let i = 0, keys = Object.keys(normalizedStores); i < keys.length; i++) {\n        const storeName = keys[i];\n        if (__stores__[storeName]) {\n          __stores__[storeName]._setState(() => normalizedStores[storeName]);\n        }\n      }\n    }\n\n    mergedOptions.skipStorageUpdate && setSkipStorageUpdate(false);\n  }\n}\n\nexport const snapshotManager = new SnapshotManager();\n","import { QueryEntity } from '../queryEntity';\nimport { Query } from '../query';\nimport { filterNil } from '../filterNil';\nimport { toBoolean } from '../toBoolean';\nimport { getAkitaConfig } from '../config';\nimport { getValue } from '../getValueByString';\nimport { setValue } from '../setValueByString';\n\nexport type Queries<State> = Query<State> | QueryEntity<State>;\n\nexport abstract class AkitaPlugin<State = any> {\n  protected constructor(protected query: Queries<State>, config?: { resetFn?: Function }) {\n    if (config && config.resetFn) {\n      if (getAkitaConfig().resettable) {\n        this.onReset(config.resetFn);\n      }\n    }\n  }\n\n  /** This method is responsible for getting access to the query. */\n  protected getQuery() {\n    return this.query;\n  }\n\n  /** This method is responsible for getting access to the store. */\n  protected getStore() {\n    return this.getQuery().__store__;\n  }\n\n  /** This method is responsible for cleaning. */\n  public abstract destroy();\n\n  /** This method is responsible tells whether the plugin is entityBased or not.  */\n  protected isEntityBased(entityId: any) {\n    return toBoolean(entityId);\n  }\n\n  /** This method is responsible for selecting the source; it can be the whole store or one entity. */\n  protected selectSource(entityId: any, property?: string) {\n    if (this.isEntityBased(entityId)) {\n      return (this.getQuery() as QueryEntity<State>).selectEntity(entityId).pipe(filterNil);\n    }\n\n    if (property) {\n      return this.getQuery().select(state => getValue(state, this.withStoreName(property)));\n    }\n\n    return this.getQuery().select();\n  }\n\n  protected getSource(entityId: any, property?: string): any {\n    if (this.isEntityBased(entityId)) {\n      return (this.getQuery() as QueryEntity<State>).getEntity(entityId);\n    }\n\n    const state = this.getQuery().getValue();\n\n    if (property) {\n      return getValue(state, this.withStoreName(property));\n    }\n\n    return state;\n  }\n\n  protected withStoreName(prop: string) {\n    return `${this.storeName}.${prop}`;\n  }\n\n  protected get storeName() {\n    return this.getStore().storeName;\n  }\n\n  /** This method is responsible for updating the store or one entity; it can be the whole store or one entity. */\n  protected updateStore(newState, entityId?, property?: string) {\n    if (this.isEntityBased(entityId)) {\n      this.getStore().update(entityId, newState);\n    } else {\n      if (property) {\n        this.getStore()._setState(state => {\n          return setValue(state, this.withStoreName(property), newState);\n        });\n        return;\n      }\n      this.getStore()._setState(state => ({ ...state, ...newState }));\n    }\n  }\n\n  /**\n   * Function to invoke upon reset\n   */\n  private onReset(fn: Function) {\n    const original = this.getStore().reset;\n    this.getStore().reset = (...params) => {\n      /** It should run after the plugin destroy method */\n      setTimeout(() => {\n        original.apply(this.getStore(), params);\n        fn();\n      });\n    };\n  }\n}\n","import { QueryEntity } from '../../queryEntity';\nimport { delay, map, switchMap, take } from 'rxjs/operators';\nimport { BehaviorSubject, from, isObservable, Observable, Subscription } from 'rxjs';\nimport { EntityState, ID, getEntityType } from '../../types';\nimport { AkitaPlugin } from '../plugin';\nimport { applyTransaction } from '../../transaction';\nimport { isUndefined } from '../../isUndefined';\nimport { action, logAction } from '../../actions';\nimport { isNil } from '../../isNil';\n\nexport interface PaginationResponse<E> {\n  currentPage: number;\n  perPage: number;\n  lastPage: number;\n  data: E[];\n  total?: number;\n  from?: number;\n  to?: number;\n  pageControls?: number[];\n}\n\nexport type PaginatorConfig = {\n  pagesControls?: boolean;\n  range?: boolean;\n  startWith?: number;\n  cacheTimeout?: Observable<number>;\n  clearStoreWithCache?: boolean;\n};\n\nconst paginatorDefaults: PaginatorConfig = {\n  pagesControls: false,\n  range: false,\n  startWith: 1,\n  cacheTimeout: undefined,\n  clearStoreWithCache: true\n};\n\nexport class PaginatorPlugin<State extends EntityState> extends AkitaPlugin<State> {\n  /** Save current filters, sorting, etc. in cache */\n  metadata = new Map();\n\n  private page: BehaviorSubject<number>;\n  private pages = new Map<number, { ids: ID[] }>();\n  private readonly clearCacheSubscription: Subscription;\n\n  private pagination: PaginationResponse<getEntityType<State>> = {\n    currentPage: 1,\n    perPage: 0,\n    total: 0,\n    lastPage: 0,\n    data: []\n  };\n\n  /**\n   * When the user navigates to a different page and return\n   * we don't want to call `clearCache` on first time.\n   */\n  private initial = true;\n\n  constructor(protected query: QueryEntity<State>, public config: PaginatorConfig = {}) {\n    super(query, {\n      resetFn: () => {\n        this.initial = false;\n        this.destroy({ clearCache: true, currentPage: 1 });\n      }\n    });\n    this.config = Object.assign(paginatorDefaults, config);\n    const { startWith, cacheTimeout } = this.config;\n    this.page = new BehaviorSubject(startWith);\n    if (isObservable(cacheTimeout)) {\n      this.clearCacheSubscription = cacheTimeout.subscribe(() => this.clearCache());\n    }\n  }\n\n  /**\n   * Proxy to the query loading\n   */\n  isLoading$ = this.query.selectLoading().pipe(delay(0));\n\n  /**\n   * Listen to page changes\n   */\n  get pageChanges() {\n    return this.page.asObservable();\n  }\n\n  /**\n   * Get the current page number\n   */\n  get currentPage() {\n    return this.pagination.currentPage;\n  }\n\n  /**\n   * Check if current page is the first one\n   */\n  get isFirst() {\n    return this.currentPage === 1;\n  }\n\n  /**\n   * Check if current page is the last one\n   */\n  get isLast() {\n    return this.currentPage === this.pagination.lastPage;\n  }\n\n  /**\n   * Whether to generate an array of pages for *ngFor\n   * [1, 2, 3, 4]\n   */\n  withControls() {\n    this.config.pagesControls = true;\n    return this;\n  }\n\n  /**\n   * Whether to generate the `from` and `to` keys\n   * [1, 2, 3, 4]\n   */\n  withRange() {\n    this.config.range = true;\n    return this;\n  }\n\n  /**\n   * Set the loading state\n   */\n  setLoading(value = true) {\n    this.getStore().setLoading(value);\n  }\n\n  /**\n   * Update the pagination object and add the page\n   */\n  @action('@Pagination - New Page')\n  update(response: PaginationResponse<getEntityType<State>>) {\n    this.pagination = response;\n    this.addPage(response.data);\n  }\n\n  /**\n   *\n   * Set the ids and add the page to store\n   */\n  addPage(data: getEntityType<State>[]) {\n    this.pages.set(this.currentPage, { ids: data.map(entity => entity[this.getStore().idKey]) });\n    this.getStore().upsertMany(data);\n  }\n\n  /**\n   * Clear the cache.\n   */\n  clearCache(options: { clearStore?: boolean } = {}) {\n    if (!this.initial) {\n      logAction('@Pagination - Clear Cache');\n\n      if (options.clearStore !== false && (this.config.clearStoreWithCache || options.clearStore)) {\n        this.getStore().remove();\n      }\n\n      this.pages = new Map();\n      this.metadata = new Map();\n    }\n    this.initial = false;\n  }\n\n  clearPage(page: number) {\n    this.pages.delete(page);\n  }\n\n  /**\n   * Clear the cache timeout and optionally the pages\n   */\n  destroy({ clearCache, currentPage }: { clearCache?: boolean; currentPage?: number } = {}) {\n    if (this.clearCacheSubscription) {\n      this.clearCacheSubscription.unsubscribe();\n    }\n    if (clearCache) {\n      this.clearCache();\n    }\n    if (!isUndefined(currentPage)) {\n      this.setPage(currentPage);\n    }\n    this.initial = true;\n  }\n\n  /**\n   * Whether the provided page is active\n   */\n  isPageActive(page: number) {\n    return this.currentPage === page;\n  }\n\n  /**\n   * Set the current page\n   */\n  setPage(page: number) {\n    if (page !== this.currentPage || !this.hasPage(page)) {\n      this.page.next((this.pagination.currentPage = page));\n    }\n  }\n\n  /**\n   * Increment current page\n   */\n  nextPage() {\n    if (this.currentPage !== this.pagination.lastPage) {\n      this.setPage(this.pagination.currentPage + 1);\n    }\n  }\n\n  /**\n   * Decrement current page\n   */\n  prevPage() {\n    if (this.pagination.currentPage > 1) {\n      this.setPage(this.pagination.currentPage - 1);\n    }\n  }\n\n  /**\n   * Set current page to last\n   */\n  setLastPage() {\n    this.setPage(this.pagination.lastPage);\n  }\n\n  /**\n   * Set current page to first\n   */\n  setFirstPage() {\n    this.setPage(1);\n  }\n\n  /**\n   * Check if page exists in cache\n   */\n  hasPage(page: number) {\n    return this.pages.has(page);\n  }\n\n  /**\n   * Get the current page if it's in cache, otherwise invoke the request\n   */\n  getPage(req: () => Observable<PaginationResponse<getEntityType<State>>>) {\n    let page = this.pagination.currentPage;\n    if (this.hasPage(page)) {\n      return this.selectPage(page);\n    } else {\n      this.setLoading(true);\n      return from(req()).pipe(\n        switchMap((config: PaginationResponse<getEntityType<State>>) => {\n          page = config.currentPage;\n          applyTransaction(() => {\n            this.setLoading(false);\n            this.update(config);\n          });\n          return this.selectPage(page);\n        })\n      );\n    }\n  }\n\n  getQuery(): QueryEntity<State> {\n    return this.query;\n  }\n\n  refreshCurrentPage() {\n    if (isNil(this.currentPage) === false) {\n      this.clearPage(this.currentPage);\n      this.setPage(this.currentPage);\n    }\n  }\n\n  private getFrom() {\n    if (this.isFirst) {\n      return 1;\n    }\n    return (this.currentPage - 1) * this.pagination.perPage + 1;\n  }\n\n  private getTo() {\n    if (this.isLast) {\n      return this.pagination.total;\n    }\n    return this.currentPage * this.pagination.perPage;\n  }\n\n  /**\n   * Select the page\n   */\n  private selectPage(page: number): Observable<PaginationResponse<getEntityType<State>>> {\n    return this.query.selectAll({ asObject: true }).pipe(\n      take(1),\n      map(entities => {\n        let response: PaginationResponse<getEntityType<State>> = {\n          ...this.pagination,\n          data: this.pages.get(page).ids.map(id => entities[id])\n        };\n\n        const { range, pagesControls } = this.config;\n\n        /** If no total - calc it */\n        if (isNaN(this.pagination.total)) {\n          if (response.lastPage === 1) {\n            response.total = response.data ? response.data.length : 0;\n          } else {\n            response.total = response.perPage * response.lastPage;\n          }\n          this.pagination.total = response.total;\n        }\n\n        if (range) {\n          response.from = this.getFrom();\n          response.to = this.getTo();\n        }\n\n        if (pagesControls) {\n          response.pageControls = generatePages(this.pagination.total, this.pagination.perPage);\n        }\n\n        return response;\n      })\n    );\n  }\n}\n\n/**\n * Generate an array so we can ngFor them to navigate between pages\n */\nfunction generatePages(total: number, perPage: number) {\n  const len = Math.ceil(total / perPage);\n  let arr = [];\n  for (let i = 0; i < len; i++) {\n    arr.push(i + 1);\n  }\n  return arr;\n}\n\n/** backward compatibility */\nexport const Paginator = PaginatorPlugin;\n","import { AkitaPlugin } from '../plugin';\nimport { Query } from '../../query';\nimport { Observable, Subscription } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { getValue } from '../../getValueByString';\nimport { toBoolean } from '../../toBoolean';\nimport { isString } from '../../isString';\nimport { setValue } from '../../setValueByString';\nimport { logAction } from '../../actions';\n\nexport type FormGroupLike = {\n  patchValue: Function;\n  setValue: Function;\n  value: any;\n  get: Function;\n  valueChanges: Observable<any>;\n  controls: any;\n};\n\nexport type AkitaFormProp<T> = {\n  [key: string]: T;\n};\n\nexport type PersistFormParams = {\n  debounceTime?: number;\n  formKey?: string;\n  emitEvent?: boolean;\n  arrControlFactory?: ArrayControlFactory;\n};\n\nexport type ArrayControlFactory = (value: any) => any; // Todo: Return  AbstractControl interface\n\nexport class PersistNgFormPlugin<T = any> extends AkitaPlugin {\n  formChanges: Subscription;\n  private isRootKeys: boolean;\n  private form: FormGroupLike;\n  private isKeyBased: boolean;\n  private initialValue;\n  private builder;\n\n  constructor(protected query: Query<any>, private factoryFnOrPath?: Function | string, private params: PersistFormParams = {}) {\n    super(query);\n    this.params = { ...{ debounceTime: 300, formKey: 'akitaForm', emitEvent: false, arrControlFactory: v => this.builder.control(v) }, ...params };\n    this.isRootKeys = toBoolean(factoryFnOrPath) === false;\n    this.isKeyBased = isString(factoryFnOrPath) || this.isRootKeys;\n  }\n\n  setForm(form: FormGroupLike, builder?) {\n    this.form = form;\n    this.builder = builder;\n    this.activate();\n    return this;\n  }\n\n  reset(initialState?: T) {\n    let value;\n    if (initialState) {\n      value = initialState;\n    } else {\n      value = this.isKeyBased ? this.initialValue : (this as any).factoryFnOrPath();\n    }\n\n    if (this.isKeyBased) {\n      Object.keys(this.initialValue).forEach(stateKey => {\n        const value = this.initialValue[stateKey];\n        if (Array.isArray(value) && this.builder) {\n          const formArray = this.form.controls[stateKey];\n          this.cleanArray(formArray);\n          value.forEach((v, i) => {\n            this.form.get(stateKey).insert(i, (this.params.arrControlFactory as Function)(v));\n          });\n        }\n      });\n    }\n    this.form.patchValue(value, { emitEvent: this.params.emitEvent });\n\n    const storeValue = this.isKeyBased ? setValue(this.getQuery().getValue(), `${this.getStore().storeName}.${this.factoryFnOrPath}`, value) : { [this.params.formKey]: value };\n    this.updateStore(storeValue);\n  }\n\n  private cleanArray(control) {\n    while (control.length !== 0) {\n      control.removeAt(0);\n    }\n  }\n\n  private resolveInitialValue(formValue, root) {\n    if (!formValue) return;\n    return Object.keys(formValue).reduce((acc, stateKey) => {\n      const value = root[stateKey];\n      if (Array.isArray(value) && this.builder) {\n        const factory = this.params.arrControlFactory;\n        this.cleanArray(this.form.get(stateKey));\n        value.forEach((v, i) => {\n          this.form.get(stateKey).insert(i, (factory as Function)(v));\n        });\n      }\n      acc[stateKey] = root[stateKey];\n      return acc;\n    }, {});\n  }\n\n  private activate() {\n    let path;\n\n    if (this.isKeyBased) {\n      if (this.isRootKeys) {\n        this.initialValue = this.resolveInitialValue(this.form.value, this.getQuery().getValue());\n        this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });\n      } else {\n        path = `${this.getStore().storeName}.${this.factoryFnOrPath}`;\n        const root = getValue(this.getQuery().getValue(), path);\n        this.initialValue = this.resolveInitialValue(root, root);\n        this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });\n      }\n    } else {\n      if (!(this.getQuery().getValue() as AkitaFormProp<T>)[this.params.formKey]) {\n        logAction('@PersistNgFormPlugin activate');\n        this.updateStore({ [this.params.formKey]: (this as any).factoryFnOrPath() });\n      }\n\n      const value = this.getQuery().getValue()[this.params.formKey];\n      this.form.patchValue(value);\n    }\n\n    this.formChanges = this.form.valueChanges.pipe(debounceTime(this.params.debounceTime)).subscribe(value => {\n      logAction('@PersistForm - Update');\n      let newState;\n      if (this.isKeyBased) {\n        if (this.isRootKeys) {\n          newState = state => ({ ...state, ...value });\n        } else {\n          newState = state => setValue(state, path, value);\n        }\n      } else {\n        newState = () => ({ [this.params.formKey]: value });\n      }\n      this.updateStore(newState(this.getQuery().getValue()));\n    });\n  }\n\n  destroy() {\n    this.formChanges && this.formChanges.unsubscribe();\n    this.form = null;\n    this.builder = null;\n  }\n}\n","// @internal\nexport function capitalize(value: string) {\n  return value && value.charAt(0).toUpperCase() + value.slice(1);\n}\n","import { currentAction, setSkipAction } from './actions';\nimport { isDefined } from './isDefined';\nimport { $$addStore, $$deleteStore, $$updateStore } from './dispatchers';\nimport { __stores__ } from './stores';\nimport { capitalize } from './capitalize';\nimport { isNotBrowser } from './root';\n\nexport type DevtoolsOptions = {\n  /** instance name visible in devtools */\n  name: string;\n  /**  maximum allowed actions to be stored in the history tree */\n  maxAge: number;\n  latency: number;\n  actionsBlacklist: string[];\n  actionsWhitelist: string[];\n  storesWhitelist: string[];\n  shouldCatchErrors: boolean;\n  logTrace: boolean;\n  predicate: (state: any, action: any) => boolean;\n  shallow: boolean;\n  sortAlphabetically: boolean;\n};\nlet subs = [];\n\nexport type NgZoneLike = { run: any };\n\nexport function akitaDevtools(ngZone: NgZoneLike, options?: Partial<DevtoolsOptions>);\nexport function akitaDevtools(options?: Partial<DevtoolsOptions>);\nexport function akitaDevtools(ngZoneOrOptions?: NgZoneLike | Partial<DevtoolsOptions>, options: Partial<DevtoolsOptions> = {}) {\n  if (isNotBrowser) return;\n\n  if (!(window as any).__REDUX_DEVTOOLS_EXTENSION__) {\n    return;\n  }\n\n  subs.length &&\n    subs.forEach((s) => {\n      if (s.unsubscribe) {\n        s.unsubscribe();\n      } else {\n        s && s();\n      }\n    });\n\n  const isAngular = ngZoneOrOptions && ngZoneOrOptions['run'];\n\n  if (!isAngular) {\n    ngZoneOrOptions = ngZoneOrOptions || {};\n    (ngZoneOrOptions as any).run = (cb) => cb();\n    options = ngZoneOrOptions as Partial<DevtoolsOptions>;\n  }\n\n  const defaultOptions: Partial<DevtoolsOptions> & { name: string } = { name: 'Akita', shallow: true, storesWhitelist: [] };\n  const merged = Object.assign({}, defaultOptions, options);\n  const storesWhitelist = merged.storesWhitelist;\n  const devTools = (window as any).__REDUX_DEVTOOLS_EXTENSION__.connect(merged);\n  let appState = {};\n\n  const isAllowed = (storeName) => {\n    if (!storesWhitelist.length) {\n      return true;\n    }\n\n    return storesWhitelist.indexOf(storeName) > -1;\n  };\n\n  subs.push(\n    $$addStore.subscribe((storeName) => {\n      if (isAllowed(storeName) === false) return;\n      appState = {\n        ...appState,\n        [storeName]: __stores__[storeName]._value(),\n      };\n      devTools.send({ type: `[${capitalize(storeName)}] - @@INIT` }, appState);\n    })\n  );\n\n  subs.push(\n    $$deleteStore.subscribe((storeName) => {\n      if (isAllowed(storeName) === false) return;\n      delete appState[storeName];\n      devTools.send({ type: `[${storeName}] - Delete Store` }, appState);\n    })\n  );\n\n  subs.push(\n    $$updateStore.subscribe(({ storeName, action }) => {\n      if (isAllowed(storeName) === false) return;\n      const { type, entityIds, skip } = action;\n\n      if (skip) {\n        setSkipAction(false);\n        return;\n      }\n\n      const store = __stores__[storeName];\n      if (!store) {\n        return;\n      }\n\n      if (options.shallow === false && appState[storeName]) {\n        const isEqual = JSON.stringify(store._value()) === JSON.stringify(appState[storeName]);\n        if (isEqual) return;\n      }\n\n      appState = {\n        ...appState,\n        [storeName]: store._value(),\n      };\n\n      const normalize = capitalize(storeName);\n      let msg = isDefined(entityIds) ? `[${normalize}] - ${type} (ids: ${entityIds})` : `[${normalize}] - ${type}`;\n\n      if (options.logTrace) {\n        console.group(msg);\n        console.trace();\n        console.groupEnd();\n      }\n\n      if (options.sortAlphabetically) {\n        const sortedAppState = Object.keys(appState)\n          .sort()\n          .reduce((acc, storeName) => {\n            acc[storeName] = appState[storeName];\n            return acc;\n          }, {});\n\n        devTools.send({ type: msg }, sortedAppState);\n        return;\n      }\n\n      devTools.send({ type: msg }, appState);\n    })\n  );\n\n  subs.push(\n    devTools.subscribe((message) => {\n      if (message.type === 'DISPATCH') {\n        const payloadType = message.payload.type;\n\n        if (payloadType === 'COMMIT') {\n          devTools.init(appState);\n          return;\n        }\n\n        if (message.state) {\n          const rootState = JSON.parse(message.state);\n          for (let i = 0, keys = Object.keys(rootState); i < keys.length; i++) {\n            const storeName = keys[i];\n            if (__stores__[storeName]) {\n              (ngZoneOrOptions as NgZoneLike).run(() => {\n                __stores__[storeName]._setState(() => rootState[storeName], false);\n              });\n            }\n          }\n        }\n      }\n    })\n  );\n}\n","import { Observable } from 'rxjs';\nimport { EntityState, OrArray, getIDType } from '../types';\nimport { QueryEntity } from '../queryEntity';\nimport { isUndefined } from '../isUndefined';\nimport { coerceArray } from '../coerceArray';\nimport { toBoolean } from '../toBoolean';\nimport { isFunction } from '../isFunction';\n\nexport type RebaseAction<P = any> = (plugin: P) => any;\n\nexport type RebaseActions<P = any> = { beforeRemove?: RebaseAction; beforeAdd?: RebaseAction; afterAdd?: RebaseAction };\n\n/**\n * Each plugin that wants to add support for entities should extend this interface.\n */\nexport abstract class EntityCollectionPlugin<State extends EntityState, P> {\n  protected entities = new Map<getIDType<State>, P>();\n\n  protected constructor(protected query: QueryEntity<State>, private entityIds: OrArray<getIDType<State>>) {}\n\n  /**\n   * Get the entity plugin instance.\n   */\n  protected getEntity(id: getIDType<State>): P {\n    return this.entities.get(id);\n  }\n\n  /**\n   * Whether the entity plugin exist.\n   */\n  protected hasEntity(id: getIDType<State>): boolean {\n    return this.entities.has(id);\n  }\n\n  /**\n   * Remove the entity plugin instance.\n   */\n  protected removeEntity(id: getIDType<State>) {\n    this.destroy(id);\n    return this.entities.delete(id);\n  }\n\n  /**\n   * Set the entity plugin instance.\n   */\n  protected createEntity(id: getIDType<State>, plugin: P) {\n    return this.entities.set(id, plugin);\n  }\n\n  /**\n   * If the user passes `entityIds` we take them; otherwise, we take all.\n   */\n  protected getIds(): any {\n    return isUndefined(this.entityIds) ? this.query.getValue().ids : coerceArray(this.entityIds);\n  }\n\n  /**\n   * When you call one of the plugin methods, you can pass id/ids or undefined which means all.\n   */\n  protected resolvedIds(ids?): getIDType<State>[] {\n    return isUndefined(ids) ? this.getIds() : coerceArray(ids);\n  }\n\n  /**\n   * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.\n   *\n   * For example in your plugin you may do the following:\n   *\n   * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));\n   */\n  protected rebase(ids: getIDType<State>[], actions: RebaseActions<P> = {}) {\n    /**\n     *\n     * If the user passes `entityIds` & we have new ids check if we need to add/remove instances.\n     *\n     * This phase will be called only upon update.\n     */\n    if (toBoolean(ids)) {\n      /**\n       * Which means all\n       */\n      if (isUndefined(this.entityIds)) {\n        for (let i = 0, len = ids.length; i < len; i++) {\n          const entityId = ids[i];\n          if (this.hasEntity(entityId) === false) {\n            isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);\n            const plugin = this.instantiatePlugin(entityId);\n            this.entities.set(entityId, plugin);\n            isFunction(actions.afterAdd) && actions.afterAdd(plugin);\n          }\n        }\n\n        this.entities.forEach((plugin, entityId) => {\n          if (ids.indexOf(entityId) === -1) {\n            isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);\n            this.removeEntity(entityId);\n          }\n        });\n      } else {\n        /**\n         * Which means the user passes specific ids\n         */\n        const _ids = coerceArray(this.entityIds);\n        for (let i = 0, len = _ids.length; i < len; i++) {\n          const entityId = _ids[i];\n          /** The Entity in current ids and doesn't exist, add it. */\n          if (ids.indexOf(entityId) > -1 && this.hasEntity(entityId) === false) {\n            isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);\n            const plugin = this.instantiatePlugin(entityId);\n            this.entities.set(entityId, plugin);\n            isFunction(actions.afterAdd) && actions.afterAdd(plugin);\n          } else {\n            this.entities.forEach((plugin, entityId) => {\n              /** The Entity not in current ids and exists, remove it. */\n              if (ids.indexOf(entityId) === -1 && this.hasEntity(entityId) === true) {\n                isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);\n                this.removeEntity(entityId);\n              }\n            });\n          }\n        }\n      }\n    } else {\n      /**\n       * Otherwise, start with the provided ids or all.\n       */\n      this.getIds().forEach(id => {\n        if (!this.hasEntity(id)) this.createEntity(id, this.instantiatePlugin(id));\n      });\n    }\n  }\n\n  /**\n   * Listen for add/remove entities.\n   */\n  protected selectIds(): Observable<any> {\n    return this.query.select(state => state.ids);\n  }\n\n  /**\n   * Base method for activation, you can override it if you need to.\n   */\n  protected activate(ids?: any[]) {\n    this.rebase(ids);\n  }\n\n  /**\n   * This method is responsible for plugin instantiation.\n   *\n   * For example:\n   * return new StateHistory(this.query, this.params, id) as P;\n   */\n  protected abstract instantiatePlugin(id: getIDType<State>): P;\n\n  /**\n   * This method is responsible for cleaning.\n   */\n  public abstract destroy(id?: getIDType<State>);\n\n  /**\n   * Loop over each id and invoke the plugin method.\n   */\n  protected forEachId(ids: OrArray<getIDType<State>>, cb: (entity: P) => any) {\n    const _ids = this.resolvedIds(ids);\n\n    for (let i = 0, len = _ids.length; i < len; i++) {\n      const id = _ids[i];\n      if (this.hasEntity(id)) {\n        cb(this.getEntity(id));\n      }\n    }\n  }\n}\n","import { pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { AkitaPlugin, Queries } from '../plugin';\nimport { logAction } from '../../actions';\nimport { isFunction } from '../../isFunction';\n\nexport interface StateHistoryParams {\n  maxAge?: number;\n  watchProperty?: string;\n  comparator?: (prevState, currentState) => boolean;\n}\n\nexport type History<State> = {\n  past: State[];\n  present: State | null;\n  future: State[];\n};\n\nexport class StateHistoryPlugin<State = any> extends AkitaPlugin<State> {\n  /** Allow skipping an update from outside */\n  private skip = false;\n\n  private history = {\n    past: [],\n    present: null,\n    future: []\n  };\n\n  /** Skip the update when redo/undo */\n  private skipUpdate = false;\n  private subscription;\n\n  /* Subjects for supporting observable hasPast$ and hasFuture$ */\n  private hasPastSubject: BehaviorSubject<boolean>;\n  private _hasPast$: Observable<boolean>;\n  private hasFutureSubject: BehaviorSubject<boolean>;\n  private _hasFuture$: Observable<boolean>;\n\n  constructor(protected query: Queries<State>, private params: StateHistoryParams = {}, private _entityId?: any) {\n    super(query, {\n      resetFn: () => this.clear()\n    });\n    params.maxAge = !!params.maxAge ? params.maxAge : 10;\n    params.comparator = params.comparator || (() => true);\n\n    this.activate();\n  }\n\n  /**\n   * Observable stream representing whether the history plugin has an available past\n   *\n   */\n  get hasPast$(): Observable<boolean> {\n    return this._hasPast$;\n  }\n\n  /**\n   * Observable stream representing whether the history plugin has an available future\n   *\n   */\n  get hasFuture$(): Observable<boolean> {\n    return this._hasFuture$;\n  }\n\n  get hasPast() {\n    return this.history.past.length > 0;\n  }\n\n  get hasFuture() {\n    return this.history.future.length > 0;\n  }\n\n  private get property() {\n    return this.params.watchProperty;\n  }\n\n  /* Updates the hasPast$ hasFuture$ observables*/\n  private updateHasHistory() {\n    this.hasFutureSubject.next(this.hasFuture);\n    this.hasPastSubject.next(this.hasPast);\n  }\n\n  activate() {\n    this.hasPastSubject = new BehaviorSubject(false);\n    this._hasPast$ = this.hasPastSubject.asObservable().pipe(distinctUntilChanged());\n    this.hasFutureSubject = new BehaviorSubject(false);\n    this._hasFuture$ = this.hasFutureSubject.asObservable().pipe(distinctUntilChanged());\n\n    this.history.present = this.getSource(this._entityId, this.property);\n    this.subscription = (this as any)\n      .selectSource(this._entityId, this.property)\n      .pipe(pairwise())\n      .subscribe(([past, present]) => {\n        if (this.skip) {\n          this.skip = false;\n          return;\n        }\n        /**\n         *  comparator: (prev, current) => isEqual(prev, current) === false\n         */\n        const shouldUpdate = this.params.comparator(past, present);\n\n        if (!this.skipUpdate && shouldUpdate) {\n          if (this.history.past.length === this.params.maxAge) {\n            this.history.past = this.history.past.slice(1);\n          }\n          this.history.past = [...this.history.past, past];\n          this.history.present = present;\n          this.updateHasHistory();\n        }\n      });\n  }\n\n  undo() {\n    if (this.history.past.length > 0) {\n      const { past, present } = this.history;\n      const previous = past[past.length - 1];\n      this.history.past = past.slice(0, past.length - 1);\n      this.history.present = previous;\n      this.history.future = [present, ...this.history.future];\n      this.update();\n    }\n  }\n\n  redo() {\n    if (this.history.future.length > 0) {\n      const { past, present } = this.history;\n      const next = this.history.future[0];\n      const newFuture = this.history.future.slice(1);\n      this.history.past = [...past, present];\n      this.history.present = next;\n      this.history.future = newFuture;\n      this.update('Redo');\n    }\n  }\n\n  jumpToPast(index: number) {\n    if (index < 0 || index >= this.history.past.length) return;\n\n    const { past, future, present } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9];\n     * const index = 2;\n     *\n     * newPast = past.slice(0, index) = [1, 2];\n     * newPresent = past[index] = 3;\n     * newFuture = [...past.slice(index + 1),present, ...future] = [4, 5, 6, 7, 8, 9];\n     *\n     */\n    const newPast = past.slice(0, index);\n    const newFuture = [...past.slice(index + 1), present, ...future];\n    const newPresent = past[index];\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update();\n  }\n\n  jumpToFuture(index: number) {\n    if (index < 0 || index >= this.history.future.length) return;\n\n    const { past, future, present } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9, 10]\n     * const index = 1\n     *\n     * newPast = [...past, present, ...future.slice(0, index) = [1, 2, 3, 4, 5, 6, 7];\n     * newPresent = future[index] = 8;\n     * newFuture = futrue.slice(index+1) = [9, 10];\n     *\n     */\n\n    const newPast = [...past, present, ...future.slice(0, index)];\n    const newPresent = future[index];\n    const newFuture = future.slice(index + 1);\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update('Redo');\n  }\n\n  /**\n   *\n   * jump n steps in the past or forward\n   *\n   */\n  jump(n: number) {\n    if (n > 0) return this.jumpToFuture(n - 1);\n    if (n < 0) return this.jumpToPast(this.history.past.length + n);\n  }\n\n  /**\n   * Clear the history\n   *\n   * @param customUpdateFn Callback function for only clearing part of the history\n   *\n   * @example\n   *\n   * stateHistory.clear((history) => {\n   *  return {\n   *    past: history.past,\n   *    present: history.present,\n   *    future: []\n   *  };\n   * });\n   */\n  clear(customUpdateFn?: (history: History<State>) => History<State>) {\n    this.history = isFunction(customUpdateFn)\n      ? customUpdateFn(this.history)\n      : {\n          past: [],\n          present: null,\n          future: []\n        };\n    this.updateHasHistory();\n  }\n\n  destroy(clearHistory = false) {\n    if (clearHistory) {\n      this.clear();\n    }\n    this.subscription.unsubscribe();\n  }\n\n  ignoreNext() {\n    this.skip = true;\n  }\n\n  private update(action = 'Undo') {\n    this.skipUpdate = true;\n    logAction(`@StateHistory - ${action}`);\n    this.updateStore(this.history.present, this._entityId, this.property);\n    this.updateHasHistory();\n    this.skipUpdate = false;\n  }\n}\n","import { EntityState, OrArray, getIDType } from '../../types';\nimport { QueryEntity } from '../../queryEntity';\nimport { StateHistoryParams, StateHistoryPlugin } from './stateHistoryPlugin';\nimport { toBoolean } from '../../toBoolean';\nimport { skip } from 'rxjs/operators';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\n\nexport interface StateHistoryEntityParams<IDType> extends StateHistoryParams {\n  entityIds?: OrArray<IDType>;\n}\n\nexport class EntityStateHistoryPlugin<State extends EntityState = any, P extends StateHistoryPlugin<State> = StateHistoryPlugin<State>> extends EntityCollectionPlugin<State, P> {\n  constructor(protected query: QueryEntity<State>, protected readonly params: StateHistoryEntityParams<getIDType<State>> = {}) {\n    super(query, params.entityIds);\n    params.maxAge = toBoolean(params.maxAge) ? params.maxAge : 10;\n    this.activate();\n    this.selectIds()\n      .pipe(skip(1))\n      .subscribe(ids => this.activate(ids));\n  }\n\n  redo(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.redo());\n  }\n\n  undo(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.undo());\n  }\n\n  hasPast(id: getIDType<State>) {\n    if (this.hasEntity(id)) {\n      return this.getEntity(id).hasPast;\n    }\n  }\n\n  hasFuture(id: getIDType<State>) {\n    if (this.hasEntity(id)) {\n      return this.getEntity(id).hasFuture;\n    }\n  }\n\n  jumpToFuture(ids: OrArray<getIDType<State>>, index: number) {\n    this.forEachId(ids, e => e.jumpToFuture(index));\n  }\n\n  jumpToPast(ids: OrArray<getIDType<State>>, index: number) {\n    this.forEachId(ids, e => e.jumpToPast(index));\n  }\n\n  clear(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.clear());\n  }\n\n  destroy(ids?: OrArray<getIDType<State>>, clearHistory = false) {\n    this.forEachId(ids, e => e.destroy(clearHistory));\n  }\n\n  ignoreNext(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.ignoreNext());\n  }\n\n  protected instantiatePlugin(id: getIDType<State>) {\n    return new StateHistoryPlugin<State>(this.query, this.params, id) as P;\n  }\n}\n","import { AkitaPlugin, Queries } from '../plugin';\nimport { QueryEntity } from '../../queryEntity';\nimport { BehaviorSubject, combineLatest, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, map, skip } from 'rxjs/operators';\nimport { isUndefined } from '../../isUndefined';\nimport { Query } from '../../query';\nimport { coerceArray } from '../../coerceArray';\nimport { isFunction } from '../../isFunction';\nimport { logAction } from '../../actions';\n\ntype Head<State = any> = State | Partial<State>;\n\nexport type DirtyCheckComparator<State> = (head: State, current: State) => boolean;\n\nexport type DirtyCheckParams<StoreState = any> = {\n  comparator?: DirtyCheckComparator<StoreState>;\n  watchProperty?: keyof StoreState | (keyof StoreState)[];\n};\n\nexport const dirtyCheckDefaultParams = {\n  comparator: (head, current) => JSON.stringify(head) !== JSON.stringify(current)\n};\n\nexport function getNestedPath(nestedObj, path: string) {\n  const pathAsArray: string[] = path.split('.');\n  return pathAsArray.reduce((obj, key) => (obj && obj[key] !== 'undefined' ? obj[key] : undefined), nestedObj);\n}\n\nexport type DirtyCheckResetParams<StoreState = any> = {\n  updateFn?: StoreState | ((head: StoreState, current: StoreState) => any);\n};\n\nexport class DirtyCheckPlugin<State = any> extends AkitaPlugin<State> {\n  private head: Head<State>;\n  private dirty = new BehaviorSubject(false);\n  private subscription: Subscription;\n  private active = false;\n  private _reset = new Subject();\n\n  isDirty$: Observable<boolean> = this.dirty.asObservable().pipe(distinctUntilChanged());\n  reset$ = this._reset.asObservable();\n\n  constructor(protected query: Queries<State>, private params?: DirtyCheckParams<State>, private _entityId?: any) {\n    super(query);\n    this.params = { ...dirtyCheckDefaultParams, ...params };\n    if (this.params.watchProperty) {\n      let watchProp = coerceArray(this.params.watchProperty) as any[];\n      if (query instanceof QueryEntity && watchProp.includes('entities') && !watchProp.includes('ids')) {\n        watchProp.push('ids');\n      }\n      this.params.watchProperty = watchProp;\n    }\n  }\n\n  reset(params: DirtyCheckResetParams = {}) {\n    let currentValue = this.head;\n    if (isFunction(params.updateFn)) {\n      if (this.isEntityBased(this._entityId)) {\n        currentValue = params.updateFn(this.head, (this.getQuery() as QueryEntity<State>).getEntity(this._entityId));\n      } else {\n        currentValue = params.updateFn(this.head, (this.getQuery() as Query<State>).getValue());\n      }\n    }\n    logAction(`@DirtyCheck - Revert`);\n    this.updateStore(currentValue, this._entityId);\n    this._reset.next();\n  }\n\n  setHead() {\n    if (!this.active) {\n      this.activate();\n      this.active = true;\n    } else {\n      this.head = this._getHead();\n    }\n    this.updateDirtiness(false);\n    return this;\n  }\n\n  isDirty(): boolean {\n    return !!this.dirty.value;\n  }\n\n  hasHead() {\n    return !!this.getHead();\n  }\n\n  destroy() {\n    this.head = null;\n    this.subscription && this.subscription.unsubscribe();\n    this._reset && this._reset.complete();\n  }\n\n  isPathDirty(path: string) {\n    const head = this.getHead();\n    const current = (this.getQuery() as Query<State>).getValue();\n    const currentPathValue = getNestedPath(current, path);\n    const headPathValue = getNestedPath(head, path);\n\n    return this.params.comparator(currentPathValue, headPathValue);\n  }\n\n  protected getHead() {\n    return this.head;\n  }\n\n  private activate() {\n    this.head = this._getHead();\n    /** if we are tracking specific properties select only the relevant ones */\n    const source = this.params.watchProperty\n      ? (this.params.watchProperty as (keyof State)[]).map(prop =>\n          this.query\n            .select(state => state[prop])\n            .pipe(\n              map(val => ({\n                val,\n                __akitaKey: prop\n              }))\n            )\n        )\n      : [this.selectSource(this._entityId)];\n    this.subscription = combineLatest(...source)\n      .pipe(skip(1))\n      .subscribe((currentState: any[]) => {\n        if (isUndefined(this.head)) return;\n        /** __akitaKey is used to determine if we are tracking a specific property or a store change */\n        const isChange = currentState.some(state => {\n          const head = state.__akitaKey ? this.head[state.__akitaKey as any] : this.head;\n          const compareTo = state.__akitaKey ? state.val : state;\n\n          return this.params.comparator(head, compareTo);\n        });\n\n        this.updateDirtiness(isChange);\n      });\n  }\n\n  private updateDirtiness(isDirty: boolean) {\n    this.dirty.next(isDirty);\n  }\n\n  private _getHead(): Head<State> {\n    let head: Head<State> = this.getSource(this._entityId);\n    if (this.params.watchProperty) {\n      head = this.getWatchedValues(head as State);\n    }\n    return head;\n  }\n\n  private getWatchedValues(source: State): Partial<State> {\n    return (this.params.watchProperty as (keyof State)[]).reduce(\n      (watched, prop) => {\n        watched[prop] = source[prop];\n        return watched;\n      },\n      {} as Partial<State>\n    );\n  }\n}\n","import { DirtyCheckComparator, dirtyCheckDefaultParams, DirtyCheckPlugin, DirtyCheckResetParams, getNestedPath } from './dirtyCheckPlugin';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\nimport { auditTime, map, skip } from 'rxjs/operators';\nimport { merge, Observable, Subject } from 'rxjs';\nimport { EntityState, OrArray, getIDType, getEntityType } from '../../types';\nimport { QueryEntity } from '../../queryEntity';\nimport { coerceArray } from '../../coerceArray';\n\nexport type DirtyCheckCollectionParams<State extends EntityState> = {\n  comparator?: DirtyCheckComparator<getEntityType<State>>;\n  entityIds?: OrArray<getIDType<State>>;\n};\n\nexport class EntityDirtyCheckPlugin<State extends EntityState = any, P extends DirtyCheckPlugin<State> = DirtyCheckPlugin<State>> extends EntityCollectionPlugin<State, P> {\n  private _someDirty = new Subject();\n  someDirty$: Observable<boolean> = merge(this.query.select(state => state.entities), this._someDirty.asObservable()).pipe(\n    auditTime(0),\n    map(() => this.checkSomeDirty())\n  );\n\n  constructor(protected query: QueryEntity<State>, private readonly params: DirtyCheckCollectionParams<State> = {}) {\n    super(query, params.entityIds);\n    this.params = { ...dirtyCheckDefaultParams, ...params };\n    // TODO lazy activate?\n    this.activate();\n    this.selectIds()\n      .pipe(skip(1))\n      .subscribe(ids => {\n        super.rebase(ids, { afterAdd: plugin => plugin.setHead() });\n      });\n  }\n\n  setHead(ids?: OrArray<getIDType<State>>) {\n    if (this.params.entityIds && ids) {\n      const toArray = coerceArray(ids) as getIDType<State>[];\n      const someAreWatched = coerceArray(this.params.entityIds).some(id => toArray.indexOf(id) > -1);\n      if (someAreWatched === false) {\n        return this;\n      }\n    }\n    this.forEachId(ids, e => e.setHead());\n    this._someDirty.next();\n    return this;\n  }\n\n  hasHead(id: getIDType<State>): boolean {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return entity.hasHead();\n    }\n\n    return false;\n  }\n\n  reset(ids?: OrArray<getIDType<State>>, params: DirtyCheckResetParams = {}) {\n    this.forEachId(ids, e => e.reset(params));\n  }\n\n  isDirty(id: getIDType<State>): Observable<boolean>;\n  isDirty(id: getIDType<State>, asObservable: true): Observable<boolean>;\n  isDirty(id: getIDType<State>, asObservable: false): boolean;\n  isDirty(id: getIDType<State>, asObservable = true): Observable<boolean> | boolean {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return asObservable ? entity.isDirty$ : entity.isDirty();\n    }\n\n    return false;\n  }\n\n  someDirty(): boolean {\n    return this.checkSomeDirty();\n  }\n\n  isPathDirty(id: getIDType<State>, path: string) {\n    if (this.entities.has(id)) {\n      const head = (this.getEntity(id) as any).getHead();\n      const current = this.query.getEntity(id);\n      const currentPathValue = getNestedPath(current, path);\n      const headPathValue = getNestedPath(head, path);\n\n      return this.params.comparator(currentPathValue, headPathValue);\n    }\n\n    return null;\n  }\n\n  destroy(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.destroy());\n    /** complete only when the plugin destroys */\n    if (!ids) {\n      this._someDirty.complete();\n    }\n  }\n\n  protected instantiatePlugin(id: getIDType<State>): P {\n    return new DirtyCheckPlugin(this.query, this.params, id) as P;\n  }\n\n  private checkSomeDirty(): boolean {\n    const entitiesIds = this.resolvedIds();\n    for (const id of entitiesIds) {\n      if (this.getEntity(id).isDirty()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","import { EntityStore } from './entityStore';\nimport { AkitaError } from './errors';\nimport { isNil } from './isNil';\nimport { Store } from './store';\nimport { configKey } from './storeConfig';\nimport { __stores__ } from './stores';\nimport { Constructor } from './types';\n\nexport enum StoreAction {\n  Update = 'UPDATE',\n}\n\nconst StoreActionMapping = {\n  [StoreAction.Update]: 'update',\n};\n\nexport enum EntityStoreAction {\n  Update = 'UPDATE',\n  AddEntities = 'ADD_ENTITIES',\n  SetEntities = 'SET_ENTITIES',\n  UpdateEntities = 'UPDATE_ENTITIES',\n  RemoveEntities = 'REMOVE_ENTITIES',\n  UpsertEntities = 'UPSERT_ENTITIES',\n  UpsertManyEntities = 'UPSERT_MANY_ENTITIES',\n}\n\nconst EntityStoreActionMapping = {\n  [EntityStoreAction.Update]: 'update',\n  [EntityStoreAction.AddEntities]: 'add',\n  [EntityStoreAction.SetEntities]: 'set',\n  [EntityStoreAction.UpdateEntities]: 'update',\n  [EntityStoreAction.RemoveEntities]: 'remove',\n  [EntityStoreAction.UpsertEntities]: 'upsert',\n  [EntityStoreAction.UpsertManyEntities]: 'upsertMany',\n};\n\n/**\n * Get a {@link Store} from the global store registry.\n * @param storeClass The {@link Store} class of the instance to be returned.\n */\nexport function getStore<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : never>(storeClass: Constructor<TStore>): TStore {\n  return getStoreByName<TStore, S>(storeClass[configKey]['storeName']);\n}\n\n/**\n * Get a {@link Store} from the global store registry.\n * @param storeName The {@link Store} name of the instance to be returned.\n */\nexport function getStoreByName<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : never>(storeName: string): TStore {\n  const store = __stores__[storeName] as TStore;\n\n  if (isNil(store)) {\n    throw new AkitaError(`${store} doesn't exist`);\n  }\n\n  return store;\n}\n\n/**\n * Get a {@link EntityStore} from the global store registry.\n * @param storeClass The {@link EntityStore} class of the instance to be returned.\n */\nexport function getEntityStore<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : never>(storeClass: Constructor<TEntityStore>): TEntityStore {\n  return getStore(storeClass as Constructor<Store<S>>) as TEntityStore;\n}\n\n/**\n * Get a {@link EntityStore} from the global store registry.\n * @param storeName The {@link EntityStore} name of the instance to be returned.\n */\nexport function getEntityStoreByName<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : never>(storeName: string): TEntityStore {\n  return getStoreByName<TEntityStore, S>(storeName) as TEntityStore;\n}\n\n/**\n * Run {@link StoreAction.Update} action.\n * @param storeClassOrName The {@link Store} class or name in which the action should be executed.\n * @param action The {@link StoreAction.Update} action, see {@link Store.update}.\n * @param operation The operation to execute the {@link StoreAction.Update} action.\n * @example\n *\n *  runStoreAction(BooksStore, StoreAction.Update, update => update({ filter: 'COMPLETE' }));\n *\n */\nexport function runStoreAction<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : any>(\n  storeClassOrName: Constructor<TStore> | string,\n  action: StoreAction.Update,\n  operation: (operator: TStore['update']) => void\n);\nexport function runStoreAction<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : any>(\n  storeClassOrName: Constructor<TStore> | string,\n  action: StoreAction,\n  operation: (operator: TStore[keyof TStore] & Function) => void\n) {\n  const store = typeof storeClassOrName === 'string' ? getStoreByName<TStore, S>(storeClassOrName) : getStore<TStore, S>(storeClassOrName);\n  operation(store[StoreActionMapping[action]].bind(store));\n}\n\n/**\n * Run {@link EntityStoreAction.SetEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.SetEntities} action, see {@link EntityStore.set}.\n * @param operation The operation to execute the {@link EntityStoreAction.SetEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.SetEntities, set => set([{ id: 1 }, { id: 2 }]));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.SetEntities,\n  operation: (operator: TEntityStore['set']) => void\n);\n/**\n * Run {@link EntityStoreAction.AddEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.AddEntities} action, see {@link EntityStore.add}.\n * @param operation The operation to execute the {@link EntityStoreAction.AddEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.AddEntities, add => add({ id: 1 }));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.AddEntities,\n  operation: (operator: TEntityStore['add']) => void\n);\n/**\n * Run {@link EntityStoreAction.UpdateEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.UpdateEntities} action, see {@link EntityStore.update}.\n * @param operation The operation to execute the {@link EntityStoreAction.UpdateEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.UpdateEntities, update => update(2, { title: 'New title' }));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.UpdateEntities,\n  operation: (operator: TEntityStore['update']) => void\n);\n/**\n * Run {@link EntityStoreAction.RemoveEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.RemoveEntities} action, see {@link EntityStore.remove}.\n * @param operation The operation to execute the {@link EntityStoreAction.RemoveEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.RemoveEntities, remove => remove(2));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.RemoveEntities,\n  operation: (operator: TEntityStore['remove']) => void\n);\n/**\n * Run {@link EntityStoreAction.UpsertEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.UpsertEntities} action, see {@link EntityStore.upsert}.\n * @param operation The operation to execute the {@link EntityStoreAction.UpsertEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.UpsertEntities, upsert => upsert([2, 3], { title: 'New Title' }, (id, newState) => ({ id, ...newState, price: 0 })));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.UpsertEntities,\n  operation: (operator: TEntityStore['upsert']) => void\n);\n/**\n * Run {@link EntityStoreAction.UpsertManyEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.UpsertManyEntities} action, see {@link EntityStore.upsertMany}.\n * @param operation The operation to execute the {@link EntityStoreAction.UpsertManyEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.UpsertManyEntities, upsertMany => upsertMany([\n *    { id: 2, title: 'New title', price: 0 },\n *    { id: 4, title: 'Another title', price: 0 },\n *  ));\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.UpsertManyEntities,\n  operation: (operator: TEntityStore['upsertMany']) => void\n);\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction,\n  operation: (operator: TEntityStore[keyof TEntityStore] & Function) => void\n) {\n  const store = typeof storeClassOrName === 'string' ? getEntityStoreByName<TEntityStore, S>(storeClassOrName) : getEntityStore<TEntityStore, S>(storeClassOrName);\n  operation(store[EntityStoreActionMapping[action]].bind(store));\n}\n","import { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { isFunction } from './isFunction';\nimport { isObject } from './isObject';\nimport { IDS, ItemPredicate } from './types';\n\n/**\n * Update item in a collection\n *\n * @example\n *\n *\n * store.update(1, entity => ({\n *   comments: arrayUpdate(entity.comments, 1, { name: 'newComment' })\n * }))\n */\nexport function arrayUpdate<T extends any[], Entity = any>(arr: T, predicateOrIds: IDS | ItemPredicate<Entity>, obj: Partial<Entity>, idKey = DEFAULT_ID_KEY): T {\n  let condition: ItemPredicate<Entity>;\n\n  if (isFunction(predicateOrIds)) {\n    condition = predicateOrIds;\n  } else {\n    const ids = coerceArray(predicateOrIds);\n    condition = (item) => ids.includes(isObject(item) ? item[idKey] : item) === true;\n  }\n\n  const updateFn = (state) =>\n    state.map((entity, index) => {\n      if (condition(entity, index) === true) {\n        return isObject(entity)\n          ? {\n              ...entity,\n              ...obj,\n            }\n          : obj;\n      }\n\n      return entity;\n    });\n\n  return updateFn(arr);\n}\n","import { OrArray } from './types';\nimport { coerceArray } from './coerceArray';\nimport { AddEntitiesOptions } from './addEntities';\n\n/**\n * Add item to a collection\n *\n * @example\n *\n *\n * store.update(state => ({\n *   comments: arrayAdd(state.comments, { id: 2 })\n * }))\n *\n */\n\nexport function arrayAdd<T extends any[], Entity = any>(arr: T, newEntity: OrArray<Entity>, options: AddEntitiesOptions = {}): T {\n  const newEntities = coerceArray(newEntity);\n  const toArr = arr || [];\n\n  return options.prepend ? [...newEntities, ...toArr] : ([...toArr, ...newEntities] as any);\n}\n","/**\n * Create an array value comparator for a specific key of the value.\n * @param prop The property of the value to be compared.\n */\nexport function byKey<T>(prop: keyof T) {\n  return (a: T, b: T) => a[prop] === b[prop];\n}\n\n/**\n * Create an array value comparator for the id field of an array value.\n */\nexport function byId<T extends Record<'id', any>>() {\n  return byKey<T>('id');\n}\n\n/**\n * Adds or removes a value from an array by comparing its values. If a matching value exists it is removed, otherwise\n * it is added to the array.\n *\n * @param array The array to modify.\n * @param newValue The new value to toggle.\n * @param compare A compare function to determine equality of array values. Default is an equality test by object identity.\n */\nexport function arrayToggle<T>(array: T[], newValue: T, compare: (a: T, b: T) => boolean = (a, b) => a === b) {\n  const index = array.findIndex((oldValue) => compare(newValue, oldValue));\n  return !!~index ? [...array.slice(0, index), ...array.slice(index + 1)] : [...array, newValue];\n}\n","import { EntityState, getEntityType, getIDType } from './types';\nimport { Observable } from 'rxjs';\n\nexport abstract class EntityService<S extends EntityState> {\n  abstract get<T>(id?: getIDType<S>, config?: any): Observable<T>;\n  abstract add<T>(entity: getEntityType<EntityState>, config?: any): Observable<T>;\n  abstract update<T>(id: getIDType<S>, entity: Partial<getEntityType<S>>, config: any): Observable<T>;\n  abstract delete<T>(id: getIDType<S>, config: any): Observable<T>;\n}\n","import { merge, MonoTypeOperatorFunction, Observable, of, Operator, Subscriber, TeardownLogic } from 'rxjs';\nimport { filter, first, switchMap, tap } from 'rxjs/operators';\nimport { QueryEntity } from './queryEntity';\nimport { EntityState, getEntityType, getQueryEntityState } from './types';\n\n/**\n * Track id updates of an entity and re-evaluation the query with the changed entity id.\n * Hint: Don't place the operator after other operators in the same pipeline as those will be skipped on\n * re-evaluation. Also, it can't be used with the selection operator, e.g <code>selectEntity(1, e => e.title)</code>\n * @param query The query from which the entity is selected.\n * @example\n *\n *   query.selectEntity(1).pipe(trackIdChanges(query)).subscribe(entity => { ... })\n *\n */\nexport function trackIdChanges<K extends QueryEntity<S, T>, S extends EntityState<T> = getQueryEntityState<K>, T = getEntityType<S>>(query: K): MonoTypeOperatorFunction<T> {\n  return (source) => source.lift<T>(new TrackIdChanges(query));\n}\n\nclass TrackIdChanges<K extends QueryEntity<S, T>, S extends EntityState<T>, T = getEntityType<S>> implements Operator<T, T> {\n  constructor(readonly query: K) {}\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    return source\n      .pipe(\n        first(),\n        switchMap((entity) => {\n          let currId = entity[this.query.__store__.config.idKey];\n          let pending = false;\n\n          return merge(of({ newId: undefined, oldId: currId, pending: false }), this.query.__store__.selectEntityIdChanges$).pipe(\n            // the new id must differ form the old id\n            filter((change) => change.oldId === currId),\n            // extract the current pending state of the id update\n            tap((change) => (pending = change.pending)),\n            // only update the selection query if the id update is already applied to the store\n            filter((change) => change.newId !== currId && !pending),\n            // build a selection query for the new entity id\n            switchMap((change) =>\n              this.query\n                .selectEntity((currId = change.newId || currId))\n                // skip undefined value if pending.\n                .pipe(filter(() => !pending))\n            )\n          );\n        })\n      )\n      .subscribe(subscriber);\n  }\n}\n","import { Order } from './sort';\n\nexport type SortBy<E, S = any> = ((a: E, b: E, state?: S) => number) | keyof E;\n\nexport interface SortByOptions<E> {\n  sortBy?: SortBy<E>;\n  sortByOrder?: Order;\n}\n\nexport interface QueryConfigOptions<E = any> extends SortByOptions<E> {}\n\nexport const queryConfigKey = 'akitaQueryConfig';\n\nexport function QueryConfig<E>(metadata: QueryConfigOptions<E>) {\n  return function(constructor: Function) {\n    constructor[queryConfigKey] = {};\n    for (let i = 0, keys = Object.keys(metadata); i < keys.length; i++) {\n      const key = keys[i];\n      constructor[queryConfigKey][key] = metadata[key];\n    }\n  };\n}\n","import { AkitaConfig } from './config';\n\nexport type StoreConfigOptions = {\n  name: string;\n  resettable?: AkitaConfig['resettable'];\n  cache?: { ttl: number };\n  deepFreezeFn?: (o: any) => any;\n  idKey?: string;\n  producerFn?: AkitaConfig['producerFn'];\n};\n\nexport type UpdatableStoreConfigOptions = {\n  cache?: { ttl: number };\n};\n\nexport const configKey = 'akitaConfig';\n\nexport function StoreConfig(metadata: StoreConfigOptions) {\n  return function(constructor: Function) {\n    constructor[configKey] = { idKey: 'id' };\n\n    for (let i = 0, keys = Object.keys(metadata); i < keys.length; i++) {\n      const key = keys[i];\n      /* name is preserved read only key */\n      if (key === 'name') {\n        constructor[configKey]['storeName'] = metadata[key];\n      } else {\n        constructor[configKey][key] = metadata[key];\n      }\n    }\n  };\n}\n","import { IDS, ItemPredicate } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { coerceArray } from './coerceArray';\nimport { isObject } from './isObject';\nimport { isFunction } from './isFunction';\nimport { not } from './not';\n\n/**\n * Remove item from collection\n *\n * @example\n *\n *\n * store.update(state => ({\n *   names: arrayRemove(state.names, ['one', 'second'])\n * }))\n */\nexport function arrayRemove<T extends any[], Entity = any>(arr: T, identifier: IDS | ItemPredicate<Entity>, idKey = DEFAULT_ID_KEY): T {\n  let identifiers;\n  let filterFn;\n\n  if (isFunction(identifier)) {\n    filterFn = not(identifier);\n  } else {\n    identifiers = coerceArray(identifier as IDS);\n    filterFn = (current) => {\n      return identifiers.includes(isObject(current) ? current[idKey] : current) === false;\n    };\n  }\n\n  if (Array.isArray(arr)) {\n    return arr.filter(filterFn) as any;\n  }\n}\n","// @internal\nexport function not(pred: Function): Function {\n  return function(...args) {\n    return !pred(...args);\n  };\n}\n","import { ID } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { arrayAdd } from './arrayAdd';\nimport { arrayUpdate } from './arrayUpdate';\nimport { isObject } from './isObject';\n\n/**\n * Upsert item in a collection\n *\n * @example\n *\n *\n * store.update(1, entity => ({\n *   comments: arrayUpsert(entity.comments, 1, { name: 'newComment' })\n * }))\n */\nexport function arrayUpsert<Root extends any[]>(arr: Root, id: ID, obj: Partial<Root[0]>, idKey = DEFAULT_ID_KEY): Root[0][] {\n  const entityIsObject = isObject(obj);\n  const entityExists = arr.some(entity => (entityIsObject ? entity[idKey] === id : entity === id));\n  if (entityExists) {\n    return arrayUpdate(arr, id, obj, idKey);\n  } else {\n    return arrayAdd(arr, entityIsObject ? { ...obj, [idKey]: id } : obj);\n  }\n}\n","import { EMPTY, Observable, of } from 'rxjs';\nimport { Store } from './store';\n\n/**\n * \n * Helper function for checking if we have data in cache\n * \n * export class ProductsService {\n *   constructor(private productsStore: ProductsStore) {}\n\n *   get(): Observable<void> {\n *     const request = this.http.get().pipe(\n *       tap(this.productsStore.set(response))\n *     );\n *\n *     return cacheable(this.productsStore, request);\n *   }\n * }\n */\nexport function cacheable<T>(store: Store, request$: Observable<T>, options: { emitNext: boolean } = { emitNext: false }): Observable<T | undefined | never> {\n  if (store._cache().value) {\n    return options.emitNext ? of(undefined) : EMPTY;\n  }\n  return request$;\n}\n","import { combineLatest, Observable, ObservableInput, ObservedValueOf } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\n\ntype ReturnTypes<T extends Observable<any>[]> = { [P in keyof T]: T[P] extends Observable<infer R> ? R : never };\ntype Observables = [Observable<any>] | Observable<any>[];\n\nexport function combineQueries<R extends Observables>(observables: R): Observable<ReturnTypes<R>> {\n  return combineLatest(observables).pipe(auditTime(0)) as any;\n}\n","import { Store } from './store';\nimport { Query } from './query';\nimport { StoreConfigOptions } from './storeConfig';\nimport { EntityStore } from './entityStore';\nimport { QueryEntity } from './queryEntity';\nimport { QueryConfigOptions } from './queryConfig';\nimport { EntityState } from './types';\n\nexport function createStore<State>(initialState: Partial<State>, options: Partial<StoreConfigOptions>) {\n  return new Store<State>(initialState, options);\n}\n\nexport function createQuery<State>(store: Store<State>) {\n  return new Query<State>(store);\n}\n\nexport function createEntityStore<State extends EntityState>(initialState: Partial<State>, options: Partial<StoreConfigOptions>) {\n  return new EntityStore<State>(initialState, options);\n}\n\nexport function createEntityQuery<State extends EntityState>(store: EntityStore<State>, options: QueryConfigOptions = {}) {\n  return new QueryEntity<State>(store, options);\n}\n","/**\n * Generate random guid\n *\n * @example\n *\n * {\n *   id: guid()\n * }\n *\n * @remarks this isn't a GUID, but a 10 char random alpha-num\n */\nexport function guid() {\n  return Math.random()\n    .toString(36)\n    .slice(2);\n}\n","import { isArray } from './isArray';\n\n// @internal\nexport function isNumber(value: any): value is number {\n  return !isArray(value) && value - parseFloat(value) + 1 >= 0;\n}\n","import { __stores__ } from './stores';\nimport { applyTransaction } from './transaction';\n\nexport interface ResetStoresParams {\n  exclude: string[];\n}\n\n/**\n * Reset stores back to their initial state\n *\n * @example\n *\n * resetStores()\n * resetStores({\n *   exclude: ['auth']\n * })\n */\nexport function resetStores(options?: Partial<ResetStoresParams>) {\n  const defaults: ResetStoresParams = {\n    exclude: []\n  };\n\n  options = Object.assign({}, defaults, options);\n  const stores = Object.keys(__stores__);\n\n  applyTransaction(() => {\n    for (const store of stores) {\n      const s = __stores__[store];\n      if (!options.exclude) {\n        s.reset();\n      } else {\n        if (options.exclude.indexOf(s.storeName) === -1) {\n          s.reset();\n        }\n      }\n    }\n  });\n}\n","import { Store } from './store';\nimport { Observable, defer } from 'rxjs';\nimport { finalize } from 'rxjs/operators';\n\nexport function setLoading(store: Store) {\n  return function<T>(source: Observable<T>) {\n    return defer(() => {\n      store.setLoading(true);\n      return source.pipe(finalize(() => store.setLoading(false)));\n    });\n  };\n}\n","import { DEFAULT_ID_KEY } from './defaultIDKey';\n\n// @internal\nexport function toEntitiesIds<E>(entities: E[], idKey = DEFAULT_ID_KEY) {\n  const ids = [];\n  for (const entity of entities) {\n    ids.push(entity[idKey]);\n  }\n  return ids;\n}\n"]}