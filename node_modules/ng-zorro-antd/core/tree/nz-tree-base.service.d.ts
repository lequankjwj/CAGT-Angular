/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NzSafeAny } from 'ng-zorro-antd/core/types';
import { BehaviorSubject } from 'rxjs';
import { NzTreeNode, NzTreeNodeKey } from './nz-tree-base-node';
import { NzFormatEmitEvent } from './nz-tree-base.definitions';
import * as ɵngcc0 from '@angular/core';
export declare class NzTreeBaseService {
    DRAG_SIDE_RANGE: number;
    DRAG_MIN_GAP: number;
    isCheckStrictly: boolean;
    isMultiple: boolean;
    selectedNode: NzTreeNode;
    rootNodes: NzTreeNode[];
    flattenNodes$: BehaviorSubject<NzTreeNode[]>;
    selectedNodeList: NzTreeNode[];
    expandedNodeList: NzTreeNode[];
    checkedNodeList: NzTreeNode[];
    halfCheckedNodeList: NzTreeNode[];
    matchedNodeList: NzTreeNode[];
    /**
     * reset tree nodes will clear default node list
     */
    initTree(nzNodes: NzTreeNode[]): void;
    flattenTreeData(nzNodes: NzTreeNode[], expandedKeys?: NzTreeNodeKey[] | true): void;
    getSelectedNode(): NzTreeNode | null;
    /**
     * get some list
     */
    getSelectedNodeList(): NzTreeNode[];
    /**
     * return checked nodes
     */
    getCheckedNodeList(): NzTreeNode[];
    getHalfCheckedNodeList(): NzTreeNode[];
    /**
     * return expanded nodes
     */
    getExpandedNodeList(): NzTreeNode[];
    /**
     * return search matched nodes
     */
    getMatchedNodeList(): NzTreeNode[];
    isArrayOfNzTreeNode(value: NzSafeAny[]): boolean;
    /**
     * set drag node
     */
    setSelectedNode(node: NzTreeNode): void;
    /**
     * set node selected status
     */
    setNodeActive(node: NzTreeNode): void;
    /**
     * add or remove node to selectedNodeList
     */
    setSelectedNodeList(node: NzTreeNode, isMultiple?: boolean): void;
    /**
     * merge checked nodes
     */
    setHalfCheckedNodeList(node: NzTreeNode): void;
    setCheckedNodeList(node: NzTreeNode): void;
    /**
     * conduct checked/selected/expanded keys
     */
    conductNodeState(type?: string): NzTreeNode[];
    /**
     * set expanded nodes
     */
    setExpandedNodeList(node: NzTreeNode): void;
    setMatchedNodeList(node: NzTreeNode): void;
    /**
     * check state
     * @param isCheckStrictly
     */
    refreshCheckState(isCheckStrictly?: boolean): void;
    conduct(node: NzTreeNode, isCheckStrictly?: boolean): void;
    /**
     * 1、children half checked
     * 2、children all checked, parent checked
     * 3、no children checked
     */
    conductUp(node: NzTreeNode): void;
    /**
     * reset child check state
     */
    conductDown(node: NzTreeNode, value: boolean): void;
    /**
     * flush after delete node
     */
    afterRemove(nodes: NzTreeNode[]): void;
    /**
     * drag event
     */
    refreshDragNode(node: NzTreeNode): void;
    resetNodeLevel(node: NzTreeNode): void;
    calcDropPosition(event: DragEvent): number;
    /**
     * drop
     * 0: inner -1: pre 1: next
     */
    dropAndApply(targetNode: NzTreeNode, dragPos?: number): void;
    /**
     * emit Structure
     * eventName
     * node
     * event: MouseEvent / DragEvent
     * dragNode
     */
    formatEvent(eventName: string, node: NzTreeNode | null, event: MouseEvent | DragEvent | null): NzFormatEmitEvent;
    /**
     * New functions for flatten nodes
     */
    getIndexOfArray(list: NzTreeNode[], key: string): number;
    /**
     * Render by nzCheckedKeys
     * When keys equals null, just render with checkStrictly
     * @param keys
     * @param checkStrictly
     */
    conductCheck(keys: NzTreeNodeKey[] | null, checkStrictly: boolean): void;
    conductExpandedKeys(keys?: NzTreeNodeKey[] | true): void;
    conductSelectedKeys(keys: NzTreeNodeKey[], isMulti: boolean): void;
    /**
     * Expand parent nodes by child node
     * @param node
     */
    expandNodeAllParentBySearch(node: NzTreeNode): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NzTreeBaseService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NzTreeBaseService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnotdHJlZS1iYXNlLnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsibnotdHJlZS1iYXNlLnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuaW1wb3J0IHsgTnpTYWZlQW55IH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3R5cGVzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTnpUcmVlTm9kZSwgTnpUcmVlTm9kZUtleSB9IGZyb20gJy4vbnotdHJlZS1iYXNlLW5vZGUnO1xuaW1wb3J0IHsgTnpGb3JtYXRFbWl0RXZlbnQgfSBmcm9tICcuL256LXRyZWUtYmFzZS5kZWZpbml0aW9ucyc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOelRyZWVCYXNlU2VydmljZSB7XG4gICAgRFJBR19TSURFX1JBTkdFOiBudW1iZXI7XG4gICAgRFJBR19NSU5fR0FQOiBudW1iZXI7XG4gICAgaXNDaGVja1N0cmljdGx5OiBib29sZWFuO1xuICAgIGlzTXVsdGlwbGU6IGJvb2xlYW47XG4gICAgc2VsZWN0ZWROb2RlOiBOelRyZWVOb2RlO1xuICAgIHJvb3ROb2RlczogTnpUcmVlTm9kZVtdO1xuICAgIGZsYXR0ZW5Ob2RlcyQ6IEJlaGF2aW9yU3ViamVjdDxOelRyZWVOb2RlW10+O1xuICAgIHNlbGVjdGVkTm9kZUxpc3Q6IE56VHJlZU5vZGVbXTtcbiAgICBleHBhbmRlZE5vZGVMaXN0OiBOelRyZWVOb2RlW107XG4gICAgY2hlY2tlZE5vZGVMaXN0OiBOelRyZWVOb2RlW107XG4gICAgaGFsZkNoZWNrZWROb2RlTGlzdDogTnpUcmVlTm9kZVtdO1xuICAgIG1hdGNoZWROb2RlTGlzdDogTnpUcmVlTm9kZVtdO1xuICAgIC8qKlxuICAgICAqIHJlc2V0IHRyZWUgbm9kZXMgd2lsbCBjbGVhciBkZWZhdWx0IG5vZGUgbGlzdFxuICAgICAqL1xuICAgIGluaXRUcmVlKG56Tm9kZXM6IE56VHJlZU5vZGVbXSk6IHZvaWQ7XG4gICAgZmxhdHRlblRyZWVEYXRhKG56Tm9kZXM6IE56VHJlZU5vZGVbXSwgZXhwYW5kZWRLZXlzPzogTnpUcmVlTm9kZUtleVtdIHwgdHJ1ZSk6IHZvaWQ7XG4gICAgZ2V0U2VsZWN0ZWROb2RlKCk6IE56VHJlZU5vZGUgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIGdldCBzb21lIGxpc3RcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZE5vZGVMaXN0KCk6IE56VHJlZU5vZGVbXTtcbiAgICAvKipcbiAgICAgKiByZXR1cm4gY2hlY2tlZCBub2Rlc1xuICAgICAqL1xuICAgIGdldENoZWNrZWROb2RlTGlzdCgpOiBOelRyZWVOb2RlW107XG4gICAgZ2V0SGFsZkNoZWNrZWROb2RlTGlzdCgpOiBOelRyZWVOb2RlW107XG4gICAgLyoqXG4gICAgICogcmV0dXJuIGV4cGFuZGVkIG5vZGVzXG4gICAgICovXG4gICAgZ2V0RXhwYW5kZWROb2RlTGlzdCgpOiBOelRyZWVOb2RlW107XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHNlYXJjaCBtYXRjaGVkIG5vZGVzXG4gICAgICovXG4gICAgZ2V0TWF0Y2hlZE5vZGVMaXN0KCk6IE56VHJlZU5vZGVbXTtcbiAgICBpc0FycmF5T2ZOelRyZWVOb2RlKHZhbHVlOiBOelNhZmVBbnlbXSk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogc2V0IGRyYWcgbm9kZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGVkTm9kZShub2RlOiBOelRyZWVOb2RlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBzZXQgbm9kZSBzZWxlY3RlZCBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXROb2RlQWN0aXZlKG5vZGU6IE56VHJlZU5vZGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGFkZCBvciByZW1vdmUgbm9kZSB0byBzZWxlY3RlZE5vZGVMaXN0XG4gICAgICovXG4gICAgc2V0U2VsZWN0ZWROb2RlTGlzdChub2RlOiBOelRyZWVOb2RlLCBpc011bHRpcGxlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogbWVyZ2UgY2hlY2tlZCBub2Rlc1xuICAgICAqL1xuICAgIHNldEhhbGZDaGVja2VkTm9kZUxpc3Qobm9kZTogTnpUcmVlTm9kZSk6IHZvaWQ7XG4gICAgc2V0Q2hlY2tlZE5vZGVMaXN0KG5vZGU6IE56VHJlZU5vZGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGNvbmR1Y3QgY2hlY2tlZC9zZWxlY3RlZC9leHBhbmRlZCBrZXlzXG4gICAgICovXG4gICAgY29uZHVjdE5vZGVTdGF0ZSh0eXBlPzogc3RyaW5nKTogTnpUcmVlTm9kZVtdO1xuICAgIC8qKlxuICAgICAqIHNldCBleHBhbmRlZCBub2Rlc1xuICAgICAqL1xuICAgIHNldEV4cGFuZGVkTm9kZUxpc3Qobm9kZTogTnpUcmVlTm9kZSk6IHZvaWQ7XG4gICAgc2V0TWF0Y2hlZE5vZGVMaXN0KG5vZGU6IE56VHJlZU5vZGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGNoZWNrIHN0YXRlXG4gICAgICogQHBhcmFtIGlzQ2hlY2tTdHJpY3RseVxuICAgICAqL1xuICAgIHJlZnJlc2hDaGVja1N0YXRlKGlzQ2hlY2tTdHJpY3RseT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIGNvbmR1Y3Qobm9kZTogTnpUcmVlTm9kZSwgaXNDaGVja1N0cmljdGx5PzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogMeOAgWNoaWxkcmVuIGhhbGYgY2hlY2tlZFxuICAgICAqIDLjgIFjaGlsZHJlbiBhbGwgY2hlY2tlZCwgcGFyZW50IGNoZWNrZWRcbiAgICAgKiAz44CBbm8gY2hpbGRyZW4gY2hlY2tlZFxuICAgICAqL1xuICAgIGNvbmR1Y3RVcChub2RlOiBOelRyZWVOb2RlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiByZXNldCBjaGlsZCBjaGVjayBzdGF0ZVxuICAgICAqL1xuICAgIGNvbmR1Y3REb3duKG5vZGU6IE56VHJlZU5vZGUsIHZhbHVlOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBmbHVzaCBhZnRlciBkZWxldGUgbm9kZVxuICAgICAqL1xuICAgIGFmdGVyUmVtb3ZlKG5vZGVzOiBOelRyZWVOb2RlW10pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGRyYWcgZXZlbnRcbiAgICAgKi9cbiAgICByZWZyZXNoRHJhZ05vZGUobm9kZTogTnpUcmVlTm9kZSk6IHZvaWQ7XG4gICAgcmVzZXROb2RlTGV2ZWwobm9kZTogTnpUcmVlTm9kZSk6IHZvaWQ7XG4gICAgY2FsY0Ryb3BQb3NpdGlvbihldmVudDogRHJhZ0V2ZW50KTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIGRyb3BcbiAgICAgKiAwOiBpbm5lciAtMTogcHJlIDE6IG5leHRcbiAgICAgKi9cbiAgICBkcm9wQW5kQXBwbHkodGFyZ2V0Tm9kZTogTnpUcmVlTm9kZSwgZHJhZ1Bvcz86IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogZW1pdCBTdHJ1Y3R1cmVcbiAgICAgKiBldmVudE5hbWVcbiAgICAgKiBub2RlXG4gICAgICogZXZlbnQ6IE1vdXNlRXZlbnQgLyBEcmFnRXZlbnRcbiAgICAgKiBkcmFnTm9kZVxuICAgICAqL1xuICAgIGZvcm1hdEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBub2RlOiBOelRyZWVOb2RlIHwgbnVsbCwgZXZlbnQ6IE1vdXNlRXZlbnQgfCBEcmFnRXZlbnQgfCBudWxsKTogTnpGb3JtYXRFbWl0RXZlbnQ7XG4gICAgLyoqXG4gICAgICogTmV3IGZ1bmN0aW9ucyBmb3IgZmxhdHRlbiBub2Rlc1xuICAgICAqL1xuICAgIGdldEluZGV4T2ZBcnJheShsaXN0OiBOelRyZWVOb2RlW10sIGtleTogc3RyaW5nKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBieSBuekNoZWNrZWRLZXlzXG4gICAgICogV2hlbiBrZXlzIGVxdWFscyBudWxsLCBqdXN0IHJlbmRlciB3aXRoIGNoZWNrU3RyaWN0bHlcbiAgICAgKiBAcGFyYW0ga2V5c1xuICAgICAqIEBwYXJhbSBjaGVja1N0cmljdGx5XG4gICAgICovXG4gICAgY29uZHVjdENoZWNrKGtleXM6IE56VHJlZU5vZGVLZXlbXSB8IG51bGwsIGNoZWNrU3RyaWN0bHk6IGJvb2xlYW4pOiB2b2lkO1xuICAgIGNvbmR1Y3RFeHBhbmRlZEtleXMoa2V5cz86IE56VHJlZU5vZGVLZXlbXSB8IHRydWUpOiB2b2lkO1xuICAgIGNvbmR1Y3RTZWxlY3RlZEtleXMoa2V5czogTnpUcmVlTm9kZUtleVtdLCBpc011bHRpOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBFeHBhbmQgcGFyZW50IG5vZGVzIGJ5IGNoaWxkIG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGV4cGFuZE5vZGVBbGxQYXJlbnRCeVNlYXJjaChub2RlOiBOelRyZWVOb2RlKTogdm9pZDtcbn1cbiJdfQ==